diff -Nur ../linux-2.6.33-lpc313x/arch/arm/boot/compressed/lib1funcs.S ../linux-2.6.33-lpc313x_original/arch/arm/boot/compressed/lib1funcs.S
--- ../linux-2.6.33-lpc313x/arch/arm/boot/compressed/lib1funcs.S	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/arch/arm/boot/compressed/lib1funcs.S	2012-10-07 01:54:36.000000000 +0200
@@ -0,0 +1,348 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+	
+#else
+
+	@ Initially shift the divisor left 3 bits if possible,
+	@ set curbit accordingly.  This allows for curbit to be located
+	@ at the left end of each 4 bit nibbles in the division loop
+	@ to save one loop in most cases.
+	tst	\divisor, #0xe0000000
+	moveq	\divisor, \divisor, lsl #3
+	moveq	\curbit, #8
+	movne	\curbit, #1
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	movlo	\curbit, \curbit, lsl #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	movlo	\curbit, \curbit, lsl #1
+	blo	1b
+
+	mov	\result, #0
+
+#endif
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+
+#else
+
+	cmp	\divisor, #(1 << 16)
+	movhs	\divisor, \divisor, lsr #16
+	movhs	\order, #16
+	movlo	\order, #0
+
+	cmp	\divisor, #(1 << 8)
+	movhs	\divisor, \divisor, lsr #8
+	addhs	\order, \order, #8
+
+	cmp	\divisor, #(1 << 4)
+	movhs	\divisor, \divisor, lsr #4
+	addhs	\order, \order, #4
+
+	cmp	\divisor, #(1 << 2)
+	addhi	\order, \order, #3
+	addls	\order, \order, \divisor, lsr #1
+
+#endif
+
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+#else
+
+	mov	\order, #0
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	addlo	\order, \order, #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	addlo	\order, \order, #1
+	blo	1b
+
+#endif
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+
+ENTRY(__udivsi3)
+ENTRY(__aeabi_uidiv)
+
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+ENDPROC(__udivsi3)
+ENDPROC(__aeabi_uidiv)
+
+ENTRY(__umodsi3)
+
+	subs	r2, r1, #1			@ compare divisor with 1
+	bcc	Ldiv0
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq   r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	movls	pc, lr
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+	mov	pc, lr
+
+ENDPROC(__umodsi3)
+
+ENTRY(__divsi3)
+ENTRY(__aeabi_idiv)
+
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+ENDPROC(__divsi3)
+ENDPROC(__aeabi_idiv)
+
+ENTRY(__modsi3)
+
+	cmp	r1, #0
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	movs	ip, r0				@ preserve sign of dividend
+	rsbmi	r0, r0, #0			@ if negative make positive
+	subs	r2, r1, #1			@ compare divisor with 1
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq	r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	bls	10f
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+10:	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+ENDPROC(__modsi3)
+
+#ifdef CONFIG_AEABI
+
+ENTRY(__aeabi_uidivmod)
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+ENDPROC(__aeabi_uidivmod)
+
+ENTRY(__aeabi_idivmod)
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+ENDPROC(__aeabi_idivmod)
+
+#endif
+
+Ldiv0:
+
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+
+
BinÃ¤rdateien ../linux-2.6.33-lpc313x/arch/arm/boot/compressed/piggy.gzip and ../linux-2.6.33-lpc313x_original/arch/arm/boot/compressed/piggy.gzip sind verschieden.
diff -Nur ../linux-2.6.33-lpc313x/arch/arm/include/asm/atomic.h ../linux-2.6.33-lpc313x_original/arch/arm/include/asm/atomic.h
--- ../linux-2.6.33-lpc313x/arch/arm/include/asm/atomic.h	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/arch/arm/include/asm/atomic.h	2012-10-06 18:29:27.000000000 +0200
@@ -208,7 +208,7 @@
 
 #define atomic_xchg(v, new) (xchg(&((v)->counter), new))
 
-static inline int atomic_add_unless(atomic_t *v, int a, int u)
+static inline int __atomic_add_unless(atomic_t *v, int a, int u)
 {
 	int c, old;
 
@@ -217,7 +217,7 @@
 		c = old;
 	return c != u;
 }
-#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+#define atomic_inc_not_zero(v) __atomic_add_unless((v), 1, 0)
 
 #define atomic_inc(v)		atomic_add(1, v)
 #define atomic_dec(v)		atomic_sub(1, v)
diff -Nur ../linux-2.6.33-lpc313x/.config.old ../linux-2.6.33-lpc313x_original/.config.old
--- ../linux-2.6.33-lpc313x/.config.old	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/.config.old	2012-10-06 18:29:27.000000000 +0200
@@ -0,0 +1,1931 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.33
+# Sat Oct  6 16:42:47 2012
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_U8500 is not set
+CONFIG_ARCH_LPC313X=y
+
+#
+# LPC313x Implementations
+#
+CONFIG_MACH_EA313X=y
+# CONFIG_MACH_EA3152 is not set
+# CONFIG_MACH_VAL3153 is not set
+# CONFIG_MACH_VAL3154 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_SCHED_HRTICK is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_VERBOSE=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_ARPD=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+# CONFIG_DEFAULT_BIC is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+# CONFIG_IP_VS_PROTO_TCP is not set
+# CONFIG_IP_VS_PROTO_UDP is not set
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+
+#
+# IPVS scheduler
+#
+# CONFIG_IP_VS_RR is not set
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS application helper
+#
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=m
+CONFIG_CAN_RAW=m
+CONFIG_CAN_BCM=m
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_VCAN=m
+CONFIG_CAN_DEV=m
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_MCP251X=m
+# CONFIG_CAN_SJA1000 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+# CONFIG_BT_SCO is not set
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+# CONFIG_BT_HCIUART_H4 is not set
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_ATH3K is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE="rtlwifi/rtl8712u.bin"
+CONFIG_EXTRA_FIRMWARE_DIR="/home/brenson/gnublin-buildroot-git/buildroot-2011.11/target/device/Gnublin/"
+CONFIG_DEBUG_DRIVER=y
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_NEW_LPC313x_IO=y
+CONFIG_LPC313x_ADC=m
+CONFIG_LPC313x_PWM=m
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_XIP=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_ENC28J60=m
+# CONFIG_ENC28J60_WRITEVERIFY is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+# CONFIG_RT73USB is not set
+# CONFIG_RT2800USB is not set
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_WL12XX is not set
+# CONFIG_ZD1211RW is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=m
+# CONFIG_USB_RTL8150 is not set
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET=m
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_LPC31XX_SERIAL_DMA_SUPPORT is not set
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_XILINX is not set
+CONFIG_SPI_LPC313X=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+CONFIG_GPIO_PCA953X=m
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+CONFIG_HWMON_DEBUG_CHIP=y
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=m
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+CONFIG_SENSORS_SHT15=m
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_LPC313X_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_88PM8607 is not set
+# CONFIG_AB4500_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_IR_CORE=y
+CONFIG_VIDEO_IR=y
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_EHSET is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+CONFIG_USB_EHCI_LPC=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP210X=m
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=m
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+CONFIG_USB_GADGET_FSL_USB2=y
+CONFIG_USB_FSL_USB2=y
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_ZERO=m
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_ETH_EEM is not set
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_USB_G_MULTI is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_LPC313x=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_OTUS is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+CONFIG_R8712U=y
+# CONFIG_R8712_AP is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_PLAN9AUTH is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+# CONFIG_RAMZSWAP is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_STRIP is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/Kconfig ../linux-2.6.33-lpc313x_original/drivers/staging/Kconfig
--- ../linux-2.6.33-lpc313x/drivers/staging/Kconfig	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/Kconfig	2012-10-06 18:29:29.000000000 +0200
@@ -81,6 +81,8 @@
 
 source "drivers/staging/rtl8192e/Kconfig"
 
+source "drivers/staging/rtl8712/Kconfig"
+
 source "drivers/staging/mimio/Kconfig"
 
 source "drivers/staging/frontier/Kconfig"
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/Makefile ../linux-2.6.33-lpc313x_original/drivers/staging/Makefile
--- ../linux-2.6.33-lpc313x/drivers/staging/Makefile	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/Makefile	2012-10-06 18:29:29.000000000 +0200
@@ -23,6 +23,7 @@
 obj-$(CONFIG_RTL8192SU)		+= rtl8192su/
 obj-$(CONFIG_RTL8192U)		+= rtl8192u/
 obj-$(CONFIG_RTL8192E)		+= rtl8192e/
+obj-$(CONFIG_R8712U)		+= rtl8712/
 obj-$(CONFIG_INPUT_MIMIO)	+= mimio/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
 obj-$(CONFIG_DREAM)		+= dream/
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/basic_types.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/basic_types.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/basic_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/basic_types.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#include <linux/types.h>
+
+#define SIZE_T __kernel_size_t
+#define sint signed int
+#define FIELD_OFFSET(s, field)	((addr_t)&((s *)(0))->field)
+
+/* Should we extend this to be host_addr_t and target_addr_t for case:
+ *	host : x86_64
+ *	target : mips64
+ */
+#define addr_t unsigned long
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof(SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#endif /*__BASIC_TYPES_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/big_endian.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/big_endian.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/big_endian.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/big_endian.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_BIG_ENDIAN_H
+#define _LINUX_BYTEORDER_BIG_ENDIAN_H
+
+#ifndef __BIG_ENDIAN
+#define __BIG_ENDIAN 4321
+#endif
+#ifndef __BIG_ENDIAN_BITFIELD
+#define __BIG_ENDIAN_BITFIELD
+#endif
+
+#include "swab.h"
+
+#define __constant_htonl(x) ((__u32)(x))
+#define __constant_ntohl(x) ((__u32)(x))
+#define __constant_htons(x) ((__u16)(x))
+#define __constant_ntohs(x) ((__u16)(x))
+#define __constant_cpu_to_le64(x) ___constant_swab64((x))
+#define __constant_le64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_le32(x) ___constant_swab32((x))
+#define __constant_le32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_le16(x) ___constant_swab16((x))
+#define __constant_le16_to_cpu(x) ___constant_swab16((x))
+#define __constant_cpu_to_be64(x) ((__u64)(x))
+#define __constant_be64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_be32(x) ((__u32)(x))
+#define __constant_be32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_be16(x) ((__u16)(x))
+#define __constant_be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64(x) __swab64((x))
+#define __le64_to_cpu(x) __swab64((x))
+#define __cpu_to_le32(x) __swab32((x))
+#define __le32_to_cpu(x) __swab32((x))
+#define __cpu_to_le16(x) __swab16((x))
+#define __le16_to_cpu(x) __swab16((x))
+#define __cpu_to_be64(x) ((__u64)(x))
+#define __be64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_be32(x) ((__u32)(x))
+#define __be32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_be16(x) ((__u16)(x))
+#define __be16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_le64p(x) __swab64p((x))
+#define __le64_to_cpup(x) __swab64p((x))
+#define __cpu_to_le32p(x) __swab32p((x))
+#define __le32_to_cpup(x) __swab32p((x))
+#define __cpu_to_le16p(x) __swab16p((x))
+#define __le16_to_cpup(x) __swab16p((x))
+#define __cpu_to_be64p(x) (*(__u64 *)(x))
+#define __be64_to_cpup(x) (*(__u64 *)(x))
+#define __cpu_to_be32p(x) (*(__u32 *)(x))
+#define __be32_to_cpup(x) (*(__u32 *)(x))
+#define __cpu_to_be16p(x) (*(__u16 *)(x))
+#define __be16_to_cpup(x) (*(__u16 *)(x))
+#define __cpu_to_le64s(x) __swab64s((x))
+#define __le64_to_cpus(x) __swab64s((x))
+#define __cpu_to_le32s(x) __swab32s((x))
+#define __le32_to_cpus(x) __swab32s((x))
+#define __cpu_to_le16s(x) __swab16s((x))
+#define __le16_to_cpus(x) __swab16s((x))
+#define __cpu_to_be64s(x) do {} while (0)
+#define __be64_to_cpus(x) do {} while (0)
+#define __cpu_to_be32s(x) do {} while (0)
+#define __be32_to_cpus(x) do {} while (0)
+#define __cpu_to_be16s(x) do {} while (0)
+#define __be16_to_cpus(x) do {} while (0)
+
+#include "generic.h"
+
+#endif /* _LINUX_BYTEORDER_BIG_ENDIAN_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/drv_types.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/drv_types.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/drv_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/drv_types.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,204 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*---------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+-----------------------------------------------------------------------*/
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+struct _adapter;
+
+#include "osdep_service.h"
+#include "wlan_bssdef.h"
+#include "rtl8712_spec.h"
+#include "rtl8712_hal.h"
+#include <linux/mutex.h>
+#include <linux/completion.h>
+
+enum _NIC_VERSION {
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+};
+
+struct _adapter;
+
+struct	qos_priv	{
+	/* bit mask option: u-apsd, s-apsd, ts, block ack... */
+	unsigned int qos_option;
+};
+
+#include "rtl871x_ht.h"
+#include "rtl871x_cmd.h"
+#include "rtl871x_xmit.h"
+#include "rtl871x_recv.h"
+#include "rtl871x_security.h"
+#include "rtl871x_pwrctrl.h"
+#include "rtl871x_io.h"
+#include "rtl871x_eeprom.h"
+#include "sta_info.h"
+#include "rtl871x_mlme.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_debug.h"
+#include "rtl871x_rf.h"
+#include "rtl871x_event.h"
+#include "rtl871x_led.h"
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+
+struct specific_device_id {
+	u32		flags;
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv {
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	u8	network_mode;	/*infra, ad-hoc, auto*/
+	struct ndis_802_11_ssid	ssid;
+	u8	channel;/* ad-hoc support requirement */
+	u8	wireless_mode;/* A, B, G, auto */
+	u8	vrtl_carrier_sense; /*Enable, Disable, Auto*/
+	u8	vcs_type;/*RTS/CTS, CTS-to-self*/
+	u16	rts_thresh;
+	u16  frag_thresh;
+	u8	preamble;/*long, short, auto*/
+	u8  scan_mode;/*active, passive*/
+	u8  adhoc_tx_pwr;
+	u8  soft_ap;
+	u8  smart_ps;
+	u8 power_mgnt;
+	u8 radio_enable;
+	u8 long_retry_lmt;
+	u8 short_retry_lmt;
+	u16 busy_thresh;
+	u8 ack_policy;
+	u8 mp_mode;
+	u8 software_encrypt;
+	u8 software_decrypt;
+	/* UAPSD */
+	u8 wmm_enable;
+	u8 uapsd_enable;
+	u8 uapsd_max_sp;
+	u8 uapsd_acbk_en;
+	u8 uapsd_acbe_en;
+	u8 uapsd_acvi_en;
+	u8 uapsd_acvo_en;
+
+	struct wlan_bssid_ex dev_network;
+
+	u8 ht_enable;
+	u8 cbw40_enable;
+	u8 ampdu_enable;/*for tx*/
+	u8 rf_config;
+	u8 low_power;
+	u8 wifi_test;
+};
+
+/* For registry parameters */
+#define RGTRY_OFT(field) ((addr_t)FIELD_OFFSET(struct registry_priv, field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv *)0)->field)
+#define BSSID_OFT(field) ((addr_t)FIELD_OFFSET(struct ndis_wlan_bssid_ex, \
+			 field))
+#define BSSID_SZ(field)   sizeof(((struct ndis_wlan_bssid_ex *)0)->field)
+
+struct dvobj_priv {
+	struct _adapter *padapter;
+	u32 nr_endpoint;
+	u8   ishighspeed;
+	uint(*inirp_init)(struct _adapter *adapter);
+	uint(*inirp_deinit)(struct _adapter *adapter);
+	struct semaphore usb_suspend_sema;
+	struct usb_device *pusbdev;
+};
+
+/**
+ * struct _adapter - the main adapter structure for this device.
+ *
+ * bup: True indicates that the interface is Up.
+ */
+struct _adapter {
+	struct	dvobj_priv dvobjpriv;
+	struct	mlme_priv mlmepriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	struct	io_queue	*pio_queue;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	struct	registry_priv	registrypriv;
+	struct	wlan_acl_pool	acl_list;
+	struct	pwrctrl_priv	pwrctrlpriv;
+	struct	eeprom_priv eeprompriv;
+	struct	hal_priv	halpriv;
+	struct	led_priv	ledpriv;
+	struct mp_priv  mppriv;
+	s32	bDriverStopped;
+	s32	bSurpriseRemoved;
+	u32	IsrContent;
+	u32	ImrContent;
+	bool	fw_found;
+	u8	EepromAddressSize;
+	u8	hw_init_completed;
+	struct task_struct *cmdThread;
+	 pid_t evtThread;
+	struct task_struct *xmitThread;
+	pid_t recvThread;
+	uint(*dvobj_init)(struct _adapter *adapter);
+	void  (*dvobj_deinit)(struct _adapter *adapter);
+	struct net_device *pnetdev;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	int pid; /*process id from UI*/
+	_workitem wkFilterRxFF0;
+	u8 blnEnableRxFF0Filter;
+	spinlock_t lockRxFF0Filter;
+	const struct firmware *fw;
+	struct usb_interface *pusb_intf;
+	struct mutex mutex_start;
+	struct completion rtl8712_fw_ready;
+};
+
+static inline u8 *myid(struct eeprom_priv *peepriv)
+{
+	return peepriv->mac_addr;
+}
+
+u8 r8712_usb_hal_bus_init(struct _adapter *adapter);
+
+#endif /*__DRV_TYPES_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ethernet.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ethernet.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ethernet.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ethernet.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH		6	/*!< Ethernet Address Length*/
+#define ETHERNET_HEADER_SIZE		14	/*!< Ethernet Header Length*/
+#define LLC_HEADER_SIZE			6	/*!< LLC Header Length*/
+#define TYPE_LENGTH_FIELD_SIZE		2	/*!< Type/Length Size*/
+#define MINIMUM_ETHERNET_PACKET_SIZE	60	/*!< Min Ethernet Packet Size*/
+#define MAXIMUM_ETHERNET_PACKET_SIZE	1514	/*!< Max Ethernet Packet Size*/
+
+/*!< Is Multicast Address? */
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01) != 0)
+/*!< Is Broadcast Address? */
+#define RT_ETH_IS_BROADCAST(_pAddr)	(				\
+			((u8 *)(_pAddr))[0] == 0xff	&&		\
+			((u8 *)(_pAddr))[1] == 0xff	&&		\
+			((u8 *)(_pAddr))[2] == 0xff	&&		\
+			((u8 *)(_pAddr))[3] == 0xff	&&		\
+			((u8 *)(_pAddr))[4] == 0xff	&&		\
+			((u8 *)(_pAddr))[5] == 0xff)
+
+#endif /* #ifndef __INC_ETHERNET_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/generic.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/generic.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/generic.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/generic.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/*
+ * linux/byteorder_generic.h
+ * Generic Byte-reordering support
+ *
+ * Francois-Rene Rideau <fare@tunes.org> 19970707
+ *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
+ *    cleaned them up.
+ *    I hope it is compliant with non-GCC compilers.
+ *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
+ *    because I wasn't sure it would be ok to put it in types.h
+ *    Upgraded it to 2.1.43
+ * Francois-Rene Rideau <fare@tunes.org> 19971012
+ *    Upgraded it to 2.1.57
+ *    to please Linus T., replaced huge #ifdef's between little/big endian
+ *    by nestedly #include'd files.
+ * Francois-Rene Rideau <fare@tunes.org> 19971205
+ *    Made it to 2.1.71; now a facelift:
+ *    Put files under include/linux/byteorder/
+ *    Split swab from generic support.
+ *
+ * TODO:
+ *   = Regular kernel maintainers could also replace all these manual
+ *    byteswap macros that remain, disseminated among drivers,
+ *    after some grep or the sources...
+ *   = Linus might want to rename all these macros and files to fit his taste,
+ *    to fit his personal naming scheme.
+ *   = it seems that a few drivers would also appreciate
+ *    nybble swapping support...
+ *   = every architecture could add their byteswap macro in asm/byteorder.h
+ *    see how some architectures already do (i386, alpha, ppc, etc)
+ *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
+ *    distinguished throughout the kernel. This is not the case currently,
+ *    since little endian, big endian, and pdp endian machines needn't it.
+ *    But this might be the case for, say, a port of Linux to 20/21 bit
+ *    architectures (and F21 Linux addict around?).
+ */
+
+/*
+ * The following macros are to be defined by <asm/byteorder.h>:
+ *
+ * Conversion of long and short int between network and host format
+ *	ntohl(__u32 x)
+ *	ntohs(__u16 x)
+ *	htonl(__u32 x)
+ *	htons(__u16 x)
+ * It seems that some programs (which? where? or perhaps a standard? POSIX?)
+ * might like the above to be functions, not macros (why?).
+ * if that's true, then detect them, and take measures.
+ * Anyway, the measure is: define only ___ntohl as a macro instead,
+ * and in a separate file, have
+ * unsigned long inline ntohl(x){return ___ntohl(x);}
+ *
+ * The same for constant arguments
+ *	__constant_ntohl(__u32 x)
+ *	__constant_ntohs(__u16 x)
+ *	__constant_htonl(__u32 x)
+ *	__constant_htons(__u16 x)
+ *
+ * Conversion of XX-bit integers (16- 32- or 64-)
+ * between native CPU format and little/big endian format
+ * 64-bit stuff only defined for proper architectures
+ *	cpu_to_[bl]eXX(__uXX x)
+ *	[bl]eXX_to_cpu(__uXX x)
+ *
+ * The same, but takes a pointer to the value to convert
+ *	cpu_to_[bl]eXXp(__uXX x)
+ *	[bl]eXX_to_cpup(__uXX x)
+ *
+ * The same, but change in situ
+ *	cpu_to_[bl]eXXs(__uXX x)
+ *	[bl]eXX_to_cpus(__uXX x)
+ *
+ * See asm-foo/byteorder.h for examples of how to provide
+ * architecture-optimized versions
+ *
+ */
+
+
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+
+
+/*
+ * Handle ntohl and suches. These have various compatibility
+ * issues - like we want to give the prototype even though we
+ * also have a macro for them in case some strange program
+ * wants to take the address of the thing or something..
+ *
+ * Note that these used to return a "long" in libc5, even though
+ * long is often 64-bit these days.. Thus the casts.
+ *
+ * They have to be macros in order to do the constant folding
+ * correctly - if the argument passed into a inline function
+ * it is no longer constant according to gcc..
+ */
+
+#undef ntohl
+#undef ntohs
+#undef htonl
+#undef htons
+
+/*
+ * Do the prototypes. Somebody might want to take the
+ * address or some such sick thing..
+ */
+extern __u32			ntohl(__u32);
+extern __u32			htonl(__u32);
+extern unsigned short int	ntohs(unsigned short int);
+extern unsigned short int	htons(unsigned short int);
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/hal_init.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/hal_init.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/hal_init.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/hal_init.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,404 @@
+/******************************************************************************
+ * hal_init.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HAL_INIT_C_
+
+#include <linux/usb.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/firmware.h>
+#include <linux/module.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "usb_osintf.h"
+
+#define FWBUFF_ALIGN_SZ 512
+#define MAX_DUMP_FWSZ	49152 /*default = 49152 (48k)*/
+
+static void rtl871x_load_fw_cb(const struct firmware *firmware, void *context)
+{
+	struct _adapter *padapter = context;
+
+	complete(&padapter->rtl8712_fw_ready);
+	if (!firmware) {
+		struct usb_device *udev = padapter->dvobjpriv.pusbdev;
+		struct usb_interface *pusb_intf = padapter->pusb_intf;
+		printk(KERN_ERR "r8712u: Firmware request failed\n");
+		padapter->fw_found = false;
+		usb_put_dev(udev);
+		usb_set_intfdata(pusb_intf, NULL);
+		return;
+	}
+	padapter->fw = firmware;
+	padapter->fw_found = true;
+	/* firmware available - start netdev */
+	register_netdev(padapter->pnetdev);
+}
+
+static const char firmware_file[] = "rtlwifi/rtl8712u.bin";
+
+int rtl871x_load_fw(struct _adapter *padapter)
+{
+	struct device *dev = &padapter->dvobjpriv.pusbdev->dev;
+	int rc;
+
+	init_completion(&padapter->rtl8712_fw_ready);
+	printk(KERN_INFO "r8712u: Loading firmware from \"%s\"\n",
+	       firmware_file);
+	rc = request_firmware_nowait(THIS_MODULE, 1, firmware_file, dev,
+				     GFP_KERNEL, padapter, rtl871x_load_fw_cb);
+	if (rc)
+		printk(KERN_ERR "r8712u: Firmware request error %d\n", rc);
+	return rc;
+}
+MODULE_FIRMWARE("rtlwifi/rtl8712u.bin");
+
+static u32 rtl871x_open_fw(struct _adapter *padapter, const u8 **ppmappedfw)
+{
+	const struct firmware **praw = &padapter->fw;
+
+	if (padapter->fw->size > 200000) {
+		printk(KERN_ERR "r8172u: Badfw->size of %d\n",
+		       (int)padapter->fw->size);
+		return 0;
+	}
+	*ppmappedfw = (u8 *)((*praw)->data);
+	return (*praw)->size;
+}
+
+static void fill_fwpriv(struct _adapter *padapter, struct fw_priv *pfwpriv)
+{
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	memset(pfwpriv, 0, sizeof(struct fw_priv));
+	/* todo: check if needs endian conversion */
+	pfwpriv->hci_sel =  RTL8712_HCI_TYPE_72USB;
+	pfwpriv->usb_ep_num = (u8)pdvobj->nr_endpoint;
+	pfwpriv->bw_40MHz_en = pregpriv->cbw40_enable;
+	switch (pregpriv->rf_config) {
+	case RTL8712_RF_1T1R:
+		pfwpriv->rf_config = RTL8712_RFC_1T1R;
+		break;
+	case RTL8712_RF_2T2R:
+		pfwpriv->rf_config = RTL8712_RFC_2T2R;
+		break;
+	case RTL8712_RF_1T2R:
+	default:
+		pfwpriv->rf_config = RTL8712_RFC_1T2R;
+	}
+	pfwpriv->mp_mode = (pregpriv->mp_mode == 1) ? 1 : 0;
+	pfwpriv->vcsType = pregpriv->vrtl_carrier_sense; /* 0:off 1:on 2:auto */
+	pfwpriv->vcsMode = pregpriv->vcs_type; /* 1:RTS/CTS 2:CTS to self */
+	/* default enable turboMode */
+	pfwpriv->turboMode = ((pregpriv->wifi_test == 1) ? 0 : 1);
+	pfwpriv->lowPowerMode = pregpriv->low_power;
+}
+
+static void update_fwhdr(struct fw_hdr	*pfwhdr, const u8 *pmappedfw)
+{
+	pfwhdr->signature = le16_to_cpu(*(u16 *)pmappedfw);
+	pfwhdr->version = le16_to_cpu(*(u16 *)(pmappedfw+2));
+	/* define the size of boot loader */
+	pfwhdr->dmem_size = le32_to_cpu(*(uint *)(pmappedfw+4));
+	/* define the size of FW in IMEM */
+	pfwhdr->img_IMEM_size = le32_to_cpu(*(uint *)(pmappedfw+8));
+	/* define the size of FW in SRAM */
+	pfwhdr->img_SRAM_size = le32_to_cpu(*(uint *)(pmappedfw+12));
+	/* define the size of DMEM variable */
+	pfwhdr->fw_priv_sz = le32_to_cpu(*(uint *)(pmappedfw+16));
+}
+
+static u8 chk_fwhdr(struct fw_hdr *pfwhdr, u32 ulfilelength)
+{
+	u32	fwhdrsz, fw_sz;
+	u8 intf, rfconf;
+
+	/* check signature */
+	if ((pfwhdr->signature != 0x8712) && (pfwhdr->signature != 0x8192))
+		return _FAIL;
+	/* check interface */
+	intf = (u8)((pfwhdr->version&0x3000) >> 12);
+	/* check rf_conf */
+	rfconf = (u8)((pfwhdr->version&0xC000) >> 14);
+	/* check fw_priv_sze & sizeof(struct fw_priv) */
+	if (pfwhdr->fw_priv_sz != sizeof(struct fw_priv))
+		return _FAIL;
+	/* check fw_sz & image_fw_sz */
+	fwhdrsz = FIELD_OFFSET(struct fw_hdr, fwpriv) + pfwhdr->fw_priv_sz;
+	fw_sz =  fwhdrsz + pfwhdr->img_IMEM_size + pfwhdr->img_SRAM_size +
+		 pfwhdr->dmem_size;
+	if (fw_sz != ulfilelength)
+		return _FAIL;
+	return _SUCCESS;
+}
+
+static u8 rtl8712_dl_fw(struct _adapter *padapter)
+{
+	sint i;
+	u8 tmp8, tmp8_a;
+	u16 tmp16;
+	u32 maxlen = 0, tmp32; /* for compare usage */
+	uint dump_imem_sz, imem_sz, dump_emem_sz, emem_sz; /* max = 49152; */
+	struct fw_hdr fwhdr;
+	u32 ulfilelength;	/* FW file size */
+	const u8 *pmappedfw = NULL;
+	u8 *ptmpchar = NULL, *ppayload, *ptr;
+	struct tx_desc *ptx_desc;
+	u32 txdscp_sz = sizeof(struct tx_desc);
+	u8 ret = _FAIL;
+
+	ulfilelength = rtl871x_open_fw(padapter, &pmappedfw);
+	if (pmappedfw && (ulfilelength > 0)) {
+		update_fwhdr(&fwhdr, pmappedfw);
+		if (chk_fwhdr(&fwhdr, ulfilelength) == _FAIL)
+			return ret;
+		fill_fwpriv(padapter, &fwhdr.fwpriv);
+		/* firmware check ok */
+		maxlen = (fwhdr.img_IMEM_size > fwhdr.img_SRAM_size) ?
+			  fwhdr.img_IMEM_size : fwhdr.img_SRAM_size;
+		maxlen += txdscp_sz;
+		ptmpchar = _malloc(maxlen + FWBUFF_ALIGN_SZ);
+		if (ptmpchar == NULL)
+			return ret;
+
+		ptx_desc = (struct tx_desc *)(ptmpchar + FWBUFF_ALIGN_SZ -
+			    ((addr_t)(ptmpchar) & (FWBUFF_ALIGN_SZ - 1)));
+		ppayload = (u8 *)(ptx_desc) + txdscp_sz;
+		ptr = (u8 *)pmappedfw + FIELD_OFFSET(struct fw_hdr, fwpriv) +
+		      fwhdr.fw_priv_sz;
+		/* Download FirmWare */
+		/* 1. determine IMEM code size and Load IMEM Code Section */
+		imem_sz = fwhdr.img_IMEM_size;
+		do {
+			memset(ptx_desc, 0, TXDESC_SIZE);
+			if (imem_sz >  MAX_DUMP_FWSZ/*49152*/)
+				dump_imem_sz = MAX_DUMP_FWSZ;
+			else {
+				dump_imem_sz = imem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+			}
+			ptx_desc->txdw0 |= cpu_to_le32(dump_imem_sz &
+						       0x0000ffff);
+			memcpy(ppayload, ptr, dump_imem_sz);
+			r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+				  dump_imem_sz + TXDESC_SIZE,
+				  (u8 *)ptx_desc);
+			ptr += dump_imem_sz;
+			imem_sz -= dump_imem_sz;
+		} while (imem_sz > 0);
+		i = 10;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _IMEM_CODE_DONE) == 0) && (i > 0)) {
+			udelay(10);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0 || (tmp16 & _IMEM_CHK_RPT) == 0)
+			goto exit_fail;
+
+		/* 2.Download EMEM code size and Load EMEM Code Section */
+		emem_sz = fwhdr.img_SRAM_size;
+		do {
+			memset(ptx_desc, 0, TXDESC_SIZE);
+			if (emem_sz >  MAX_DUMP_FWSZ) /* max=48k */
+				dump_emem_sz = MAX_DUMP_FWSZ;
+			else {
+				dump_emem_sz = emem_sz;
+				ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+			}
+			ptx_desc->txdw0 |= cpu_to_le32(dump_emem_sz &
+						       0x0000ffff);
+			memcpy(ppayload, ptr, dump_emem_sz);
+			r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+				  dump_emem_sz+TXDESC_SIZE, (u8 *)ptx_desc);
+			ptr += dump_emem_sz;
+			emem_sz -= dump_emem_sz;
+		} while (emem_sz > 0);
+		i = 5;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _EMEM_CODE_DONE) == 0) && (i > 0)) {
+			udelay(10);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0 || (tmp16 & _EMEM_CHK_RPT) == 0)
+			goto exit_fail;
+
+		/* 3.Enable CPU */
+		tmp8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, tmp8|BIT(2));
+		tmp8_a = r8712_read8(padapter, SYS_CLKR);
+		if (tmp8_a != (tmp8|BIT(2)))
+			goto exit_fail;
+
+		tmp8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN+1, tmp8|BIT(2));
+		tmp8_a = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		if (tmp8_a != (tmp8|BIT(2)))
+			goto exit_fail;
+
+		tmp32 = r8712_read32(padapter, TCR);
+
+		/* 4.polling IMEM Ready */
+		i = 100;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _IMEM_RDY) == 0) && (i > 0)) {
+			msleep(20);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0) {
+			r8712_write16(padapter, 0x10250348, 0xc000);
+			r8712_write16(padapter, 0x10250348, 0xc001);
+			r8712_write16(padapter, 0x10250348, 0x2000);
+			r8712_write16(padapter, 0x10250348, 0x2001);
+			r8712_write16(padapter, 0x10250348, 0x2002);
+			r8712_write16(padapter, 0x10250348, 0x2003);
+			goto exit_fail;
+		}
+		/* 5.Download DMEM code size and Load EMEM Code Section */
+		memset(ptx_desc, 0, TXDESC_SIZE);
+		ptx_desc->txdw0 |= cpu_to_le32(fwhdr.fw_priv_sz&0x0000ffff);
+		ptx_desc->txdw0 |= cpu_to_le32(BIT(28));
+		memcpy(ppayload, &fwhdr.fwpriv, fwhdr.fw_priv_sz);
+		r8712_write_mem(padapter, RTL8712_DMA_VOQ,
+			  fwhdr.fw_priv_sz + TXDESC_SIZE, (u8 *)ptx_desc);
+
+		/* polling dmem code done */
+		i = 100;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _DMEM_CODE_DONE) == 0) && (i > 0)) {
+			msleep(20);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0)
+			goto exit_fail;
+
+		tmp8 = r8712_read8(padapter, 0x1025000A);
+		if (tmp8 & BIT(4)) /* When boot from EEPROM,
+				    & FW need more time to read EEPROM */
+			i = 60;
+		else			/* boot from EFUSE */
+			i = 30;
+		tmp16 = r8712_read16(padapter, TCR);
+		while (((tmp16 & _FWRDY) == 0) && (i > 0)) {
+			msleep(100);
+			tmp16 = r8712_read16(padapter, TCR);
+			i--;
+		}
+		if (i == 0)
+			goto exit_fail;
+	} else
+		goto exit_fail;
+	ret = _SUCCESS;
+
+exit_fail:
+	kfree(ptmpchar);
+	return ret;
+}
+
+uint rtl8712_hal_init(struct _adapter *padapter)
+{
+	u32 val32;
+	int i;
+
+	/* r8712 firmware download */
+	if (rtl8712_dl_fw(padapter) != _SUCCESS)
+		return _FAIL;
+
+	printk(KERN_INFO "r8712u: 1 RCR=0x%x\n",  r8712_read32(padapter, RCR));
+	val32 = r8712_read32(padapter, RCR);
+	r8712_write32(padapter, RCR, (val32 | BIT(26))); /* Enable RX TCP
+							    Checksum offload */
+	printk(KERN_INFO "r8712u: 2 RCR=0x%x\n", r8712_read32(padapter, RCR));
+	val32 = r8712_read32(padapter, RCR);
+	r8712_write32(padapter, RCR, (val32|BIT(25))); /* Append PHY status */
+	val32 = 0;
+	val32 = r8712_read32(padapter, 0x10250040);
+	r8712_write32(padapter,  0x10250040, (val32&0x00FFFFFF));
+	/* for usb rx aggregation */
+	r8712_write8(padapter, 0x102500B5, r8712_read8(padapter, 0x102500B5) |
+	       BIT(0)); /* page = 128bytes */
+	r8712_write8(padapter, 0x102500BD, r8712_read8(padapter, 0x102500BD) |
+	       BIT(7)); /* enable usb rx aggregation */
+	r8712_write8(padapter, 0x102500D9, 1); /* TH=1 => means that invalidate
+						*  usb rx aggregation */
+	r8712_write8(padapter, 0x1025FE5B, 0x04); /* 1.7ms/4 */
+	/* Fix the RX FIFO issue(USB error) */
+	r8712_write8(padapter, 0x1025fe5C, r8712_read8(padapter, 0x1025fe5C)
+		     | BIT(7));
+	for (i = 0; i < 6; i++)
+		padapter->eeprompriv.mac_addr[i] = r8712_read8(padapter,
+							       MACID + i);
+	return _SUCCESS;
+}
+
+uint rtl8712_hal_deinit(struct _adapter *padapter)
+{
+	r8712_write8(padapter, RF_CTRL, 0x00);
+	/* Turn off BB */
+	msleep(20);
+	/* Turn off MAC	*/
+	r8712_write8(padapter, SYS_CLKR+1, 0x38); /* Switch Control Path */
+	r8712_write8(padapter, SYS_FUNC_EN+1, 0x70);
+	r8712_write8(padapter, PMC_FSM, 0x06);  /* Enable Loader Data Keep */
+	r8712_write8(padapter, SYS_ISO_CTRL, 0xF9); /* Isolation signals from
+						     * CORE, PLL */
+	r8712_write8(padapter, SYS_ISO_CTRL+1, 0xe8); /* Enable EFUSE 1.2V */
+	r8712_write8(padapter, AFE_PLL_CTRL, 0x00); /* Disable AFE PLL. */
+	r8712_write8(padapter, LDOA15_CTRL, 0x54);  /* Disable A15V */
+	r8712_write8(padapter, SYS_FUNC_EN+1, 0x50); /* Disable E-Fuse 1.2V */
+	r8712_write8(padapter, LDOV12D_CTRL, 0x24); /* Disable LDO12(for CE) */
+	r8712_write8(padapter, AFE_MISC, 0x30); /* Disable AFE BG&MB */
+	/* Option for Disable 1.6V LDO.	*/
+	r8712_write8(padapter, SPS0_CTRL, 0x56); /* Disable 1.6V LDO */
+	r8712_write8(padapter, SPS0_CTRL+1, 0x43);  /* Set SW PFM */
+	return _SUCCESS;
+}
+
+uint rtl871x_hal_init(struct _adapter *padapter)
+{
+	padapter->hw_init_completed = false;
+	if (padapter->halpriv.hal_bus_init == NULL)
+		return _FAIL;
+	else {
+		if (padapter->halpriv.hal_bus_init(padapter) != _SUCCESS)
+			return _FAIL;
+	}
+	if (rtl8712_hal_init(padapter) == _SUCCESS)
+		padapter->hw_init_completed = true;
+	else {
+		padapter->hw_init_completed = false;
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ieee80211.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ieee80211.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ieee80211.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ieee80211.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,421 @@
+/******************************************************************************
+ * ieee80211.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _IEEE80211_C
+
+#include "drv_types.h"
+#include "ieee80211.h"
+#include "wifi.h"
+#include "osdep_service.h"
+#include "wlan_bssdef.h"
+
+static const u8 WPA_OUI_TYPE[] = {0x00, 0x50, 0xf2, 1};
+static const u8 WPA_CIPHER_SUITE_NONE[] = {0x00, 0x50, 0xf2, 0};
+static const u8 WPA_CIPHER_SUITE_WEP40[] = {0x00, 0x50, 0xf2, 1};
+static const u8 WPA_CIPHER_SUITE_TKIP[] = {0x00, 0x50, 0xf2, 2};
+static const u8 WPA_CIPHER_SUITE_CCMP[] = {0x00, 0x50, 0xf2, 4};
+static const u8 WPA_CIPHER_SUITE_WEP104[] = {0x00, 0x50, 0xf2, 5};
+
+static const u8 RSN_CIPHER_SUITE_NONE[] = {0x00, 0x0f, 0xac, 0};
+static const u8 RSN_CIPHER_SUITE_WEP40[] = {0x00, 0x0f, 0xac, 1};
+static const u8 RSN_CIPHER_SUITE_TKIP[] = {0x00, 0x0f, 0xac, 2};
+static const u8 RSN_CIPHER_SUITE_CCMP[] = {0x00, 0x0f, 0xac, 4};
+static const u8 RSN_CIPHER_SUITE_WEP104[] = {0x00, 0x0f, 0xac, 5};
+
+/*-----------------------------------------------------------
+ * for adhoc-master to generate ie and provide supported-rate to fw
+ *-----------------------------------------------------------
+ */
+
+static u8 WIFI_CCKRATES[] =  {
+	(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)
+};
+
+static u8 WIFI_OFDMRATES[] = {
+	(IEEE80211_OFDM_RATE_6MB),
+	(IEEE80211_OFDM_RATE_9MB),
+	(IEEE80211_OFDM_RATE_12MB),
+	(IEEE80211_OFDM_RATE_18MB),
+	(IEEE80211_OFDM_RATE_24MB),
+	(IEEE80211_OFDM_RATE_36MB),
+	(IEEE80211_OFDM_RATE_48MB),
+	(IEEE80211_OFDM_RATE_54MB)
+};
+
+uint r8712_is_cckrates_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0) {
+		if ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||
+		    (((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))
+			return true;
+			i++;
+		}
+		return false;
+}
+
+uint r8712_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0) {
+		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
+			return false;
+		i++;
+	}
+	return true;
+}
+
+/* r8712_set_ie will update frame length */
+u8 *r8712_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen)
+{
+	*pbuf = (u8)index;
+	*(pbuf + 1) = (u8)len;
+	if (len > 0)
+		memcpy((void *)(pbuf + 2), (void *)source, len);
+	*frlen = *frlen + (len + 2);
+	return pbuf + len + 2;
+}
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+u8 *r8712_get_ie(u8 *pbuf, sint index, sint *len, sint limit)
+{
+	sint tmp, i;
+	u8 *p;
+
+	if (limit < 1)
+		return NULL;
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while (1) {
+		if (*p == index) {
+			*len = *(p + 1);
+			return p;
+		} else {
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+	return NULL;
+}
+
+static void set_supported_rate(u8 *SupportedRates, uint mode)
+{
+	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+	switch (mode) {
+	case WIRELESS_11B:
+		memcpy(SupportedRates, WIFI_CCKRATES,
+			IEEE80211_CCK_RATE_LEN);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11A:
+		memcpy(SupportedRates, WIFI_OFDMRATES,
+			IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	case WIRELESS_11BG:
+		memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+		memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES,
+			IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	}
+}
+
+static uint r8712_get_rateset_len(u8 *rateset)
+{
+	uint i = 0;
+
+	while (1) {
+		if ((rateset[i]) == 0)
+			break;
+		if (i > 12)
+			break;
+		i++;
+	}
+	return i;
+}
+
+int r8712_generate_ie(struct registry_priv *pregistrypriv)
+{
+	int sz = 0, rateLen;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *ie = pdev_network->IEs;
+
+	/*timestamp will be inserted by hardware*/
+	sz += 8;
+	ie += sz;
+	/*beacon interval : 2bytes*/
+	*(u16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);
+	sz += 2;
+	ie += 2;
+	/*capability info*/
+	*(u16 *)ie = 0;
+	*(u16 *)ie |= cpu_to_le16(cap_IBSS);
+	if (pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(u16 *)ie |= cpu_to_le16(cap_ShortPremble);
+	if (pdev_network->Privacy)
+		*(u16 *)ie |= cpu_to_le16(cap_Privacy);
+	sz += 2;
+	ie += 2;
+	/*SSID*/
+	ie = r8712_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength,
+		    pdev_network->Ssid.Ssid, &sz);
+	/*supported rates*/
+	set_supported_rate(pdev_network->SupportedRates,
+			   pregistrypriv->wireless_mode);
+	rateLen = r8712_get_rateset_len(pdev_network->SupportedRates);
+	if (rateLen > 8) {
+		ie = r8712_set_ie(ie, _SUPPORTEDRATES_IE_, 8,
+			    pdev_network->SupportedRates, &sz);
+		ie = r8712_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8),
+			    (pdev_network->SupportedRates + 8), &sz);
+	} else
+		ie = r8712_set_ie(ie, _SUPPORTEDRATES_IE_,
+			    rateLen, pdev_network->SupportedRates, &sz);
+	/*DS parameter set*/
+	ie = r8712_set_ie(ie, _DSSET_IE_, 1,
+		    (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
+	/*IBSS Parameter Set*/
+	ie = r8712_set_ie(ie, _IBSS_PARA_IE_, 2,
+		    (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
+	return sz;
+}
+
+unsigned char *r8712_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{
+	int len;
+	u16 val16;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
+	u8 *pbuf = pie;
+
+	while (1) {
+		pbuf = r8712_get_ie(pbuf, _WPA_IE_ID_, &len, limit);
+		if (pbuf) {
+			/*check if oui matches...*/
+			if (memcmp((pbuf + 2), wpa_oui_type,
+			    sizeof(wpa_oui_type)))
+				goto check_next_ie;
+			/*check version...*/
+			memcpy((u8 *)&val16, (pbuf + 6), sizeof(val16));
+			val16 = le16_to_cpu(val16);
+			if (val16 != 0x0001)
+				goto check_next_ie;
+			*wpa_ie_len = *(pbuf + 1);
+			return pbuf;
+		} else {
+			*wpa_ie_len = 0;
+			return NULL;
+		}
+check_next_ie:
+		limit = limit - (pbuf - pie) - 2 - len;
+		if (limit <= 0)
+			break;
+		pbuf += (2 + len);
+	}
+	*wpa_ie_len = 0;
+	return NULL;
+}
+
+unsigned char *r8712_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{
+	return r8712_get_ie(pie, _WPA2_IE_ID_, rsn_ie_len, limit);
+}
+
+static int r8712_get_wpa_cipher_suite(u8 *s)
+{
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_NONE;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_WEP40;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_TKIP;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_CCMP;
+	if (!memcmp(s, (void *)WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN))
+		return WPA_CIPHER_WEP104;
+	return 0;
+}
+
+static int r8712_get_wpa2_cipher_suite(u8 *s)
+{
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_NONE;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_WEP40;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_TKIP;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_CCMP;
+	if (!memcmp(s, (void *)RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN))
+		return WPA_CIPHER_WEP104;
+	return 0;
+}
+
+int r8712_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+		 int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie + 1) != (u8)(wpa_ie_len - 2))
+	     || (memcmp(wpa_ie + 2, (void *)WPA_OUI_TYPE, WPA_SELECTOR_LEN)))
+		return _FAIL;
+	pos = wpa_ie;
+	pos += 8;
+	left = wpa_ie_len - 8;
+	/*group_cipher*/
+	if (left >= WPA_SELECTOR_LEN) {
+		*group_cipher = r8712_get_wpa_cipher_suite(pos);
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+	} else if (left > 0)
+		return _FAIL;
+	/*pairwise_cipher*/
+	if (left >= 2) {
+		count = le16_to_cpu(*(u16 *)pos);
+		pos += 2;
+		left -= 2;
+		if (count == 0 || left < count * WPA_SELECTOR_LEN)
+			return _FAIL;
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= r8712_get_wpa_cipher_suite(pos);
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+	} else if (left == 1)
+		return _FAIL;
+	return ret;
+}
+
+int r8712_parse_wpa2_ie(u8 *rsn_ie, int rsn_ie_len, int *group_cipher,
+		  int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+	if ((*rsn_ie != _WPA2_IE_ID_) || (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
+		return _FAIL;
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;
+	/*group_cipher*/
+	if (left >= RSN_SELECTOR_LEN) {
+		*group_cipher = r8712_get_wpa2_cipher_suite(pos);
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+	} else if (left > 0)
+		return _FAIL;
+	/*pairwise_cipher*/
+	if (left >= 2) {
+		count = le16_to_cpu(*(u16 *)pos);
+		pos += 2;
+		left -= 2;
+		if (count == 0 || left < count * RSN_SELECTOR_LEN)
+			return _FAIL;
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= r8712_get_wpa2_cipher_suite(pos);
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+	} else if (left == 1)
+		return _FAIL;
+	return ret;
+}
+
+int r8712_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len,
+	       u8 *wpa_ie, u16 *wpa_len)
+{
+	u8 authmode, sec_idx;
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint cnt;
+
+	/*Search required WPA or WPA2 IE and copy to sec_ie[ ]*/
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+	sec_idx = 0;
+	while (cnt < in_len) {
+		authmode = in_ie[cnt];
+		if ((authmode == _WPA_IE_ID_) &&
+		    (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {
+			memcpy(wpa_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
+			*wpa_len = in_ie[cnt+1]+2;
+			cnt += in_ie[cnt + 1] + 2;  /*get next */
+		} else {
+			if (authmode == _WPA2_IE_ID_) {
+				memcpy(rsn_ie, &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				*rsn_len = in_ie[cnt+1] + 2;
+				cnt += in_ie[cnt+1] + 2;  /*get next*/
+			} else
+				cnt += in_ie[cnt+1] + 2;   /*get next*/
+		}
+	}
+	return *rsn_len + *wpa_len;
+}
+
+int r8712_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
+{
+	int match;
+	uint cnt;
+	u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+	cnt = 12;
+	match = false;
+	while (cnt < in_len) {
+		eid = in_ie[cnt];
+		if ((eid == _WPA_IE_ID_) &&
+		    (!memcmp(&in_ie[cnt+2], wps_oui, 4))) {
+			memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			*wps_ielen = in_ie[cnt+1]+2;
+			cnt += in_ie[cnt+1]+2;
+			match = true;
+			break;
+		} else
+			cnt += in_ie[cnt+1]+2; /* goto next */
+	}
+	return match;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ieee80211.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ieee80211.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ieee80211.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ieee80211.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,796 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include <linux/compiler.h>
+#include <linux/wireless.h>
+
+#define MGMT_QUEUE_NUM 5
+#define ETH_ALEN	6
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE			2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME				4
+
+#define IEEE_PARAM_WPA_ENABLED			1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED		3
+#define IEEE_PARAM_PRIVACY_INVOKED		4
+#define IEEE_PARAM_AUTH_ALGS			5
+#define IEEE_PARAM_IEEE_802_1X			6
+#define IEEE_PARAM_WPAX_SELECT			7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH			1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG		2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR		3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED	4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED		5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED	6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE				BIT(0)
+#define WPA_CIPHER_WEP40			BIT(1)
+#define WPA_CIPHER_WEP104			BIT(2)
+#define WPA_CIPHER_TKIP				BIT(3)
+#define WPA_CIPHER_CCMP				BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN			4
+#define RSN_HEADER_LEN				4
+
+#define RSN_SELECTOR_LEN 4
+
+enum NETWORK_TYPE {
+	WIRELESS_INVALID	= 0,
+	WIRELESS_11B		= 1,
+	WIRELESS_11G		= 2,
+	WIRELESS_11BG		= (WIRELESS_11B | WIRELESS_11G),
+	WIRELESS_11A		= 4,
+	WIRELESS_11N		= 8,
+	WIRELESS_11GN		= (WIRELESS_11G | WIRELESS_11N),
+	WIRELESS_11BGN		= (WIRELESS_11B | WIRELESS_11G | WIRELESS_11N),
+};
+
+
+struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+		struct {
+			int command;
+			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+	} u;
+};
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	struct list_head list;
+};
+
+struct ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __packed;
+
+struct ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __packed;
+
+
+struct	ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	u16	qc;
+}  __packed;
+
+struct  ieee80211_hdr_3addr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8  addr1[ETH_ALEN];
+	u8  addr2[ETH_ALEN];
+	u8  addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u16 qc;
+}  __packed;
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __packed;
+
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define IEEE80211_FCTL_VERS		0x0002
+#define IEEE80211_FCTL_FTYPE		0x000c
+#define IEEE80211_FCTL_STYPE		0x00f0
+#define IEEE80211_FCTL_TODS		0x0100
+#define IEEE80211_FCTL_FROMDS		0x0200
+#define IEEE80211_FCTL_MOREFRAGS	0x0400
+#define IEEE80211_FCTL_RETRY		0x0800
+#define IEEE80211_FCTL_PM		0x1000
+#define IEEE80211_FCTL_MOREDATA	0x2000
+#define IEEE80211_FCTL_WEP		0x4000
+#define IEEE80211_FCTL_ORDER		0x8000
+
+#define IEEE80211_FTYPE_MGMT		0x0000
+#define IEEE80211_FTYPE_CTL		0x0004
+#define IEEE80211_FTYPE_DATA		0x0008
+
+/* management */
+#define IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define IEEE80211_STYPE_ASSOC_RESP	0x0010
+#define IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define IEEE80211_STYPE_PROBE_REQ	0x0040
+#define IEEE80211_STYPE_PROBE_RESP	0x0050
+#define IEEE80211_STYPE_BEACON		0x0080
+#define IEEE80211_STYPE_ATIM		0x0090
+#define IEEE80211_STYPE_DISASSOC	0x00A0
+#define IEEE80211_STYPE_AUTH		0x00B0
+#define IEEE80211_STYPE_DEAUTH		0x00C0
+
+/* control */
+#define IEEE80211_STYPE_PSPOLL		0x00A0
+#define IEEE80211_STYPE_RTS		0x00B0
+#define IEEE80211_STYPE_CTS		0x00C0
+#define IEEE80211_STYPE_ACK		0x00D0
+#define IEEE80211_STYPE_CFEND		0x00E0
+#define IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define IEEE80211_STYPE_DATA		0x0000
+#define IEEE80211_STYPE_DATA_CFACK	0x0010
+#define IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define IEEE80211_STYPE_NULLFUNC	0x0040
+#define IEEE80211_STYPE_CFACK		0x0050
+#define IEEE80211_STYPE_CFPOLL		0x0060
+#define IEEE80211_STYPE_CFACKPOLL	0x0070
+#define IEEE80211_QOS_DATAGRP		0x0080
+#define IEEE80211_QoS_DATAGRP		IEEE80211_QOS_DATAGRP
+
+#define IEEE80211_SCTL_FRAG		0x000F
+#define IEEE80211_SCTL_SEQ		0xFFF0
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+struct ieee80211_snap_hdr {
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+} __packed;
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+#define WLAN_EID_RSN 48
+#define WLAN_EID_GENERIC 221
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN			4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN			8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK		(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK   (IEEE80211_CCK_BASIC_RATES_MASK | \
+					   IEEE80211_CCK_RATE_5MB_MASK | \
+					   IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK  (IEEE80211_OFDM_BASIC_RATES_MASK | \
+					   IEEE80211_OFDM_RATE_9MB_MASK  | \
+					   IEEE80211_OFDM_RATE_18MB_MASK | \
+					   IEEE80211_OFDM_RATE_36MB_MASK | \
+					   IEEE80211_OFDM_RATE_48MB_MASK | \
+					   IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+				     IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   /*jackson*/
+	uint tid;	/*jackson*/
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats {
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+struct ieee80211_security {
+	u16 active_key:2,
+	    enabled:1,
+	    auth_mode:2,
+	    auth_algo:4,
+	    unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __packed;
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __packed;
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __packed;
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __packed;
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+} __packed;
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __packed;
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+} __packed;
+
+struct ieee80211_assoc_request_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	struct ieee80211_info_element_hdr info_element;
+} __packed;
+
+struct ieee80211_assoc_response_frame {
+	struct ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+} __packed;
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+/*(HZ / 2)*/
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN 128
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+/*
+ * join_res:
+ * -1: authentication fail
+ * -2: association fail
+ * > 0: TID
+ */
+
+enum ieee80211_state {
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+	return 1;
+}
+
+extern inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case IEEE80211_FTYPE_DATA:
+		if (fc & IEEE80211_QOS_DATAGRP)
+			hdrlen += 2;
+		if ((fc & IEEE80211_FCTL_FROMDS) && (fc & IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case IEEE80211_STYPE_CTS:
+		case IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+	return hdrlen;
+}
+
+struct registry_priv;
+
+u8 *r8712_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+u8 *r8712_get_ie(u8*pbuf, sint index, sint *len, sint limit);
+unsigned char *r8712_get_wpa_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+unsigned char *r8712_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len,
+				 int limit);
+int r8712_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+			int *pairwise_cipher);
+int r8712_parse_wpa2_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher,
+			int *pairwise_cipher);
+int r8712_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len,
+		     u8 *wpa_ie, u16 *wpa_len);
+int r8712_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+int r8712_generate_ie(struct registry_priv *pregistrypriv);
+uint r8712_is_cckrates_included(u8 *rate);
+uint r8712_is_cckratesonly_included(u8 *rate);
+
+#endif /* IEEE80211_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/if_ether.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/if_ether.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/if_ether.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/if_ether.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet
+					 * [ NOT AN OFFICIAL ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr
+					 * Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames			*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011i		/* 802.2 frames			*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+	unsigned short  h_vlan_TCI;	/* Encapsulates priority and VLAN ID*/
+	unsigned short  h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short)\
+				 pvlan->h_vlan_TCI)) >> 13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short)\
+				    pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ip.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ip.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/ip.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/ip.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,137 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+
+#include "rtl871x_byteorder.h"
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 | IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 | IPOPT_CONTROL)
+#define IPOPT_SEC	(2 | IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 | IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 | IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 | IPOPT_CONTROL)
+#define IPOPT_SID	(8 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_SSRR	(9 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_RA	(20 | IPOPT_CONTROL | IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+ *
+ * REASONS: it is clear that nobody used them because:
+ * - MAX_ROUTES value was wrong.
+ * - "struct route" was wrong.
+ * - "struct timestamp" had fatally misaligned bitfields and was completely
+ *   unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+struct ip_options {
+	__u32		faddr;			/* Saved first hop address */
+	unsigned char	optlen;
+	unsigned char srr;
+	unsigned char rr;
+	unsigned char ts;
+	unsigned char is_setbyuser:1,	/* Set by setsockopt?		      */
+		      is_data:1,	/* Options in __data, rather than skb */
+		      is_strictroute:1, /* Strict source route		      */
+		      srr_is_hit:1,	/* Packet destination addr was our one*/
+		      is_changed:1,	/* IP checksum more not valid	      */
+		      rr_needaddr:1,	/* Need to record addr of outgoing dev*/
+		      ts_needtime:1,	/* Need to record timestamp	      */
+		      ts_needaddr:1;	/* Need to record addr of outgoing dev*/
+	unsigned char router_alert;
+	unsigned char __pad1;
+	unsigned char __pad2;
+	unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/Kconfig ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/Kconfig
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/Kconfig	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,26 @@
+config R8712U
+	tristate "RealTek RTL8712U (RTL8192SU) Wireless LAN NIC driver"
+	depends on WLAN && USB
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select FW_LOADER
+	default N
+	---help---
+	This option adds the Realtek RTL8712 USB device such as the D-Link DWA-130.
+	If built as a module, it will be called r8712u.
+
+config R8712_AP
+	bool "Realtek RTL8712U AP code"
+	depends on R8712U
+	default N
+	---help---
+	This option allows the Realtek RTL8712 USB device to be an Access Point.
+
+config R8712_TX_AGGR
+	bool "Realtek RTL8712U Transmit Aggregation code"
+	depends on R8712U && BROKEN
+	default N
+	---help---
+	This option provides transmit aggregation for the Realtek RTL8712 USB device.
+
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/little_endian.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/little_endian.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/little_endian.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/little_endian.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#include "swab.h"
+
+#define __constant_htonl(x) ___constant_swab32((x))
+#define __constant_ntohl(x) ___constant_swab32((x))
+#define __constant_htons(x) ___constant_swab16((x))
+#define __constant_ntohs(x) ___constant_swab16((x))
+#define __constant_cpu_to_le64(x) ((__u64)(x))
+#define __constant_le64_to_cpu(x) ((__u64)(x))
+#define __constant_cpu_to_le32(x) ((__u32)(x))
+#define __constant_le32_to_cpu(x) ((__u32)(x))
+#define __constant_cpu_to_le16(x) ((__u16)(x))
+#define __constant_le16_to_cpu(x) ((__u16)(x))
+#define __constant_cpu_to_be64(x) ___constant_swab64((x))
+#define __constant_be64_to_cpu(x) ___constant_swab64((x))
+#define __constant_cpu_to_be32(x) ___constant_swab32((x))
+#define __constant_be32_to_cpu(x) ___constant_swab32((x))
+#define __constant_cpu_to_be16(x) ___constant_swab16((x))
+#define __constant_be16_to_cpu(x) ___constant_swab16((x))
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64 *)(x))
+#define __le64_to_cpup(x) (*(__u64 *)(x))
+#define __cpu_to_le32p(x) (*(__u32 *)(x))
+#define __le32_to_cpup(x) (*(__u32 *)(x))
+#define __cpu_to_le16p(x) (*(__u16 *)(x))
+#define __le16_to_cpup(x) (*(__u16 *)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+#include "generic.h"
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/Makefile ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/Makefile
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/Makefile	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,34 @@
+r8712u-y :=				\
+		rtl871x_cmd.o		\
+		rtl8712_cmd.o		\
+		rtl871x_security.o	\
+		rtl871x_eeprom.o	\
+		rtl8712_efuse.o		\
+		hal_init.o		\
+		usb_halinit.o		\
+		usb_ops.o		\
+		usb_ops_linux.o		\
+		rtl871x_io.o		\
+		rtl8712_io.o		\
+		rtl871x_ioctl_linux.o	\
+		rtl871x_ioctl_rtl.o	\
+		rtl871x_ioctl_set.o	\
+		rtl8712_led.o		\
+		rtl871x_mlme.o		\
+		ieee80211.o		\
+		rtl871x_mp_ioctl.o	\
+		rtl871x_mp.o		\
+		mlme_linux.o		\
+		recv_linux.o		\
+		xmit_linux.o		\
+		usb_intf.o		\
+		os_intfs.o		\
+		rtl871x_pwrctrl.o	\
+		rtl8712_recv.o		\
+		rtl871x_recv.o		\
+		rtl871x_sta_mgt.o	\
+		rtl871x_xmit.o		\
+		rtl8712_xmit.o
+
+obj-$(CONFIG_R8712U)	:= r8712u.o
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mlme_linux.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mlme_linux.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mlme_linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mlme_linux.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,170 @@
+/******************************************************************************
+ * mlme_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _MLME_OSDEP_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mlme_osdep.h"
+
+static void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+
+	_r8712_sitesurvey_ctrl_handler(adapter);
+	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer,
+		   3000);
+}
+
+static void join_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_r8712_join_timeout_handler(adapter);
+}
+
+static void _scan_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	r8712_scan_timeout_handler(adapter);
+}
+
+static void dhcp_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_r8712_dhcp_timeout_handler(adapter);
+}
+
+static void wdg_timeout_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+
+	_r8712_wdg_timeout_handler(adapter);
+
+	_set_timer(&adapter->mlmepriv.wdg_timer, 2000);
+}
+
+void r8712_init_mlme_timer(struct _adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev,
+		    join_timeout_handler, (pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer),
+		    padapter->pnetdev, sitesurvey_ctrl_handler,
+		    (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev,
+		    _scan_timeout_handler, (pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->dhcp_timer), padapter->pnetdev,
+		    dhcp_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+	_init_timer(&(pmlmepriv->wdg_timer), padapter->pnetdev,
+		    wdg_timeout_handler, (u8 *)(pmlmepriv->nic_hdl));
+}
+
+void r8712_os_indicate_connect(struct _adapter *adapter)
+{
+	r8712_indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+}
+
+static struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
+void r8712_os_indicate_disconnect(struct _adapter *adapter)
+{
+	u8 backupPMKIDIndex = 0;
+	u8 backupTKIPCountermeasure = 0x00;
+
+	r8712_indicate_wx_disassoc_event(adapter);
+	netif_carrier_off(adapter->pnetdev);
+	if (adapter->securitypriv.AuthAlgrthm == 2) { /*/802.1x*/
+		/* We have to backup the PMK information for WiFi PMK Caching
+		 * test item. Backup the btkip_countermeasure information.
+		 * When the countermeasure is trigger, the driver have to
+		 * disconnect with AP for 60 seconds.
+		 */
+
+		memset(&backupPMKIDList[0], 0x00, sizeof(
+			struct RT_PMKID_LIST) *	NUM_PMKID_CACHE);
+		memcpy(&backupPMKIDList[0], &adapter->securitypriv.
+			PMKIDList[0], sizeof(struct RT_PMKID_LIST) *
+			NUM_PMKID_CACHE);
+		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = adapter->securitypriv.
+					   btkip_countermeasure;
+		memset((unsigned char *)&adapter->securitypriv, 0,
+			 sizeof(struct security_priv));
+		_init_timer(&(adapter->securitypriv.tkip_timer),
+			    adapter->pnetdev, r8712_use_tkipkey_handler,
+			    adapter);
+		/* Restore the PMK information to securitypriv structure
+		 * for the following connection. */
+		memcpy(&adapter->securitypriv.PMKIDList[0],
+			&backupPMKIDList[0],
+			sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		adapter->securitypriv.btkip_countermeasure =
+					 backupTKIPCountermeasure;
+	} else { /*reset values in securitypriv*/
+		struct security_priv *psec_priv = &adapter->securitypriv;
+
+		psec_priv->AuthAlgrthm = 0; /*open system*/
+		psec_priv->PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->PrivacyKeyIndex = 0;
+		psec_priv->XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->XGrpKeyid = 1;
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
+		psec_priv->wps_phase = false;
+	}
+}
+
+void r8712_report_sec_ie(struct _adapter *adapter, u8 authmode, u8 *sec_ie)
+{
+	uint len;
+	u8 *buff, *p, i;
+	union iwreq_data wrqu;
+
+	buff = NULL;
+	if (authmode == _WPA_IE_ID_) {
+		buff = _malloc(IW_CUSTOM_MAX);
+		if (buff == NULL)
+			return;
+		memset(buff, 0, IW_CUSTOM_MAX);
+		p = buff;
+		p += sprintf(p, "ASSOCINFO(ReqIEs=");
+		len = sec_ie[1] + 2;
+		len =  (len < IW_CUSTOM_MAX) ? len : IW_CUSTOM_MAX;
+		for (i = 0; i < len; i++)
+			p += sprintf(p, "%02x", sec_ie[i]);
+		p += sprintf(p, ")");
+		memset(&wrqu, 0, sizeof(wrqu));
+		wrqu.data.length = p-buff;
+		wrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ?
+				   wrqu.data.length : IW_CUSTOM_MAX;
+		wireless_send_event(adapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
+		kfree(buff);
+	}
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mlme_osdep.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mlme_osdep.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mlme_osdep.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mlme_osdep.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+void r8712_init_mlme_timer(struct _adapter *padapter);
+void r8712_os_indicate_disconnect(struct _adapter *adapter);
+void r8712_os_indicate_connect(struct _adapter *adapter);
+void r8712_report_sec_ie(struct _adapter *adapter, u8 authmode, u8 *sec_ie);
+int r8712_recv_indicatepkts_in_order(struct _adapter *adapter,
+				struct recv_reorder_ctrl *precvreorder_ctrl,
+				int bforced);
+void r8712_indicate_wx_assoc_event(struct _adapter *padapter);
+void r8712_indicate_wx_disassoc_event(struct _adapter *padapter);
+
+#endif	/*_MLME_OSDEP_H_*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mp_custom_oid.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mp_custom_oid.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/mp_custom_oid.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/mp_custom_oid.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,299 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+/* 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+ * 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+ * 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
+ *
+ * by Owen for Production Kit
+ * For Production Kit with Agilent Equipments
+ * in order to make our custom oids hopefully somewhat unique
+ * we will use 0xFF (indicating implementation specific OID)
+ *	 81(first byte of non zero Realtek unique identifier)
+ *	 80 (second byte of non zero Realtek unique identifier)
+ *	 XX (the custom OID number - providing 255 possible custom oids)
+ */
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST				0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS		0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE		0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER		0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS			0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS	0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS \
+							0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS	0xFF818586
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+#define OID_RT_GET_CONNECT_STATE			0xFF030001
+#define OID_RT_RESCAN					0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE				0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY			0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100
+#define OID_RT_PRO_READ_REGISTER			0xFF871101
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103
+#define OID_RT_PRO_BURST_WRITE_REGISTER			0xFF871104
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D
+/*Method 2 for H2C/C2H*/
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E
+#define OID_RT_POLL_RX_STATUS				0xFF87111F
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122
+#define OID_RT_PRO_READ_TSSI				0xFF871123
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151
+/*Method 2 , using workitem */
+#define OID_RT_SET_READ_REG				0xFF871181
+#define OID_RT_SET_WRITE_REG				0xFF871182
+#define OID_RT_SET_BURST_READ_REG			0xFF871183
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185
+#define OID_RT_SET_READ16_EEPROM			0xFF871186
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188
+
+/*For SDIO INTERFACE only*/
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0
+#define OID_RT_PRO_871X_DRV_EXT				0xFF8711A1
+
+/*For USB INTERFACE only*/
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201
+#define OID_RT_PRO_DELE_STA_INFO			0xFF871202
+#define OID_RT_PRO_QUERY_DR_VARIABLE			0xFF871203
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A
+
+#define OID_RT_SET_RX_PACKET_TYPE			0xFF87120B
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214
+
+#define OID_RT_GET_POWER_MODE				0xFF871215
+
+#define OID_RT_PRO_EFUSE				0xFF871216
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217
+
+#endif /*#ifndef __CUSTOM_OID_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/osdep_intf.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/osdep_intf.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/osdep_intf.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/osdep_intf.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0 : 1)) << 2)
+
+struct intf_priv {
+	u8 *intf_dev;
+	/* when in USB, IO is through interrupt in/out endpoints */
+	struct usb_device *udev;
+	struct urb *piorw_urb;
+	struct semaphore io_retevt;
+};
+
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+#endif	/*_OSDEP_INTF_H_*/
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/osdep_service.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/osdep_service.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/osdep_service.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/osdep_service.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#define _SUCCESS	1
+#define _FAIL		0
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/sem.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <linux/proc_fs.h>      /* Necessary because we use the proc fs */
+
+#include "basic_types.h"
+
+struct	__queue	{
+	struct	list_head	queue;
+	spinlock_t lock;
+};
+
+#define _pkt struct sk_buff
+#define _buffer unsigned char
+#define thread_exit() complete_and_exit(NULL, 0)
+#define _workitem struct work_struct
+
+#define _init_queue(pqueue)				\
+	do {						\
+		_init_listhead(&((pqueue)->queue));	\
+		spin_lock_init(&((pqueue)->lock));	\
+	} while (0)
+
+static inline struct list_head *get_next(struct list_head *list)
+{
+	return list->next;
+}
+
+static inline struct list_head *get_list_head(struct  __queue *queue)
+{
+	return &(queue->queue);
+}
+
+#define LIST_CONTAINOR(ptr, type, member) \
+	((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+
+static inline void _enter_hwio_critical(struct semaphore *prwlock,
+					unsigned long *pirqL)
+{
+	down(prwlock);
+}
+
+static inline void _exit_hwio_critical(struct semaphore *prwlock,
+				       unsigned long *pirqL)
+{
+	up(prwlock);
+}
+
+static inline void list_delete(struct list_head *plist)
+{
+	list_del_init(plist);
+}
+
+static inline void _init_timer(struct timer_list *ptimer,
+			       struct  net_device *padapter,
+			       void *pfunc, void *cntx)
+{
+	ptimer->function = pfunc;
+	ptimer->data = (addr_t)cntx;
+	init_timer(ptimer);
+}
+
+static inline void _set_timer(struct timer_list *ptimer, u32 delay_time)
+{
+	mod_timer(ptimer, (jiffies+(delay_time*HZ/1000)));
+}
+
+static inline void _cancel_timer(struct timer_list *ptimer, u8 *bcancelled)
+{
+	del_timer(ptimer);
+	*bcancelled = true; /*true ==1; false==0*/
+}
+
+static inline void _init_workitem(_workitem *pwork, void *pfunc, void *cntx)
+{
+	INIT_WORK(pwork, pfunc);
+}
+
+static inline void _set_workitem(_workitem *pwork)
+{
+	schedule_work(pwork);
+}
+
+#include "rtl871x_byteorder.h"
+
+#ifndef BIT
+	#define BIT(x)	(1 << (x))
+#endif
+
+/*
+For the following list_xxx operations,
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+static inline u32 is_list_empty(struct list_head *phead)
+{
+	if (list_empty(phead))
+		return true;
+	else
+		return false;
+}
+
+static inline void list_insert_tail(struct list_head *plist,
+				    struct list_head *phead)
+{
+	list_add_tail(plist, phead);
+}
+
+static inline u32 _down_sema(struct semaphore *sema)
+{
+	if (down_interruptible(sema))
+		return _FAIL;
+	else
+		return _SUCCESS;
+}
+
+static inline void _rtl_rwlock_init(struct semaphore *prwlock)
+{
+	sema_init(prwlock, 1);
+}
+
+static inline void _init_listhead(struct list_head *list)
+{
+	INIT_LIST_HEAD(list);
+}
+
+static inline u32 _queue_empty(struct  __queue *pqueue)
+{
+	return is_list_empty(&(pqueue->queue));
+}
+
+static inline u32 end_of_queue_search(struct list_head *head, struct list_head *plist)
+{
+	if (head == plist)
+		return true;
+	else
+		return false;
+}
+
+static inline void sleep_schedulable(int ms)
+{
+	u32 delta;
+
+	delta = (ms * HZ) / 1000;/*(ms)*/
+	if (delta == 0)
+		delta = 1;/* 1 ms */
+	set_current_state(TASK_INTERRUPTIBLE);
+	if (schedule_timeout(delta) != 0)
+		return ;
+}
+
+static inline u8 *_malloc(u32 sz)
+{
+	return	kmalloc(sz, GFP_ATOMIC);
+}
+
+static inline unsigned char _cancel_timer_ex(struct timer_list *ptimer)
+{
+	return del_timer(ptimer);
+}
+
+static inline void thread_enter(void *context)
+{
+	allow_signal(SIGTERM);
+}
+
+static inline void flush_signals_thread(void)
+{
+	if (signal_pending(current))
+		flush_signals(current);
+}
+
+static inline u32 _RND8(u32 sz)
+{
+	return ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;
+}
+
+static inline u32 _RND128(u32 sz)
+{
+	return ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;
+}
+
+static inline u32 _RND256(u32 sz)
+{
+	return ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;
+}
+
+static inline u32 _RND512(u32 sz)
+{
+	return ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;
+}
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/os_intfs.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/os_intfs.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/os_intfs.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/os_intfs.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,487 @@
+/******************************************************************************
+ * os_intfs.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _OS_INTFS_C_
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/firmware.h>
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "xmit_osdep.h"
+#include "recv_osdep.h"
+#include "rtl871x_ioctl.h"
+#include "usb_osintf.h"
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("rtl871x wireless lan driver");
+MODULE_AUTHOR("Larry Finger");
+
+static char ifname[IFNAMSIZ] = "wlan%d";
+
+/* module param defaults */
+static int chip_version = RTL8712_2ndCUT;
+static int rfintfs = HWPI;
+static int lbkmode = RTL8712_AIR_TRX;
+static int hci = RTL8712_USB;
+static int ampdu_enable = 1;/*for enable tx_ampdu*/
+
+/* The video_mode variable is for vedio mode.*/
+/* It may be specify when inserting module with video_mode=1 parameter.*/
+static int video_mode = 1;   /* enable video mode*/
+
+/*Ndis802_11Infrastructure; infra, ad-hoc, auto*/
+static int network_mode = Ndis802_11IBSS;
+static int channel = 1;/*ad-hoc support requirement*/
+static int wireless_mode = WIRELESS_11BG;
+static int vrtl_carrier_sense = AUTO_VCS;
+static int vcs_type = RTS_CTS;
+static int frag_thresh = 2346;
+static int preamble = PREAMBLE_LONG;/*long, short, auto*/
+static int scan_mode = 1;/*active, passive*/
+static int adhoc_tx_pwr = 1;
+static int soft_ap;
+static int smart_ps = 1;
+static int power_mgnt = PS_MODE_ACTIVE;
+static int radio_enable = 1;
+static int long_retry_lmt = 7;
+static int short_retry_lmt = 7;
+static int busy_thresh = 40;
+static int ack_policy = NORMAL_ACK;
+static int mp_mode;
+static int software_encrypt;
+static int software_decrypt;
+
+static int wmm_enable;/* default is set to disable the wmm.*/
+static int uapsd_enable;
+static int uapsd_max_sp = NO_LIMIT;
+static int uapsd_acbk_en;
+static int uapsd_acbe_en;
+static int uapsd_acvi_en;
+static int uapsd_acvo_en;
+
+static int ht_enable = 1;
+static int cbw40_enable = 1;
+static int rf_config = RTL8712_RF_1T2R;  /* 1T2R*/
+static int low_power;
+/* mac address to use instead of the one stored in Efuse */
+char *r8712_initmac;
+static char *initmac;
+/* if wifi_test = 1, driver will disable the turbo mode and pass it to
+ * firmware private.
+ */
+static int wifi_test = 0;
+
+module_param_string(ifname, ifname, sizeof(ifname), S_IRUGO|S_IWUSR);
+module_param(wifi_test, int, 0644);
+module_param(initmac, charp, 0644);
+module_param(video_mode, int, 0644);
+module_param(chip_version, int, 0644);
+module_param(rfintfs, int, 0644);
+module_param(lbkmode, int, 0644);
+module_param(hci, int, 0644);
+module_param(network_mode, int, 0644);
+module_param(channel, int, 0644);
+module_param(mp_mode, int, 0644);
+module_param(wmm_enable, int, 0644);
+module_param(vrtl_carrier_sense, int, 0644);
+module_param(vcs_type, int, 0644);
+module_param(busy_thresh, int, 0644);
+module_param(ht_enable, int, 0644);
+module_param(cbw40_enable, int, 0644);
+module_param(ampdu_enable, int, 0644);
+module_param(rf_config, int, 0644);
+module_param(power_mgnt, int, 0644);
+module_param(low_power, int, 0644);
+
+MODULE_PARM_DESC(ifname, " Net interface name, wlan%d=default");
+MODULE_PARM_DESC(initmac, "MAC-Address, default: use FUSE");
+
+static uint loadparam(struct _adapter *padapter, struct  net_device *pnetdev);
+static int netdev_open(struct net_device *pnetdev);
+static int netdev_close(struct net_device *pnetdev);
+
+static uint loadparam(struct _adapter *padapter, struct  net_device *pnetdev)
+{
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+	registry_par->chip_version = (u8)chip_version;
+	registry_par->rfintfs = (u8)rfintfs;
+	registry_par->lbkmode = (u8)lbkmode;
+	registry_par->hci = (u8)hci;
+	registry_par->network_mode  = (u8)network_mode;
+	memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+	registry_par->channel = (u8)channel;
+	registry_par->wireless_mode = (u8)wireless_mode;
+	registry_par->vrtl_carrier_sense = (u8)vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)vcs_type;
+	registry_par->frag_thresh = (u16)frag_thresh;
+	registry_par->preamble = (u8)preamble;
+	registry_par->scan_mode = (u8)scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)adhoc_tx_pwr;
+	registry_par->soft_ap = (u8)soft_ap;
+	registry_par->smart_ps = (u8)smart_ps;
+	registry_par->power_mgnt = (u8)power_mgnt;
+	registry_par->radio_enable = (u8)radio_enable;
+	registry_par->long_retry_lmt = (u8)long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)short_retry_lmt;
+	registry_par->busy_thresh = (u16)busy_thresh;
+	registry_par->ack_policy = (u8)ack_policy;
+	registry_par->mp_mode = (u8)mp_mode;
+	registry_par->software_encrypt = (u8)software_encrypt;
+	registry_par->software_decrypt = (u8)software_decrypt;
+	/*UAPSD*/
+	registry_par->wmm_enable = (u8)wmm_enable;
+	registry_par->uapsd_enable = (u8)uapsd_enable;
+	registry_par->uapsd_max_sp = (u8)uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)uapsd_acvo_en;
+	registry_par->ht_enable = (u8)ht_enable;
+	registry_par->cbw40_enable = (u8)cbw40_enable;
+	registry_par->ampdu_enable = (u8)ampdu_enable;
+	registry_par->rf_config = (u8)rf_config;
+	registry_par->low_power = (u8)low_power;
+	registry_par->wifi_test = (u8) wifi_test;
+	r8712_initmac = initmac;
+	return status;
+}
+
+static int r871x_net_set_mac_address(struct net_device *pnetdev, void *p)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+	struct sockaddr *addr = p;
+
+	if (padapter->bup == false)
+		memcpy(pnetdev->dev_addr, addr->sa_data, ETH_ALEN);
+	return 0;
+}
+
+static struct net_device_stats *r871x_net_get_stats(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;
+	padapter->stats.rx_packets = precvpriv->rx_pkts;
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+	return &padapter->stats;
+}
+
+static const struct net_device_ops rtl8712_netdev_ops = {
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_close,
+	.ndo_start_xmit = r8712_xmit_entry,
+	.ndo_set_mac_address = r871x_net_set_mac_address,
+	.ndo_get_stats = r871x_net_get_stats,
+	.ndo_do_ioctl = r871x_ioctl,
+};
+
+struct net_device *r8712_init_netdev(void)
+{
+	struct _adapter *padapter;
+	struct net_device *pnetdev;
+
+	pnetdev = alloc_etherdev(sizeof(struct _adapter));
+	if (!pnetdev)
+		return NULL;
+	if (dev_alloc_name(pnetdev, ifname) < 0) {
+		strcpy(ifname, "wlan%d");
+		dev_alloc_name(pnetdev, ifname);
+	}
+	padapter = (struct _adapter *) netdev_priv(pnetdev);
+	padapter->pnetdev = pnetdev;
+	printk(KERN_INFO "r8712u: register rtl8712_netdev_ops to"
+	       " netdev_ops\n");
+	pnetdev->netdev_ops = &rtl8712_netdev_ops;
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
+	pnetdev->wireless_handlers = (struct iw_handler_def *)
+				     &r871x_handlers_def;
+	/*step 2.*/
+	loadparam(padapter, pnetdev);
+	netif_carrier_off(pnetdev);
+	padapter->pid = 0;  /* Initial the PID value used for HW PBC.*/
+	return pnetdev;
+}
+
+static u32 start_drv_threads(struct _adapter *padapter)
+{
+	padapter->cmdThread = kthread_run(r8712_cmd_thread, padapter,
+			      padapter->pnetdev->name);
+	if (IS_ERR(padapter->cmdThread) < 0)
+		return _FAIL;
+	return _SUCCESS;
+}
+
+void r8712_stop_drv_threads(struct _adapter *padapter)
+{
+	/*Below is to termindate r8712_cmd_thread & event_thread...*/
+	up(&padapter->cmdpriv.cmd_queue_sema);
+	if (padapter->cmdThread)
+		_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
+	padapter->cmdpriv.cmd_seq = 1;
+}
+
+static void start_drv_timers(struct _adapter *padapter)
+{
+	_set_timer(&padapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer,
+		   5000);
+	_set_timer(&padapter->mlmepriv.wdg_timer, 2000);
+}
+
+void r8712_stop_drv_timers(struct _adapter *padapter)
+{
+	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
+	_cancel_timer_ex(&padapter->securitypriv.tkip_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.dhcp_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.wdg_timer);
+	_cancel_timer_ex(&padapter->mlmepriv.sitesurveyctrl.
+			 sitesurvey_ctrl_timer);
+}
+
+static u8 init_default_value(struct _adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	/*xmit_priv*/
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+	/* mlme_priv */
+	/* Maybe someday we should rename this variable to "active_mode"(Jeff)*/
+	pmlmepriv->passive_mode = 1; /* 1: active, 0: passive. */
+	/*ht_priv*/
+	{
+		int i;
+		struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+
+		phtpriv->ampdu_enable = false;/*set to disabled*/
+		for (i = 0; i < 16; i++)
+			phtpriv->baddbareq_issued[i] = false;
+	}
+	/*security_priv*/
+	psecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;
+	psecuritypriv->binstallGrpkey = _FAIL;
+	/*pwrctrl_priv*/
+	/*registry_priv*/
+	r8712_init_registrypriv_dev_network(padapter);
+	r8712_update_registrypriv_dev_network(padapter);
+	/*misc.*/
+	return ret;
+}
+
+u8 r8712_init_drv_sw(struct _adapter *padapter)
+{
+	if ((r8712_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+		return _FAIL;
+	padapter->cmdpriv.padapter = padapter;
+	if ((r8712_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+		return _FAIL;
+	if (r8712_init_mlme_priv(padapter) == _FAIL)
+		return _FAIL;
+	_r8712_init_xmit_priv(&padapter->xmitpriv, padapter);
+	_r8712_init_recv_priv(&padapter->recvpriv, padapter);
+	memset((unsigned char *)&padapter->securitypriv, 0,
+	       sizeof(struct security_priv));
+	_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pnetdev,
+		    r8712_use_tkipkey_handler, padapter);
+	_r8712_init_sta_priv(&padapter->stapriv);
+	padapter->stapriv.padapter = padapter;
+	r8712_init_bcmc_stainfo(padapter);
+	r8712_init_pwrctrl_priv(padapter);
+	sema_init(&(padapter->pwrctrlpriv.pnp_pwr_mgnt_sema), 0);
+	mp871xinit(padapter);
+	if (init_default_value(padapter) != _SUCCESS)
+		return _FAIL;
+	r8712_InitSwLeds(padapter);
+	return _SUCCESS;
+}
+
+u8 r8712_free_drv_sw(struct _adapter *padapter)
+{
+	struct net_device *pnetdev = (struct net_device *)padapter->pnetdev;
+
+	r8712_free_cmd_priv(&padapter->cmdpriv);
+	r8712_free_evt_priv(&padapter->evtpriv);
+	r8712_DeInitSwLeds(padapter);
+	r8712_free_mlme_priv(&padapter->mlmepriv);
+	r8712_free_io_queue(padapter);
+	_free_xmit_priv(&padapter->xmitpriv);
+	if (padapter->fw_found)
+		_r8712_free_sta_priv(&padapter->stapriv);
+	_r8712_free_recv_priv(&padapter->recvpriv);
+	mp871xdeinit(padapter);
+	if (pnetdev)
+		free_netdev(pnetdev);
+	return _SUCCESS;
+}
+
+
+static void enable_video_mode(struct _adapter *padapter, int cbw40_value)
+{
+	/*   bit 8:
+	 *   1 -> enable video mode to 96B AP
+	 *   0 -> disable video mode to 96B AP
+	 *   bit 9:
+	 *   1 -> enable 40MHz mode
+	 *   0 -> disable 40MHz mode
+	 *   bit 10:
+	 *   1 -> enable STBC
+	 *   0 -> disable STBC
+	 */
+	u32  intcmd = 0xf4000500;   /* enable bit8, bit10*/
+
+	if (cbw40_value) {
+		/* if the driver supports the 40M bandwidth,
+		 * we can enable the bit 9.*/
+		intcmd |= 0x200;
+	}
+	r8712_fw_cmd(padapter, intcmd);
+}
+
+/**
+ *
+ * This function intends to handle the activation of an interface
+ * i.e. when it is brought Up/Active from a Down state.
+ *
+ */
+static int netdev_open(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+
+	mutex_lock(&padapter->mutex_start);
+	if (padapter->bup == false) {
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bup = true;
+		if (rtl871x_hal_init(padapter) != _SUCCESS)
+			goto netdev_open_error;
+		if (r8712_initmac == NULL)
+			/* Use the mac address stored in the Efuse */
+			memcpy(pnetdev->dev_addr,
+				padapter->eeprompriv.mac_addr, ETH_ALEN);
+		else {
+			/* We have to inform f/w to use user-supplied MAC
+			 * address.
+			 */
+			msleep(200);
+			r8712_setMacAddr_cmd(padapter, (u8 *)pnetdev->dev_addr);
+			/*
+			 * The "myid" function will get the wifi mac address
+			 * from eeprompriv structure instead of netdev
+			 * structure. So, we have to overwrite the mac_addr
+			 * stored in the eeprompriv structure. In this case,
+			 * the real mac address won't be used anymore. So that,
+			 * the eeprompriv.mac_addr should store the mac which
+			 * users specify.
+			 */
+			memcpy(padapter->eeprompriv.mac_addr,
+				pnetdev->dev_addr, ETH_ALEN);
+		}
+		if (start_drv_threads(padapter) != _SUCCESS)
+			goto netdev_open_error;
+		if (padapter->dvobjpriv.inirp_init == NULL)
+			goto netdev_open_error;
+		else
+			padapter->dvobjpriv.inirp_init(padapter);
+		r8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,
+				  padapter->registrypriv.smart_ps);
+	}
+	if (!netif_queue_stopped(pnetdev))
+		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+
+	 if (video_mode)
+		enable_video_mode(padapter, cbw40_enable);
+	/* start driver mlme relation timer */
+	start_drv_timers(padapter);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+	mutex_unlock(&padapter->mutex_start);
+	return 0;
+netdev_open_error:
+	padapter->bup = false;
+	netif_carrier_off(pnetdev);
+	netif_stop_queue(pnetdev);
+	mutex_unlock(&padapter->mutex_start);
+	return -1;
+}
+
+/**
+ *
+ * This function intends to handle the shutdown of an interface
+ * i.e. when it is brought Down from an Up/Active state.
+ *
+ */
+static int netdev_close(struct net_device *pnetdev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(pnetdev);
+
+	/* Close LED*/
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_POWER_OFF);
+	msleep(200);
+
+	/*s1.*/
+	if (pnetdev) {
+		if (!netif_queue_stopped(pnetdev))
+			netif_stop_queue(pnetdev);
+	}
+	/*s2.*/
+	/*s2-1.  issue disassoc_cmd to fw*/
+	r8712_disassoc_cmd(padapter);
+	/*s2-2.  indicate disconnect to os*/
+	r8712_ind_disconnect(padapter);
+	/*s2-3.*/
+	r8712_free_assoc_resources(padapter);
+	/*s2-4.*/
+	r8712_free_network_queue(padapter);
+	/* The interface is no longer Up: */
+	padapter->bup = false;
+	release_firmware(padapter->fw);
+	/* never exit with a firmware callback pending */
+	wait_for_completion(&padapter->rtl8712_fw_ready);
+	return 0;
+}
+
+#include "mlme_osdep.h"
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/recv_linux.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/recv_linux.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/recv_linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/recv_linux.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,173 @@
+/******************************************************************************
+ * recv_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RECV_OSDEP_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include "recv_osdep.h"
+#include "osdep_intf.h"
+#include "ethernet.h"
+#include <linux/if_arp.h>
+#include "usb_ops.h"
+
+/*init os related resource in struct recv_priv*/
+/*alloc os related resource in union recv_frame*/
+int r8712_os_recv_resource_alloc(struct _adapter *padapter,
+				 union recv_frame *precvframe)
+{
+	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
+	return _SUCCESS;
+}
+
+/*alloc os related resource in struct recv_buf*/
+int r8712_os_recvbuf_resource_alloc(struct _adapter *padapter,
+				    struct recv_buf *precvbuf)
+{
+	int res = _SUCCESS;
+
+	precvbuf->irp_pending = false;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if (precvbuf->purb == NULL)
+		res = _FAIL;
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = false;
+	precvbuf->pallocated_buf = NULL;
+	precvbuf->pbuf = NULL;
+	precvbuf->pdata = NULL;
+	precvbuf->phead = NULL;
+	precvbuf->ptail = NULL;
+	precvbuf->pend = NULL;
+	precvbuf->transfer_len = 0;
+	precvbuf->len = 0;
+	return res;
+}
+
+/*free os related resource in struct recv_buf*/
+int r8712_os_recvbuf_resource_free(struct _adapter *padapter,
+			     struct recv_buf *precvbuf)
+{
+	if (precvbuf->pskb)
+		dev_kfree_skb_any(precvbuf->pskb);
+	if (precvbuf->purb) {
+		usb_kill_urb(precvbuf->purb);
+		usb_free_urb(precvbuf->purb);
+	}
+	return _SUCCESS;
+}
+
+void r8712_handle_tkip_mic_err(struct _adapter *padapter, u8 bgroup)
+{
+	union iwreq_data wrqu;
+	struct iw_michaelmicfailure ev;
+	struct mlme_priv *pmlmepriv  = &padapter->mlmepriv;
+
+	memset(&ev, 0x00, sizeof(ev));
+	if (bgroup)
+		ev.flags |= IW_MICFAILURE_GROUP;
+	else
+		ev.flags |= IW_MICFAILURE_PAIRWISE;
+	ev.src_addr.sa_family = ARPHRD_ETHER;
+	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
+	memset(&wrqu, 0x00, sizeof(wrqu));
+	wrqu.data.length = sizeof(ev);
+	wireless_send_event(padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu,
+			    (char *)&ev);
+}
+
+void r8712_recv_indicatepkt(struct _adapter *padapter,
+			    union recv_frame *precv_frame)
+{
+	struct recv_priv *precvpriv;
+	struct  __queue	*pfree_recv_queue;
+	_pkt *skb;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	skb = precv_frame->u.hdr.pkt;
+	if (skb == NULL)
+		goto _recv_indicatepkt_drop;
+	skb->data = precv_frame->u.hdr.rx_data;
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+	skb->tail = (sk_buff_data_t)(precv_frame->u.hdr.rx_tail -
+		     precv_frame->u.hdr.rx_head);
+#else
+	skb->tail = (sk_buff_data_t)precv_frame->u.hdr.rx_tail;
+#endif
+	skb->len = precv_frame->u.hdr.len;
+	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	else
+		skb->ip_summed = CHECKSUM_NONE;
+	skb->dev = padapter->pnetdev;
+	skb->protocol = eth_type_trans(skb, padapter->pnetdev);
+	netif_rx(skb);
+	precv_frame->u.hdr.pkt = NULL; /* pointers to NULL before
+					* r8712_free_recvframe() */
+	r8712_free_recvframe(precv_frame, pfree_recv_queue);
+	return;
+_recv_indicatepkt_drop:
+	 /*enqueue back to free_recv_queue*/
+	 if (precv_frame)
+		r8712_free_recvframe(precv_frame, pfree_recv_queue);
+	 precvpriv->rx_drop++;
+}
+
+void r8712_os_read_port(struct _adapter *padapter, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	precvbuf->ref_cnt--;
+	/*free skb in recv_buf*/
+	dev_kfree_skb_any(precvbuf->pskb);
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = false;
+	if (precvbuf->irp_pending == false)
+		r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+			 (unsigned char *)precvbuf);
+}
+
+static void _r8712_reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl =
+			 (struct recv_reorder_ctrl *)FunctionContext;
+
+	r8712_reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	struct _adapter *padapter = preorder_ctrl->padapter;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev,
+		    _r8712_reordering_ctrl_timeout_handler, preorder_ctrl);
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/recv_osdep.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/recv_osdep.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/recv_osdep.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/recv_osdep.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include <linux/skbuff.h>
+
+sint _r8712_init_recv_priv(struct recv_priv *precvpriv,
+			   struct _adapter *padapter);
+void _r8712_free_recv_priv(struct recv_priv *precvpriv);
+s32  r8712_recv_entry(union recv_frame *precv_frame);
+void r8712_recv_indicatepkt(struct _adapter *adapter,
+			    union recv_frame *precv_frame);
+void r8712_handle_tkip_mic_err(struct _adapter *padapter, u8 bgroup);
+int r8712_init_recv_priv(struct recv_priv *precvpriv,
+			 struct _adapter *padapter);
+void r8712_free_recv_priv(struct recv_priv *precvpriv);
+int r8712_os_recv_resource_alloc(struct _adapter *padapter,
+				 union recv_frame *precvframe);
+int r8712_os_recvbuf_resource_alloc(struct _adapter *padapter,
+				    struct recv_buf *precvbuf);
+int r8712_os_recvbuf_resource_free(struct _adapter *padapter,
+				   struct recv_buf *precvbuf);
+void r8712_os_read_port(struct _adapter *padapter, struct recv_buf *precvbuf);
+void r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __RTL8712_BITDEF_H__
+#define __RTL8712_BITDEF_H__
+
+#include "rtl8712_cmdctrl_bitdef.h"
+#include "rtl8712_syscfg_bitdef.h"
+#include "rtl8712_macsetting_bitdef.h"
+#include "rtl8712_timectrl_bitdef.h"
+#include "rtl8712_fifoctrl_bitdef.h"
+#include "rtl8712_ratectrl_bitdef.h"
+#include "rtl8712_edcasetting_bitdef.h"
+#include "rtl8712_wmac_bitdef.h"
+#include "rtl8712_security_bitdef.h"
+#include "rtl8712_powersave_bitdef.h"
+#include "rtl8712_gp_bitdef.h"
+#include "rtl8712_interrupt_bitdef.h"
+#include "rtl8712_debugctrl_bitdef.h"
+
+#endif /* __RTL8712_BITDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmd.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmd.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmd.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,483 @@
+/******************************************************************************
+ * rtl8712_cmd.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_CMD_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <linux/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/rtnetlink.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "rtl871x_byteorder.h"
+#include "rtl871x_ioctl_set.h"
+
+static void check_hw_pbc(struct _adapter *padapter)
+{
+	u8	tmp1byte;
+
+	r8712_write8(padapter, MAC_PINMUX_CTRL, (GPIOMUX_EN | GPIOSEL_GPIO));
+	tmp1byte = r8712_read8(padapter, GPIO_IO_SEL);
+	tmp1byte &= ~(HAL_8192S_HW_GPIO_WPS_BIT);
+	r8712_write8(padapter, GPIO_IO_SEL, tmp1byte);
+	tmp1byte = r8712_read8(padapter, GPIO_CTRL);
+	if (tmp1byte == 0xff)
+		return ;
+	if (tmp1byte&HAL_8192S_HW_GPIO_WPS_BIT) {
+		/* Here we only set bPbcPressed to true
+		 * After trigger PBC, the variable will be set to false */
+		DBG_8712("CheckPbcGPIO - PBC is pressed !!!!\n");
+		/* 0 is the default value and it means the application monitors
+		 * the HW PBC doesn't privde its pid to driver. */
+		if (padapter->pid == 0)
+			return;
+		kill_pid(find_vpid(padapter->pid), SIGUSR1, 1);
+	}
+}
+
+/* query rx phy status from fw.
+ * Adhoc mode: beacon.
+ * Infrastructure mode: beacon , data. */
+static void query_fw_rx_phy_status(struct _adapter *padapter)
+{
+	u32 val32 = 0;
+	int pollingcnts = 50;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == true) {
+		r8712_write32(padapter, IOCMD_CTRL_REG, 0xf4000001);
+		msleep(100);
+		/* Wait FW complete IO Cmd */
+		while ((r8712_read32(padapter, IOCMD_CTRL_REG)) &&
+		       (pollingcnts > 0)) {
+			pollingcnts--;
+			msleep(20);
+		}
+		if (pollingcnts != 0)
+			val32 = r8712_read32(padapter, IOCMD_DATA_REG);
+		else /* time out */
+			val32 = 0;
+		val32 = val32 >> 4;
+		padapter->recvpriv.fw_rssi =
+			 (u8)r8712_signal_scale_mapping(val32);
+	}
+}
+
+/* check mlme, hw, phy, or dynamic algorithm status. */
+static void StatusWatchdogCallback(struct _adapter *padapter)
+{
+	check_hw_pbc(padapter);
+	query_fw_rx_phy_status(padapter);
+}
+
+static void r871x_internal_cmd_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	struct drvint_cmd_parm *pdrvcmd;
+
+	if (!pbuf)
+		return;
+	pdrvcmd = (struct drvint_cmd_parm *)pbuf;
+	switch (pdrvcmd->i_cid) {
+	case WDG_WK_CID:
+		StatusWatchdogCallback(padapter);
+		break;
+	default:
+		break;
+	}
+	kfree(pdrvcmd->pbuf);
+}
+
+static u8 read_macreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	/*  invoke cmd->callback function */
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_macreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	/*  invoke cmd->callback function */
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 read_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj	*pcmd);
+	struct readBB_parm *prdbbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	prdbbparm = (struct readBB_parm *)pcmd->parmbuf;
+	if (pcmd->rsp && pcmd->rspsz > 0)
+		memcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_bbreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct writeBB_parm *pwritebbparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	pwritebbparm = (struct writeBB_parm *)pcmd->parmbuf;
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 read_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	u32 val;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct readRF_parm *prdrfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	prdrfparm = (struct readRF_parm *)pcmd->parmbuf;
+	if (pcmd->rsp && pcmd->rspsz > 0)
+		memcpy(pcmd->rsp, (u8 *)&val, pcmd->rspsz);
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 write_rfreg_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+
+	pwriterfparm = (struct writeRF_parm *)pcmd->parmbuf;
+	pcmd_callback = cmd_callback[pcmd->cmdcode].callback;
+	if (pcmd_callback == NULL)
+		r8712_free_cmd_obj(pcmd);
+	else
+		pcmd_callback(padapter, pcmd);
+	return H2C_SUCCESS;
+}
+
+static u8 sys_suspend_hdl(struct _adapter *padapter, u8 *pbuf)
+{
+	struct cmd_obj *pcmd  = (struct cmd_obj *)pbuf;
+	struct usb_suspend_parm *psetusbsuspend;
+
+	psetusbsuspend = (struct usb_suspend_parm *)pcmd->parmbuf;
+	r8712_free_cmd_obj(pcmd);
+	return H2C_SUCCESS;
+}
+
+static struct cmd_obj *cmd_hdl_filter(struct _adapter *padapter,
+				      struct cmd_obj *pcmd)
+{
+	struct cmd_obj *pcmd_r;
+
+	if (pcmd == NULL)
+		return pcmd;
+	pcmd_r = NULL;
+
+	switch (pcmd->cmdcode) {
+	case GEN_CMD_CODE(_Read_MACREG):
+		read_macreg_hdl(padapter, (u8 *)pcmd);
+		pcmd_r = pcmd;
+		break;
+	case GEN_CMD_CODE(_Write_MACREG):
+		write_macreg_hdl(padapter, (u8 *)pcmd);
+		pcmd_r = pcmd;
+		break;
+	case GEN_CMD_CODE(_Read_BBREG):
+		read_bbreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Write_BBREG):
+		write_bbreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Read_RFREG):
+		read_rfreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_Write_RFREG):
+		write_rfreg_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_SetUsbSuspend):
+		sys_suspend_hdl(padapter, (u8 *)pcmd);
+		break;
+	case GEN_CMD_CODE(_JoinBss):
+		r8712_joinbss_reset(padapter);
+		/* Before set JoinBss_CMD to FW, driver must ensure FW is in
+		 * PS_MODE_ACTIVE. Directly write rpwm to radio on and assign
+		 * new pwr_mode to Driver, instead of use workitem to change
+		 * state. */
+		if (padapter->pwrctrlpriv.pwr_mode > PS_MODE_ACTIVE) {
+			padapter->pwrctrlpriv.pwr_mode = PS_MODE_ACTIVE;
+			_enter_pwrlock(&(padapter->pwrctrlpriv.lock));
+			r8712_set_rpwm(padapter, PS_STATE_S4);
+			up(&(padapter->pwrctrlpriv.lock));
+		}
+		pcmd_r = pcmd;
+		break;
+	case _DRV_INT_CMD_:
+		r871x_internal_cmd_hdl(padapter, pcmd->parmbuf);
+		r8712_free_cmd_obj(pcmd);
+		pcmd_r = NULL;
+		break;
+	default:
+		pcmd_r = pcmd;
+		break;
+	}
+	return pcmd_r; /* if returning pcmd_r == NULL, pcmd must be free. */
+}
+
+static u8 check_cmd_fifo(struct _adapter *padapter, uint sz)
+{
+	u8 res = _SUCCESS;
+	return res;
+}
+
+u8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd)
+{
+	int pollingcnts = 50;
+
+	r8712_write32(pAdapter, IOCMD_CTRL_REG, cmd);
+	msleep(100);
+	while ((0 != r8712_read32(pAdapter, IOCMD_CTRL_REG)) &&
+	       (pollingcnts > 0)) {
+		pollingcnts--;
+		msleep(20);
+	}
+	if (pollingcnts == 0)
+		return false;
+	return true;
+}
+
+void r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag)
+{
+	if (flag == 0)	/* set */
+		r8712_write32(pAdapter, IOCMD_DATA_REG, *value);
+	else		/* query */
+		*value = r8712_read32(pAdapter, IOCMD_DATA_REG);
+}
+
+int r8712_cmd_thread(void *context)
+{
+	struct cmd_obj *pcmd;
+	unsigned int cmdsz, wr_sz, *pcmdbuf, *prspbuf;
+	struct tx_desc *pdesc;
+	void (*pcmd_callback)(struct _adapter *dev, struct cmd_obj *pcmd);
+	struct _adapter *padapter = (struct _adapter *)context;
+	struct	cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+
+	thread_enter(padapter);
+	while (1) {
+		if ((_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+			break;
+		if ((padapter->bDriverStopped == true) ||
+		    (padapter->bSurpriseRemoved == true))
+			break;
+		if (r8712_register_cmd_alive(padapter) != _SUCCESS)
+			continue;
+_next:
+		pcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if (!(pcmd)) {
+			r8712_unregister_cmd_alive(padapter);
+			continue;
+		}
+		pcmdbuf = (unsigned int *)pcmdpriv->cmd_buf;
+		prspbuf = (unsigned int *)pcmdpriv->rsp_buf;
+		pdesc = (struct tx_desc *)pcmdbuf;
+		memset(pdesc, 0, TXDESC_SIZE);
+		pcmd = cmd_hdl_filter(padapter, pcmd);
+		if (pcmd) { /* if pcmd != NULL, cmd will be handled by f/w */
+			struct dvobj_priv *pdvobj = (struct dvobj_priv *)
+						    &padapter->dvobjpriv;
+			u8 blnPending = 0;
+			pcmdpriv->cmd_issued_cnt++;
+			cmdsz = _RND8((pcmd->cmdsz)); /* _RND8	*/
+			wr_sz = TXDESC_SIZE + 8 + cmdsz;
+			pdesc->txdw0 |= cpu_to_le32((wr_sz-TXDESC_SIZE) &
+						     0x0000ffff);
+			if (pdvobj->ishighspeed) {
+				if ((wr_sz % 512) == 0)
+					blnPending = 1;
+			} else {
+				if ((wr_sz % 64) == 0)
+					blnPending = 1;
+			}
+			if (blnPending) /* 32 bytes for TX Desc - 8 offset */
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +
+						OFFSET_SZ + 8) << OFFSET_SHT) &
+						0x00ff0000);
+			else {
+				pdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE +
+							      OFFSET_SZ) <<
+							      OFFSET_SHT) &
+							      0x00ff0000);
+			}
+			pdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+			pdesc->txdw1 |= cpu_to_le32((0x13 << QSEL_SHT) &
+						    0x00001f00);
+			pcmdbuf += (TXDESC_SIZE >> 2);
+			*pcmdbuf = cpu_to_le32((cmdsz & 0x0000ffff) |
+					       (pcmd->cmdcode << 16) |
+					       (pcmdpriv->cmd_seq << 24));
+			pcmdbuf += 2 ; /* 8 bytes aligment */
+			memcpy((u8 *)pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+			while (check_cmd_fifo(padapter, wr_sz) == _FAIL) {
+				if ((padapter->bDriverStopped == true) ||
+				    (padapter->bSurpriseRemoved == true))
+					break;
+				msleep(100);
+				continue;
+			}
+			if (blnPending)
+				wr_sz += 8;   /* Append 8 bytes */
+			r8712_write_mem(padapter, RTL8712_DMA_H2CCMD, wr_sz,
+				       (u8 *)pdesc);
+			pcmdpriv->cmd_seq++;
+			if (pcmd->cmdcode == GEN_CMD_CODE(_CreateBss)) {
+				pcmd->res = H2C_SUCCESS;
+				pcmd_callback = cmd_callback[pcmd->
+						cmdcode].callback;
+				if (pcmd_callback)
+					pcmd_callback(padapter, pcmd);
+				continue;
+			}
+			if (pcmd->cmdcode == GEN_CMD_CODE(_SetPwrMode)) {
+				if (padapter->pwrctrlpriv.bSleep) {
+					_enter_pwrlock(&(padapter->
+						       pwrctrlpriv.lock));
+					r8712_set_rpwm(padapter, PS_STATE_S2);
+					up(&padapter->pwrctrlpriv.lock);
+				}
+			}
+			r8712_free_cmd_obj(pcmd);
+			if (_queue_empty(&(pcmdpriv->cmd_queue))) {
+				r8712_unregister_cmd_alive(padapter);
+				continue;
+			} else
+				goto _next;
+		} else
+			goto _next;
+		flush_signals_thread();
+	}
+	/* free all cmd_obj resources */
+	do {
+		pcmd = r8712_dequeue_cmd(&(pcmdpriv->cmd_queue));
+		if (pcmd == NULL)
+			break;
+		r8712_free_cmd_obj(pcmd);
+	} while (1);
+	up(&pcmdpriv->terminate_cmdthread_sema);
+	thread_exit();
+}
+
+void r8712_event_handle(struct _adapter *padapter, uint *peventbuf)
+{
+	u8 evt_code, evt_seq;
+	u16 evt_sz;
+	void (*event_callback)(struct _adapter *dev, u8 *pbuf);
+	struct	evt_priv *pevt_priv = &(padapter->evtpriv);
+
+	if (peventbuf == NULL)
+		goto _abort_event_;
+	evt_sz = (u16)(le32_to_cpu(*peventbuf) & 0xffff);
+	evt_seq = (u8)((le32_to_cpu(*peventbuf) >> 24) & 0x7f);
+	evt_code = (u8)((le32_to_cpu(*peventbuf) >> 16) & 0xff);
+	/* checking event sequence... */
+	if ((evt_seq & 0x7f) != pevt_priv->event_seq) {
+		pevt_priv->event_seq = ((evt_seq + 1) & 0x7f);
+		goto _abort_event_;
+	}
+	/* checking if event code is valid */
+	if (evt_code >= MAX_C2HEVT) {
+		pevt_priv->event_seq = ((evt_seq+1) & 0x7f);
+		goto _abort_event_;
+	} else if ((evt_code == GEN_EVT_CODE(_Survey)) &&
+		   (evt_sz > sizeof(struct wlan_bssid_ex))) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+	/* checking if event size match the event parm size */
+	if ((wlanevents[evt_code].parmsize) &&
+	    (wlanevents[evt_code].parmsize != evt_sz)) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	} else if ((evt_sz == 0) && (evt_code != GEN_EVT_CODE(_WPS_PBC))) {
+		pevt_priv->event_seq = ((evt_seq+1)&0x7f);
+		goto _abort_event_;
+	}
+	pevt_priv->event_seq++;	/* update evt_seq */
+	if (pevt_priv->event_seq > 127)
+		pevt_priv->event_seq = 0;
+	peventbuf = peventbuf + 2; /* move to event content, 8 bytes aligment */
+	if (peventbuf) {
+		event_callback = wlanevents[evt_code].event_callback;
+		if (event_callback)
+			event_callback(padapter, (u8 *)peventbuf);
+	}
+	pevt_priv->evt_done_cnt++;
+_abort_event_:
+	return;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmdctrl_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMDCTRL_BITDEF_H__
+#define __RTL8712_CMDCTRL_BITDEF_H__
+
+/*
+ * 2. Command Control Registers	 (Offset: 0x0040 - 0x004F)*/
+/*--------------------------------------------------------------------------*/
+/*       8192S (CMD) command register bits	(Offset 0x40, 16 bits)*/
+/*--------------------------------------------------------------------------*/
+#define		_APSDOFF_STATUS		BIT(15)
+#define		_APSDOFF		BIT(14)
+#define		_BBRSTn			BIT(13)  /*Enable OFDM/CCK*/
+#define		_BB_GLB_RSTn		BIT(12)   /*Enable BB*/
+#define		_SCHEDULE_EN		BIT(10)  /*Enable MAC scheduler*/
+#define		_MACRXEN		BIT(9)
+#define		_MACTXEN		BIT(8)
+#define		_DDMA_EN		BIT(7)  /*FW off load function enable*/
+#define		_FW2HW_EN		BIT(6)  /*MAC every module reset */
+#define		_RXDMA_EN		BIT(5)
+#define		_TXDMA_EN		BIT(4)
+#define		_HCI_RXDMA_EN		BIT(3)
+#define		_HCI_TXDMA_EN		BIT(2)
+
+/*TXPAUSE*/
+#define	_STOPHCCA			BIT(6)
+#define	_STOPHIGH			BIT(5)
+#define	_STOPMGT			BIT(4)
+#define	_STOPVO				BIT(3)
+#define	_STOPVI				BIT(2)
+#define	_STOPBE				BIT(1)
+#define	_STOPBK				BIT(0)
+
+/*TCR*/
+#define	_DISCW				BIT(20)
+#define	_ICV				BIT(19)
+#define	_CFEND_FMT			BIT(17)
+#define	_CRC				BIT(16)
+#define	_FWRDY				BIT(7)
+#define _BASECHG			BIT(6)
+#define	_IMEM_RDY			BIT(5)
+#define _DMEM_CODE_DONE			BIT(4)
+#define _EMEM_CHK_RPT			BIT(3)
+#define _EMEM_CODE_DONE			BIT(2)
+#define _IMEM_CHK_RPT			BIT(1)
+#define _IMEM_CODE_DONE			BIT(0)
+
+#define	_TXDMA_INIT_VALUE	(_IMEM_CHK_RPT|_EMEM_CHK_RPT)
+
+/*RCR*/
+#define	_ENMBID				BIT(27)
+#define	_APP_PHYST_RXFF			BIT(25)
+#define	_APP_PHYST_STAFF		BIT(24)
+#define	_CBSSID				BIT(23)
+#define	_APWRMGT			BIT(22)
+#define	_ADD3				BIT(21)
+#define	_AMF				BIT(20)
+#define	_ACF				BIT(19)
+#define	_ADF				BIT(18)
+#define	_APP_MIC			BIT(17)
+#define	_APP_ICV			BIT(16)
+#define	_RXFTH_MSK			0x0000E000
+#define	_RXFTH_SHT			13
+#define	_AICV				BIT(12)
+#define	_RXPKTLMT_MSK			0x00000FC0
+#define	_RXPKTLMT_SHT			6
+#define	_ACRC32				BIT(5)
+#define	_AB				BIT(3)
+#define	_AM				BIT(2)
+#define	_APM				BIT(1)
+#define	_AAP				BIT(0)
+
+/*MSR*/
+#define	_NETTYPE_MSK			0x03
+#define	_NETTYPE_SHT			0
+
+/*BT*/
+#define _BTMODE_MSK			0x06
+#define _BTMODE_SHT			1
+#define _ENBT				BIT(0)
+
+/*MBIDCTRL*/
+#define	_ENMBID_MODE			BIT(15)
+#define	_BCNNO_MSK			0x7000
+#define	_BCNNO_SHT			12
+#define	_BCNSPACE_MSK			0x0FFF
+#define	_BCNSPACE_SHT			0
+
+
+#endif /* __RTL8712_CMDCTRL_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmdctrl_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMDCTRL_REGDEF_H__
+#define __RTL8712_CMDCTRL_REGDEF_H__
+
+
+#define CR			(RTL8712_CMDCTRL_ + 0x0000)
+#define TXPAUSE			(RTL8712_CMDCTRL_ + 0x0002)
+#define TCR			(RTL8712_CMDCTRL_ + 0x0004)
+#define RCR			(RTL8712_CMDCTRL_ + 0x0008)
+#define MSR			(RTL8712_CMDCTRL_ + 0x000C)
+#define SYSF_CFG		(RTL8712_CMDCTRL_ + 0x000D)
+#define MBIDCTRL		(RTL8712_CMDCTRL_ + 0x000E)
+
+
+#endif /* __RTL8712_CMDCTRL_REGDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmd.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmd.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_cmd.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,244 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_CMD_H_
+#define __RTL8712_CMD_H_
+
+#define CMD_HDR_SZ      8
+
+u8 r8712_fw_cmd(struct _adapter *pAdapter, u32 cmd);
+void r8712_fw_cmd_data(struct _adapter *pAdapter, u32 *value, u8 flag);
+
+struct cmd_hdr {
+	u32 cmd_dw0;
+	u32 cmd_dw1;
+};
+
+enum rtl8712_h2c_cmd {
+	GEN_CMD_CODE(_Read_MACREG),	/*0*/
+	GEN_CMD_CODE(_Write_MACREG),
+	GEN_CMD_CODE(_Read_BBREG),
+	GEN_CMD_CODE(_Write_BBREG),
+	GEN_CMD_CODE(_Read_RFREG),
+	GEN_CMD_CODE(_Write_RFREG), /*5*/
+	GEN_CMD_CODE(_Read_EEPROM),
+	GEN_CMD_CODE(_Write_EEPROM),
+	GEN_CMD_CODE(_Read_EFUSE),
+	GEN_CMD_CODE(_Write_EFUSE),
+
+	GEN_CMD_CODE(_Read_CAM),	/*10*/
+	GEN_CMD_CODE(_Write_CAM),
+	GEN_CMD_CODE(_setBCNITV),
+	GEN_CMD_CODE(_setMBIDCFG),
+	GEN_CMD_CODE(_JoinBss),   /*14*/
+	GEN_CMD_CODE(_DisConnect), /*15*/
+	GEN_CMD_CODE(_CreateBss),
+	GEN_CMD_CODE(_SetOpMode),
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+	GEN_CMD_CODE(_SetAuth),
+
+	GEN_CMD_CODE(_SetKey),	/*20*/
+	GEN_CMD_CODE(_SetStaKey),
+	GEN_CMD_CODE(_SetAssocSta),
+	GEN_CMD_CODE(_DelAssocSta),
+	GEN_CMD_CODE(_SetStaPwrState),
+	GEN_CMD_CODE(_SetBasicRate), /*25*/
+	GEN_CMD_CODE(_GetBasicRate),
+	GEN_CMD_CODE(_SetDataRate),
+	GEN_CMD_CODE(_GetDataRate),
+	GEN_CMD_CODE(_SetPhyInfo),
+
+	GEN_CMD_CODE(_GetPhyInfo),	/*30*/
+	GEN_CMD_CODE(_SetPhy),
+	GEN_CMD_CODE(_GetPhy),
+	GEN_CMD_CODE(_readRssi),
+	GEN_CMD_CODE(_readGain),
+	GEN_CMD_CODE(_SetAtim), /*35*/
+	GEN_CMD_CODE(_SetPwrMode),
+	GEN_CMD_CODE(_JoinbssRpt),
+	GEN_CMD_CODE(_SetRaTable),
+	GEN_CMD_CODE(_GetRaTable),
+
+	GEN_CMD_CODE(_GetCCXReport), /*40*/
+	GEN_CMD_CODE(_GetDTMReport),
+	GEN_CMD_CODE(_GetTXRateStatistics),
+	GEN_CMD_CODE(_SetUsbSuspend),
+	GEN_CMD_CODE(_SetH2cLbk),
+	GEN_CMD_CODE(_AddBAReq), /*45*/
+
+	GEN_CMD_CODE(_SetChannel), /*46*/
+/* MP_OFFLOAD Start (47~54)*/
+	GEN_CMD_CODE(_SetTxPower),
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+	GEN_CMD_CODE(_SetSingleToneTx),
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+/* MP_OFFLOAD End*/
+	GEN_CMD_CODE(_TX_Beacon), /*55*/
+	GEN_CMD_CODE(_SetPowerTracking),
+	GEN_CMD_CODE(_AMSDU_TO_AMPDU), /*57*/
+	GEN_CMD_CODE(_SetMacAddress), /*58*/
+
+	GEN_CMD_CODE(_DisconnectCtrl), /*59*/
+	GEN_CMD_CODE(_SetChannelPlan), /*60*/
+	GEN_CMD_CODE(_DisconnectCtrlEx), /*61*/
+
+	/* To do, modify these h2c cmd, add or delete */
+	GEN_CMD_CODE(_GetH2cLbk) ,
+
+	/* WPS extra IE */
+	GEN_CMD_CODE(_SetProbeReqExtraIE) ,
+	GEN_CMD_CODE(_SetAssocReqExtraIE) ,
+	GEN_CMD_CODE(_SetProbeRspExtraIE) ,
+	GEN_CMD_CODE(_SetAssocRspExtraIE) ,
+
+	/* the following is driver will do */
+	GEN_CMD_CODE(_GetCurDataRate) ,
+
+	GEN_CMD_CODE(_GetTxRetrycnt),  /* to record times that Tx retry to
+					* transmmit packet after association
+					*/
+	GEN_CMD_CODE(_GetRxRetrycnt),  /* to record total number of the
+					* received frame with ReTry bit set in
+					* the WLAN header
+					*/
+
+	GEN_CMD_CODE(_GetBCNOKcnt),
+	GEN_CMD_CODE(_GetBCNERRcnt),
+	GEN_CMD_CODE(_GetCurTxPwrLevel),
+
+	GEN_CMD_CODE(_SetDIG),
+	GEN_CMD_CODE(_SetRA),
+	GEN_CMD_CODE(_SetPT),
+	GEN_CMD_CODE(_ReadTSSI),
+
+	MAX_H2CCMD
+};
+
+
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_		_Write_RFREG_CMD_
+#define _DRV_INT_CMD_		(MAX_H2CCMD+1)
+#define _SetRFIntFs_CMD_	(MAX_H2CCMD+2)
+
+#ifdef _RTL8712_CMD_C_
+static struct _cmd_callback	cmd_callback[] = {
+	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL},
+	{GEN_CMD_CODE(_Read_BBREG), &r8712_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &r8712_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &r8712_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &r8712_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), &r8712_createbss_cmd_callback},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &r8712_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &r8712_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &r8712_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable), NULL},
+
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
+	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
+	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+/* MP_OFFLOAD Start (47~54)*/
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL},
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+/* MP_OFFLOAD End*/
+	{GEN_CMD_CODE(_TX_Beacon), NULL}, /*55*/
+	{GEN_CMD_CODE(_SetPowerTracking), NULL},
+	{GEN_CMD_CODE(_AMSDU_TO_AMPDU), NULL}, /*57*/
+	{GEN_CMD_CODE(_SetMacAddress), NULL}, /*58*/
+
+	{GEN_CMD_CODE(_DisconnectCtrl), NULL}, /*59*/
+	{GEN_CMD_CODE(_SetChannelPlan), NULL}, /*60*/
+	{GEN_CMD_CODE(_DisconnectCtrlEx), NULL}, /*61*/
+
+	/* To do, modify these h2c cmd, add or delete */
+	{GEN_CMD_CODE(_GetH2cLbk), NULL},
+
+	{_SetProbeReqExtraIE_CMD_, NULL},
+	{_SetAssocReqExtraIE_CMD_, NULL},
+	{_SetProbeRspExtraIE_CMD_, NULL},
+	{_SetAssocRspExtraIE_CMD_, NULL},
+	{_GetCurDataRate_CMD_, NULL},
+	{_GetTxRetrycnt_CMD_, NULL},
+	{_GetRxRetrycnt_CMD_, NULL},
+	{_GetBCNOKcnt_CMD_, NULL},
+	{_GetBCNERRcnt_CMD_, NULL},
+	{_GetCurTxPwrLevel_CMD_, NULL},
+	{_SetDIG_CMD_, NULL},
+	{_SetRA_CMD_, NULL},
+	{_SetPT_CMD_, NULL},
+	{GEN_CMD_CODE(_ReadTSSI), &r8712_readtssi_cmdrsp_callback}
+};
+#endif
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_debugctrl_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,55 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_DEBUGCTRL_BITDEF_H__
+#define __RTL8712_DEBUGCTRL_BITDEF_H__
+
+/*BIST*/
+#define	_BIST_RST			BIT(0)
+
+/*LMS*/
+#define	_LMS_MSK			0x03
+
+/*WDG_CTRL*/
+#define	_OVSEL_MSK			0x0600
+#define	_OVSEL_SHT			9
+#define	_WDGCLR				BIT(8)
+#define	_WDGEN_MSK			0x00FF
+#define	_WDGEN_SHT			0
+
+/*INTM*/
+#define	_TXTIMER_MSK		0xF000
+#define	_TXTIMER_SHT		12
+#define	_TXNUM_MSK			0x0F00
+#define	_TXNUM_SHT			8
+#define	_RXTIMER_MSK		0x00F0
+#define	_RXTIMER_SHT		4
+#define	_RXNUM_MSK			0x000F
+#define	_RXNUM_SHT			0
+
+/*FDLOCKTURN0*/
+/*FDLOCKTURN1*/
+#define	_TURN1				BIT(0)
+
+/*FDLOCKFLAG0*/
+/*FDLOCKFLAG1*/
+#define	_LOCKFLAG1_MSK		0x03
+
+
+#endif /* __RTL8712_DEBUGCTRL_BITDEF_H__ */
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_debugctrl_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_DEBUGCTRL_REGDEF_H__
+#define __RTL8712_DEBUGCTRL_REGDEF_H__
+
+#define BIST			(RTL8712_DEBUGCTRL_ + 0x00)
+#define DBS			(RTL8712_DEBUGCTRL_ + 0x04)
+#define LMS			(RTL8712_DEBUGCTRL_ + 0x05)
+#define CPUINST			(RTL8712_DEBUGCTRL_ + 0x08)
+#define CPUCAUSE		(RTL8712_DEBUGCTRL_ + 0x0C)
+#define LBUS_ERR_ADDR		(RTL8712_DEBUGCTRL_ + 0x10)
+#define LBUS_ERR_CMD		(RTL8712_DEBUGCTRL_ + 0x14)
+#define LBUS_ERR_DATA_L		(RTL8712_DEBUGCTRL_ + 0x18)
+#define LBUS_ERR_DATA_H		(RTL8712_DEBUGCTRL_ + 0x1C)
+#define LBUS_EXCEPTION_ADDR	(RTL8712_DEBUGCTRL_ + 0x20)
+#define WDG_CTRL		(RTL8712_DEBUGCTRL_ + 0x24)
+#define INTMTU			(RTL8712_DEBUGCTRL_ + 0x28)
+#define INTM			(RTL8712_DEBUGCTRL_ + 0x2A)
+#define FDLOCKTURN0		(RTL8712_DEBUGCTRL_ + 0x2C)
+#define FDLOCKTURN1		(RTL8712_DEBUGCTRL_ + 0x2D)
+#define FDLOCKFLAG0		(RTL8712_DEBUGCTRL_ + 0x2E)
+#define FDLOCKFLAG1		(RTL8712_DEBUGCTRL_ + 0x2F)
+#define TRXPKTBUF_DBG_DATA	(RTL8712_DEBUGCTRL_ + 0x30)
+#define TRXPKTBUF_DBG_CTRL	(RTL8712_DEBUGCTRL_ + 0x38)
+#define DPLL_MON		(RTL8712_DEBUGCTRL_ + 0x3A)
+
+
+
+#endif /* __RTL8712_DEBUGCTRL_REGDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_edcasetting_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,77 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_EDCASETTING_BITDEF_H__
+#define __RTL8712_EDCASETTING_BITDEF_H__
+
+/*EDCAPARAM*/
+#define	_TXOPLIMIT_MSK		0xFFFF0000
+#define	_TXOPLIMIT_SHT		16
+#define	_ECWIN_MSK		0x0000FF00
+#define	_ECWIN_SHT		8
+#define	_AIFS_MSK		0x000000FF
+#define	_AIFS_SHT		0
+
+/*BCNTCFG*/
+#define	_BCNECW_MSK		0xFF00
+#define	_BCNECW_SHT		8
+#define	_BCNIFS_MSK		0x00FF
+#define	_BCNIFS_SHT		0
+
+/*CWRR*/
+#define	_CWRR_MSK		0x03FF
+
+/*ACMAVG*/
+#define	_AVG_TIME_UP		BIT(3)
+#define	_AVGPERIOD_MSK		0x03
+
+/*ACMHWCTRL*/
+#define	_VOQ_ACM_STATUS		BIT(6)
+#define	_VIQ_ACM_STATUS		BIT(5)
+#define	_BEQ_ACM_STATUS		BIT(4)
+#define	_VOQ_ACM_EN		BIT(3)
+#define	_VIQ_ACM_EN		BIT(2)
+#define	_BEQ_ACM_EN		BIT(1)
+#define	_ACMHWEN		BIT(0)
+
+/*VO_ADMTIME*/
+#define	_VO_ACM_RUT		BIT(18)
+#define	_VO_ADMTIME_MSK		0x0003FFF
+
+/*VI_ADMTIME*/
+#define	_VI_ACM_RUT		BIT(18)
+#define	_VI_ADMTIME_MSK		0x0003FFF
+
+/*BE_ADMTIME*/
+#define	_BE_ACM_RUT		BIT(18)
+#define	_BE_ADMTIME_MSK		0x0003FFF
+
+/*Retry limit reg*/
+#define	_SRL_MSK		0xFF00
+#define	_SRL_SHT		8
+#define	_LRL_MSK		0x00FF
+#define	_LRL_SHT		0
+
+#endif /* __RTL8712_EDCASETTING_BITDEF_H__*/
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_edcasetting_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_EDCASETTING_REGDEF_H__
+#define __RTL8712_EDCASETTING_REGDEF_H__
+
+#define EDCA_VO_PARAM		(RTL8712_EDCASETTING_ + 0x00)
+#define EDCA_VI_PARAM		(RTL8712_EDCASETTING_ + 0x04)
+#define EDCA_BE_PARAM		(RTL8712_EDCASETTING_ + 0x08)
+#define EDCA_BK_PARAM		(RTL8712_EDCASETTING_ + 0x0C)
+#define BCNTCFG			(RTL8712_EDCASETTING_ + 0x10)
+#define CWRR			(RTL8712_EDCASETTING_ + 0x12)
+#define ACMAVG			(RTL8712_EDCASETTING_ + 0x16)
+#define ACMHWCTRL		(RTL8712_EDCASETTING_ + 0x17)
+#define VO_ADMTIME		(RTL8712_EDCASETTING_ + 0x18)
+#define VI_ADMTIME		(RTL8712_EDCASETTING_ + 0x1C)
+#define BE_ADMTIME		(RTL8712_EDCASETTING_ + 0x20)
+#define RL			(RTL8712_EDCASETTING_ + 0x24)
+
+#endif /* __RTL8712_EDCASETTING_REGDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_efuse.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_efuse.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_efuse.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_efuse.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,575 @@
+/*
+ * rtl8712_efuse.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_EFUSE_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl8712_efuse.h"
+
+/* reserve 3 bytes for HW stop read */
+static int efuse_available_max_size = EFUSE_MAX_SIZE - 3 /*0x1FD*/;
+
+static void efuse_reg_ctrl(struct _adapter *padapter, u8 bPowerOn)
+{
+	u8 tmpu8 = 0;
+
+	if (true == bPowerOn) {
+		/* -----------------e-fuse pwr & clk reg ctrl ---------------
+		 * Enable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 |= 0x80;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		msleep(20); /* for some platform , need some delay time */
+		/* Change Efuse Clock for write action to 40MHZ */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x03);
+		msleep(20); /* for some platform , need some delay time */
+	} else {
+		/* -----------------e-fuse pwr & clk reg ctrl -----------------
+		 * Disable LDOE25 Macro Block
+		 */
+		tmpu8 = r8712_read8(padapter, EFUSE_TEST + 3);
+		tmpu8 &= 0x7F;
+		r8712_write8(padapter, EFUSE_TEST + 3, tmpu8);
+		/* Change Efuse Clock for write action to 500K */
+		r8712_write8(padapter, EFUSE_CLK_CTRL, 0x02);
+	}
+}
+
+/*
+ * Before write E-Fuse, this function must be called.
+ */
+u8 r8712_efuse_reg_init(struct _adapter *padapter)
+{
+	return true;
+}
+
+void r8712_efuse_reg_uninit(struct _adapter *padapter)
+{
+	efuse_reg_ctrl(padapter, false);
+}
+
+static u8 efuse_one_byte_read(struct _adapter *padapter, u16 addr, u8 *data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL+3, 0x72); /* read cmd */
+	/* wait for complete */
+	while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100) {
+		*data = r8712_read8(padapter, EFUSE_CTRL);
+		bResult = true;
+	} else {
+		*data = 0xff;
+		bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_one_byte_write(struct _adapter *padapter, u16 addr, u8 data)
+{
+	u8 tmpidx = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl -------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	r8712_write8(padapter, EFUSE_CTRL+2, ((u8)((addr>>8)&0x03)) |
+	       (r8712_read8(padapter, EFUSE_CTRL+2)&0xFC));
+	r8712_write8(padapter, EFUSE_CTRL, data); /* data */
+	r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+	/* wait for complete */
+	while ((0x80 &  r8712_read8(padapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100)
+		bResult = true;
+	else
+		bResult = false;
+	return bResult;
+}
+
+static u8 efuse_one_byte_rw(struct _adapter *padapter, u8 bRead, u16 addr,
+			    u8 *data)
+{
+	u8 tmpidx = 0, tmpv8 = 0, bResult;
+
+	/* -----------------e-fuse reg ctrl --------------------------------- */
+	r8712_write8(padapter, EFUSE_CTRL+1, (u8)(addr&0xFF)); /* address */
+	tmpv8 = ((u8)((addr >> 8) & 0x03)) |
+		 (r8712_read8(padapter, EFUSE_CTRL + 2) & 0xFC);
+	r8712_write8(padapter, EFUSE_CTRL+2, tmpv8);
+	if (true == bRead) {
+		r8712_write8(padapter, EFUSE_CTRL+3,  0x72); /* read cmd */
+		while (!(0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100) {
+			*data = r8712_read8(padapter, EFUSE_CTRL);
+			bResult = true;
+		} else {
+			*data = 0;
+			bResult = false;
+		}
+	} else {
+		r8712_write8(padapter, EFUSE_CTRL, *data); /* data */
+		r8712_write8(padapter, EFUSE_CTRL+3, 0xF2); /* write cmd */
+		while ((0x80 & r8712_read8(padapter, EFUSE_CTRL+3)) &&
+		       (tmpidx < 100))
+			tmpidx++;
+		if (tmpidx < 100)
+			bResult = true;
+		else
+			bResult = false;
+	}
+	return bResult;
+}
+
+static u8 efuse_is_empty(struct _adapter *padapter, u8 *empty)
+{
+	u8 value, ret = true;
+
+	/* read one byte to check if E-Fuse is empty */
+	if (efuse_one_byte_rw(padapter, true, 0, &value) == true) {
+		if (0xFF == value)
+			*empty = true;
+		else
+			*empty = false;
+	} else
+		ret = false;
+	return ret;
+}
+
+void r8712_efuse_change_max_size(struct _adapter *padapter)
+{
+	u16 pre_pg_data_saddr = 0x1FB;
+	u16 i;
+	u16 pre_pg_data_size = 5;
+	u8 pre_pg_data[5];
+
+	for (i = 0; i < pre_pg_data_size; i++)
+		efuse_one_byte_read(padapter, pre_pg_data_saddr + i,
+				    &pre_pg_data[i]);
+	if ((pre_pg_data[0] == 0x03) && (pre_pg_data[1] == 0x00) &&
+	    (pre_pg_data[2] == 0x00) && (pre_pg_data[3] == 0x00) &&
+	    (pre_pg_data[4] == 0x0C))
+		efuse_available_max_size -= pre_pg_data_size;
+}
+
+int r8712_efuse_get_max_size(struct _adapter *padapter)
+{
+	return	efuse_available_max_size;
+}
+
+static u8 calculate_word_cnts(const u8 word_en)
+{
+	u8 word_cnts = 0;
+	u8 word_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++)
+		if (!(word_en & BIT(word_idx)))
+			word_cnts++; /* 0 : write enable */
+	return word_cnts;
+}
+
+static void pgpacket_copy_data(const u8 word_en, const u8 *sourdata,
+			       u8 *targetdata)
+{
+	u8 tmpindex = 0;
+	u8 word_idx, byte_idx;
+
+	for (word_idx = 0; word_idx < PGPKG_MAX_WORDS; word_idx++) {
+		if (!(word_en&BIT(word_idx))) {
+			byte_idx = word_idx * 2;
+			targetdata[byte_idx] = sourdata[tmpindex++];
+			targetdata[byte_idx + 1] = sourdata[tmpindex++];
+		}
+	}
+}
+
+u16 r8712_efuse_get_current_size(struct _adapter *padapter)
+{
+	int bContinual = true;
+	u16 efuse_addr = 0;
+	u8 hoffset = 0, hworden = 0;
+	u8 efuse_data, word_cnts = 0;
+
+	while (bContinual && efuse_one_byte_read(padapter, efuse_addr,
+	       &efuse_data) && (efuse_addr < efuse_available_max_size)) {
+		if (efuse_data != 0xFF) {
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			/* read next header */
+			efuse_addr = efuse_addr + (word_cnts * 2) + 1;
+		} else
+			bContinual = false ;
+	}
+	return efuse_addr;
+}
+
+u8 r8712_efuse_pg_packet_read(struct _adapter *padapter, u8 offset, u8 *data)
+{
+	u8 hoffset = 0, hworden = 0, word_cnts = 0;
+	u16 efuse_addr = 0;
+	u8 efuse_data;
+	u8 tmpidx = 0;
+	u8 tmpdata[PGPKT_DATA_SIZE];
+	u8 ret = true;
+
+	if (data == NULL)
+		return false;
+	if (offset > 0x0f)
+		return false;
+	memset(data, 0xFF, sizeof(u8)*PGPKT_DATA_SIZE);
+	while (efuse_addr < efuse_available_max_size) {
+		if (efuse_one_byte_read(padapter, efuse_addr, &efuse_data) ==
+		    true) {
+			if (efuse_data == 0xFF)
+				break;
+			hoffset = (efuse_data >> 4) & 0x0F;
+			hworden =  efuse_data & 0x0F;
+			word_cnts = calculate_word_cnts(hworden);
+			if (hoffset == offset) {
+				memset(tmpdata, 0xFF, PGPKT_DATA_SIZE);
+				for (tmpidx = 0; tmpidx < word_cnts * 2;
+				     tmpidx++) {
+					if (efuse_one_byte_read(padapter,
+					    efuse_addr+1+tmpidx, &efuse_data) ==
+					     true) {
+						tmpdata[tmpidx] = efuse_data;
+					} else
+						ret = false;
+				}
+				pgpacket_copy_data(hworden, tmpdata, data);
+			}
+			efuse_addr += 1 + (word_cnts*2);
+		} else {
+			ret = false;
+			break;
+		}
+	}
+	return ret;
+}
+
+static u8 fix_header(struct _adapter *padapter, u8 header, u16 header_addr)
+{
+	struct PGPKT_STRUCT pkt;
+	u8 offset, word_en, value;
+	u16 addr;
+	int i;
+	u8 ret = true;
+
+	pkt.offset = GET_EFUSE_OFFSET(header);
+	pkt.word_en = GET_EFUSE_WORD_EN(header);
+	addr = header_addr + 1 + calculate_word_cnts(pkt.word_en) * 2;
+	if (addr > efuse_available_max_size)
+		return false;
+	/* retrieve original data */
+	addr = 0;
+	while (addr < header_addr) {
+		if (efuse_one_byte_read(padapter, addr++, &value) == false) {
+			ret = false;
+			break;
+		}
+		offset = GET_EFUSE_OFFSET(value);
+		word_en = GET_EFUSE_WORD_EN(value);
+		if (pkt.offset != offset) {
+			addr += calculate_word_cnts(word_en)*2;
+			continue;
+		}
+		for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+			if (BIT(i) & word_en) {
+				if (BIT(i) & pkt.word_en) {
+					if (efuse_one_byte_read(
+							padapter, addr,
+							&value) == true)
+						pkt.data[i*2] = value;
+					else
+						return false;
+					if (efuse_one_byte_read(
+							padapter,
+							addr + 1,
+							&value) == true)
+						pkt.data[i*2 + 1] =
+							value;
+					else
+						return false;
+				}
+				addr += 2;
+			}
+		}
+	}
+	if (addr != header_addr)
+		return false;
+	addr++;
+	/* fill original data */
+	for (i = 0; i < PGPKG_MAX_WORDS; i++) {
+		if (BIT(i) & pkt.word_en) {
+			efuse_one_byte_write(padapter, addr, pkt.data[i*2]);
+			efuse_one_byte_write(padapter, addr+1,
+					pkt.data[i*2 + 1]);
+			/* additional check */
+			if (efuse_one_byte_read(padapter, addr, &value)
+				== false)
+				ret = false;
+			else if (pkt.data[i*2] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr,
+							pkt.data[i * 2]);
+			}
+			if (efuse_one_byte_read(padapter, addr+1, &value) ==
+				false)
+				ret = false;
+			else if (pkt.data[i*2 + 1] != value) {
+				ret = false;
+				if (0xFF == value) /* write again */
+					efuse_one_byte_write(padapter, addr+1,
+							pkt.data[i*2 + 1]);
+			}
+		}
+		addr += 2;
+	}
+	return ret;
+}
+
+u8 r8712_efuse_pg_packet_write(struct _adapter *padapter, const u8 offset,
+			 const u8 word_en, const u8 *data)
+{
+	u8 pg_header = 0;
+	u16 efuse_addr = 0, curr_size = 0;
+	u8 efuse_data, target_word_cnts = 0;
+	static int repeat_times;
+	int sub_repeat;
+	u8 bResult = true;
+
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	efuse_data = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (efuse_data != 0x03)
+		return false;
+	pg_header = MAKE_EFUSE_HEADER(offset, word_en);
+	target_word_cnts = calculate_word_cnts(word_en);
+	repeat_times = 0;
+	efuse_addr = 0;
+	while (efuse_addr < efuse_available_max_size) {
+		curr_size = r8712_efuse_get_current_size(padapter);
+		if ((curr_size + 1 + target_word_cnts * 2) >
+		     efuse_available_max_size)
+			return false; /*target_word_cnts + pg header(1 byte)*/
+		efuse_addr = curr_size; /* current size is also the last addr*/
+		efuse_one_byte_write(padapter, efuse_addr, pg_header); /*hdr*/
+		sub_repeat = 0;
+		/* check if what we read is what we write */
+		while (efuse_one_byte_read(padapter, efuse_addr,
+					   &efuse_data) == false) {
+			if (++sub_repeat > _REPEAT_THRESHOLD_) {
+				bResult = false; /* continue to blind write */
+				break; /* continue to blind write */
+			}
+		}
+		if ((sub_repeat > _REPEAT_THRESHOLD_) ||
+		    (pg_header == efuse_data)) {
+			/* write header ok OR can't check header(creep) */
+			u8 i;
+
+			/* go to next address */
+			efuse_addr++;
+			for (i = 0; i < target_word_cnts*2; i++) {
+				efuse_one_byte_write(padapter,
+						     efuse_addr + i,
+						     *(data + i));
+				if (efuse_one_byte_read(padapter,
+				    efuse_addr + i, &efuse_data) == false)
+					bResult = false;
+				else if (*(data+i) != efuse_data) /* fail */
+					bResult = false;
+			}
+			break;
+		} else { /* write header fail */
+			bResult = false;
+			if (0xFF == efuse_data)
+				return bResult; /* not thing damaged. */
+			/* call rescue procedure */
+			if (fix_header(padapter, efuse_data, efuse_addr) ==
+			    false)
+				return false; /* rescue fail */
+
+			if (++repeat_times > _REPEAT_THRESHOLD_) /* fail */
+				break;
+			/* otherwise, take another risk... */
+		}
+	}
+	return bResult;
+}
+
+u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead, u16 start_addr,
+		      u16 cnts, u8 *data)
+{
+	int i;
+	u8 res = true;
+
+	if (start_addr > EFUSE_MAX_SIZE)
+		return false;
+	if ((bRead == false) && ((start_addr + cnts) >
+	   efuse_available_max_size))
+		return false;
+	if ((false == bRead) && (r8712_efuse_reg_init(padapter) == false))
+		return false;
+	/* -----------------e-fuse one byte read / write ---------------------*/
+	for (i = 0; i < cnts; i++) {
+		if ((start_addr + i) > EFUSE_MAX_SIZE) {
+			res = false;
+			break;
+		}
+		res = efuse_one_byte_rw(padapter, bRead, start_addr + i,
+		      data + i);
+		if ((false == bRead) && (false == res))
+			break;
+	}
+	if (false == bRead)
+		r8712_efuse_reg_uninit(padapter);
+	return res;
+}
+
+u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, ret = true;
+	u8 pktdata[PGPKT_DATA_SIZE];
+	int i, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	if ((efuse_is_empty(padapter, &offset) == true) && (offset ==
+	     true)) {
+		for (i = 0; i < cnts; i++)
+			data[i] = 0xFF;
+		return ret;
+	}
+	offset = (addr >> 3) & 0xF;
+	ret = r8712_efuse_pg_packet_read(padapter, offset, pktdata);
+	i = addr & 0x7;	/* pktdata index */
+	idx = 0;	/* data index */
+
+	do {
+		for (; i < PGPKT_DATA_SIZE; i++) {
+			data[idx++] = pktdata[i];
+			if (idx == cnts)
+				return ret;
+		}
+		offset++;
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			ret = false;
+		i = 0;
+	} while (1);
+	return ret;
+}
+
+u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr, u16 cnts,
+			 u8 *data)
+{
+	u8 offset, word_en, empty;
+	u8 pktdata[PGPKT_DATA_SIZE], newdata[PGPKT_DATA_SIZE];
+	int i, j, idx;
+
+	if ((addr + cnts) > EFUSE_MAP_MAX_SIZE)
+		return false;
+	/* check if E-Fuse Clock Enable and E-Fuse Clock is 40M */
+	empty = r8712_read8(padapter, EFUSE_CLK_CTRL);
+	if (empty != 0x03)
+		return false;
+	if (efuse_is_empty(padapter, &empty) == true) {
+		if (true == empty)
+			memset(pktdata, 0xFF, PGPKT_DATA_SIZE);
+	} else
+		return false;
+	offset = (addr >> 3) & 0xF;
+	if (empty == false)
+		if (!r8712_efuse_pg_packet_read(padapter, offset, pktdata))
+			return false;
+	word_en = 0xF;
+	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	i = addr & 0x7;	/* pktdata index */
+	j = 0;		/* newdata index */
+	idx = 0;	/* data index */
+
+	if (i & 0x1) {
+		/*  odd start */
+		if (data[idx] != pktdata[i]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[j++] = pktdata[i - 1];
+			newdata[j++] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < PGPKT_DATA_SIZE; i += 2) {
+			if ((cnts - idx) == 1) {
+				if (data[idx] != pktdata[i]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = pktdata[1 + 1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != pktdata[i]) || (data[idx+1] !=
+				     pktdata[i+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[j++] = data[idx];
+					newdata[j++] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts)
+				break;
+		}
+
+		if (word_en != 0xF)
+			if (r8712_efuse_pg_packet_write(padapter, offset,
+			    word_en, newdata) == false)
+				return false;
+		if (idx == cnts)
+			break;
+		offset++;
+		if (empty == false)
+			if (!r8712_efuse_pg_packet_read(padapter, offset,
+			    pktdata))
+				return false;
+		i = 0;
+		j = 0;
+		word_en = 0xF;
+		memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	} while (1);
+
+	return true;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_efuse.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_efuse.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_efuse.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_efuse.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,43 @@
+#ifndef __RTL8712_EFUSE_H__
+#define __RTL8712_EFUSE_H__
+
+#include "osdep_service.h"
+
+
+#define _REPEAT_THRESHOLD_	3
+
+#define EFUSE_MAX_SIZE		512
+#define EFUSE_MAP_MAX_SIZE	128
+
+#define PGPKG_MAX_WORDS	4
+#define PGPKT_DATA_SIZE	8 /* PGPKG_MAX_WORDS*2; BYTES sizeof(u8)*8*/
+#define MAX_PGPKT_SIZE	9 /* 1 + PGPKT_DATA_SIZE; header + 2 * 4 words (BYTES)*/
+
+#define GET_EFUSE_OFFSET(header)	((header & 0xF0) >> 4)
+#define GET_EFUSE_WORD_EN(header)	(header & 0x0F)
+#define MAKE_EFUSE_HEADER(offset, word_en)	(((offset & 0x0F) << 4) | \
+						(word_en & 0x0F))
+/*--------------------------------------------------------------------------*/
+struct PGPKT_STRUCT {
+	u8 offset;
+	u8 word_en;
+	u8 data[PGPKT_DATA_SIZE];
+};
+/*--------------------------------------------------------------------------*/
+u8 r8712_efuse_reg_init(struct _adapter *padapter);
+void r8712_efuse_reg_uninit(struct _adapter *padapter);
+u16 r8712_efuse_get_current_size(struct _adapter *padapter);
+int r8712_efuse_get_max_size(struct _adapter *padapter);
+void r8712_efuse_change_max_size(struct _adapter *padapter);
+u8 r8712_efuse_pg_packet_read(struct _adapter *padapter,
+			      u8 offset, u8 *data);
+u8 r8712_efuse_pg_packet_write(struct _adapter *padapter,
+			       const u8 offset, const u8 word_en,
+			       const u8 *data);
+u8 r8712_efuse_access(struct _adapter *padapter, u8 bRead,
+		      u16 start_addr, u16 cnts, u8 *data);
+u8 r8712_efuse_map_read(struct _adapter *padapter, u16 addr,
+			u16 cnts, u8 *data);
+u8 r8712_efuse_map_write(struct _adapter *padapter, u16 addr,
+				u16 cnts, u8 *data);
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_event.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_event.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_event.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_event.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,99 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_EVENT_H_
+#define _RTL8712_EVENT_H_
+
+void r8712_event_handle(struct _adapter *padapter, uint *peventbuf);
+void r8712_got_addbareq_event_callback(struct _adapter *adapter , u8 *pbuf);
+
+enum rtl8712_c2h_event {
+	GEN_EVT_CODE(_Read_MACREG) = 0,		/*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+	GEN_EVT_CODE(_Read_RFREG),
+	GEN_EVT_CODE(_Read_EEPROM),
+	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),		/*5*/
+	GEN_EVT_CODE(_Get_BasicRate),
+	GEN_EVT_CODE(_Get_DataRate),
+	GEN_EVT_CODE(_Survey),			/*8*/
+	GEN_EVT_CODE(_SurveyDone),		/*9*/
+
+	GEN_EVT_CODE(_JoinBss),			/*10*/
+	GEN_EVT_CODE(_AddSTA),
+	GEN_EVT_CODE(_DelSTA),
+	GEN_EVT_CODE(_AtimDone),
+	GEN_EVT_CODE(_TX_Report),
+	GEN_EVT_CODE(_CCX_Report),		/*15*/
+	GEN_EVT_CODE(_DTM_Report),
+	GEN_EVT_CODE(_TX_Rate_Statistics),
+	GEN_EVT_CODE(_C2HLBK),
+	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),		/*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		/*filen: only for PCIE, USB*/
+	GEN_EVT_CODE(_WPS_PBC),			/*24*/
+	GEN_EVT_CODE(_ADDBAReq_Report),		/*25*/
+	MAX_C2HEVT
+};
+
+
+#ifdef _RTL8712_CMD_C_
+
+static struct fwevent wlanevents[] = {
+	{0, NULL},	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &r8712_survey_event_callback},		/*8*/
+	{sizeof(struct surveydone_event),
+		&r8712_surveydone_event_callback},	/*9*/
+
+	{0, &r8712_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &r8712_stassoc_event_callback},
+	{sizeof(struct stadel_event), &r8712_stadel_event_callback},
+	{0, &r8712_atimdone_event_callback},
+	{0, NULL},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},	/*fwdbg_event_callback},*/
+	{0, NULL},	/*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &r8712_cpwm_event_callback},
+	{0, &r8712_wpspbc_event_callback},
+	{0, &r8712_got_addbareq_event_callback},
+};
+
+#endif/*_RTL8712_CMD_C_*/
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_fifoctrl_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_FIFOCTRL_BITDEF_H__
+#define __RTL8712_FIFOCTRL_BITDEF_H__
+
+/*PBP*/
+#define	_PSTX_MSK			0xF0
+#define	_PSTX_SHT			4
+#define	_PSRX_MSK			0x0F
+#define	_PSRX_SHT			0
+
+/*TXFF_STATUS*/
+#define	_TXSTATUS_OVF		BIT(15)
+
+/*RXFF_STATUS*/
+#define	_STATUSFF1_OVF		BIT(7)
+#define	_STATUSFF1_EMPTY	BIT(6)
+#define	_STATUSFF0_OVF		BIT(5)
+#define	_STATUSFF0_EMPTY	BIT(4)
+#define	_RXFF1_OVF			BIT(3)
+#define	_RXFF1_EMPTY		BIT(2)
+#define	_RXFF0_OVF			BIT(1)
+#define	_RXFF0_EMPTY		BIT(0)
+
+/*TXFF_EMPTY_TH*/
+#define	_BKQ_EMPTY_TH_MSK	0x0F0000
+#define	_BKQ_EMPTY_TH_SHT	16
+#define	_BEQ_EMPTY_TH_MSK	0x00F000
+#define	_BEQ_EMPTY_TH_SHT	12
+#define	_VIQ_EMPTY_TH_MSK	0x000F00
+#define	_VIQ_EMPTY_TH_SHT	8
+#define	_VOQ_EMPTY_TH_MSK	0x0000F0
+#define	_VOQ_EMPTY_TH_SHT	4
+#define	_BMCQ_EMPTY_TH_MSK	0x00000F
+#define	_BMCQ_EMPTY_TH_SHT	0
+
+/*SDIO_RX_BLKSZ*/
+#define	_SDIO_RX_BLKSZ_MSK	0x07
+
+/*RXDMA_CTRL*/
+#define	_C2HFF_POLL		BIT(4)
+#define	_RXPKT_POLL		BIT(0)
+
+/*RXPKT_NUM*/
+#define	_RXCMD_NUM_MSK		0xFF00
+#define	_RXCMD_NUM_SHT		8
+#define	_RXFF0_NUM_MSK		0x00FF
+#define	_RXFF0_NUM_SHT		0
+
+/*FIFOPAGE2*/
+#define	_PUB_AVAL_PG_MSK	0xFFFF0000
+#define	_PUB_AVAL_PG_SHT	16
+#define	_BCN_AVAL_PG_MSK	0x0000FFFF
+#define	_BCN_AVAL_PG_SHT	0
+
+/*RX0PKTNUM*/
+#define	_RXFF0_DEC_POLL				BIT(15)
+#define	_RXFF0_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF0_PKT_DEC_NUM_SHT		8
+#define	_RXFF0_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF0_PKTNUM_RPT_SHT		0
+
+/*RX1PKTNUM*/
+#define	_RXFF1_DEC_POLL				BIT(15)
+#define	_RXFF1_PKT_DEC_NUM_MSK		0x3F00
+#define	_RXFF1_PKT_DEC_NUM_SHT		8
+#define	_RXFF1_PKTNUM_RPT_MSK		0x00FF
+#define	_RXFF1_PKTNUM_RPT_SHT		0
+
+/*RXFLTMAP0*/
+#define	_MGTFLT13EN		BIT(13)
+#define	_MGTFLT12EN		BIT(12)
+#define	_MGTFLT11EN		BIT(11)
+#define	_MGTFLT10EN		BIT(10)
+#define	_MGTFLT9EN		BIT(9)
+#define	_MGTFLT8EN		BIT(8)
+#define	_MGTFLT5EN		BIT(5)
+#define	_MGTFLT4EN		BIT(4)
+#define	_MGTFLT3EN		BIT(3)
+#define	_MGTFLT2EN		BIT(2)
+#define	_MGTFLT1EN		BIT(1)
+#define	_MGTFLT0EN		BIT(0)
+
+/*RXFLTMAP1*/
+#define	_CTRLFLT15EN	BIT(15)
+#define	_CTRLFLT14EN	BIT(14)
+#define	_CTRLFLT13EN	BIT(13)
+#define	_CTRLFLT12EN	BIT(12)
+#define	_CTRLFLT11EN	BIT(11)
+#define	_CTRLFLT10EN	BIT(10)
+#define	_CTRLFLT9EN		BIT(9)
+#define	_CTRLFLT8EN		BIT(8)
+#define	_CTRLFLT7EN		BIT(7)
+#define	_CTRLFLT6EN		BIT(6)
+
+/*RXFLTMAP2*/
+#define	_DATAFLT15EN	BIT(15)
+#define	_DATAFLT14EN	BIT(14)
+#define	_DATAFLT13EN	BIT(13)
+#define	_DATAFLT12EN	BIT(12)
+#define	_DATAFLT11EN	BIT(11)
+#define	_DATAFLT10EN	BIT(10)
+#define	_DATAFLT9EN		BIT(9)
+#define	_DATAFLT8EN		BIT(8)
+#define	_DATAFLT7EN		BIT(7)
+#define	_DATAFLT6EN		BIT(6)
+#define	_DATAFLT5EN		BIT(5)
+#define	_DATAFLT4EN		BIT(4)
+#define	_DATAFLT3EN		BIT(3)
+#define	_DATAFLT2EN		BIT(2)
+#define	_DATAFLT1EN		BIT(1)
+#define	_DATAFLT0EN		BIT(0)
+
+/*RXFLTMAP3*/
+#define	_MESHAFLT1EN		BIT(1)
+#define	_MESHAFLT0EN		BIT(0)
+
+/*TXPKT_NUM_CTRL*/
+#define	_TXPKTNUM_DEC		BIT(8)
+#define	_TXPKTNUM_MSK		0x00FF
+#define	_TXPKTNUM_SHT		0
+
+/*TXFF_PG_NUM*/
+#define	_TXFF_PG_NUM_MSK	0x0FFF
+
+
+#endif	/*	__RTL8712_FIFOCTRL_BITDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_fifoctrl_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_FIFOCTRL_REGDEF_H__
+#define __RTL8712_FIFOCTRL_REGDEF_H__
+
+#define RQPN			(RTL8712_FIFOCTRL_ + 0x00)
+#define RXFF_BNDY		(RTL8712_FIFOCTRL_ + 0x0C)
+#define RXRPT_BNDY		(RTL8712_FIFOCTRL_ + 0x10)
+#define TXPKTBUF_PGBNDY		(RTL8712_FIFOCTRL_ + 0x14)
+#define PBP			(RTL8712_FIFOCTRL_ + 0x15)
+#define RX_DRVINFO_SZ		(RTL8712_FIFOCTRL_ + 0x16)
+#define TXFF_STATUS		(RTL8712_FIFOCTRL_ + 0x17)
+#define RXFF_STATUS		(RTL8712_FIFOCTRL_ + 0x18)
+#define TXFF_EMPTY_TH		(RTL8712_FIFOCTRL_ + 0x19)
+#define SDIO_RX_BLKSZ		(RTL8712_FIFOCTRL_ + 0x1C)
+#define RXDMA_RXCTRL		(RTL8712_FIFOCTRL_ + 0x1D)
+#define RXPKT_NUM		(RTL8712_FIFOCTRL_ + 0x1E)
+#define RXPKT_NUM_C2H		(RTL8712_FIFOCTRL_ + 0x1F)
+#define C2HCMD_UDT_SIZE		(RTL8712_FIFOCTRL_ + 0x20)
+#define C2HCMD_UDT_ADDR		(RTL8712_FIFOCTRL_ + 0x22)
+#define FIFOPAGE2		(RTL8712_FIFOCTRL_ + 0x24)
+#define FIFOPAGE1		(RTL8712_FIFOCTRL_ + 0x28)
+#define FW_RSVD_PG_CTRL		(RTL8712_FIFOCTRL_ + 0x30)
+#define TXRPTFF_RDPTR		(RTL8712_FIFOCTRL_ + 0x40)
+#define TXRPTFF_WTPTR		(RTL8712_FIFOCTRL_ + 0x44)
+#define C2HFF_RDPTR		(RTL8712_FIFOCTRL_ + 0x48)
+#define C2HFF_WTPTR		(RTL8712_FIFOCTRL_ + 0x4C)
+#define RXFF0_RDPTR		(RTL8712_FIFOCTRL_ + 0x50)
+#define RXFF0_WTPTR		(RTL8712_FIFOCTRL_ + 0x54)
+#define RXFF1_RDPTR		(RTL8712_FIFOCTRL_ + 0x58)
+#define RXFF1_WTPTR		(RTL8712_FIFOCTRL_ + 0x5C)
+#define RXRPT0FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x60)
+#define RXRPT0FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x64)
+#define RXRPT1FF_RDPTR		(RTL8712_FIFOCTRL_ + 0x68)
+#define RXRPT1FF_WTPTR		(RTL8712_FIFOCTRL_ + 0x6C)
+#define RX0PKTNUM		(RTL8712_FIFOCTRL_ + 0x72)
+#define RX1PKTNUM		(RTL8712_FIFOCTRL_ + 0x74)
+#define RXFLTMAP0		(RTL8712_FIFOCTRL_ + 0x76)
+#define RXFLTMAP1		(RTL8712_FIFOCTRL_ + 0x78)
+#define RXFLTMAP2		(RTL8712_FIFOCTRL_ + 0x7A)
+#define RXFLTMAP3		(RTL8712_FIFOCTRL_ + 0x7c)
+#define TBDA			(RTL8712_FIFOCTRL_ + 0x84)
+#define THPDA			(RTL8712_FIFOCTRL_ + 0x88)
+#define TCDA			(RTL8712_FIFOCTRL_ + 0x8C)
+#define TMDA			(RTL8712_FIFOCTRL_ + 0x90)
+#define HDA			(RTL8712_FIFOCTRL_ + 0x94)
+#define TVODA			(RTL8712_FIFOCTRL_ + 0x98)
+#define TVIDA			(RTL8712_FIFOCTRL_ + 0x9C)
+#define TBEDA			(RTL8712_FIFOCTRL_ + 0xA0)
+#define TBKDA			(RTL8712_FIFOCTRL_ + 0xA4)
+#define RCDA			(RTL8712_FIFOCTRL_ + 0xA8)
+#define RDSA			(RTL8712_FIFOCTRL_ + 0xAC)
+#define TXPKT_NUM_CTRL		(RTL8712_FIFOCTRL_ + 0xB0)
+#define TXQ_PGADD		(RTL8712_FIFOCTRL_ + 0xB3)
+#define TXFF_PG_NUM		(RTL8712_FIFOCTRL_ + 0xB4)
+
+
+
+#endif	/* __RTL8712_FIFOCTRL_REGDEF_H__ */
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_gp_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_gp_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_gp_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_gp_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_GP_BITDEF_H__
+#define __RTL8712_GP_BITDEF_H__
+
+/*GPIO_CTRL*/
+#define	_GPIO_MOD_MSK			0xFF000000
+#define	_GPIO_MOD_SHT			24
+#define	_GPIO_IO_SEL_MSK		0x00FF0000
+#define	_GPIO_IO_SEL_SHT		16
+#define	_GPIO_OUT_MSK			0x0000FF00
+#define	_GPIO_OUT_SHT			8
+#define	_GPIO_IN_MSK			0x000000FF
+#define	_GPIO_IN_SHT			0
+
+/*SYS_PINMUX_CFG*/
+#define	_GPIOSEL_MSK			0x0003
+#define	_GPIOSEL_SHT			0
+
+/*LED_CFG*/
+#define _LED1SV				BIT(7)
+#define _LED1CM_MSK			0x0070
+#define _LED1CM_SHT			4
+#define _LED0SV				BIT(3)
+#define _LED0CM_MSK			0x0007
+#define _LED0CM_SHT			0
+
+/*PHY_REG*/
+#define _HST_RDRDY_SHT			0
+#define _HST_RDRDY_MSK			0xFF
+#define _HST_RDRDY			BIT(_HST_RDRDY_SHT)
+#define _CPU_WTBUSY_SHT			1
+#define _CPU_WTBUSY_MSK			0xFF
+#define _CPU_WTBUSY			BIT(_CPU_WTBUSY_SHT)
+
+/* 11. General Purpose Registers   (Offset: 0x02E0 - 0x02FF)*/
+
+/*       8192S GPIO Config Setting (offset 0x2F1, 1 byte)*/
+
+/*----------------------------------------------------------------------------*/
+
+#define		GPIOMUX_EN	BIT(3)	/* When this bit is set to "1",
+					 * GPIO PINs will switch to MAC
+					 * GPIO Function*/
+#define		GPIOSEL_GPIO	0	/* UART or JTAG or pure GPIO*/
+#define		GPIOSEL_PHYDBG	1	/* PHYDBG*/
+#define		GPIOSEL_BT	2	/* BT_coex*/
+#define		GPIOSEL_WLANDBG	3	/* WLANDBG*/
+#define		GPIOSEL_GPIO_MASK	(~(BIT(0)|BIT(1)))
+/* HW Readio OFF switch (GPIO BIT) */
+#define		HAL_8192S_HW_GPIO_OFF_BIT	BIT(3)
+#define		HAL_8192S_HW_GPIO_OFF_MASK	0xF7
+#define		HAL_8192S_HW_GPIO_WPS_BIT	BIT(4)
+
+#endif	/*__RTL8712_GP_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_gp_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_gp_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_gp_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_gp_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_GP_REGDEF_H__
+#define __RTL8712_GP_REGDEF_H__
+
+#define PSTIMER			(RTL8712_GP_ + 0x00)
+#define TIMER1			(RTL8712_GP_ + 0x04)
+#define TIMER2			(RTL8712_GP_ + 0x08)
+#define GPIO_CTRL		(RTL8712_GP_ + 0x0C)
+#define GPIO_IO_SEL		(RTL8712_GP_ + 0x0E)
+#define GPIO_INTCTRL		(RTL8712_GP_ + 0x10)
+#define MAC_PINMUX_CTRL		(RTL8712_GP_ + 0x11)
+#define LEDCFG			(RTL8712_GP_ + 0x12)
+#define PHY_REG_RPT		(RTL8712_GP_ + 0x13)
+#define PHY_REG_DATA		(RTL8712_GP_ + 0x14)
+
+
+#endif	/*__RTL8712_GP_REGDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_hal.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_hal.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_hal.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_hal.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_HAL_H__
+#define __RTL8712_HAL_H__
+
+enum _HW_VERSION {
+	RTL8712_FPGA,
+	RTL8712_1stCUT,	/*A Cut (RTL8712_ASIC)*/
+	RTL8712_2ndCUT,	/*B Cut*/
+	RTL8712_3rdCUT,	/*C Cut*/
+};
+
+enum _LOOPBACK_TYPE {
+	RTL8712_AIR_TRX = 0,
+	RTL8712_MAC_LBK,
+	RTL8712_BB_LBK,
+	RTL8712_MAC_FW_LBK = 4,
+	RTL8712_BB_FW_LBK = 8,
+};
+
+enum RTL871X_HCI_TYPE {
+	RTL8712_SDIO,
+	RTL8712_USB,
+};
+
+enum RTL8712_RF_CONFIG {
+	RTL8712_RF_1T1R,
+	RTL8712_RF_1T2R,
+	RTL8712_RF_2T2R
+};
+
+enum _RTL8712_HCI_TYPE_ {
+	RTL8712_HCI_TYPE_PCIE = 0x01,
+	RTL8712_HCI_TYPE_AP_PCIE = 0x81,
+	RTL8712_HCI_TYPE_USB = 0x02,
+	RTL8712_HCI_TYPE_92USB = 0x02,
+	RTL8712_HCI_TYPE_AP_USB = 0x82,
+	RTL8712_HCI_TYPE_72USB = 0x12,
+	RTL8712_HCI_TYPE_SDIO = 0x04,
+	RTL8712_HCI_TYPE_72SDIO = 0x14
+};
+
+struct fw_priv {   /*8-bytes alignment required*/
+	/*--- long word 0 ----*/
+	unsigned char signature_0;  /*0x12: CE product, 0x92: IT product*/
+	unsigned char signature_1;  /*0x87: CE product, 0x81: IT product*/
+	unsigned char hci_sel; /*0x81: PCI-AP, 01:PCIe, 02: 92S-U, 0x82: USB-AP,
+			    * 0x12: 72S-U, 03:SDIO*/
+	unsigned char chip_version; /*the same value as register value*/
+	unsigned char customer_ID_0; /*customer  ID low byte*/
+	unsigned char customer_ID_1; /*customer  ID high byte*/
+	unsigned char rf_config;  /*0x11:  1T1R, 0x12: 1T2R, 0x92: 1T2R turbo,
+			     * 0x22: 2T2R*/
+	unsigned char usb_ep_num;  /* 4: 4EP, 6: 6EP, 11: 11EP*/
+	/*--- long word 1 ----*/
+	unsigned char regulatory_class_0; /*regulatory class bit map 0*/
+	unsigned char regulatory_class_1; /*regulatory class bit map 1*/
+	unsigned char regulatory_class_2; /*regulatory class bit map 2*/
+	unsigned char regulatory_class_3; /*regulatory class bit map 3*/
+	unsigned char rfintfs;    /* 0:SWSI, 1:HWSI, 2:HWPI*/
+	unsigned char def_nettype;
+	unsigned char turboMode;
+	unsigned char lowPowerMode;/* 0: noral mode, 1: low power mode*/
+	/*--- long word 2 ----*/
+	unsigned char lbk_mode; /*0x00: normal, 0x03: MACLBK, 0x01: PHYLBK*/
+	unsigned char mp_mode; /* 1: for MP use, 0: for normal driver */
+	unsigned char vcsType; /* 0:off 1:on 2:auto */
+	unsigned char vcsMode; /* 1:RTS/CTS 2:CTS to self */
+	unsigned char rsvd022;
+	unsigned char rsvd023;
+	unsigned char rsvd024;
+	unsigned char rsvd025;
+	/*--- long word 3 ----*/
+	unsigned char qos_en;    /*1: QoS enable*/
+	unsigned char bw_40MHz_en;   /*1: 40MHz BW enable*/
+	unsigned char AMSDU2AMPDU_en;   /*1: 4181 convert AMSDU to AMPDU,
+				   * 0: disable*/
+	unsigned char AMPDU_en;   /*1: 11n AMPDU enable*/
+	unsigned char rate_control_offload; /*1: FW offloads,0: driver handles*/
+	unsigned char aggregation_offload;  /*1: FW offloads,0: driver handles*/
+	unsigned char rsvd030;
+	unsigned char rsvd031;
+	/*--- long word 4 ----*/
+	unsigned char beacon_offload;   /* 1. FW offloads, 0: driver handles*/
+	unsigned char MLME_offload;   /* 2. FW offloads, 0: driver handles*/
+	unsigned char hwpc_offload;   /* 3. FW offloads, 0: driver handles*/
+	unsigned char tcp_checksum_offload; /*4. FW offloads,0: driver handles*/
+	unsigned char tcp_offload;    /* 5. FW offloads, 0: driver handles*/
+	unsigned char ps_control_offload; /* 6. FW offloads, 0: driver handles*/
+	unsigned char WWLAN_offload;   /* 7. FW offloads, 0: driver handles*/
+	unsigned char rsvd040;
+	/*--- long word 5 ----*/
+	unsigned char tcp_tx_frame_len_L;  /*tcp tx packet length low byte*/
+	unsigned char tcp_tx_frame_len_H;  /*tcp tx packet length high byte*/
+	unsigned char tcp_rx_frame_len_L;  /*tcp rx packet length low byte*/
+	unsigned char tcp_rx_frame_len_H;  /*tcp rx packet length high byte*/
+	unsigned char rsvd050;
+	unsigned char rsvd051;
+	unsigned char rsvd052;
+	unsigned char rsvd053;
+};
+
+struct fw_hdr {/*8-byte alinment required*/
+	unsigned short	signature;
+	unsigned short	version;	/*0x8000 ~ 0x8FFF for FPGA version,
+					 *0x0000 ~ 0x7FFF for ASIC version,*/
+	unsigned int		dmem_size;    /*define the size of boot loader*/
+	unsigned int		img_IMEM_size; /*define the size of FW in IMEM*/
+	unsigned int		img_SRAM_size; /*define the size of FW in SRAM*/
+	unsigned int		fw_priv_sz; /*define the size of DMEM variable*/
+	unsigned short	efuse_addr;
+	unsigned short	h2ccnd_resp_addr;
+	unsigned int		SVNRevision;
+	unsigned int		release_time; /*Mon:Day:Hr:Min*/
+	struct fw_priv	fwpriv;
+};
+
+struct hal_priv {
+	/*Endpoint handles*/
+	struct  net_device *pipehdls_r8712[10];
+	u8 (*hal_bus_init)(struct _adapter *adapter);
+};
+
+uint	 rtl8712_hal_init(struct _adapter *padapter);
+int rtl871x_load_fw(struct _adapter *padapter);
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_interrupt_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_INTERRUPT_BITDEF_H__
+#define __RTL8712_INTERRUPT_BITDEF_H__
+
+/*HIMR*/
+/*HISR*/
+#define	_CPUERR					BIT(29)
+#define	_ATIMEND				BIT(28)
+#define	_TXBCNOK				BIT(27)
+#define	_TXBCNERR				BIT(26)
+#define	_BCNDMAINT4				BIT(25)
+#define	_BCNDMAINT3				BIT(24)
+#define	_BCNDMAINT2				BIT(23)
+#define	_BCNDMAINT1				BIT(22)
+#define	_BCNDOK4				BIT(21)
+#define	_BCNDOK3				BIT(20)
+#define	_BCNDOK2				BIT(19)
+#define	_BCNDOK1				BIT(18)
+#define	_TIMEOUT2				BIT(17)
+#define	_TIMEOUT1				BIT(16)
+#define	_TXFOVW					BIT(15)
+#define	_PSTIMEOUT				BIT(14)
+#define	_BCNDMAINT0				BIT(13)
+#define	_FOVW					BIT(12)
+#define	_RDU					BIT(11)
+#define	_RXCMDOK				BIT(10)
+#define	_BCNDOK0				BIT(9)
+#define	_HIGHDOK				BIT(8)
+#define	_COMDOK					BIT(7)
+#define	_MGTDOK					BIT(6)
+#define	_HCCADOK				BIT(5)
+#define	_BKDOK					BIT(4)
+#define	_BEDOK					BIT(3)
+#define	_VIDOK					BIT(2)
+#define	_VODOK					BIT(1)
+#define	_RXOK					BIT(0)
+
+
+#endif	/*__RTL8712_INTERRUPT_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_io.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_io.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_io.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_io.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,151 @@
+/******************************************************************************
+ * rtl8712_io.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>.
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_IO_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_io.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+u8 r8712_read8(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u8 r_val;
+
+	_read8 = pintfhdl->io_ops._read8;
+	r_val = _read8(pintfhdl, addr);
+	return r_val;
+}
+
+u16 r8712_read16(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u16 r_val;
+
+	_read16 = pintfhdl->io_ops._read16;
+	r_val = _read16(pintfhdl, addr);
+	return r_val;
+}
+
+u32 r8712_read32(struct _adapter *adapter, u32 addr)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	u32 r_val;
+
+	_read32 = pintfhdl->io_ops._read32;
+	r_val = _read32(pintfhdl, addr);
+	return r_val;
+}
+
+void r8712_write8(struct _adapter *adapter, u32 addr, u8 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+
+	_write8 = pintfhdl->io_ops._write8;
+	_write8(pintfhdl, addr, val);
+}
+
+void r8712_write16(struct _adapter *adapter, u32 addr, u16 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	_write16 = pintfhdl->io_ops._write16;
+	_write16(pintfhdl, addr, val);
+}
+
+void r8712_write32(struct _adapter *adapter, u32 addr, u32 val)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = (struct intf_hdl *)(&(pio_queue->intf));
+
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	_write32 = pintfhdl->io_ops._write32;
+	_write32(pintfhdl, addr, val);
+}
+
+void r8712_read_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true))
+		return;
+	_read_mem = pintfhdl->io_ops._read_mem;
+	_read_mem(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_write_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+
+	_write_mem = pintfhdl->io_ops._write_mem;
+	_write_mem(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_read_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl	*pintfhdl = &(pio_queue->intf);
+
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true))
+		return;
+	_read_port = pintfhdl->io_ops._read_port;
+	_read_port(pintfhdl, addr, cnt, pmem);
+}
+
+void r8712_write_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	struct io_queue *pio_queue = (struct io_queue *)adapter->pio_queue;
+	struct intf_hdl *pintfhdl = &(pio_queue->intf);
+
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+	_write_port = pintfhdl->io_ops._write_port;
+	_write_port(pintfhdl, addr, cnt, pmem);
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_led.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_led.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_led.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_led.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1815 @@
+/******************************************************************************
+ * rtl8712_led.c
+ *
+ * Copyright(c) 2007 - 2010  Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#include "drv_types.h"
+
+/*===========================================================================
+ *	Constant.
+ *===========================================================================
+
+ *
+ * Default LED behavior.
+ */
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
+#define LED_BLINK_LINK_INTERVAL_ALPHA		500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+/*===========================================================================
+ * LED object.
+ *===========================================================================
+ */
+enum _LED_STATE_871x {
+	LED_UNKNOWN = 0,
+	LED_ON = 1,
+	LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_POWER_ON_BLINK = 5,
+	LED_SCAN_BLINK = 6, /* LED is blinking during scanning period,
+			     * the # of times to blink is depend on time
+			     * for scanning. */
+	LED_NO_LINK_BLINK = 7, /* LED is blinking during no link state. */
+	LED_BLINK_StartToBlink = 8,/* Customzied for Sercomm Printer
+				    * Server case */
+	LED_BLINK_WPS = 9,	/* LED is blinkg during WPS communication */
+	LED_TXRX_BLINK = 10,
+	LED_BLINK_WPS_STOP = 11,	/*for ALPHA */
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	/*for BELKIN */
+};
+
+/*===========================================================================
+ *	Prototype of protected function.
+ *===========================================================================
+ */
+static void BlinkTimerCallback(unsigned long data);
+
+static void BlinkWorkItemCallback(struct work_struct *work);
+/*===========================================================================
+ * LED_819xUsb routines.
+ *===========================================================================
+ *
+ *
+ *
+ *	Description:
+ *		Initialize an LED_871x object.
+ */
+static void InitLed871x(struct _adapter *padapter, struct LED_871x *pLed,
+		 enum LED_PIN_871x	LedPin)
+{
+	struct  net_device *nic;
+
+	nic = padapter->pnetdev;
+	pLed->padapter = padapter;
+	pLed->LedPin = LedPin;
+	pLed->CurrLedState = LED_OFF;
+	pLed->bLedOn = false;
+	pLed->bLedBlinkInProgress = false;
+	pLed->BlinkTimes = 0;
+	pLed->BlinkingLedState = LED_UNKNOWN;
+	_init_timer(&(pLed->BlinkTimer), nic, BlinkTimerCallback, pLed);
+	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+}
+
+/*
+ *	Description:
+ *		DeInitialize an LED_871x object.
+ */
+static void DeInitLed871x(struct LED_871x *pLed)
+{
+	_cancel_timer_ex(&(pLed->BlinkTimer));
+	/* We should reset bLedBlinkInProgress if we cancel
+	 * the LedControlTimer, */
+	pLed->bLedBlinkInProgress = false;
+}
+
+/*
+ *	Description:
+ *		Turn on LED according to LedPin specified.
+ */
+static void SwLedOn(struct _adapter *padapter, struct LED_871x *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) ||
+	    (padapter->bDriverStopped == true))
+		return;
+	LedCfg = r8712_read8(padapter, LEDCFG);
+	switch (pLed->LedPin) {
+	case LED_PIN_GPIO0:
+		break;
+	case LED_PIN_LED0:
+		/* SW control led0 on.*/
+		r8712_write8(padapter, LEDCFG, LedCfg&0xf0);
+		break;
+	case LED_PIN_LED1:
+		/* SW control led1 on.*/
+		r8712_write8(padapter, LEDCFG, LedCfg&0x0f);
+		break;
+	default:
+		break;
+	}
+	pLed->bLedOn = true;
+}
+
+/*
+ *	Description:
+ *		Turn off LED according to LedPin specified.
+ */
+static void SwLedOff(struct _adapter *padapter, struct LED_871x *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) ||
+	    (padapter->bDriverStopped == true))
+		return;
+	LedCfg = r8712_read8(padapter, LEDCFG);
+	switch (pLed->LedPin) {
+	case LED_PIN_GPIO0:
+		break;
+	case LED_PIN_LED0:
+		LedCfg &= 0xf0; /* Set to software control.*/
+		r8712_write8(padapter, LEDCFG, (LedCfg|BIT(3)));
+		break;
+	case LED_PIN_LED1:
+		LedCfg &= 0x0f; /* Set to software control.*/
+		r8712_write8(padapter, LEDCFG, (LedCfg|BIT(7)));
+		break;
+	default:
+		break;
+	}
+	pLed->bLedOn = false;
+}
+
+/*===========================================================================
+ * Interface to manipulate LED objects.
+ *===========================================================================
+ *
+ *	Description:
+ *		Initialize all LED_871x objects.
+ */
+void r8712_InitSwLeds(struct _adapter *padapter)
+{
+	struct led_priv	*pledpriv = &(padapter->ledpriv);
+
+	pledpriv->LedControlHandler = LedControl871x;
+	InitLed871x(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
+	InitLed871x(padapter, &(pledpriv->SwLed1), LED_PIN_LED1);
+}
+
+/*	Description:
+ *		DeInitialize all LED_819xUsb objects.
+ */
+void r8712_DeInitSwLeds(struct _adapter *padapter)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	DeInitLed871x(&(ledpriv->SwLed0));
+	DeInitLed871x(&(ledpriv->SwLed1));
+}
+
+/*	Description:
+ *		Implementation of LED blinking behavior.
+ *		It toggle off LED and schedule corresponding timer if necessary.
+ */
+static void SwLedBlink(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	/* Determine if we shall change LED state again. */
+	pLed->BlinkTimes--;
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_NORMAL:
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	case LED_BLINK_StartToBlink:
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		    (pmlmepriv->fw_state & WIFI_STATION_STATE))
+			bStopBlinking = true;
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		   ((pmlmepriv->fw_state & WIFI_ADHOC_STATE) ||
+		    (pmlmepriv->fw_state & WIFI_ADHOC_MASTER_STATE)))
+			bStopBlinking = true;
+		else if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		break;
+	default:
+		bStopBlinking = true;
+		break;
+	}
+	if (bStopBlinking) {
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+		    (pLed->bLedOn == false))
+			SwLedOn(padapter, pLed);
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED) ==
+			 true) &&  pLed->bLedOn == true)
+			SwLedOff(padapter, pLed);
+		pLed->BlinkTimes = 0;
+		pLed->bLedBlinkInProgress = false;
+	} else {
+		/* Assign LED state to toggle. */
+		if (pLed->BlinkingLedState == LED_ON)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+
+		/* Schedule a timer to toggle LED state. */
+		switch (pLed->CurrLedState) {
+		case LED_BLINK_NORMAL:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+			break;
+		case LED_BLINK_SLOWLY:
+		case LED_BLINK_StartToBlink:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		case LED_BLINK_WPS:
+			if (pLed->BlinkingLedState == LED_ON)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LONG_INTERVAL);
+			else
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LONG_INTERVAL);
+			break;
+		default:
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		}
+	}
+}
+
+static void SwLedBlink1(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct led_priv *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct eeprom_priv *peeprompriv = &(padapter->eeprompriv);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+	u8 bStopBlinking = false;
+
+	if (peeprompriv->CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	if (peeprompriv->CustomerID == RT_CID_DEFAULT) {
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+			if (!pLed1->bSWLedCtrl) {
+				SwLedOn(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			} else if (!pLed1->bLedOn)
+				SwLedOn(padapter, pLed1);
+		} else {
+			if (!pLed1->bSWLedCtrl) {
+				SwLedOff(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			} else if (pLed1->bLedOn)
+				SwLedOff(padapter, pLed1);
+		}
+	}
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_SLOWLY:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_NORMAL:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->bLedLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LINK_INTERVAL_ALPHA);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->bLedLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_LINK_INTERVAL_ALPHA);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = LED_OFF;
+				else
+					pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			pLed->BlinkTimes = 0;
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_WPS_STOP:	/* WPS success */
+		if (pLed->BlinkingLedState == LED_ON) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			bStopBlinking = false;
+		} else
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		}
+		pLed->bLedWPSBlinkInProgress = false;
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink2(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				SwLedOff(padapter, pLed);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				SwLedOff(padapter, pLed);
+			}
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink3(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		if (pLed->CurrLedState != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				if (!pLed->bLedOn)
+					SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				if (pLed->bLedOn)
+					SwLedOff(padapter, pLed);
+			}
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				pLed->CurrLedState = LED_ON;
+				pLed->BlinkingLedState = LED_ON;
+				if (!pLed->bLedOn)
+					SwLedOn(padapter, pLed);
+			} else if (!check_fwstate(pmlmepriv, _FW_LINKED)) {
+				pLed->CurrLedState = LED_OFF;
+				pLed->BlinkingLedState = LED_OFF;
+				if (pLed->bLedOn)
+					SwLedOff(padapter, pLed);
+			}
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_WPS_STOP:	/*WPS success*/
+		if (pLed->BlinkingLedState == LED_ON) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			bStopBlinking = false;
+		} else
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			SwLedOn(padapter, pLed);
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink4(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	if (!pLed1->bLedWPSBlinkInProgress &&
+	    pLed1->BlinkingLedState == LED_UNKNOWN) {
+		pLed1->BlinkingLedState = LED_OFF;
+		pLed1->CurrLedState = LED_OFF;
+		SwLedOff(padapter, pLed1);
+	}
+	switch (pLed->CurrLedState) {
+	case LED_BLINK_SLOWLY:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_BLINK_StartToBlink:
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SLOWLY_INTERVAL);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	case LED_BLINK_WPS_STOP:	/*WPS authentication fail*/
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_BLINK_WPS_STOP_OVERLAP:	/*WPS session overlap */
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0) {
+			if (pLed->bLedOn)
+				pLed->BlinkTimes = 1;
+			else
+				bStopBlinking = true;
+		}
+		if (bStopBlinking) {
+			pLed->BlinkTimes = 10;
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink5(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_SCAN_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_FASTER_INTERVAL_ALPHA);
+			pLed->bLedScanBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_FASTER_INTERVAL_ALPHA);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			 if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedBlink6(struct LED_871x *pLed)
+{
+	struct _adapter *padapter = pLed->padapter;
+	u8 bStopBlinking = false;
+
+	/* Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == LED_ON)
+		SwLedOn(padapter, pLed);
+	else
+		SwLedOff(padapter, pLed);
+	switch (pLed->CurrLedState) {
+	case LED_TXRX_BLINK:
+		pLed->BlinkTimes--;
+		if (pLed->BlinkTimes == 0)
+			bStopBlinking = true;
+		if (bStopBlinking) {
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			if (!pLed->bLedOn)
+				SwLedOn(padapter, pLed);
+			pLed->bLedBlinkInProgress = false;
+		} else {
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_BLINK_WPS:
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*	Description:
+ *		Callback function of LED BlinkTimer,
+ *		it just schedules to corresponding BlinkWorkItem.
+ */
+static void BlinkTimerCallback(unsigned long data)
+{
+	struct LED_871x  *pLed = (struct LED_871x *)data;
+
+	/* This fixed the crash problem on Fedora 12 when trying to do thei
+	 * insmod;ifconfig up;rmmod commands. */
+	if ((pLed->padapter->bSurpriseRemoved == true) ||
+	    (pLed->padapter->bDriverStopped == true))
+		return;
+	_set_workitem(&(pLed->BlinkWorkItem));
+}
+
+/*	Description:
+ *		Callback function of LED BlinkWorkItem.
+ *		We dispatch acture LED blink action according to LedStrategy.
+ */
+static void BlinkWorkItemCallback(struct work_struct *work)
+{
+	struct LED_871x *pLed = container_of(work, struct LED_871x,
+				BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+
+	switch (ledpriv->LedStrategy) {
+	case SW_LED_MODE0:
+		SwLedBlink(pLed);
+		break;
+	case SW_LED_MODE1:
+		SwLedBlink1(pLed);
+		break;
+	case SW_LED_MODE2:
+		SwLedBlink2(pLed);
+		break;
+	case SW_LED_MODE3:
+		SwLedBlink3(pLed);
+		break;
+	case SW_LED_MODE4:
+		SwLedBlink4(pLed);
+		break;
+	case SW_LED_MODE5:
+		SwLedBlink5(pLed);
+		break;
+	case SW_LED_MODE6:
+		SwLedBlink6(pLed);
+		break;
+	default:
+		SwLedBlink(pLed);
+		break;
+	}
+}
+
+/*============================================================================
+ * Default LED behavior.
+ *============================================================================
+ *
+ *	Description:
+ *		Implement each led action for SW_LED_MODE0.
+ *		This is default strategy.
+ */
+
+static void SwLedControlMode1(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv *ledpriv = &(padapter->ledpriv);
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sitesurvey_ctrl *psitesurveyctrl = &(pmlmepriv->sitesurveyctrl);
+
+	if (padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+	switch (LedAction) {
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (pLed->bLedNoLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			  IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_LINK:
+		if (pLed->bLedLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((psitesurveyctrl->traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			; /* dummy branch */
+		 else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		 }
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+
+	case LED_CTL_START_WPS: /*wait until xinpin finish */
+	case LED_CTL_START_WPS_BOTTON:
+		 if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedNoLinkBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			 pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress == true) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+		else
+			pLed->bLedWPSBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedNoLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode2(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	 *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_SITE_SURVEY:
+		 if (pmlmepriv->sitesurveyctrl.traffic_busy)
+			; /* dummy branch */
+		 else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		 }
+		break;
+
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if ((pLed->bLedBlinkInProgress == false) &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			   IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+
+	case LED_CTL_LINK:
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_ON;
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		 }
+		break;
+
+	case LED_CTL_STOP_WPS:
+		pLed->bLedWPSBlinkInProgress = false;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_STOP_WPS_FAIL:
+		pLed->bLedWPSBlinkInProgress = false;
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (!IS_LED_BLINKING(pLed)) {
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode3(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_SITE_SURVEY:
+		if (pmlmepriv->sitesurveyctrl.traffic_busy)
+			; /* dummy branch */
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if ((pLed->bLedBlinkInProgress == false) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_LINK:
+		if (IS_LED_WPS_BLINKING(pLed))
+			return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_START_WPS: /* wait until xinpin finish */
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		} else
+			pLed->bLedWPSBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed->bLedOn) {
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+		} else {
+			pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_START_TO_LINK:
+	case LED_CTL_NO_LINK:
+		if (!IS_LED_BLINKING(pLed)) {
+			pLed->CurrLedState = LED_OFF;
+			pLed->BlinkingLedState = LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode4(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+	struct LED_871x *pLed1 = &(ledpriv->SwLed1);
+
+	switch (LedAction) {
+	case LED_CTL_START_TO_LINK:
+		if (pLed1->bLedWPSBlinkInProgress) {
+			pLed1->bLedWPSBlinkInProgress = false;
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->BlinkingLedState = LED_OFF;
+			pLed1->CurrLedState = LED_OFF;
+			if (pLed1->bLedOn)
+				_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		if (pLed->bLedStartToLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			pLed->bLedStartToLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			if (pLed->bLedOn) {
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_SLOWLY_INTERVAL);
+			} else {
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NORMAL_INTERVAL);
+			}
+		}
+		break;
+	case LED_CTL_LINK:
+	case LED_CTL_NO_LINK:
+		/*LED1 settings*/
+		if (LedAction == LED_CTL_LINK) {
+			if (pLed1->bLedWPSBlinkInProgress) {
+				pLed1->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pLed1->BlinkingLedState = LED_OFF;
+				pLed1->CurrLedState = LED_OFF;
+				if (pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+		}
+		if (pLed->bLedNoLinkBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((pmlmepriv->sitesurveyctrl.traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			;
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK ||
+			    IS_LED_WPS_BLINKING(pLed))
+				return;
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed1->bLedWPSBlinkInProgress) {
+			pLed1->bLedWPSBlinkInProgress = false;
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->BlinkingLedState = LED_OFF;
+			pLed1->CurrLedState = LED_OFF;
+			if (pLed1->bLedOn)
+				_set_timer(&(pLed->BlinkTimer), 0);
+		}
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedNoLinkBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn) {
+				pLed->BlinkingLedState = LED_OFF;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_SLOWLY_INTERVAL);
+			} else {
+				pLed->BlinkingLedState = LED_ON;
+				_set_timer(&(pLed->BlinkTimer),
+					   LED_BLINK_NORMAL_INTERVAL);
+			}
+		}
+		break;
+	case LED_CTL_STOP_WPS:	/*WPS connect success*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		break;
+	case LED_CTL_STOP_WPS_FAIL:	/*WPS authentication fail*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		/*LED1 settings*/
+		if (pLed1->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+		else
+			pLed1->bLedWPSBlinkInProgress = true;
+		pLed1->CurrLedState = LED_BLINK_WPS_STOP;
+		if (pLed1->bLedOn)
+			pLed1->BlinkingLedState = LED_OFF;
+		else
+			pLed1->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_CTL_STOP_WPS_FAIL_OVERLAP:	/*WPS session overlap*/
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->bLedNoLinkBlinkInProgress = true;
+		pLed->CurrLedState = LED_BLINK_SLOWLY;
+		if (pLed->bLedOn)
+			pLed->BlinkingLedState = LED_OFF;
+		else
+			pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer),
+			   LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+		/*LED1 settings*/
+		if (pLed1->bLedWPSBlinkInProgress)
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+		else
+			pLed1->bLedWPSBlinkInProgress = true;
+		pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
+		pLed1->BlinkTimes = 10;
+		if (pLed1->bLedOn)
+			pLed1->BlinkingLedState = LED_OFF;
+		else
+			pLed1->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedNoLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedNoLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedLinkBlinkInProgress = false;
+		}
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		if (pLed->bLedScanBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedScanBlinkInProgress = false;
+		}
+		if (pLed->bLedStartToLinkBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedStartToLinkBlinkInProgress = false;
+		}
+		if (pLed1->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed1->BlinkTimer));
+			pLed1->bLedWPSBlinkInProgress = false;
+		}
+		pLed1->BlinkingLedState = LED_UNKNOWN;
+		SwLedOff(padapter, pLed);
+		SwLedOff(padapter, pLed1);
+		break;
+	default:
+		break;
+	}
+}
+
+static void SwLedControlMode5(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	if (padapter->eeprompriv.CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+
+	switch (LedAction) {
+	case LED_CTL_POWER_ON:
+	case LED_CTL_NO_LINK:
+	case LED_CTL_LINK:	/* solid blue */
+		if (pLed->CurrLedState == LED_SCAN_BLINK)
+			return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		pLed->bLedBlinkInProgress = false;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_SITE_SURVEY:
+		if ((pmlmepriv->sitesurveyctrl.traffic_busy) &&
+		    (check_fwstate(pmlmepriv, _FW_LINKED) == true))
+			; /* dummy branch */
+		else if (pLed->bLedScanBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedScanBlinkInProgress = true;
+			pLed->CurrLedState = LED_SCAN_BLINK;
+			pLed->BlinkTimes = 24;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false) {
+			if (pLed->CurrLedState == LED_SCAN_BLINK)
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+	default:
+		break;
+	}
+}
+
+
+static void SwLedControlMode6(struct _adapter *padapter,
+			      enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct LED_871x *pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction) {
+	case LED_CTL_POWER_ON:
+	case LED_CTL_NO_LINK:
+	case LED_CTL_LINK:	/*solid blue*/
+	case LED_CTL_SITE_SURVEY:
+		if (IS_LED_WPS_BLINKING(pLed))
+				return;
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		pLed->bLedBlinkInProgress = false;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+			pLed->bLedBlinkInProgress = true;
+			pLed->CurrLedState = LED_TXRX_BLINK;
+			pLed->BlinkTimes = 2;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_FASTER_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_START_WPS: /*wait until xinpin finish*/
+	case LED_CTL_START_WPS_BOTTON:
+		if (pLed->bLedWPSBlinkInProgress == false) {
+			if (pLed->bLedBlinkInProgress == true) {
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			pLed->bLedWPSBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_WPS;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = LED_OFF;
+			else
+				pLed->BlinkingLedState = LED_ON;
+			_set_timer(&(pLed->BlinkTimer),
+				   LED_BLINK_SCAN_INTERVAL_ALPHA);
+		}
+		break;
+	case LED_CTL_STOP_WPS_FAIL:
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		pLed->CurrLedState = LED_ON;
+		pLed->BlinkingLedState = LED_ON;
+		_set_timer(&(pLed->BlinkTimer), 0);
+		break;
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = LED_OFF;
+		pLed->BlinkingLedState = LED_OFF;
+		if (pLed->bLedBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		if (pLed->bLedWPSBlinkInProgress) {
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedWPSBlinkInProgress = false;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+	default:
+		break;
+	}
+}
+
+/*	Description:
+ *		Dispatch LED action according to pHalData->LedStrategy.
+ */
+void LedControl871x(struct _adapter *padapter, enum LED_CTL_MODE LedAction)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	if (ledpriv->bRegUseLed == false)
+		return;
+	switch (ledpriv->LedStrategy) {
+	case SW_LED_MODE0:
+		break;
+	case SW_LED_MODE1:
+		SwLedControlMode1(padapter, LedAction);
+		break;
+	case SW_LED_MODE2:
+		SwLedControlMode2(padapter, LedAction);
+		break;
+	case SW_LED_MODE3:
+		SwLedControlMode3(padapter, LedAction);
+		break;
+	case SW_LED_MODE4:
+		SwLedControlMode4(padapter, LedAction);
+		break;
+	case SW_LED_MODE5:
+		SwLedControlMode5(padapter, LedAction);
+		break;
+	case SW_LED_MODE6:
+		SwLedControlMode6(padapter, LedAction);
+		break;
+	default:
+		break;
+	}
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_macsetting_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_MACSETTING_BITDEF_H__
+#define __RTL8712_MACSETTING_BITDEF_H__
+
+
+/*MACID*/
+/*BSSID*/
+
+/*HWVID*/
+#define	_HWVID_MSK				0x0F
+
+/*MAR*/
+/*MBIDCANCONTENT*/
+
+/*MBIDCANCFG*/
+#define	_POOLING				BIT(31)
+#define	_WRITE_EN				BIT(16)
+#define	_CAM_ADDR_MSK			0x001F
+#define	_CAM_ADDR_SHT			0
+
+/*BUILDTIME*/
+#define _BUILDTIME_MSK			0x3FFFFFFF
+
+/*BUILDUSER*/
+
+
+
+#endif /* __RTL8712_MACSETTING_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_macsetting_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_MACSETTING_REGDEF_H__
+#define __RTL8712_MACSETTING_REGDEF_H__
+
+#define MACID				(RTL8712_MACIDSETTING_ + 0x0000)
+#define BSSIDR				(RTL8712_MACIDSETTING_ + 0x0008)
+#define HWVID				(RTL8712_MACIDSETTING_ + 0x000E)
+#define MAR				(RTL8712_MACIDSETTING_ + 0x0010)
+#define MBIDCANCONTENT			(RTL8712_MACIDSETTING_ + 0x0018)
+#define MBIDCANCFG			(RTL8712_MACIDSETTING_ + 0x0020)
+#define BUILDTIME			(RTL8712_MACIDSETTING_ + 0x0024)
+#define BUILDUSER			(RTL8712_MACIDSETTING_ + 0x0028)
+
+
+
+#endif /*__RTL8712_MACSETTING_REGDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_powersave_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_POWERSAVE_BITDEF_H__
+#define __RTL8712_POWERSAVE_BITDEF_H__
+
+/*WOWCTRL*/
+#define	_UWF			BIT(3)
+#define	_MAGIC			BIT(2)
+#define	_WOW_EN			BIT(1)
+#define	_PMEN			BIT(0)
+
+/*PSSTATUS*/
+#define	_PSSTATUS_SEL_MSK		0x0F
+
+/*PSSWITCH*/
+#define	_PSSWITCH_ACT			BIT(7)
+#define	_PSSWITCH_SEL_MSK		0x0F
+#define	_PSSWITCH_SEL_SHT		0
+
+/*LPNAV_CTRL*/
+#define	_LPNAV_EN			BIT(31)
+#define	_LPNAV_EARLY_MSK		0x7FFF0000
+#define	_LPNAV_EARLY_SHT		16
+#define	_LPNAV_TH_MSK			0x0000FFFF
+#define	_LPNAV_TH_SHT			0
+
+/*RPWM*/
+/*CPWM*/
+#define	_TOGGLING			BIT(7)
+#define	_WWLAN				BIT(3)
+#define	_RPS_ST				BIT(2)
+#define	_WLAN_TRX			BIT(1)
+#define	_SYS_CLK			BIT(0)
+
+#endif /* __RTL8712_POWERSAVE_BITDEF_H__*/
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_powersave_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_powersave_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_powersave_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_powersave_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_POWERSAVE_REGDEF_H__
+#define __RTL8712_POWERSAVE_REGDEF_H__
+
+#define WOWCTRL				(RTL8712_POWERSAVE_ + 0x00)
+#define PSSTATUS			(RTL8712_POWERSAVE_ + 0x01)
+#define PSSWITCH			(RTL8712_POWERSAVE_ + 0x02)
+#define MIMOPS_WAITPERIOD		(RTL8712_POWERSAVE_ + 0x03)
+#define LPNAV_CTRL			(RTL8712_POWERSAVE_ + 0x04)
+#define WFM0				(RTL8712_POWERSAVE_ + 0x10)
+#define WFM1				(RTL8712_POWERSAVE_ + 0x20)
+#define WFM2				(RTL8712_POWERSAVE_ + 0x30)
+#define WFM3				(RTL8712_POWERSAVE_ + 0x40)
+#define WFM4				(RTL8712_POWERSAVE_ + 0x50)
+#define WFM5				(RTL8712_POWERSAVE_ + 0x60)
+#define WFCRC				(RTL8712_POWERSAVE_ + 0x70)
+#define RPWM				(RTL8712_POWERSAVE_ + 0x7C)
+#define CPWM				(RTL8712_POWERSAVE_ + 0x7D)
+
+#endif /* __RTL8712_POWERSAVE_REGDEF_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_ratectrl_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_RATECTRL_BITDEF_H__
+#define __RTL8712_RATECTRL_BITDEF_H__
+
+/*INIRTSMCS_SEL*/
+#define	_INIRTSMCS_SEL_MSK		0x3F
+
+/* RRSR*/
+#define	_RRSR_SHORT			BIT(23)
+#define	_RRSR_RSC_MSK		0x600000
+#define	_RRSR_RSC_SHT		21
+#define	_RRSR_BITMAP_MSK	0x0FFFFF
+#define	_RRSR_BITMAP_SHT	0
+
+/* AGGLEN_LMT_H*/
+#define	_AGGLMT_MCS32_MSK			0xF0
+#define	_AGGLMT_MCS32_SHT			4
+#define	_AGGLMT_MCS15_SGI_MSK		0x0F
+#define	_AGGLMT_MCS15_SGI_SHT		0
+
+/* DARFRC*/
+/* RARFRC*/
+/* MCS_TXAGC*/
+/* CCK_TXAGC*/
+#define	_CCK_MSK			0xFF00
+#define	_CCK_SHT			8
+#define	_BARKER_MSK			0x00FF
+#define	_BARKER_SHT			0
+
+#endif	/*	__RTL8712_RATECTRL_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_ratectrl_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_RATECTRL_REGDEF_H__
+#define __RTL8712_RATECTRL_REGDEF_H__
+
+#define INIMCS_SEL			(RTL8712_RATECTRL_ + 0x00)
+#define INIRTSMCS_SEL		(RTL8712_RATECTRL_ + 0x20)
+#define RRSR				(RTL8712_RATECTRL_ + 0x21)
+#define ARFR0				(RTL8712_RATECTRL_ + 0x24)
+#define ARFR1				(RTL8712_RATECTRL_ + 0x28)
+#define ARFR2				(RTL8712_RATECTRL_ + 0x2C)
+#define ARFR3				(RTL8712_RATECTRL_ + 0x30)
+#define ARFR4				(RTL8712_RATECTRL_ + 0x34)
+#define ARFR5				(RTL8712_RATECTRL_ + 0x38)
+#define ARFR6				(RTL8712_RATECTRL_ + 0x3C)
+#define ARFR7				(RTL8712_RATECTRL_ + 0x40)
+#define AGGLEN_LMT_H		(RTL8712_RATECTRL_ + 0x47)
+#define AGGLEN_LMT_L		(RTL8712_RATECTRL_ + 0x48)
+#define DARFRC				(RTL8712_RATECTRL_ + 0x50)
+#define RARFRC				(RTL8712_RATECTRL_ + 0x58)
+#define MCS_TXAGC0			(RTL8712_RATECTRL_ + 0x60)
+#define MCS_TXAGC1			(RTL8712_RATECTRL_ + 0x61)
+#define MCS_TXAGC2			(RTL8712_RATECTRL_ + 0x62)
+#define MCS_TXAGC3			(RTL8712_RATECTRL_ + 0x63)
+#define MCS_TXAGC4			(RTL8712_RATECTRL_ + 0x64)
+#define MCS_TXAGC5			(RTL8712_RATECTRL_ + 0x65)
+#define MCS_TXAGC6			(RTL8712_RATECTRL_ + 0x66)
+#define MCS_TXAGC7			(RTL8712_RATECTRL_ + 0x67)
+#define CCK_TXAGC			(RTL8712_RATECTRL_ + 0x68)
+
+
+#endif	/*__RTL8712_RATECTRL_REGDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_recv.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_recv.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_recv.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_recv.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1133 @@
+/******************************************************************************
+ * rtl8712_recv.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_RECV_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "ip.h"
+#include "if_ether.h"
+#include "ethernet.h"
+#include "usb_ops.h"
+#include "wifi.h"
+
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 bridge_tunnel_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static u8 rfc1042_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+static void recv_tasklet(void *priv);
+
+int r8712_init_recv_priv(struct recv_priv *precvpriv, struct _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	int res = _SUCCESS;
+	addr_t tmpaddr = 0;
+	int alignment = 0;
+	struct sk_buff *pskb = NULL;
+
+	sema_init(&precvpriv->recv_sema, 0);
+	sema_init(&precvpriv->terminate_recvthread_sema, 0);
+	/*init recv_buf*/
+	_init_queue(&precvpriv->free_recv_buf_queue);
+	precvpriv->pallocated_recv_buf = _malloc(NR_RECVBUFF *
+					 sizeof(struct recv_buf) + 4);
+	if (precvpriv->pallocated_recv_buf == NULL)
+		return _FAIL;
+	memset(precvpriv->pallocated_recv_buf, 0, NR_RECVBUFF *
+		sizeof(struct recv_buf) + 4);
+	precvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -
+			      ((addr_t) (precvpriv->pallocated_recv_buf) & 3);
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		_init_listhead(&precvbuf->list);
+		spin_lock_init(&precvbuf->recvbuf_lock);
+		res = r8712_os_recvbuf_resource_alloc(padapter, precvbuf);
+		if (res == _FAIL)
+			break;
+		precvbuf->ref_cnt = 0;
+		precvbuf->adapter = padapter;
+		list_insert_tail(&precvbuf->list,
+				 &(precvpriv->free_recv_buf_queue.queue));
+		precvbuf++;
+	}
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))recv_tasklet,
+	     (unsigned long)padapter);
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+	skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+	for (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {
+		pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ +
+		       RECVBUFF_ALIGN_SZ);
+		if (pskb) {
+			pskb->dev = padapter->pnetdev;
+			tmpaddr = (addr_t)pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));
+			skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+		}
+		pskb = NULL;
+	}
+	return res;
+}
+
+void r8712_free_recv_priv(struct recv_priv *precvpriv)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	struct _adapter *padapter = precvpriv->adapter;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF ; i++) {
+		r8712_os_recvbuf_resource_free(padapter, precvbuf);
+		precvbuf++;
+	}
+	kfree(precvpriv->pallocated_recv_buf);
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+	if (skb_queue_len(&precvpriv->rx_skb_queue))
+		printk(KERN_WARNING "r8712u: rx_skb_queue not empty\n");
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue))
+		printk(KERN_WARNING "r8712u: free_recv_skb_queue not empty "
+		       "%d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+}
+
+int r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res = _SUCCESS;
+
+	precvbuf->transfer_len = 0;
+	precvbuf->len = 0;
+	precvbuf->ref_cnt = 0;
+	if (precvbuf->pbuf) {
+		precvbuf->pdata = precvbuf->pbuf;
+		precvbuf->phead = precvbuf->pbuf;
+		precvbuf->ptail = precvbuf->pbuf;
+		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
+	}
+	return res;
+}
+
+int r8712_free_recvframe(union recv_frame *precvframe,
+		   struct  __queue *pfree_recv_queue)
+{
+	unsigned long irqL;
+	struct _adapter *padapter = precvframe->u.hdr.adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	if (precvframe->u.hdr.pkt) {
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);/*free skb by driver*/
+		precvframe->u.hdr.pkt = NULL;
+	}
+	spin_lock_irqsave(&pfree_recv_queue->lock, irqL);
+	list_delete(&(precvframe->u.hdr.list));
+	list_insert_tail(&(precvframe->u.hdr.list),
+			 get_list_head(pfree_recv_queue));
+	if (padapter != NULL) {
+		if (pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+	spin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);
+	return _SUCCESS;
+}
+
+static void update_recvframe_attrib_from_recvstat(struct rx_pkt_attrib *pattrib,
+					   struct recv_stat *prxstat)
+{
+	u32 *pphy_info;
+	struct phy_stat *pphy_stat;
+	u16 drvinfo_sz = 0;
+
+	drvinfo_sz = (le32_to_cpu(prxstat->rxdw0)&0x000f0000)>>16;
+	drvinfo_sz = drvinfo_sz<<3;
+	/*TODO:
+	 * Offset 0 */
+	pattrib->bdecrypted = ((le32_to_cpu(prxstat->rxdw0) & BIT(27)) >> 27)
+				 ? 0 : 1;
+	pattrib->crc_err = ((le32_to_cpu(prxstat->rxdw0) & BIT(14)) >> 14);
+	/*Offset 4*/
+	/*Offset 8*/
+	/*Offset 12*/
+	if (le32_to_cpu(prxstat->rxdw3) & BIT(13)) {
+		pattrib->tcpchk_valid = 1; /* valid */
+		if (le32_to_cpu(prxstat->rxdw3) & BIT(11))
+			pattrib->tcp_chkrpt = 1; /* correct */
+		else
+			pattrib->tcp_chkrpt = 0; /* incorrect */
+		if (le32_to_cpu(prxstat->rxdw3) & BIT(12))
+			pattrib->ip_chkrpt = 1; /* correct */
+		else
+			pattrib->ip_chkrpt = 0; /* incorrect */
+	} else
+		pattrib->tcpchk_valid = 0; /* invalid */
+	pattrib->mcs_rate = (u8)((le32_to_cpu(prxstat->rxdw3)) & 0x3f);
+	pattrib->htc = (u8)((le32_to_cpu(prxstat->rxdw3) >> 14) & 0x1);
+	/*Offset 16*/
+	/*Offset 20*/
+	/*phy_info*/
+	if (drvinfo_sz) {
+		pphy_stat = (struct phy_stat *)(prxstat+1);
+		pphy_info = (u32 *)prxstat+1;
+	}
+}
+
+/*perform defrag*/
+static union recv_frame *recvframe_defrag(struct _adapter *adapter,
+				   struct  __queue *defrag_q)
+{
+	struct list_head *plist, *phead;
+	u8	*data, wlanhdr_offset;
+	u8	curfragnum;
+	struct recv_frame_hdr *pfhdr, *pnfhdr;
+	union recv_frame *prframe, *pnextrframe;
+	struct  __queue	*pfree_recv_queue;
+
+	pfree_recv_queue = &adapter->recvpriv.free_recv_queue;
+	phead = get_list_head(defrag_q);
+	plist = get_next(phead);
+	prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+	list_delete(&prframe->u.list);
+	pfhdr = &prframe->u.hdr;
+	curfragnum = 0;
+	if (curfragnum != pfhdr->attrib.frag_num) {
+		/*the first fragment number must be 0
+		 *free the whole queue*/
+		r8712_free_recvframe(prframe, pfree_recv_queue);
+		r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+		return NULL;
+	}
+	curfragnum++;
+	plist = get_list_head(defrag_q);
+	plist = get_next(plist);
+	data = get_recvframe_data(prframe);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnfhdr = &pnextrframe->u.hdr;
+		/*check the fragment sequence  (2nd ~n fragment frame) */
+		if (curfragnum != pnfhdr->attrib.frag_num) {
+			/* the fragment number must increase  (after decache)
+			 * release the defrag_q & prframe */
+			r8712_free_recvframe(prframe, pfree_recv_queue);
+			r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+			return NULL;
+		}
+		curfragnum++;
+		/* copy the 2nd~n fragment frame's payload to the first fragment
+		 * get the 2nd~last fragment frame's payload */
+		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+		/* append  to first fragment frame's tail (if privacy frame,
+		 * pull the ICV) */
+		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
+		memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
+		recvframe_put(prframe, pnfhdr->len);
+		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
+		plist = get_next(plist);
+	}
+	/* free the defrag_q queue and return the prframe */
+	r8712_free_recvframe_queue(defrag_q, pfree_recv_queue);
+	return prframe;
+}
+
+/* check if need to defrag, if needed queue the frame to defrag_q */
+union recv_frame *r8712_recvframe_chk_defrag(struct _adapter *padapter,
+					     union recv_frame *precv_frame)
+{
+	u8	ismfrag;
+	u8	fragnum;
+	u8   *psta_addr;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct	sta_priv *pstapriv ;
+	struct list_head *phead;
+	union recv_frame *prtnframe = NULL;
+	struct  __queue *pfree_recv_queue, *pdefrag_q;
+
+	pstapriv = &padapter->stapriv;
+	pfhdr = &precv_frame->u.hdr;
+	pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	/* need to define struct of wlan header frame ctrl */
+	ismfrag = pfhdr->attrib.mfrag;
+	fragnum = pfhdr->attrib.frag_num;
+	psta_addr = pfhdr->attrib.ta;
+	psta = r8712_get_stainfo(pstapriv, psta_addr);
+	if (psta == NULL)
+		pdefrag_q = NULL;
+	else
+		pdefrag_q = &psta->sta_recvpriv.defrag_q;
+
+	if ((ismfrag == 0) && (fragnum == 0))
+		prtnframe = precv_frame;/*isn't a fragment frame*/
+	if (ismfrag == 1) {
+		/* 0~(n-1) fragment frame
+		 * enqueue to defraf_g */
+		if (pdefrag_q != NULL) {
+			if (fragnum == 0) {
+				/*the first fragment*/
+				if (_queue_empty(pdefrag_q) == false) {
+					/*free current defrag_q */
+					r8712_free_recvframe_queue(pdefrag_q,
+							     pfree_recv_queue);
+				}
+			}
+			/* Then enqueue the 0~(n-1) fragment to the defrag_q */
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list, phead);
+			prtnframe = NULL;
+		} else {
+			/* can't find this ta's defrag_queue, so free this
+			 * recv_frame */
+			r8712_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+
+	}
+	if ((ismfrag == 0) && (fragnum != 0)) {
+		/* the last fragment frame
+		 * enqueue the last fragment */
+		if (pdefrag_q != NULL) {
+			phead = get_list_head(pdefrag_q);
+			list_insert_tail(&pfhdr->list, phead);
+			/*call recvframe_defrag to defrag*/
+			precv_frame = recvframe_defrag(padapter, pdefrag_q);
+			prtnframe = precv_frame;
+		} else {
+			/* can't find this ta's defrag_queue, so free this
+			 *  recv_frame */
+			r8712_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+	}
+	if ((prtnframe != NULL) && (prtnframe->u.hdr.attrib.privacy)) {
+		/* after defrag we must check tkip mic code */
+		if (r8712_recvframe_chkmic(padapter, prtnframe) == _FAIL) {
+			r8712_free_recvframe(prtnframe, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+	}
+	return prtnframe;
+}
+
+static int amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe)
+{
+	int	a_len, padding_len;
+	u16	eth_type, nSubframe_Length;
+	u8	nr_subframes, i;
+	unsigned char *data_ptr, *pdata;
+	struct rx_pkt_attrib *pattrib;
+	_pkt *sub_skb, *subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct  __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int	ret = _SUCCESS;
+
+	nr_subframes = 0;
+	pattrib = &prframe->u.hdr.attrib;
+	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
+	if (prframe->u.hdr.attrib.iv_len > 0)
+		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
+	a_len = prframe->u.hdr.len;
+	pdata = prframe->u.hdr.rx_data;
+	while (a_len > ETH_HLEN) {
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16 *)(pdata + 12));
+		/*==m==>change the length order*/
+		nSubframe_Length = (nSubframe_Length >> 8) +
+				   (nSubframe_Length << 8);
+		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+			printk(KERN_WARNING "r8712u: nRemain_Length is %d and"
+			    " nSubframe_Length is: %d\n",
+			    a_len, nSubframe_Length);
+			goto exit;
+		}
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+		/* Allocate new skb for releasing to upper layer */
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		skb_reserve(sub_skb, 12);
+		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+		memcpy(data_ptr, pdata, nSubframe_Length);
+		subframes[nr_subframes++] = sub_skb;
+		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
+			printk(KERN_WARNING "r8712u: ParseSubframe(): Too"
+			    " many Subframes! Packets dropped!\n");
+			break;
+		}
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if (a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & 3);
+			if (padding_len == 4)
+				padding_len = 0;
+			if (a_len < padding_len)
+				goto exit;
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+	for (i = 0; i < nr_subframes; i++) {
+		sub_skb = subframes[i];
+		/* convert hdr + possible LLC headers into Ethernet header */
+		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
+		if (sub_skb->len >= 8 &&
+		   ((!memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) &&
+		   eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		   !memcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE))) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and
+			 * replace EtherType */
+			skb_pull(sub_skb, SNAP_SIZE);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+				ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+				ETH_ALEN);
+		} else {
+			u16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+			len = htons(sub_skb->len);
+			memcpy(skb_push(sub_skb, 2), &len, 2);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+				ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+				ETH_ALEN);
+		}
+		/* Indicate the packets to upper layer */
+		if (sub_skb) {
+			sub_skb->protocol =
+				 eth_type_trans(sub_skb, padapter->pnetdev);
+			sub_skb->dev = padapter->pnetdev;
+			if ((pattrib->tcpchk_valid == 1) &&
+			    (pattrib->tcp_chkrpt == 1)) {
+				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+			} else
+				sub_skb->ip_summed = CHECKSUM_NONE;
+			netif_rx(sub_skb);
+		}
+	}
+exit:
+	prframe->u.hdr.len = 0;
+	r8712_free_recvframe(prframe, pfree_recv_queue);
+	return ret;
+}
+
+void r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf)
+{
+	uint voffset;
+	u8 *poffset;
+	u16 pkt_len, cmd_len, drvinfo_sz;
+	u8 eid, cmd_seq;
+	struct recv_stat *prxstat;
+
+	poffset = (u8 *)prxcmdbuf;
+	voffset = *(uint *)poffset;
+	pkt_len = le32_to_cpu(voffset) & 0x00003fff;
+	prxstat = (struct recv_stat *)prxcmdbuf;
+	drvinfo_sz = ((le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16);
+	drvinfo_sz = drvinfo_sz << 3;
+	poffset += RXDESC_SIZE + drvinfo_sz;
+	do {
+		voffset  = *(uint *)poffset;
+		cmd_len = (u16)(le32_to_cpu(voffset) & 0xffff);
+		cmd_seq = (u8)((le32_to_cpu(voffset) >> 24) & 0x7f);
+		eid = (u8)((le32_to_cpu(voffset) >> 16) & 0xff);
+		r8712_event_handle(padapter, (uint *)poffset);
+		poffset += (cmd_len + 8);/*8 bytes aligment*/
+	} while (le32_to_cpu(voffset) & BIT(31));
+
+}
+
+static int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl,
+			      u16 seq_num)
+{
+	u8 wsize = preorder_ctrl->wsize_b;
+	u16 wend = (preorder_ctrl->indicate_seq + wsize - 1) % 4096;
+
+	/* Rx Reorder initialize condition.*/
+	if (preorder_ctrl->indicate_seq == 0xffff)
+		preorder_ctrl->indicate_seq = seq_num;
+	/* Drop out the packet which SeqNum is smaller than WinStart */
+	if (SN_LESS(seq_num, preorder_ctrl->indicate_seq))
+		return false;
+	/*
+	 * Sliding window manipulation. Conditions includes:
+	 * 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	 * 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	 */
+	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq +
+					      1) % 4096;
+	else if (SN_LESS(wend, seq_num)) {
+		if (seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 - wsize;
+		else
+			preorder_ctrl->indicate_seq = 4095 - (wsize -
+						      (seq_num + 1)) + 1;
+	}
+	return true;
+}
+
+static int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl,
+			      union recv_frame *prframe)
+{
+	struct list_head *phead, *plist;
+	union recv_frame *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+	struct  __queue *ppending_recvframe_queue =
+					&preorder_ctrl->pending_recvframe_queue;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pnextattrib = &pnextrframe->u.hdr.attrib;
+		if (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+			plist = get_next(plist);
+		else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+			return false;
+		else
+			break;
+	}
+	list_delete(&(prframe->u.hdr.list));
+	list_insert_tail(&(prframe->u.hdr.list), plist);
+	return true;
+}
+
+int r8712_recv_indicatepkts_in_order(struct _adapter *padapter,
+			       struct recv_reorder_ctrl *preorder_ctrl,
+			       int bforced)
+{
+	struct list_head *phead, *plist;
+	union recv_frame *prframe;
+	struct rx_pkt_attrib *pattrib;
+	int bPktInBuf = false;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct  __queue *ppending_recvframe_queue =
+			 &preorder_ctrl->pending_recvframe_queue;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+	/* Handling some condition for forced indicate case.*/
+	if (bforced == true) {
+		if (is_list_empty(phead))
+			return true;
+		else {
+			prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+			pattrib = &prframe->u.hdr.attrib;
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+		}
+	}
+	/* Prepare indication list and indication.
+	 * Check if there is any packet need indicate. */
+	while (!is_list_empty(phead)) {
+		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		pattrib = &prframe->u.hdr.attrib;
+		if (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+			plist = get_next(plist);
+			list_delete(&(prframe->u.hdr.list));
+			if (SN_EQUAL(preorder_ctrl->indicate_seq,
+			    pattrib->seq_num))
+				preorder_ctrl->indicate_seq =
+				  (preorder_ctrl->indicate_seq + 1) % 4096;
+			/*indicate this recv_frame*/
+			if (!pattrib->amsdu) {
+				if ((padapter->bDriverStopped == false) &&
+				    (padapter->bSurpriseRemoved == false)) {
+					/* indicate this recv_frame */
+					r8712_recv_indicatepkt(padapter,
+							       prframe);
+				}
+			} else if (pattrib->amsdu == 1) {
+				if (amsdu_to_msdu(padapter, prframe) !=
+				    _SUCCESS)
+					r8712_free_recvframe(prframe,
+						   &precvpriv->free_recv_queue);
+			}
+			/* Update local variables. */
+			bPktInBuf = false;
+		} else {
+			bPktInBuf = true;
+			break;
+		}
+	}
+	return bPktInBuf;
+}
+
+static int recv_indicatepkt_reorder(struct _adapter *padapter,
+			     union recv_frame *prframe)
+{
+	unsigned long irql;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
+	struct  __queue *ppending_recvframe_queue =
+			 &preorder_ctrl->pending_recvframe_queue;
+
+	if (!pattrib->amsdu) {
+		/* s1. */
+		r8712_wlanhdr_to_ethhdr(prframe);
+		if (pattrib->qos != 1) {
+			if ((padapter->bDriverStopped == false) &&
+			   (padapter->bSurpriseRemoved == false)) {
+				r8712_recv_indicatepkt(padapter, prframe);
+				return _SUCCESS;
+			} else
+				return _FAIL;
+		}
+	}
+	spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
+	/*s2. check if winstart_b(indicate_seq) needs to been updated*/
+	if (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+		goto _err_exit;
+	/*s3. Insert all packet into Reorder Queue to maintain its ordering.*/
+	if (!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+		goto _err_exit;
+	/*s4.
+	 * Indication process.
+	 * After Packet dropping and Sliding Window shifting as above, we can
+	 * now just indicate the packets with the SeqNum smaller than latest
+	 * WinStart and buffer other packets.
+	 *
+	 * For Rx Reorder condition:
+	 * 1. All packets with SeqNum smaller than WinStart => Indicate
+	 * 2. All packets with SeqNum larger than or equal to
+	 * WinStart => Buffer it.
+	 */
+	if (r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, false) ==
+	    true) {
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer,
+			   REORDER_WAIT_TIME);
+		spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+	} else {
+		spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+	return _SUCCESS;
+_err_exit:
+	spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+	return _FAIL;
+}
+
+void r8712_reordering_ctrl_timeout_handler(void *pcontext)
+{
+	unsigned long irql;
+	struct recv_reorder_ctrl *preorder_ctrl =
+				 (struct recv_reorder_ctrl *)pcontext;
+	struct _adapter *padapter = preorder_ctrl->padapter;
+	struct  __queue *ppending_recvframe_queue =
+				 &preorder_ctrl->pending_recvframe_queue;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
+		return;
+	spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
+	r8712_recv_indicatepkts_in_order(padapter, preorder_ctrl, true);
+	spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
+}
+
+static int r8712_process_recv_indicatepkts(struct _adapter *padapter,
+			      union recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	if (phtpriv->ht_option == 1) { /*B/G/N Mode*/
+		if (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {
+			/* including perform A-MPDU Rx Ordering Buffer Control*/
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false))
+				return _FAIL;
+		}
+	} else { /*B/G mode*/
+		retval = r8712_wlanhdr_to_ethhdr(prframe);
+		if (retval != _SUCCESS)
+			return retval;
+		if ((padapter->bDriverStopped == false) &&
+		    (padapter->bSurpriseRemoved == false)) {
+			/* indicate this recv_frame */
+			r8712_recv_indicatepkt(padapter, prframe);
+		} else
+			return _FAIL;
+	}
+	return retval;
+}
+
+static u8 query_rx_pwr_percentage(s8 antpower)
+{
+	if ((antpower <= -100) || (antpower >= 20))
+		return	0;
+	else if (antpower >= 0)
+		return	100;
+	else
+		return 100 + antpower;
+}
+
+static u8 evm_db2percentage(s8 value)
+{
+	/*
+	 * -33dB~0dB to 0%~99%
+	 */
+	s8 ret_val;
+
+	ret_val = value;
+	if (ret_val >= 0)
+		ret_val = 0;
+	if (ret_val <= -33)
+		ret_val = -33;
+	ret_val = -ret_val;
+	ret_val *= 3;
+	if (ret_val == 99)
+		ret_val = 100;
+	return ret_val;
+}
+
+s32 r8712_signal_scale_mapping(s32 cur_sig)
+{
+	s32 ret_sig;
+
+	if (cur_sig >= 51 && cur_sig <= 100)
+		ret_sig = 100;
+	else if (cur_sig >= 41 && cur_sig <= 50)
+		ret_sig = 80 + ((cur_sig - 40) * 2);
+	else if (cur_sig >= 31 && cur_sig <= 40)
+		ret_sig = 66 + (cur_sig - 30);
+	else if (cur_sig >= 21 && cur_sig <= 30)
+		ret_sig = 54 + (cur_sig - 20);
+	else if (cur_sig >= 10 && cur_sig <= 20)
+		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
+	else if (cur_sig >= 5 && cur_sig <= 9)
+		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
+	else if (cur_sig >= 1 && cur_sig <= 4)
+		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
+	else
+		ret_sig = cur_sig;
+	return ret_sig;
+}
+
+static s32  translate2dbm(struct _adapter *padapter, u8 signal_strength_idx)
+{
+	s32 signal_power; /* in dBm.*/
+	/* Translate to dBm (x=0.5y-95).*/
+	signal_power = (s32)((signal_strength_idx + 1) >> 1);
+	signal_power -= 95;
+	return signal_power;
+}
+
+static void query_rx_phy_status(struct _adapter *padapter,
+				union recv_frame *prframe)
+{
+	u8 i, max_spatial_stream, evm;
+	struct recv_stat *prxstat = (struct recv_stat *)prframe->u.hdr.rx_head;
+	struct phy_stat *pphy_stat = (struct phy_stat *)(prxstat + 1);
+	u8 *pphy_head = (u8 *)(prxstat + 1);
+	s8 rx_pwr[4], rx_pwr_all;
+	u8 pwdb_all;
+	u32 rssi, total_rssi = 0;
+	u8 bcck_rate = 0, rf_rx_num = 0, cck_highpwr = 0;
+	struct phy_cck_rx_status *pcck_buf;
+	u8 sq;
+
+	/* Record it for next packet processing*/
+	bcck_rate = (prframe->u.hdr.attrib.mcs_rate <= 3 ? 1 : 0);
+	if (bcck_rate) {
+		u8 report;
+
+		/* CCK Driver info Structure is not the same as OFDM packet.*/
+		pcck_buf = (struct phy_cck_rx_status *)pphy_stat;
+		/* (1)Hardware does not provide RSSI for CCK
+		 * (2)PWDB, Average PWDB cacluated by hardware
+		 * (for rate adaptive)
+		 */
+		if (!cck_highpwr) {
+			report = pcck_buf->cck_agc_rpt & 0xc0;
+			report = report >> 6;
+			switch (report) {
+			/* Modify the RF RNA gain value to -40, -20,
+			 * -2, 14 by Jenyu's suggestion
+			 * Note: different RF with the different
+			 * RNA gain. */
+			case 0x3:
+				rx_pwr_all = -40 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x2:
+				rx_pwr_all = -20 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x1:
+				rx_pwr_all = -2 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			case 0x0:
+				rx_pwr_all = 14 - (pcck_buf->cck_agc_rpt &
+					     0x3e);
+				break;
+			}
+		} else {
+			report = ((u8)(le32_to_cpu(pphy_stat->phydw1) >> 8)) &
+				 0x60;
+			report = report >> 5;
+			switch (report) {
+			case 0x3:
+				rx_pwr_all = -40 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x2:
+				rx_pwr_all = -20 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x1:
+				rx_pwr_all = -2 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			case 0x0:
+				rx_pwr_all = 14 - ((pcck_buf->cck_agc_rpt &
+					     0x1f) << 1);
+				break;
+			}
+		}
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+		/* CCK gain is smaller than OFDM/MCS gain,*/
+		/* so we add gain diff by experiences, the val is 6 */
+		pwdb_all += 6;
+		if (pwdb_all > 100)
+			pwdb_all = 100;
+		/* modify the offset to make the same gain index with OFDM.*/
+		if (pwdb_all > 34 && pwdb_all <= 42)
+			pwdb_all -= 2;
+		else if (pwdb_all > 26 && pwdb_all <= 34)
+			pwdb_all -= 6;
+		else if (pwdb_all > 14 && pwdb_all <= 26)
+			pwdb_all -= 8;
+		else if (pwdb_all > 4 && pwdb_all <= 14)
+			pwdb_all -= 4;
+		/*
+		 * (3) Get Signal Quality (EVM)
+		 */
+		if (pwdb_all > 40)
+			sq = 100;
+		else {
+			sq = pcck_buf->sq_rpt;
+			if (pcck_buf->sq_rpt > 64)
+				sq = 0;
+			else if (pcck_buf->sq_rpt < 20)
+				sq = 100;
+			else
+				sq = ((64-sq) * 100) / 44;
+		}
+		prframe->u.hdr.attrib.signal_qual = sq;
+		prframe->u.hdr.attrib.rx_mimo_signal_qual[0] = sq;
+		prframe->u.hdr.attrib.rx_mimo_signal_qual[1] = -1;
+	} else {
+		/* (1)Get RSSI for HT rate */
+		for (i = 0; i < ((padapter->registrypriv.rf_config) &
+			    0x0f) ; i++) {
+			rf_rx_num++;
+			rx_pwr[i] = ((pphy_head[PHY_STAT_GAIN_TRSW_SHT + i]
+				    & 0x3F) * 2) - 110;
+			/* Translate DBM to percentage. */
+			rssi = query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += rssi;
+		}
+		/* (2)PWDB, Average PWDB cacluated by hardware (for
+		 * rate adaptive) */
+		rx_pwr_all = (((pphy_head[PHY_STAT_PWDB_ALL_SHT]) >> 1) & 0x7f)
+			     - 106;
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+
+		{
+			/* (3)EVM of HT rate */
+			if (prframe->u.hdr.attrib.htc &&
+			    prframe->u.hdr.attrib.mcs_rate >= 20 &&
+			    prframe->u.hdr.attrib.mcs_rate <= 27) {
+				/* both spatial stream make sense */
+				max_spatial_stream = 2;
+			} else {
+				/* only spatial stream 1 makes sense */
+				max_spatial_stream = 1;
+			}
+			for (i = 0; i < max_spatial_stream; i++) {
+				evm = evm_db2percentage((pphy_head
+				      [PHY_STAT_RXEVM_SHT + i]));/*dbm*/
+				prframe->u.hdr.attrib.signal_qual =
+					 (u8)(evm & 0xff);
+				prframe->u.hdr.attrib.rx_mimo_signal_qual[i] =
+					 (u8)(evm & 0xff);
+			}
+		}
+	}
+	/* UI BSS List signal strength(in percentage), make it good looking,
+	 * from 0~100. It is assigned to the BSS List in
+	 * GetValueFromBeaconOrProbeRsp(). */
+	if (bcck_rate)
+		prframe->u.hdr.attrib.signal_strength =
+			 (u8)r8712_signal_scale_mapping(pwdb_all);
+	else {
+		if (rf_rx_num != 0)
+			prframe->u.hdr.attrib.signal_strength =
+				 (u8)(r8712_signal_scale_mapping(total_rssi /=
+				 rf_rx_num));
+	}
+}
+
+static void process_link_qual(struct _adapter *padapter,
+			      union recv_frame *prframe)
+{
+	u32	last_evm = 0, tmpVal;
+	struct rx_pkt_attrib *pattrib;
+
+	if (prframe == NULL || padapter == NULL)
+		return;
+	pattrib = &prframe->u.hdr.attrib;
+	if (pattrib->signal_qual != 0) {
+		/*
+		 * 1. Record the general EVM to the sliding window.
+		 */
+		if (padapter->recvpriv.signal_qual_data.total_num++ >=
+				  PHY_LINKQUALITY_SLID_WIN_MAX) {
+			padapter->recvpriv.signal_qual_data.total_num =
+				  PHY_LINKQUALITY_SLID_WIN_MAX;
+			last_evm = padapter->recvpriv.signal_qual_data.elements
+				  [padapter->recvpriv.signal_qual_data.index];
+			padapter->recvpriv.signal_qual_data.total_val -=
+				  last_evm;
+		}
+		padapter->recvpriv.signal_qual_data.total_val +=
+			  pattrib->signal_qual;
+		padapter->recvpriv.signal_qual_data.elements[padapter->
+			  recvpriv.signal_qual_data.index++] =
+			  pattrib->signal_qual;
+		if (padapter->recvpriv.signal_qual_data.index >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX)
+			padapter->recvpriv.signal_qual_data.index = 0;
+
+		/* <1> Showed on UI for user, in percentage. */
+		tmpVal = padapter->recvpriv.signal_qual_data.total_val /
+			 padapter->recvpriv.signal_qual_data.total_num;
+		padapter->recvpriv.signal = (u8)tmpVal;
+	}
+}
+
+static void process_rssi(struct _adapter *padapter, union recv_frame *prframe)
+{
+	u32 last_rssi, tmp_val;
+	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+
+	if (padapter->recvpriv.signal_strength_data.total_num++ >=
+	    PHY_RSSI_SLID_WIN_MAX) {
+		padapter->recvpriv.signal_strength_data.total_num =
+			 PHY_RSSI_SLID_WIN_MAX;
+		last_rssi = padapter->recvpriv.signal_strength_data.elements
+			    [padapter->recvpriv.signal_strength_data.index];
+		padapter->recvpriv.signal_strength_data.total_val -= last_rssi;
+	}
+	padapter->recvpriv.signal_strength_data.total_val +=
+			pattrib->signal_strength;
+	padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.
+			signal_strength_data.index++] =
+			pattrib->signal_strength;
+	if (padapter->recvpriv.signal_strength_data.index >=
+	    PHY_RSSI_SLID_WIN_MAX)
+		padapter->recvpriv.signal_strength_data.index = 0;
+	tmp_val = padapter->recvpriv.signal_strength_data.total_val /
+		  padapter->recvpriv.signal_strength_data.total_num;
+	padapter->recvpriv.rssi = (s8)translate2dbm(padapter, (u8)tmp_val);
+}
+
+static void process_phy_info(struct _adapter *padapter,
+			     union recv_frame *prframe)
+{
+	query_rx_phy_status(padapter, prframe);
+	process_rssi(padapter, prframe);
+	process_link_qual(padapter,  prframe);
+}
+
+int recv_func(struct _adapter *padapter, void *pcontext)
+{
+	struct rx_pkt_attrib *pattrib;
+	union recv_frame *prframe, *orig_prframe;
+	int retval = _SUCCESS;
+	struct  __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+	prframe = (union recv_frame *)pcontext;
+	orig_prframe = prframe;
+	pattrib = &prframe->u.hdr.attrib;
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		if (pattrib->crc_err == 1)
+			padapter->mppriv.rx_crcerrpktcount++;
+		else
+			padapter->mppriv.rx_pktcount++;
+		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == false) {
+			/* free this recv_frame */
+			r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _exit_recv_func;
+		}
+	}
+	/* check the frame crtl field and decache */
+	retval = r8712_validate_recv_frame(padapter, prframe);
+	if (retval != _SUCCESS) {
+		/* free this recv_frame */
+		r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+		goto _exit_recv_func;
+	}
+	process_phy_info(padapter, prframe);
+	prframe = r8712_decryptor(padapter, prframe);
+	if (prframe == NULL) {
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+	prframe = r8712_recvframe_chk_defrag(padapter, prframe);
+	if (prframe == NULL)
+		goto _exit_recv_func;
+	prframe = r8712_portctrl(padapter, prframe);
+	if (prframe == NULL) {
+		retval = _FAIL;
+		goto _exit_recv_func;
+	}
+	retval = r8712_process_recv_indicatepkts(padapter, prframe);
+	if (retval != _SUCCESS) {
+		r8712_free_recvframe(orig_prframe, pfree_recv_queue);
+		goto _exit_recv_func;
+	}
+_exit_recv_func:
+	return retval;
+}
+
+static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)
+{
+	u8 *pbuf, shift_sz = 0;
+	u8	frag, mf;
+	uint	pkt_len;
+	u32 transfer_len;
+	struct recv_stat *prxstat;
+	u16	pkt_cnt, drvinfo_sz, pkt_offset, tmp_len, alloc_sz;
+	struct  __queue *pfree_recv_queue;
+	_pkt  *pkt_copy = NULL;
+	union recv_frame *precvframe = NULL;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	pbuf = pskb->data;
+	prxstat = (struct recv_stat *)pbuf;
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16)&0xff;
+	pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+	transfer_len = pskb->len;
+	/* Test throughput with Netgear 3700 (No security) with Chariot 3T3R
+	 * pairs. The packet count will be a big number so that the containing
+	 * packet will effect the Rx reordering. */
+	if (transfer_len < pkt_len) {
+		/* In this case, it means the MAX_RECVBUF_SZ is too small to
+		 * get the data from 8712u. */
+		return _FAIL;
+	}
+	do {
+		prxstat = (struct recv_stat *)pbuf;
+		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
+		/* more fragment bit */
+		mf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;
+		/* ragmentation number */
+		frag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;
+		/* uint 2^3 = 8 bytes */
+		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;
+		drvinfo_sz = drvinfo_sz<<3;
+		if (pkt_len <= 0)
+			goto  _exit_recvbuf2recvframe;
+		/* Qos data, wireless lan header length is 26 */
+		if ((le32_to_cpu(prxstat->rxdw0) >> 23) & 0x01)
+			shift_sz = 2;
+		precvframe = r8712_alloc_recvframe(pfree_recv_queue);
+		if (precvframe == NULL)
+			goto  _exit_recvbuf2recvframe;
+		_init_listhead(&precvframe->u.hdr.list);
+		precvframe->u.hdr.precvbuf = NULL; /*can't access the precvbuf*/
+		precvframe->u.hdr.len = 0;
+		tmp_len = pkt_len + drvinfo_sz + RXDESC_SIZE;
+		pkt_offset = (u16)_RND128(tmp_len);
+		/* for first fragment packet, driver need allocate 1536 +
+		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
+		if ((mf == 1) && (frag == 0))
+			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/
+		else
+			alloc_sz = tmp_len;
+		/* 2 is for IP header 4 bytes alignment in QoS packet case.
+		 * 4 is for skb->data 4 bytes alignment. */
+		alloc_sz += 6;
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
+		if (pkt_copy) {
+			pkt_copy->dev = padapter->pnetdev;
+			precvframe->u.hdr.pkt = pkt_copy;
+			skb_reserve(pkt_copy, 4 - ((addr_t)(pkt_copy->data)
+				    % 4));
+			skb_reserve(pkt_copy, shift_sz);
+			memcpy(pkt_copy->data, pbuf, tmp_len);
+			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data =
+				 precvframe->u.hdr.rx_tail = pkt_copy->data;
+			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
+		} else {
+			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
+			precvframe->u.hdr.rx_head = pbuf;
+			precvframe->u.hdr.rx_data = pbuf;
+			precvframe->u.hdr.rx_tail = pbuf;
+			precvframe->u.hdr.rx_end = pbuf + alloc_sz;
+		}
+		recvframe_put(precvframe, tmp_len);
+		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+		/* because the endian issue, driver avoid reference to the
+		 * rxstat after calling update_recvframe_attrib_from_recvstat();
+		 */
+		update_recvframe_attrib_from_recvstat(&precvframe->u.hdr.attrib,
+						      prxstat);
+		r8712_recv_entry(precvframe);
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;
+		pkt_cnt--;
+		precvframe = NULL;
+		pkt_copy = NULL;
+	} while ((transfer_len > 0) && pkt_cnt > 0);
+_exit_recvbuf2recvframe:
+	return _SUCCESS;
+}
+
+static void recv_tasklet(void *priv)
+{
+	struct sk_buff *pskb;
+	struct _adapter *padapter = (struct _adapter *)priv;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {
+		recvbuf2recvframe(padapter, pskb);
+		skb_reset_tail_pointer(pskb);
+		pskb->len = 0;
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+	}
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_recv.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_recv.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_recv.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_recv.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_RECV_H_
+#define _RTL8712_RECV_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/* Realtek's v2.6.6 reduced this to 4. However, under heavy network and CPU
+ * loads, even 8 receive buffers might not be enough; cutting it to 4 seemed
+ * unwise.
+ */
+#define NR_RECVBUFF (8)
+
+#define NR_PREALLOC_RECV_SKB (8)
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+#define MAX_RECVBUF_SZ (30720) /* 30K */
+#define RECVBUFF_ALIGN_SZ 512
+#define RSVD_ROOM_SZ (0)
+/*These definition is used for Rx packet reordering.*/
+#define SN_LESS(a, b)		(((a-b) & 0x800) != 0)
+#define SN_EQUAL(a, b)	(a == b)
+#define REORDER_WAIT_TIME	30 /* (ms)*/
+
+struct recv_stat {
+	unsigned int rxdw0;
+	unsigned int rxdw1;
+	unsigned int rxdw2;
+	unsigned int rxdw3;
+	unsigned int rxdw4;
+	unsigned int rxdw5;
+};
+
+struct phy_cck_rx_status {
+	/* For CCK rate descriptor. This is a unsigned 8:1 variable.
+	 * LSB bit present 0.5. And MSB 7 bts present a signed value.
+	 * Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	sq_rpt;
+	u8	cck_agc_rpt;
+};
+
+struct phy_stat {
+	unsigned int phydw0;
+	unsigned int phydw1;
+	unsigned int phydw2;
+	unsigned int phydw3;
+	unsigned int phydw4;
+	unsigned int phydw5;
+	unsigned int phydw6;
+	unsigned int phydw7;
+};
+#define PHY_STAT_GAIN_TRSW_SHT 0
+#define PHY_STAT_PWDB_ALL_SHT 4
+#define PHY_STAT_CFOSHO_SHT 5
+#define PHY_STAT_CCK_AGC_RPT_SHT 5
+#define PHY_STAT_CFOTAIL_SHT 9
+#define PHY_STAT_RXEVM_SHT 13
+#define PHY_STAT_RXSNR_SHT 15
+#define PHY_STAT_PDSNR_SHT 19
+#define PHY_STAT_CSI_CURRENT_SHT 21
+#define PHY_STAT_CSI_TARGET_SHT 23
+#define PHY_STAT_SIGEVM_SHT 25
+#define PHY_STAT_MAX_EX_PWR_SHT 26
+
+union recvstat {
+	struct recv_stat recv_stat;
+	unsigned int value[RXDESC_SIZE>>2];
+};
+
+
+struct recv_buf {
+	struct list_head list;
+	spinlock_t recvbuf_lock;
+	u32	ref_cnt;
+	struct _adapter  *adapter;
+	struct urb *purb;
+	_pkt *pskb;
+	u8 reuse;
+	u8  irp_pending;
+	u32  transfer_len;
+	uint  len;
+	u8 *phead;
+	u8 *pdata;
+	u8 *ptail;
+	u8 *pend;
+	u8 *pbuf;
+	u8 *pallocated_buf;
+};
+
+/*
+	head  ----->
+		data  ----->
+			payload
+		tail  ----->
+	end   ----->
+	len = (unsigned int )(tail - data);
+*/
+struct recv_frame_hdr {
+	struct list_head list;
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+	struct _adapter  *adapter;
+	u8 fragcnt;
+	struct rx_pkt_attrib attrib;
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+	void *precvbuf;
+	struct sta_info *psta;
+	/*for A-MPDU Rx reordering buffer control*/
+	struct recv_reorder_ctrl *preorder_ctrl;
+};
+
+union recv_frame {
+	union {
+		struct list_head list;
+		struct recv_frame_hdr hdr;
+	} u;
+};
+
+int r8712_init_recvbuf(struct _adapter *padapter, struct recv_buf *precvbuf);
+void r8712_rxcmd_event_hdl(struct _adapter *padapter, void *prxcmdbuf);
+s32 r8712_signal_scale_mapping(s32 cur_sig);
+void r8712_reordering_ctrl_timeout_handler(void *pcontext);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_REGDEF_H__
+#define __RTL8712_REGDEF_H__
+
+#include "rtl8712_syscfg_regdef.h"
+#include "rtl8712_cmdctrl_regdef.h"
+#include "rtl8712_macsetting_regdef.h"
+#include "rtl8712_timectrl_regdef.h"
+#include "rtl8712_fifoctrl_regdef.h"
+#include "rtl8712_ratectrl_regdef.h"
+#include "rtl8712_edcasetting_regdef.h"
+#include "rtl8712_wmac_regdef.h"
+#include "rtl8712_powersave_regdef.h"
+#include "rtl8712_gp_regdef.h"
+#include "rtl8712_debugctrl_regdef.h"
+
+#define HIMR	(RTL8712_INTERRUPT_ + 0x08)
+
+#endif /* __RTL8712_REGDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_security_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_security_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_security_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_security_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SECURITY_BITDEF_H__
+#define __RTL8712_SECURITY_BITDEF_H__
+
+/*CAMCMD*/
+#define	_SECCAM_POLLING				BIT(31)
+#define	_SECCAM_CLR					BIT(30)
+#define	_SECCAM_WE					BIT(16)
+#define	_SECCAM_ADR_MSK				0x000000FF
+#define	_SECCAM_ADR_SHT				0
+
+/*CAMDBG*/
+#define	_SECCAM_INFO				BIT(31)
+#define	_SEC_KEYFOUND				BIT(30)
+#define	_SEC_CONFIG_MSK				0x3F000000
+#define	_SEC_CONFIG_SHT				24
+#define	_SEC_KEYCONTENT_MSK			0x00FFFFFF
+#define	_SEC_KEYCONTENT_SHT			0
+
+/*SECCFG*/
+#define	_NOSKMC						BIT(5)
+#define	_SKBYA2						BIT(4)
+#define	_RXDEC						BIT(3)
+#define	_TXENC						BIT(2)
+#define	_RXUSEDK					BIT(1)
+#define	_TXUSEDK					BIT(0)
+
+
+#endif	/*__RTL8712_SECURITY_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_spec.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_spec.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_spec.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_spec.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SPEC_H__
+#define __RTL8712_SPEC_H__
+
+#define RTL8712_IOBASE_TXPKT		0x10200000	/*IOBASE_TXPKT*/
+#define RTL8712_IOBASE_RXPKT		0x10210000	/*IOBASE_RXPKT*/
+#define RTL8712_IOBASE_RXCMD		0x10220000	/*IOBASE_RXCMD*/
+#define RTL8712_IOBASE_TXSTATUS		0x10230000	/*IOBASE_TXSTATUS*/
+#define RTL8712_IOBASE_RXSTATUS		0x10240000	/*IOBASE_RXSTATUS*/
+#define RTL8712_IOBASE_IOREG		0x10250000	/*IOBASE_IOREG ADDR*/
+#define RTL8712_IOBASE_SCHEDULER	0x10260000	/*IOBASE_SCHEDULE*/
+
+#define RTL8712_IOBASE_TRXDMA		0x10270000	/*IOBASE_TRXDMA*/
+#define RTL8712_IOBASE_TXLLT		0x10280000	/*IOBASE_TXLLT*/
+#define RTL8712_IOBASE_WMAC		0x10290000	/*IOBASE_WMAC*/
+#define RTL8712_IOBASE_FW2HW		0x102A0000	/*IOBASE_FW2HW*/
+#define RTL8712_IOBASE_ACCESS_PHYREG	0x102B0000	/*IOBASE_ACCESS_PHYREG*/
+
+#define RTL8712_IOBASE_FF	0x10300000 /*IOBASE_FIFO 0x1031000~0x103AFFFF*/
+
+
+/*IOREG Offset for 8712*/
+#define RTL8712_SYSCFG_		RTL8712_IOBASE_IOREG
+#define RTL8712_CMDCTRL_	(RTL8712_IOBASE_IOREG + 0x40)
+#define RTL8712_MACIDSETTING_	(RTL8712_IOBASE_IOREG + 0x50)
+#define RTL8712_TIMECTRL_	(RTL8712_IOBASE_IOREG + 0x80)
+#define RTL8712_FIFOCTRL_	(RTL8712_IOBASE_IOREG + 0xA0)
+#define RTL8712_RATECTRL_	(RTL8712_IOBASE_IOREG + 0x160)
+#define RTL8712_EDCASETTING_	(RTL8712_IOBASE_IOREG + 0x1D0)
+#define RTL8712_WMAC_		(RTL8712_IOBASE_IOREG + 0x200)
+#define RTL8712_SECURITY_	(RTL8712_IOBASE_IOREG + 0x240)
+#define RTL8712_POWERSAVE_	(RTL8712_IOBASE_IOREG + 0x260)
+#define RTL8712_GP_		(RTL8712_IOBASE_IOREG + 0x2E0)
+#define RTL8712_INTERRUPT_	(RTL8712_IOBASE_IOREG + 0x300)
+#define RTL8712_DEBUGCTRL_	(RTL8712_IOBASE_IOREG + 0x310)
+#define RTL8712_OFFLOAD_	(RTL8712_IOBASE_IOREG + 0x2D0)
+
+
+/*FIFO for 8712*/
+#define RTL8712_DMA_BCNQ	(RTL8712_IOBASE_FF + 0x10000)
+#define RTL8712_DMA_MGTQ	(RTL8712_IOBASE_FF + 0x20000)
+#define RTL8712_DMA_BMCQ	(RTL8712_IOBASE_FF + 0x30000)
+#define RTL8712_DMA_VOQ		(RTL8712_IOBASE_FF + 0x40000)
+#define RTL8712_DMA_VIQ		(RTL8712_IOBASE_FF + 0x50000)
+#define RTL8712_DMA_BEQ		(RTL8712_IOBASE_FF + 0x60000)
+#define RTL8712_DMA_BKQ		(RTL8712_IOBASE_FF + 0x70000)
+#define RTL8712_DMA_RX0FF	(RTL8712_IOBASE_FF + 0x80000)
+#define RTL8712_DMA_H2CCMD	(RTL8712_IOBASE_FF + 0x90000)
+#define RTL8712_DMA_C2HCMD	(RTL8712_IOBASE_FF + 0xA0000)
+
+
+/*------------------------------*/
+
+/*BIT 16 15*/
+#define	DID_SDIO_LOCAL			0	/* 0 0*/
+#define	DID_WLAN_IOREG			1	/* 0 1*/
+#define	DID_WLAN_FIFO			3	/* 1 1*/
+#define   DID_UNDEFINE				(-1)
+
+#define CMD_ADDR_MAPPING_SHIFT		2	/*SDIO CMD ADDR MAPPING,
+						 *shift 2 bit for match
+						 * offset[14:2]*/
+
+/*Offset for SDIO LOCAL*/
+#define	OFFSET_SDIO_LOCAL				0x0FFF
+
+/*Offset for WLAN IOREG*/
+#define OFFSET_WLAN_IOREG				0x0FFF
+
+/*Offset for WLAN FIFO*/
+#define	OFFSET_TX_BCNQ				0x0300
+#define	OFFSET_TX_HIQ					0x0310
+#define	OFFSET_TX_CMDQ				0x0320
+#define	OFFSET_TX_MGTQ				0x0330
+#define	OFFSET_TX_HCCAQ				0x0340
+#define	OFFSET_TX_VOQ					0x0350
+#define	OFFSET_TX_VIQ					0x0360
+#define	OFFSET_TX_BEQ					0x0370
+#define	OFFSET_TX_BKQ					0x0380
+#define	OFFSET_RX_RX0FFQ				0x0390
+#define	OFFSET_RX_C2HFFQ				0x03A0
+
+#define	BK_QID_01	1
+#define	BK_QID_02	2
+#define	BE_QID_01	0
+#define	BE_QID_02	3
+#define	VI_QID_01	4
+#define	VI_QID_02	5
+#define	VO_QID_01	6
+#define	VO_QID_02	7
+#define	HCCA_QID_01	8
+#define	HCCA_QID_02	9
+#define	HCCA_QID_03	10
+#define	HCCA_QID_04	11
+#define	HCCA_QID_05	12
+#define	HCCA_QID_06	13
+#define	HCCA_QID_07	14
+#define	HCCA_QID_08	15
+#define	HI_QID		17
+#define	CMD_QID	19
+#define	MGT_QID	18
+#define	BCN_QID	16
+
+#include "rtl8712_regdef.h"
+
+#include "rtl8712_bitdef.h"
+
+#include "basic_types.h"
+
+#endif /* __RTL8712_SPEC_H__ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_syscfg_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,170 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SYSCFG_BITDEF_H__
+#define __RTL8712_SYSCFG_BITDEF_H__
+
+/*SYS_PWR_CTRL*/
+/*SRCTRL0*/
+/*SRCTRL1*/
+/*SYS_CLKR*/
+
+/*SYS_IOS_CTRL*/
+#define iso_LDR2RP_SHT		8 /* EE Loader to Retention Path*/
+#define iso_LDR2RP		BIT(iso_LDR2RP_SHT) /* 1:isolation, 0:attach*/
+
+/*SYS_CTRL*/
+#define FEN_DIO_SDIO_SHT	0
+#define FEN_DIO_SDIO		BIT(FEN_DIO_SDIO_SHT)
+#define FEN_SDIO_SHT		1
+#define FEN_SDIO		BIT(FEN_SDIO_SHT)
+#define FEN_USBA_SHT		2
+#define FEN_USBA		BIT(FEN_USBA_SHT)
+#define FEN_UPLL_SHT		3
+#define FEN_UPLL		BIT(FEN_UPLL_SHT)
+#define FEN_USBD_SHT		4
+#define FEN_USBD		BIT(FEN_USBD_SHT)
+#define FEN_DIO_PCIE_SHT	5
+#define FEN_DIO_PCIE		BIT(FEN_DIO_PCIE_SHT)
+#define FEN_PCIEA_SHT		6
+#define FEN_PCIEA		BIT(FEN_PCIEA_SHT)
+#define FEN_PPLL_SHT		7
+#define FEN_PPLL		BIT(FEN_PPLL_SHT)
+#define FEN_PCIED_SHT		8
+#define FEN_PCIED		BIT(FEN_PCIED_SHT)
+#define FEN_CPUEN_SHT		10
+#define FEN_CPUEN		BIT(FEN_CPUEN_SHT)
+#define FEN_DCORE_SHT		11
+#define FEN_DCORE		BIT(FEN_DCORE_SHT)
+#define FEN_ELDR_SHT		12
+#define FEN_ELDR		BIT(FEN_ELDR_SHT)
+#define PWC_DV2LDR_SHT		13
+#define PWC_DV2LDR		BIT(PWC_DV2LDR_SHT) /* Loader Power Enable*/
+
+/*=== SYS_CLKR ===*/
+#define SYS_CLKSEL_SHT		0
+#define SYS_CLKSEL		BIT(SYS_CLKSEL_SHT) /* System Clock 80MHz*/
+#define PS_CLKSEL_SHT		1
+#define PS_CLKSEL		BIT(PS_CLKSEL_SHT) /*System power save
+						    * clock select.*/
+#define CPU_CLKSEL_SHT		2
+#define CPU_CLKSEL		BIT(CPU_CLKSEL_SHT) /* System Clock select,
+						     * 1: AFE source,
+						     * 0: System clock(L-Bus)*/
+#define INT32K_EN_SHT		3
+#define INT32K_EN		BIT(INT32K_EN_SHT)
+#define MACSLP_SHT		4
+#define MACSLP			BIT(MACSLP_SHT)
+#define MAC_CLK_EN_SHT		11
+#define MAC_CLK_EN		BIT(MAC_CLK_EN_SHT) /* MAC Clock Enable.*/
+#define SYS_CLK_EN_SHT		12
+#define SYS_CLK_EN		BIT(SYS_CLK_EN_SHT)
+#define RING_CLK_EN_SHT		13
+#define RING_CLK_EN		BIT(RING_CLK_EN_SHT)
+#define SWHW_SEL_SHT		14
+#define SWHW_SEL		BIT(SWHW_SEL_SHT) /* Load done,
+						   * control path switch.*/
+#define FWHW_SEL_SHT		15
+#define FWHW_SEL		BIT(FWHW_SEL_SHT) /* Sleep exit,
+						   * control path switch.*/
+
+/*9346CR*/
+#define	_VPDIDX_MSK		0xFF00
+#define	_VPDIDX_SHT		8
+#define	_EEM_MSK		0x00C0
+#define	_EEM_SHT		6
+#define	_EEM0			BIT(6)
+#define	_EEM1			BIT(7)
+#define	_EEPROM_EN		BIT(5)
+#define	_9356SEL		BIT(4)
+#define	_EECS			BIT(3)
+#define	_EESK			BIT(2)
+#define	_EEDI			BIT(1)
+#define	_EEDO			BIT(0)
+
+/*AFE_MISC*/
+#define	AFE_MISC_USB_MBEN_SHT	7
+#define	AFE_MISC_USB_MBEN	BIT(AFE_MISC_USB_MBEN_SHT)
+#define	AFE_MISC_USB_BGEN_SHT	6
+#define	AFE_MISC_USB_BGEN	BIT(AFE_MISC_USB_BGEN_SHT)
+#define	AFE_MISC_LD12_VDAJ_SHT	4
+#define	AFE_MISC_LD12_VDAJ_MSK	0X0030
+#define	AFE_MISC_LD12_VDAJ	BIT(AFE_MISC_LD12_VDAJ_SHT)
+#define	AFE_MISC_I32_EN_SHT	3
+#define	AFE_MISC_I32_EN		BIT(AFE_MISC_I32_EN_SHT)
+#define	AFE_MISC_E32_EN_SHT	2
+#define	AFE_MISC_E32_EN		BIT(AFE_MISC_E32_EN_SHT)
+#define	AFE_MISC_MBEN_SHT	1
+#define	AFE_MISC_MBEN		BIT(AFE_MISC_MBEN_SHT)/* Enable AFE Macro
+						       * Block's Mbias.*/
+#define	AFE_MISC_BGEN_SHT	0
+#define	AFE_MISC_BGEN		BIT(AFE_MISC_BGEN_SHT)/* Enable AFE Macro
+						       * Block's Bandgap.*/
+
+
+/*--------------------------------------------------------------------------*/
+/*       SPS1_CTRL bits				(Offset 0x18-1E, 56bits)*/
+/*--------------------------------------------------------------------------*/
+#define	SPS1_SWEN		BIT(1)	/* Enable vsps18 SW Macro Block.*/
+#define	SPS1_LDEN		BIT(0)	/* Enable VSPS12 LDO Macro block.*/
+
+
+/*----------------------------------------------------------------------------*/
+/*       LDOA15_CTRL bits		(Offset 0x20, 8bits)*/
+/*----------------------------------------------------------------------------*/
+#define	LDA15_EN		BIT(0)	/* Enable LDOA15 Macro Block*/
+
+
+/*----------------------------------------------------------------------------*/
+/*       8192S LDOV12D_CTRL bit		(Offset 0x21, 8bits)*/
+/*----------------------------------------------------------------------------*/
+#define	LDV12_EN		BIT(0)	/* Enable LDOVD12 Macro Block*/
+#define	LDV12_SDBY		BIT(1)	/* LDOVD12 standby mode*/
+
+/*CLK_PS_CTRL*/
+#define	_CLK_GATE_EN		BIT(0)
+
+
+/* EFUSE_CTRL*/
+#define EF_FLAG			BIT(31)		/* Access Flag, Write:1;
+						 *	        Read:0*/
+#define EF_PGPD			0x70000000	/* E-fuse Program time*/
+#define EF_RDT			0x0F000000	/* E-fuse read time: in the
+						 * unit of cycle time*/
+#define EF_PDN_EN		BIT(19)		/* EFuse Power down enable*/
+#define ALD_EN			BIT(18)		/* Autoload Enable*/
+#define EF_ADDR			0x0003FF00	/* Access Address*/
+#define EF_DATA			0x000000FF	/* Access Data*/
+
+/* EFUSE_TEST*/
+#define LDOE25_EN		BIT(31)		/* Enable LDOE25 Macro Block*/
+
+/* EFUSE_CLK_CTRL*/
+#define EFUSE_CLK_EN		BIT(1)		/* E-Fuse Clock Enable*/
+#define EFUSE_CLK_SEL		BIT(0)		/* E-Fuse Clock Select,
+						 * 0:500K, 1:40M*/
+
+#endif	/*__RTL8712_SYSCFG_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_syscfg_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_SYSCFG_REGDEF_H__
+#define __RTL8712_SYSCFG_REGDEF_H__
+
+
+#define SYS_ISO_CTRL		(RTL8712_SYSCFG_ + 0x0000)
+#define SYS_FUNC_EN		(RTL8712_SYSCFG_ + 0x0002)
+#define PMC_FSM			(RTL8712_SYSCFG_ + 0x0004)
+#define SYS_CLKR		(RTL8712_SYSCFG_ + 0x0008)
+#define EE_9346CR		(RTL8712_SYSCFG_ + 0x000A)
+#define EE_VPD			(RTL8712_SYSCFG_ + 0x000C)
+#define AFE_MISC		(RTL8712_SYSCFG_ + 0x0010)
+#define SPS0_CTRL		(RTL8712_SYSCFG_ + 0x0011)
+#define SPS1_CTRL		(RTL8712_SYSCFG_ + 0x0018)
+#define RF_CTRL			(RTL8712_SYSCFG_ + 0x001F)
+#define LDOA15_CTRL		(RTL8712_SYSCFG_ + 0x0020)
+#define LDOV12D_CTRL		(RTL8712_SYSCFG_ + 0x0021)
+#define LDOHCI12_CTRL		(RTL8712_SYSCFG_ + 0x0022)
+#define LDO_USB_CTRL		(RTL8712_SYSCFG_ + 0x0023)
+#define LPLDO_CTRL		(RTL8712_SYSCFG_ + 0x0024)
+#define AFE_XTAL_CTRL		(RTL8712_SYSCFG_ + 0x0026)
+#define AFE_PLL_CTRL		(RTL8712_SYSCFG_ + 0x0028)
+#define EFUSE_CTRL		(RTL8712_SYSCFG_ + 0x0030)
+#define EFUSE_TEST		(RTL8712_SYSCFG_ + 0x0034)
+#define PWR_DATA		(RTL8712_SYSCFG_ + 0x0038)
+#define DPS_TIMER		(RTL8712_SYSCFG_ + 0x003C)
+#define RCLK_MON		(RTL8712_SYSCFG_ + 0x003E)
+#define EFUSE_CLK_CTRL		(RTL8712_SYSCFG_ + 0x02F8)
+
+
+#endif /*__RTL8712_SYSCFG_REGDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_timectrl_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_TIMECTRL_BITDEF_H__
+#define __RTL8712_TIMECTRL_BITDEF_H__
+
+/*TSFTR*/
+/*SLOT*/
+/*USTIME*/
+
+/*TUBASE*/
+#define	_TUBASE_MSK			0x07FF
+
+/*SIFS_CCK*/
+#define	_SIFS_CCK_TRX_MSK		0xFF00
+#define	_SIFS_CCK_TRX_SHT		0x8
+#define	_SIFS_CCK_CTX_MSK		0x00FF
+#define	_SIFS_CCK_CTX_SHT		0
+
+/*SIFS_OFDM*/
+#define	_SIFS_OFDM_TRX_MSK		0xFF00
+#define	_SIFS_OFDM_TRX_SHT		0x8
+#define	_SIFS_OFDM_CTX_MSK		0x00FF
+#define	_SIFS_OFDM_CTX_SHT		0
+
+/*PIFS*/
+/*ACKTO*/
+/*EIFS*/
+/*BCNITV*/
+/*ATIMWND*/
+
+/*DRVERLYINT*/
+#define	_ENSWBCN				BIT(15)
+#define	_DRVERLY_TU_MSK			0x0FF0
+#define	_DRVERLY_TU_SHT			4
+#define	_DRVERLY_US_MSK			0x000F
+#define	_DRVERLY_US_SHT			0
+
+/*BCNDMATIM*/
+#define	_BCNDMATIM_MSK			0x03FF
+
+/*BCNERRTH*/
+/*MLT*/
+
+
+#endif /* __RTL8712_TIMECTRL_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_timectrl_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_TIMECTRL_REGDEF_H__
+#define __RTL8712_TIMECTRL_REGDEF_H__
+
+#define TSFTR			(RTL8712_TIMECTRL_ + 0x00)
+#define USTIME			(RTL8712_TIMECTRL_ + 0x08)
+#define SLOT			(RTL8712_TIMECTRL_ + 0x09)
+#define TUBASE			(RTL8712_TIMECTRL_ + 0x0A)
+#define SIFS_CCK		(RTL8712_TIMECTRL_ + 0x0C)
+#define SIFS_OFDM		(RTL8712_TIMECTRL_ + 0x0E)
+#define PIFS			(RTL8712_TIMECTRL_ + 0x10)
+#define ACKTO			(RTL8712_TIMECTRL_ + 0x11)
+#define EIFS			(RTL8712_TIMECTRL_ + 0x12)
+#define BCNITV			(RTL8712_TIMECTRL_ + 0x14)
+#define ATIMWND			(RTL8712_TIMECTRL_ + 0x16)
+#define DRVERLYINT		(RTL8712_TIMECTRL_ + 0x18)
+#define BCNDMATIM		(RTL8712_TIMECTRL_ + 0x1A)
+#define BCNERRTH		(RTL8712_TIMECTRL_ + 0x1C)
+#define MLT			(RTL8712_TIMECTRL_ + 0x1D)
+
+#endif /* __RTL8712_TIMECTRL_REGDEF_H__ */
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_wmac_bitdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_WMAC_BITDEF_H__
+#define __RTL8712_WMAC_BITDEF_H__
+
+/*NAVCTRL*/
+#define	_NAV_UPPER_EN			BIT(18)
+#define	_NAV_MTO_EN				BIT(17)
+#define	_NAV_UPPER				BIT(16)
+#define	_NAV_MTO_MSK			0xFF00
+#define	_NAV_MTO_SHT			8
+#define	_RTSRST_MSK				0x00FF
+#define	_RTSRST_SHT				0
+
+/*BWOPMODE*/
+#define	_20MHZBW				BIT(2)
+
+/*BACAMCMD*/
+#define	_BACAM_POLL				BIT(31)
+#define	_BACAM_RST				BIT(17)
+#define	_BACAM_RW				BIT(16)
+#define	_BACAM_ADDR_MSK			0x0000007F
+#define	_BACAM_ADDR_SHT			0
+
+/*LBDLY*/
+#define	_LBDLY_MSK				0x1F
+
+/*FWDLY*/
+#define	_FWDLY_MSK				0x0F
+
+/*RXERR_RPT*/
+#define	_RXERR_RPT_SEL_MSK		0xF0000000
+#define	_RXERR_RPT_SEL_SHT		28
+#define	_RPT_CNT_MSK			0x000FFFFF
+#define	_RPT_CNT_SHT			0
+
+
+#endif	/*__RTL8712_WMAC_BITDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_wmac_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_wmac_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_wmac_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_wmac_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_WMAC_REGDEF_H__
+#define __RTL8712_WMAC_REGDEF_H__
+
+#define NAVCTRL				(RTL8712_WMAC_ + 0x00)
+#define BWOPMODE			(RTL8712_WMAC_ + 0x03)
+#define BACAMCMD			(RTL8712_WMAC_ + 0x04)
+#define BACAMCONTENT			(RTL8712_WMAC_ + 0x08)
+#define LBDLY				(RTL8712_WMAC_ + 0x10)
+#define FWDLY				(RTL8712_WMAC_ + 0x11)
+#define HWPC_RX_CTRL			(RTL8712_WMAC_ + 0x18)
+#define MQ				(RTL8712_WMAC_ + 0x20)
+#define MA				(RTL8712_WMAC_ + 0x22)
+#define MS				(RTL8712_WMAC_ + 0x24)
+#define CLM_RESULT			(RTL8712_WMAC_ + 0x27)
+#define NHM_RPI_CNT			(RTL8712_WMAC_ + 0x28)
+#define RXERR_RPT			(RTL8712_WMAC_ + 0x30)
+#define NAV_PROT_LEN			(RTL8712_WMAC_ + 0x34)
+#define CFEND_TH			(RTL8712_WMAC_ + 0x36)
+#define AMPDU_MIN_SPACE			(RTL8712_WMAC_ + 0x37)
+#define	TXOP_STALL_CTRL			(RTL8712_WMAC_ + 0x38)
+
+
+#endif /*__RTL8712_WMAC_REGDEF_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_xmit.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_xmit.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_xmit.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_xmit.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,760 @@
+/******************************************************************************
+ * rtl8712_xmit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL8712_XMIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+static void dump_xframe(struct _adapter *padapter,
+			struct xmit_frame *pxmitframe);
+static void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz);
+
+sint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag)
+{
+	phw_txqueue->ac_tag = ac_tag;
+	switch (ac_tag) {
+	case BE_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+		break;
+	case BK_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BKQ;
+		break;
+	case VI_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_VIQ;
+		break;
+	case VO_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_VOQ;
+		break;
+	case BMC_QUEUE_INX:
+		phw_txqueue->ff_hwaddr = RTL8712_DMA_BEQ;
+		break;
+	}
+	return _SUCCESS;
+}
+
+int r8712_txframes_sta_ac_pending(struct _adapter *padapter,
+				  struct pkt_attrib *pattrib)
+{
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	int priority = pattrib->priority;
+
+	psta = pattrib->psta;
+	switch (priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+	break;
+	}
+	return ptxservq->qcnt;
+}
+
+static u32 get_ff_hwaddr(struct xmit_frame *pxmitframe)
+{
+	u32 addr = 0;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+
+	if (pxmitframe->frame_tag == TXAGG_FRAMETAG)
+		addr = RTL8712_DMA_H2CCMD;
+	else if (pxmitframe->frame_tag == MGNT_FRAMETAG)
+		addr = RTL8712_DMA_MGTQ;
+	else if (pdvobj->nr_endpoint == 6) {
+		switch (pattrib->priority) {
+		case 0:
+		case 3:
+			addr = RTL8712_DMA_BEQ;
+			break;
+		case 1:
+		case 2:
+			addr = RTL8712_DMA_BKQ;
+			break;
+		case 4:
+		case 5:
+			addr = RTL8712_DMA_VIQ;
+			break;
+		case 6:
+		case 7:
+			addr = RTL8712_DMA_VOQ;
+			break;
+		case 0x10:
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			addr = RTL8712_DMA_H2CCMD;
+			break;
+		default:
+			addr = RTL8712_DMA_BEQ;
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 4) {
+		switch (pattrib->qsel) {
+		case 0:
+		case 3:
+		case 1:
+		case 2:
+			addr = RTL8712_DMA_BEQ;/*RTL8712_EP_LO;*/
+			break;
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			addr = RTL8712_DMA_VOQ;/*RTL8712_EP_HI;*/
+			break;
+		case 0x10:
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			addr = RTL8712_DMA_H2CCMD;
+			break;
+		default:
+			addr = RTL8712_DMA_BEQ;/*RTL8712_EP_LO;*/
+			break;
+		}
+	}
+	return addr;
+}
+
+static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,
+					 struct hw_xmit *phwxmit,
+					 struct tx_servq *ptxservq,
+					 struct  __queue *pframe_queue)
+{
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame *pxmitframe = NULL;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = get_next(xmitframe_phead);
+	if ((end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = LIST_CONTAINOR(xmitframe_plist,
+			     struct xmit_frame, list);
+		list_delete(&pxmitframe->list);
+		ptxservq->qcnt--;
+		phwxmit->txcmdcnt++;
+	}
+	return pxmitframe;
+}
+
+static struct xmit_frame *dequeue_xframe_ex(struct xmit_priv *pxmitpriv,
+				     struct hw_xmit *phwxmit_i, sint entry)
+{
+	unsigned long irqL0;
+	struct list_head *sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	struct  __queue *pframe_queue = NULL;
+	struct	xmit_frame *pxmitframe = NULL;
+	int i, inx[4];
+	int j, tmp, acirp_cnt[4];
+
+	/*entry indx: 0->vo, 1->vi, 2->be, 3->bk.*/
+	inx[0] = 0; acirp_cnt[0] = pxmitpriv->voq_cnt;
+	inx[1] = 1; acirp_cnt[1] = pxmitpriv->viq_cnt;
+	inx[2] = 2; acirp_cnt[2] = pxmitpriv->beq_cnt;
+	inx[3] = 3; acirp_cnt[3] = pxmitpriv->bkq_cnt;
+	for (i = 0; i < 4; i++) {
+		for (j = i + 1; j < 4; j++) {
+			if (acirp_cnt[j] < acirp_cnt[i]) {
+				tmp = acirp_cnt[i];
+				acirp_cnt[i] = acirp_cnt[j];
+				acirp_cnt[j] = tmp;
+				tmp = inx[i];
+				inx[i] = inx[j];
+				inx[j] = tmp;
+			}
+		}
+	}
+	spin_lock_irqsave(&pxmitpriv->lock, irqL0);
+	for (i = 0; i < entry; i++) {
+		phwxmit = phwxmit_i + inx[i];
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+		while ((end_of_queue_search(sta_phead, sta_plist)) == false) {
+			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq,
+				  tx_pending);
+			pframe_queue = &ptxservq->sta_pending;
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit,
+				     ptxservq, pframe_queue);
+			if (pxmitframe) {
+				phwxmit->accnt--;
+				goto exit_dequeue_xframe_ex;
+			}
+			sta_plist = get_next(sta_plist);
+			/*Remove sta node when there are no pending packets.*/
+			if (_queue_empty(pframe_queue)) {
+				/*must be done after get_next and before break*/
+				list_delete(&ptxservq->tx_pending);
+			}
+		}
+	}
+exit_dequeue_xframe_ex:
+	spin_unlock_irqrestore(&pxmitpriv->lock, irqL0);
+	return pxmitframe;
+}
+
+void r8712_do_queue_select(struct _adapter *padapter,
+			   struct pkt_attrib *pattrib)
+{
+	unsigned int qsel = 0;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+
+	if (pdvobj->nr_endpoint == 6)
+		qsel = (unsigned int) pattrib->priority;
+	else if (pdvobj->nr_endpoint == 4) {
+		qsel = (unsigned int) pattrib->priority;
+		if (qsel == 0 || qsel == 3)
+			qsel = 3;
+		else if (qsel == 1 || qsel == 2)
+			qsel = 1;
+		else if (qsel == 4 || qsel == 5)
+			qsel = 5;
+		else if (qsel == 6 || qsel == 7)
+			qsel = 7;
+		else
+			qsel = 3;
+	}
+	pattrib->qsel = qsel;
+}
+
+#ifdef CONFIG_R8712_TX_AGGR
+u8 r8712_construct_txaggr_cmd_desc(struct xmit_buf *pxmitbuf)
+{
+	struct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;
+
+	/* Fill up TxCmd Descriptor according as USB FW Tx Aaggregation info.*/
+	/* dw0 */
+	ptx_desc->txdw0 = cpu_to_le32(CMD_HDR_SZ&0xffff);
+	ptx_desc->txdw0 |=
+		cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);
+	ptx_desc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	/* dw1 */
+	ptx_desc->txdw1 |= cpu_to_le32((0x13<<QSEL_SHT)&0x00001f00);
+
+	return _SUCCESS;
+}
+
+u8 r8712_construct_txaggr_cmd_hdr(struct xmit_buf *pxmitbuf)
+{
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)
+		pxmitbuf->priv_data;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+	struct cmd_hdr *pcmd_hdr = (struct cmd_hdr  *)
+		(pxmitbuf->pbuf + TXDESC_SIZE);
+
+	/* Fill up Cmd Header for USB FW Tx Aggregation.*/
+	/* dw0 */
+	pcmd_hdr->cmd_dw0 = cpu_to_le32((GEN_CMD_CODE(_AMSDU_TO_AMPDU) << 16) |
+					(pcmdpriv->cmd_seq << 24));
+	pcmdpriv->cmd_seq++;
+
+	return _SUCCESS;
+}
+
+u8 r8712_append_mpdu_unit(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct tx_desc *ptx_desc = (struct tx_desc *)pxmitbuf->pbuf;
+	int last_txcmdsz = 0;
+	int padding_sz = 0;
+
+	/* 802.3->802.11 convertor */
+	r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	/* free skb struct */
+	r8712_xmit_complete(padapter, pxmitframe);
+	if (pxmitframe->attrib.ether_type != 0x0806) {
+		if ((pxmitframe->attrib.ether_type != 0x888e) &&
+			(pxmitframe->attrib.dhcp_pkt != 1)) {
+			r8712_issue_addbareq_cmd(padapter,
+					pxmitframe->attrib.priority);
+		}
+	}
+	pxmitframe->last[0] = 1;
+	update_txdesc(pxmitframe, (uint *)(pxmitframe->buf_addr),
+		pxmitframe->attrib.last_txcmdsz);
+	/*padding zero */
+	last_txcmdsz = pxmitframe->attrib.last_txcmdsz;
+	padding_sz = (8 - (last_txcmdsz % 8));
+	if ((last_txcmdsz % 8) != 0) {
+		int i;
+		for (i = 0; i < padding_sz; i++)
+			*(pxmitframe->buf_addr+TXDESC_SIZE+last_txcmdsz+i) = 0;
+	}
+	/* Add the new mpdu's length */
+	ptx_desc->txdw0 = cpu_to_le32((ptx_desc->txdw0&0xffff0000) |
+		((ptx_desc->txdw0&0x0000ffff)+
+			((TXDESC_SIZE+last_txcmdsz+padding_sz)&0x0000ffff)));
+
+	return _SUCCESS;
+}
+
+
+u8 r8712_xmitframe_aggr_1st(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	/* linux complete context doesnt need to protect */
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf+TXDESC_SIZE+CMD_HDR_SZ;
+	/*RTL8712_DMA_H2CCMD */
+	r8712_construct_txaggr_cmd_desc(pxmitbuf);
+	r8712_construct_txaggr_cmd_hdr(pxmitbuf);
+	if (r8712_append_mpdu_unit(pxmitbuf, pxmitframe) == _SUCCESS)
+		pxmitbuf->aggr_nr = 1;
+
+	return _SUCCESS;
+}
+
+u16 r8712_xmitframe_aggr_next(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitbuf->priv_data = pxmitframe;
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf + TXDESC_SIZE +
+		(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);
+	if (r8712_append_mpdu_unit(pxmitbuf, pxmitframe) == _SUCCESS) {
+		r8712_free_xmitframe_ex(&pxmitframe->padapter->xmitpriv,
+					pxmitframe);
+		pxmitbuf->aggr_nr++;
+	}
+
+	return TXDESC_SIZE +
+		(((struct tx_desc *)pxmitbuf->pbuf)->txdw0 & 0x0000ffff);
+}
+
+u8 r8712_dump_aggr_xframe(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe)
+{
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *) &padapter->dvobjpriv;
+	struct tx_desc * ptxdesc = (struct tx_desc *)pxmitbuf->pbuf;
+	struct cmd_hdr *pcmd_hdr = (struct cmd_hdr *)
+		(pxmitbuf->pbuf + TXDESC_SIZE);
+	u16 total_length = (u16) (ptxdesc->txdw0 & 0xffff);
+
+	/* use 1st xmitframe as media */
+	xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+	pcmd_hdr->cmd_dw0 = cpu_to_le32(((total_length-CMD_HDR_SZ)&0x0000ffff)|
+					(pcmd_hdr->cmd_dw0&0xffff0000));
+
+	/* urb length in cmd_dw1 */
+	pcmd_hdr->cmd_dw1 = cpu_to_le32((pxmitbuf->aggr_nr & 0xff)|
+					((total_length+TXDESC_SIZE) << 16));
+	pxmitframe->last[0] = 1;
+	pxmitframe->bpending[0] = false;
+	pxmitframe->mem_addr = pxmitbuf->pbuf;
+
+	if ((pdvobj->ishighspeed && ((total_length+TXDESC_SIZE)%0x200) == 0) ||
+		((!pdvobj->ishighspeed &&
+			((total_length+TXDESC_SIZE)%0x40) == 0))) {
+		ptxdesc->txdw0 |= cpu_to_le32
+			(((TXDESC_SIZE+OFFSET_SZ+8)<<OFFSET_SHT)&0x00ff0000);
+		/*32 bytes for TX Desc + 8 bytes pending*/
+	} else {
+		ptxdesc->txdw0 |= cpu_to_le32
+			(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);
+		/*default = 32 bytes for TX Desc*/
+	}
+	r8712_write_port(pxmitframe->padapter, RTL8712_DMA_H2CCMD,
+			total_length+TXDESC_SIZE, (u8 *)pxmitframe);
+
+	return _SUCCESS;
+}
+
+#endif
+
+static void update_txdesc(struct xmit_frame *pxmitframe, uint *pmem, int sz)
+{
+	uint qsel;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct tx_desc *ptxdesc = (struct tx_desc *)pmem;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+#ifdef CONFIG_R8712_TX_AGGR
+	struct cmd_priv *pcmdpriv = (struct cmd_priv *)&padapter->cmdpriv;
+#endif
+	u8 blnSetTxDescOffset;
+	sint bmcst = IS_MCAST(pattrib->ra);
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct tx_desc txdesc_mp;
+
+	memcpy(&txdesc_mp, ptxdesc, sizeof(struct tx_desc));
+	memset(ptxdesc, 0, sizeof(struct tx_desc));
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
+	if (pdvobj->ishighspeed) {
+		if (((sz + TXDESC_SIZE) % 512) == 0)
+			blnSetTxDescOffset = 1;
+		else
+			blnSetTxDescOffset = 0;
+	} else {
+		if (((sz + TXDESC_SIZE) % 64) == 0)
+			blnSetTxDescOffset = 1;
+		else
+			blnSetTxDescOffset = 0;
+	}
+	if (blnSetTxDescOffset) {
+		/* 32 bytes for TX Desc + 8 bytes pending */
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ + 8) <<
+			      OFFSET_SHT) & 0x00ff0000);
+	} else {
+		/* default = 32 bytes for TX Desc */
+		ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ) <<
+				  OFFSET_SHT) & 0x00ff0000);
+	}
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+	if (pxmitframe->frame_tag == DATA_FRAMETAG) {
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->mac_id)&0x1f);
+
+#ifdef CONFIG_R8712_TX_AGGR
+		/* dirty workaround, need to check if it is aggr cmd. */
+		if ((u8 *)pmem != (u8 *)pxmitframe->pxmitbuf->pbuf) {
+			ptxdesc->txdw0 |= cpu_to_le32
+				((0x3 << TYPE_SHT)&TYPE_MSK);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+			if (qsel == 2)
+				qsel = 0;
+			ptxdesc->txdw1 |= cpu_to_le32
+				((qsel << QSEL_SHT) & 0x00001f00);
+			ptxdesc->txdw2 = cpu_to_le32
+				((qsel << RTS_RC_SHT)&0x001f0000);
+			ptxdesc->txdw6 |= cpu_to_le32
+				((0x5 << RSVD6_SHT)&RSVD6_MSK);
+		} else {
+			ptxdesc->txdw0 |= cpu_to_le32
+				((0x3 << TYPE_SHT)&TYPE_MSK);
+			ptxdesc->txdw1 |= cpu_to_le32
+				((0x13 << QSEL_SHT) & 0x00001f00);
+			qsel = (uint)(pattrib->qsel & 0x0000001f);
+			if (qsel == 2)
+				qsel = 0;
+			ptxdesc->txdw2 = cpu_to_le32
+				((qsel << RTS_RC_SHT)&0x0001f000);
+			ptxdesc->txdw7 |= cpu_to_le32
+				(pcmdpriv->cmd_seq << 24);
+			pcmdpriv->cmd_seq++;
+		}
+		pattrib->qsel = 0x13;
+#else
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+#endif
+		if (!pqospriv->qos_option)
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(16));/*Non-QoS*/
+		if ((pattrib->encrypt > 0) && !pattrib->bswenc) {
+			switch (pattrib->encrypt) {	/*SEC_TYPE*/
+			case _WEP40_:
+			case _WEP104_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x01 << 22) &
+						  0x00c00000);
+				/*KEY_ID when WEP is used;*/
+				ptxdesc->txdw1 |= cpu_to_le32((psecuritypriv->
+						  PrivacyKeyIndex << 17) &
+						  0x00060000);
+				break;
+			case _TKIP_:
+			case _TKIP_WTMIC_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x02 << 22) &
+						  0x00c00000);
+				break;
+			case _AES_:
+				ptxdesc->txdw1 |= cpu_to_le32((0x03 << 22) &
+						  0x00c00000);
+				break;
+			case _NO_PRIVACY_:
+			default:
+				break;
+			}
+		}
+		/*offset 8*/
+		if (bmcst)
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+
+		/*offset 12*/
+		/* f/w will increase the seqnum by itself, driver pass the
+		 * correct priority to fw
+		 * fw will check the correct priority for increasing the
+		 * seqnum per tid. about usb using 4-endpoint, qsel points out
+		 * the correct mapping between AC&Endpoint,
+		 * the purpose is that correct mapping lets the MAC release
+		 * the AC Queue list correctly. */
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &
+				 0x0fff0000);
+		if ((pattrib->ether_type != 0x888e) &&
+		    (pattrib->ether_type != 0x0806) &&
+		    (pattrib->dhcp_pkt != 1)) {
+			/*Not EAP & ARP type data packet*/
+			if (phtpriv->ht_option == 1) { /*B/G/N Mode*/
+				if (phtpriv->ampdu_enable != true)
+					ptxdesc->txdw2 |= cpu_to_le32(BK);
+			}
+		} else {
+			/* EAP data packet and ARP packet.
+			 * Use the 1M data rate to send the EAP/ARP packet.
+			 * This will maybe make the handshake smooth.
+			 */
+			/*driver uses data rate*/
+			ptxdesc->txdw4 = cpu_to_le32(0x80000000);
+			ptxdesc->txdw5 = cpu_to_le32(0x001f8000);/*1M*/
+		}
+		if (pattrib->pctrl == 1) { /* mp tx packets */
+			struct tx_desc *ptxdesc_mp;
+			ptxdesc_mp = &txdesc_mp;
+			/* offset 8 */
+			ptxdesc->txdw2 = cpu_to_le32(ptxdesc_mp->txdw2);
+			if (bmcst)
+				ptxdesc->txdw2 |= cpu_to_le32(BMC);
+			ptxdesc->txdw2 |= cpu_to_le32(BK);
+			/* offset 16 */
+			ptxdesc->txdw4 = cpu_to_le32(ptxdesc_mp->txdw4);
+			/* offset 20 */
+			ptxdesc->txdw5 = cpu_to_le32(ptxdesc_mp->txdw5);
+			pattrib->pctrl = 0;/* reset to zero; */
+		}
+	} else if (pxmitframe->frame_tag == MGNT_FRAMETAG) {
+		/* offset 4 */
+		ptxdesc->txdw1 |= (0x05) & 0x1f;/*CAM_ID(MAC_ID), default=5;*/
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+		ptxdesc->txdw1 |= cpu_to_le32(BIT(16));/* Non-QoS */
+		/* offset 8 */
+		if (bmcst)
+			ptxdesc->txdw2 |= cpu_to_le32(BMC);
+		/* offset 12 */
+		/* f/w will increase the seqnum by itself, driver pass the
+		 * correct priority to fw
+		 * fw will check the correct priority for increasing the seqnum
+		 * per tid. about usb using 4-endpoint, qsel points out the
+		 * correct mapping between AC&Endpoint,
+		 * the purpose is that correct mapping let the MAC releases
+		 * the AC Queue list correctly. */
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->priority << SEQ_SHT) &
+					      0x0fff0000);
+		/* offset 16 */
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);/*gtest*/
+		/* offset 20 */
+		ptxdesc->txdw5 = cpu_to_le32(0x001f8000);/* gtest 1M */
+	} else if (pxmitframe->frame_tag == TXAGG_FRAMETAG) {
+		/* offset 4 */
+		qsel = 0x13;
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+	} else {
+		/* offset 4 */
+		qsel = (uint)(pattrib->priority&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+		/*offset 8*/
+		/*offset 12*/
+		ptxdesc->txdw3 = cpu_to_le32((pattrib->seqnum << SEQ_SHT) &
+					      0x0fff0000);
+		/*offset 16*/
+		ptxdesc->txdw4 = cpu_to_le32(0x80002040);/*gtest*/
+		/*offset 20*/
+		ptxdesc->txdw5 = cpu_to_le32(0x001f9600);/*gtest*/
+	}
+}
+
+int r8712_xmitframe_complete(struct _adapter *padapter,
+			     struct xmit_priv *pxmitpriv,
+			     struct xmit_buf *pxmitbuf)
+{
+	struct hw_xmit *phwxmits;
+	sint hwentry;
+	struct xmit_frame *pxmitframe = NULL;
+#ifdef CONFIG_R8712_TX_AGGR
+	struct xmit_frame *p2ndxmitframe = NULL;
+#else
+	int res = _SUCCESS, xcnt = 0;
+#endif
+
+	phwxmits = pxmitpriv->hwxmits;
+	hwentry = pxmitpriv->hwxmit_entry;
+	if (pxmitbuf == NULL) {
+		pxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);
+		if (!pxmitbuf)
+			return false;
+#ifdef CONFIG_R8712_TX_AGGR
+		pxmitbuf->aggr_nr = 0;
+#endif
+	}
+	/* 1st frame dequeued */
+	pxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits, hwentry);
+	/* need to remember the 1st frame */
+	if (pxmitframe != NULL) {
+
+#ifdef CONFIG_R8712_TX_AGGR
+		/* 1. dequeue 2nd frame
+		 * 2. aggr if 2nd xframe is dequeued, else dump directly
+		 */
+		if (AGGR_NR_HIGH_BOUND > 1)
+			p2ndxmitframe = dequeue_xframe_ex(pxmitpriv, phwxmits,
+							hwentry);
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+			return false;
+		}
+		if (p2ndxmitframe != NULL)
+			if (p2ndxmitframe->frame_tag != DATA_FRAMETAG) {
+				r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+				return false;
+			}
+		r8712_xmitframe_aggr_1st(pxmitbuf, pxmitframe);
+		if (p2ndxmitframe != NULL) {
+			u16 total_length;
+			total_length = r8712_xmitframe_aggr_next(
+				pxmitbuf, p2ndxmitframe);
+			do {
+				p2ndxmitframe = dequeue_xframe_ex(
+					pxmitpriv, phwxmits, hwentry);
+				if (p2ndxmitframe != NULL)
+					total_length =
+						r8712_xmitframe_aggr_next(
+							pxmitbuf,
+							p2ndxmitframe);
+				else
+					break;
+			} while (total_length <= 0x1800 &&
+				pxmitbuf->aggr_nr <= AGGR_NR_HIGH_BOUND);
+		}
+		if (pxmitbuf->aggr_nr > 0)
+			r8712_dump_aggr_xframe(pxmitbuf, pxmitframe);
+
+#else
+
+		xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+		if (pxmitframe->frame_tag == DATA_FRAMETAG) {
+			if (pxmitframe->attrib.priority <= 15)
+				res = r8712_xmitframe_coalesce(padapter,
+					pxmitframe->pkt, pxmitframe);
+			/* always return ndis_packet after
+			 * r8712_xmitframe_coalesce */
+			r8712_xmit_complete(padapter, pxmitframe);
+		}
+		if (res == _SUCCESS)
+			dump_xframe(padapter, pxmitframe);
+		else
+			r8712_free_xmitframe_ex(pxmitpriv, pxmitframe);
+		xcnt++;
+#endif
+
+	} else { /* pxmitframe == NULL && p2ndxmitframe == NULL */
+		r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+		return false;
+	}
+	return true;
+}
+
+static void dump_xframe(struct _adapter *padapter,
+			struct xmit_frame *pxmitframe)
+{
+	int t, sz, w_sz;
+	u8 *mem_addr;
+	u32 ff_hwaddr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if (pxmitframe->attrib.ether_type != 0x0806) {
+		if (pxmitframe->attrib.ether_type != 0x888e)
+			r8712_issue_addbareq_cmd(padapter, pattrib->priority);
+	}
+	mem_addr = pxmitframe->buf_addr;
+	for (t = 0; t < pattrib->nr_frags; t++) {
+		if (t != (pattrib->nr_frags - 1)) {
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 :
+			     pattrib->icv_len);
+			pxmitframe->last[t] = 0;
+		} else {
+			sz = pattrib->last_txcmdsz;
+			pxmitframe->last[t] = 1;
+		}
+		update_txdesc(pxmitframe, (uint *)mem_addr, sz);
+		w_sz = sz + TXDESC_SIZE;
+		pxmitframe->mem_addr = mem_addr;
+		pxmitframe->bpending[t] = false;
+		ff_hwaddr = get_ff_hwaddr(pxmitframe);
+#ifdef CONFIG_R8712_TX_AGGR
+		r8712_write_port(padapter, RTL8712_DMA_H2CCMD, w_sz,
+				(unsigned char *)pxmitframe);
+#else
+		r8712_write_port(padapter, ff_hwaddr, w_sz,
+			   (unsigned char *)pxmitframe);
+#endif
+		mem_addr += w_sz;
+		mem_addr = (u8 *)RND4(((addr_t)(mem_addr)));
+	}
+}
+
+int r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int res = _SUCCESS;
+
+	res = r8712_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	pxmitframe->pkt = NULL;
+	if (res == _SUCCESS)
+		dump_xframe(padapter, pxmitframe);
+	return res;
+}
+
+int r8712_xmit_enqueue(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (r8712_xmit_classifier(padapter, pxmitframe) == _FAIL) {
+		pxmitframe->pkt = NULL;
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_xmit.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_xmit.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl8712_xmit.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl8712_xmit.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL8712_XMIT_H_
+#define _RTL8712_XMIT_H_
+
+#define HWXMIT_ENTRY	4
+
+#define VO_QUEUE_INX	0
+#define VI_QUEUE_INX	1
+#define BE_QUEUE_INX	2
+#define BK_QUEUE_INX	3
+#define TS_QUEUE_INX	4
+#define MGT_QUEUE_INX	5
+#define BMC_QUEUE_INX	6
+#define BCN_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define TXDESC_SIZE 32
+#define TXDESC_OFFSET TXDESC_SIZE
+
+#define NR_AMSDU_XMITFRAME 8
+#define NR_TXAGG_XMITFRAME 8
+
+#define MAX_AMSDU_XMITBUF_SZ 8704
+#define MAX_TXAGG_XMITBUF_SZ 16384 /*16k*/
+
+
+#define tx_cmd tx_desc
+
+
+/*
+ *defined for TX DESC Operation
+ */
+
+#define MAX_TID (15)
+
+/*OFFSET 0*/
+#define OFFSET_SZ (0)
+#define OFFSET_SHT (16)
+#define OWN	BIT(31)
+#define FSG	BIT(27)
+#define LSG	BIT(26)
+#define TYPE_SHT (24)
+#define TYPE_MSK (0x03000000)
+
+/*OFFSET 4*/
+#define PKT_OFFSET_SZ (0)
+#define QSEL_SHT (8)
+#define HWPC BIT(31)
+
+/*OFFSET 8*/
+#define BMC BIT(7)
+#define BK BIT(30)
+#define AGG_EN BIT(29)
+#define RTS_RC_SHT (16)
+
+/*OFFSET 12*/
+#define SEQ_SHT (16)
+
+/*OFFSET 16*/
+#define TXBW BIT(18)
+
+/*OFFSET 20*/
+#define DISFB BIT(15)
+#define RSVD6_MSK (0x00E00000)
+#define RSVD6_SHT (21)
+
+struct tx_desc {
+	/*DWORD 0*/
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];
+};
+
+int r8712_xmitframe_complete(struct _adapter *padapter,
+			     struct xmit_priv *pxmitpriv,
+			     struct xmit_buf *pxmitbuf);
+void r8712_do_queue_select(struct _adapter *padapter,
+			   struct pkt_attrib *pattrib);
+
+#ifdef CONFIG_R8712_TX_AGGR
+u8 r8712_xmitframe_aggr_1st(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe);
+u8 r8712_dump_aggr_xframe(struct xmit_buf *pxmitbuf,
+			struct xmit_frame *pxmitframe);
+#endif
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_byteorder.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_byteorder.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_byteorder.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_BYTEORDER_H_
+#define _RTL871X_BYTEORDER_H_
+
+#if defined(__LITTLE_ENDIAN)
+#  include "little_endian.h"
+#elif defined(__BIG_ENDIAN)
+#  include "big_endian.h"
+#else
+#  error "Must be LITTLE/BIG Endian Host"
+#endif
+
+#endif /* _RTL871X_BYTEORDER_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_cmd.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_cmd.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_cmd.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1067 @@
+/******************************************************************************
+ * rtl871x_cmd.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_CMD_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <linux/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/rtnetlink.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "rtl871x_byteorder.h"
+
+/*
+Caller and the r8712_cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+static sint _init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	sema_init(&(pcmdpriv->cmd_queue_sema), 0);
+	sema_init(&(pcmdpriv->terminate_cmdthread_sema), 0);
+
+	_init_queue(&(pcmdpriv->cmd_queue));
+
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	pcmdpriv->cmd_seq = 1;
+	pcmdpriv->cmd_allocated_buf = _malloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+	if (pcmdpriv->cmd_allocated_buf == NULL)
+		return _FAIL;
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ -
+			    ((addr_t)(pcmdpriv->cmd_allocated_buf) &
+			    (CMDBUFF_ALIGN_SZ-1));
+	pcmdpriv->rsp_allocated_buf = _malloc(MAX_RSPSZ + 4);
+	if (pcmdpriv->rsp_allocated_buf == NULL)
+		return _FAIL;
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 -
+			    ((addr_t)(pcmdpriv->rsp_allocated_buf) & 3);
+	pcmdpriv->cmd_issued_cnt = 0;
+	pcmdpriv->cmd_done_cnt = 0;
+	pcmdpriv->rsp_cnt = 0;
+	return _SUCCESS;
+}
+
+static sint _init_evt_priv(struct evt_priv *pevtpriv)
+{
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	pevtpriv->event_seq = 0;
+	pevtpriv->evt_allocated_buf = _malloc(MAX_EVTSZ + 4);
+
+	if (pevtpriv->evt_allocated_buf == NULL)
+		return _FAIL;
+	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 -
+			    ((addr_t)(pevtpriv->evt_allocated_buf) & 3);
+	pevtpriv->evt_done_cnt = 0;
+	return _SUCCESS;
+}
+
+static void _free_evt_priv(struct evt_priv *pevtpriv)
+{
+	kfree(pevtpriv->evt_allocated_buf);
+}
+
+static void _free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	if (pcmdpriv) {
+		kfree(pcmdpriv->cmd_allocated_buf);
+		kfree(pcmdpriv->rsp_allocated_buf);
+	}
+}
+
+/*
+Calling Context:
+
+_enqueue_cmd can only be called between kernel thread,
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+static sint _enqueue_cmd(struct  __queue *queue, struct cmd_obj *obj)
+{
+	unsigned long irqL;
+
+	if (obj == NULL)
+		return _SUCCESS;
+	spin_lock_irqsave(&queue->lock, irqL);
+	list_insert_tail(&obj->list, &queue->queue);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	return _SUCCESS;
+}
+
+static struct cmd_obj *_dequeue_cmd(struct  __queue *queue)
+{
+	unsigned long irqL;
+	struct cmd_obj *obj;
+
+	spin_lock_irqsave(&(queue->lock), irqL);
+	if (is_list_empty(&(queue->queue)))
+		obj = NULL;
+	else {
+		obj = LIST_CONTAINOR(get_next(&(queue->queue)),
+				     struct cmd_obj, list);
+		list_delete(&obj->list);
+	}
+	spin_unlock_irqrestore(&(queue->lock), irqL);
+	return obj;
+}
+
+u32 r8712_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	return _init_cmd_priv(pcmdpriv);
+}
+
+u32 r8712_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	return _init_evt_priv(pevtpriv);
+}
+
+void r8712_free_evt_priv(struct evt_priv *pevtpriv)
+{
+	_free_evt_priv(pevtpriv);
+}
+
+void r8712_free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	_free_cmd_priv(pcmdpriv);
+}
+
+u32 r8712_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	int res;
+
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == true)
+		return _FAIL;
+	res = _enqueue_cmd(&pcmdpriv->cmd_queue, obj);
+	up(&pcmdpriv->cmd_queue_sema);
+	return res;
+}
+
+u32 r8712_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj)
+{
+	unsigned long irqL;
+	struct  __queue *queue;
+
+	if (obj == NULL)
+		return _SUCCESS;
+	if (pcmdpriv->padapter->eeprompriv.bautoload_fail_flag == true)
+		return _FAIL;
+	queue = &pcmdpriv->cmd_queue;
+	spin_lock_irqsave(&queue->lock, irqL);
+	list_insert_tail(&obj->list, &queue->queue);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	up(&pcmdpriv->cmd_queue_sema);
+	return _SUCCESS;
+}
+
+struct cmd_obj *r8712_dequeue_cmd(struct  __queue *queue)
+{
+	return _dequeue_cmd(queue);
+}
+
+void r8712_free_cmd_obj(struct cmd_obj *pcmd)
+{
+	if ((pcmd->cmdcode != _JoinBss_CMD_) &&
+	    (pcmd->cmdcode != _CreateBss_CMD_))
+		kfree((unsigned char *)pcmd->parmbuf);
+	if (pcmd->rsp != NULL) {
+		if (pcmd->rspsz != 0)
+			kfree((unsigned char *)pcmd->rsp);
+	}
+	kfree((unsigned char *)pcmd);
+}
+
+/*
+r8712_sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC,
+	 YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+u8 r8712_sitesurvey_cmd(struct _adapter *padapter,
+			struct ndis_802_11_ssid *pssid)
+{
+	struct cmd_obj	*ph2c;
+	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psurveyPara = (struct sitesurvey_parm *)_malloc(
+		       sizeof(struct sitesurvey_parm));
+	if (psurveyPara == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,
+				   GEN_CMD_CODE(_SiteSurvey));
+	psurveyPara->bsslimit = cpu_to_le32(48);
+	psurveyPara->passive_mode = cpu_to_le32(pmlmepriv->passive_mode);
+	psurveyPara->ss_ssidlen = 0;
+	memset(psurveyPara->ss_ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	if ((pssid != NULL) && (pssid->SsidLength)) {
+		memcpy(psurveyPara->ss_ssid, pssid->Ssid, pssid->SsidLength);
+		psurveyPara->ss_ssidlen = cpu_to_le32(pssid->SsidLength);
+	}
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_SITE_SURVEY);
+	padapter->blnEnableRxFF0Filter = 0;
+	return _SUCCESS;
+}
+
+u8 r8712_setdatarate_cmd(struct _adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj		*ph2c;
+	struct setdatarate_parm	*pbsetdataratepara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pbsetdataratepara = (struct setdatarate_parm *)_malloc(
+			     sizeof(struct setdatarate_parm));
+	if (pbsetdataratepara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara,
+				   GEN_CMD_CODE(_SetDataRate));
+	pbsetdataratepara->mac_id = 5;
+	memcpy(pbsetdataratepara->datarates, rateset, NumRates);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_set_chplan_cmd(struct _adapter *padapter, int chplan)
+{
+	struct cmd_obj *ph2c;
+	struct SetChannelPlan_param *psetchplanpara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetchplanpara = (struct SetChannelPlan_param *)
+		_malloc(sizeof(struct SetChannelPlan_param));
+	if (psetchplanpara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetchplanpara,
+				GEN_CMD_CODE(_SetChannelPlan));
+	psetchplanpara->ChannelPlan = chplan;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setbasicrate_cmd(struct _adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj *ph2c;
+	struct setbasicrate_parm *pssetbasicratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pssetbasicratepara = (struct setbasicrate_parm *)_malloc(
+			      sizeof(struct setbasicrate_parm));
+	if (pssetbasicratepara == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara,
+		_SetBasicRate_CMD_);
+	memcpy(pssetbasicratepara->basicrates, rateset, NumRates);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+/* power tracking mechanism setting */
+u8 r8712_setptm_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj		*ph2c;
+	struct writePTM_parm	*pwriteptmparm;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct writePTM_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetPT));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setfwdig_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj *ph2c;
+	struct writePTM_parm *pwriteptmparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct setdig_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetDIG));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setfwra_cmd(struct _adapter *padapter, u8 type)
+{
+	struct cmd_obj *ph2c;
+	struct writePTM_parm *pwriteptmparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriteptmparm = (struct writePTM_parm *)
+		_malloc(sizeof(struct setra_parm));
+	if (pwriteptmparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteptmparm, GEN_CMD_CODE(_SetRA));
+	pwriteptmparm->type = type;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrfreg_cmd(struct _adapter  *padapter, u8 offset, u32 val)
+{
+	struct cmd_obj *ph2c;
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pwriterfparm = (struct writeRF_parm *)_malloc(
+			sizeof(struct writeRF_parm));
+	if (pwriterfparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));
+	pwriterfparm->offset = offset;
+	pwriterfparm->value = val;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_getrfreg_cmd(struct _adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj *ph2c;
+	struct readRF_parm *prdrfparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	prdrfparm = (struct readRF_parm *)_malloc(sizeof(struct readRF_parm));
+	if (prdrfparm == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_GetRFReg);
+	ph2c->parmbuf = (unsigned char *)prdrfparm;
+	ph2c->cmdsz =  sizeof(struct readRF_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readRF_rsp);
+	prdrfparm->offset = offset;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+void r8712_getbbrfreg_cmdrsp_callback(struct _adapter *padapter,
+				      struct cmd_obj *pcmd)
+{
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+	padapter->mppriv.workparam.bcompleted = true;
+}
+
+void r8712_readtssi_cmdrsp_callback(struct _adapter *padapter,
+				struct cmd_obj *pcmd)
+{
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+
+	padapter->mppriv.workparam.bcompleted = true;
+}
+
+u8 r8712_createbss_cmd(struct _adapter *padapter)
+{
+	struct cmd_obj *pcmd;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct wlan_bssid_ex *pdev_network =
+				 &padapter->registrypriv.dev_network;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _CreateBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = r8712_get_ndis_wlan_bssid_ex_sz((
+			struct ndis_wlan_bssid_ex *)
+			pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	/* notes: translate IELength & Length after assign to cmdsz; */
+	pdev_network->Length = cpu_to_le32(pcmd->cmdsz);
+	pdev_network->IELength = cpu_to_le32(pdev_network->IELength);
+	pdev_network->Ssid.SsidLength = cpu_to_le32(
+					pdev_network->Ssid.SsidLength);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+u8 r8712_joinbss_cmd(struct _adapter  *padapter, struct wlan_network *pnetwork)
+{
+	u8 *auth;
+	uint t_len = 0;
+	struct ndis_wlan_bssid_ex *psecnetwork;
+	struct cmd_obj		*pcmd;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->
+						network.InfrastructureMode;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_START_TO_LINK);
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	t_len = sizeof(u32) + 6 * sizeof(unsigned char) + 2 +
+			sizeof(struct ndis_802_11_ssid) + sizeof(u32) +
+			sizeof(s32) +
+			sizeof(enum NDIS_802_11_NETWORK_TYPE) +
+			sizeof(struct NDIS_802_11_CONFIGURATION) +
+			sizeof(enum NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof(NDIS_802_11_RATES_EX) +
+			sizeof(u32) + MAX_IE_SZ;
+
+	/* for hidden ap to set fw_state here */
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) !=
+	    true) {
+		switch (ndis_network_mode) {
+		case Ndis802_11IBSS:
+			pmlmepriv->fw_state |= WIFI_ADHOC_STATE;
+			break;
+		case Ndis802_11Infrastructure:
+			pmlmepriv->fw_state |= WIFI_STATION_STATE;
+			break;
+		case Ndis802_11APMode:
+		case Ndis802_11AutoUnknown:
+		case Ndis802_11InfrastructureMax:
+			break;
+		}
+	}
+	psecnetwork = (struct ndis_wlan_bssid_ex *)&psecuritypriv->sec_bss;
+	if (psecnetwork == NULL) {
+		kfree(pcmd);
+		return _FAIL;
+	}
+	memset(psecnetwork, 0, t_len);
+	memcpy(psecnetwork, &pnetwork->network, t_len);
+	auth = &psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0] = (unsigned char)
+					     psecnetwork->IELength;
+	if ((psecnetwork->IELength-12) < (256 - 1))
+		memcpy(&psecuritypriv->authenticator_ie[1],
+			&psecnetwork->IEs[12], psecnetwork->IELength-12);
+	else
+		memcpy(&psecuritypriv->authenticator_ie[1],
+			&psecnetwork->IEs[12], (256-1));
+	psecnetwork->IELength = 0;
+	/* If the the driver wants to use the bssid to create the connection.
+	 * If not,  we copy the connecting AP's MAC address to it so that
+	 * the driver just has the bssid information for PMKIDList searching.
+	 */
+	if (pmlmepriv->assoc_by_bssid == false)
+		memcpy(&pmlmepriv->assoc_bssid[0],
+			&pnetwork->network.MacAddress[0], ETH_ALEN);
+	psecnetwork->IELength = r8712_restruct_sec_ie(padapter,
+						&pnetwork->network.IEs[0],
+						&psecnetwork->IEs[0],
+						pnetwork->network.IELength);
+	pqospriv->qos_option = 0;
+	if (pregistrypriv->wmm_enable) {
+		u32 tmp_len;
+
+		tmp_len = r8712_restruct_wmm_ie(padapter,
+					  &pnetwork->network.IEs[0],
+					  &psecnetwork->IEs[0],
+					  pnetwork->network.IELength,
+					  psecnetwork->IELength);
+		if (psecnetwork->IELength != tmp_len) {
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; /* WMM IE in beacon */
+		} else
+			pqospriv->qos_option = 0; /* no WMM IE in beacon */
+	}
+	if (pregistrypriv->ht_enable) {
+		/* For WEP mode, we will use the bg mode to do the connection
+		 * to avoid some IOT issues, especially for Realtek 8192u
+		 * SoftAP.
+		 */
+		if ((padapter->securitypriv.PrivacyAlgrthm != _WEP40_) &&
+		    (padapter->securitypriv.PrivacyAlgrthm != _WEP104_)) {
+			/* restructure_ht_ie */
+			r8712_restructure_ht_ie(padapter,
+						&pnetwork->network.IEs[0],
+						&psecnetwork->IEs[0],
+						pnetwork->network.IELength,
+						&psecnetwork->IELength);
+		}
+	}
+	psecuritypriv->supplicant_ie[0] = (u8)psecnetwork->IELength;
+	if (psecnetwork->IELength < 255)
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],
+			psecnetwork->IELength);
+	else
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0],
+			255);
+	/* get cmdsz before endian conversion */
+	pcmd->cmdsz = r8712_get_ndis_wlan_bssid_ex_sz(psecnetwork);
+#ifdef __BIG_ENDIAN
+	/* wlan_network endian conversion */
+	psecnetwork->Length = cpu_to_le32(psecnetwork->Length);
+	psecnetwork->Ssid.SsidLength = cpu_to_le32(
+				       psecnetwork->Ssid.SsidLength);
+	psecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);
+	psecnetwork->Rssi = cpu_to_le32(psecnetwork->Rssi);
+	psecnetwork->NetworkTypeInUse = cpu_to_le32(
+					psecnetwork->NetworkTypeInUse);
+	psecnetwork->Configuration.ATIMWindow = cpu_to_le32(
+				psecnetwork->Configuration.ATIMWindow);
+	psecnetwork->Configuration.BeaconPeriod = cpu_to_le32(
+				 psecnetwork->Configuration.BeaconPeriod);
+	psecnetwork->Configuration.DSConfig = cpu_to_le32(
+				psecnetwork->Configuration.DSConfig);
+	psecnetwork->Configuration.FHConfig.DwellTime = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.DwellTime);
+	psecnetwork->Configuration.FHConfig.HopPattern = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.HopPattern);
+	psecnetwork->Configuration.FHConfig.HopSet = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.HopSet);
+	psecnetwork->Configuration.FHConfig.Length = cpu_to_le32(
+				psecnetwork->Configuration.FHConfig.Length);
+	psecnetwork->Configuration.Length = cpu_to_le32(
+				psecnetwork->Configuration.Length);
+	psecnetwork->InfrastructureMode = cpu_to_le32(
+				psecnetwork->InfrastructureMode);
+	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);
+#endif
+	_init_listhead(&pcmd->list);
+	pcmd->cmdcode = _JoinBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+u8 r8712_disassoc_cmd(struct _adapter *padapter) /* for sta_mode */
+{
+	struct cmd_obj *pdisconnect_cmd;
+	struct disconnect_parm *pdisconnect;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	pdisconnect_cmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pdisconnect_cmd == NULL)
+		return _FAIL;
+	pdisconnect = (struct disconnect_parm *)_malloc(
+		      sizeof(struct disconnect_parm));
+	if (pdisconnect == NULL) {
+		kfree((u8 *)pdisconnect_cmd);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(pdisconnect_cmd, pdisconnect,
+				   _DisConnect_CMD_);
+	r8712_enqueue_cmd(pcmdpriv, pdisconnect_cmd);
+	return _SUCCESS;
+}
+
+u8 r8712_setopmode_cmd(struct _adapter *padapter,
+		 enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct cmd_obj *ph2c;
+	struct setopmode_parm *psetop;
+
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetop = (struct setopmode_parm *)_malloc(
+		  sizeof(struct setopmode_parm));
+	if (psetop == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);
+	psetop->mode = (u8)networktype;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setstakey_cmd(struct _adapter *padapter, u8 *psta, u8 unicast_key)
+{
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp *psetstakey_rsp = NULL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct sta_info *sta = (struct sta_info *)psta;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetstakey_para = (struct set_stakey_parm *)_malloc(
+			  sizeof(struct set_stakey_parm));
+	if (psetstakey_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	psetstakey_rsp = (struct set_stakey_rsp *)_malloc(
+			  sizeof(struct set_stakey_rsp));
+	if (psetstakey_rsp == NULL) {
+		kfree((u8 *) ph2c);
+		kfree((u8 *) psetstakey_para);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+	ph2c->rsp = (u8 *) psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+	memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		psetstakey_para->algorithm = (unsigned char)
+					    psecuritypriv->PrivacyAlgrthm;
+	else
+		GET_ENCRY_ALGO(psecuritypriv, sta,
+			       psetstakey_para->algorithm, false);
+	if (unicast_key == true)
+		memcpy(&psetstakey_para->key, &sta->x_UncstKey, 16);
+	else
+		memcpy(&psetstakey_para->key,
+			&psecuritypriv->XGrpKey[
+			psecuritypriv->XGrpKeyid - 1]. skey, 16);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrfintfs_cmd(struct _adapter *padapter, u8 mode)
+{
+	struct cmd_obj *ph2c;
+	struct setrfintfs_parm *psetrfintfsparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetrfintfsparm = (struct setrfintfs_parm *)_malloc(
+			   sizeof(struct setrfintfs_parm));
+	if (psetrfintfsparm == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrfintfsparm,
+				   GEN_CMD_CODE(_SetRFIntFs));
+	psetrfintfsparm->rfintfs = mode;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setrttbl_cmd(struct _adapter *padapter,
+		      struct setratable_parm *prate_table)
+{
+	struct cmd_obj *ph2c;
+	struct setratable_parm *psetrttblparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetrttblparm = (struct setratable_parm *)_malloc(
+			sizeof(struct setratable_parm));
+	if (psetrttblparm == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm,
+				   GEN_CMD_CODE(_SetRaTable));
+	memcpy(psetrttblparm, prate_table, sizeof(struct setratable_parm));
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_gettssi_cmd(struct _adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct readTSSI_parm *prdtssiparm;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	prdtssiparm = (struct readTSSI_parm *)
+		_malloc(sizeof(struct readTSSI_parm));
+	if (prdtssiparm == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	_init_listhead(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_ReadTSSI);
+	ph2c->parmbuf = (unsigned char *)prdtssiparm;
+	ph2c->cmdsz = sizeof(struct readTSSI_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readTSSI_rsp);
+
+	prdtssiparm->offset = offset;
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setMacAddr_cmd(struct _adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct SetMacAddr_param	*psetMacAddr_para;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetMacAddr_para = (struct SetMacAddr_param *)_malloc(
+			   sizeof(struct SetMacAddr_param));
+	if (psetMacAddr_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetMacAddr_para,
+				   _SetMacAddress_CMD_);
+	memcpy(psetMacAddr_para->MacAddr, mac_addr, ETH_ALEN);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_setassocsta_cmd(struct _adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv			*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj			*ph2c;
+	struct set_assocsta_parm	*psetassocsta_para;
+	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	psetassocsta_para = (struct set_assocsta_parm *)
+			    _malloc(sizeof(struct set_assocsta_parm));
+	if (psetassocsta_para == NULL) {
+		kfree((u8 *) ph2c);
+		return _FAIL;
+	}
+	psetassocsta_rsp = (struct set_stakey_rsp *)_malloc(
+			    sizeof(struct set_assocsta_rsp));
+	if (psetassocsta_rsp == NULL) {
+		kfree((u8 *)ph2c);
+		kfree((u8 *)psetassocsta_para);
+		return _FAIL;
+	}
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
+	ph2c->rsp = (u8 *) psetassocsta_rsp;
+	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+	memcpy(psetassocsta_para->addr, mac_addr, ETH_ALEN);
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_addbareq_cmd(struct _adapter *padapter, u8 tid)
+{
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj		*ph2c;
+	struct addBaReq_parm	*paddbareq_parm;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	paddbareq_parm = (struct addBaReq_parm *)_malloc(
+			  sizeof(struct addBaReq_parm));
+	if (paddbareq_parm == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	paddbareq_parm->tid = tid;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm,
+				   GEN_CMD_CODE(_AddBAReq));
+	r8712_enqueue_cmd_ex(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+u8 r8712_wdg_wk_cmd(struct _adapter *padapter)
+{
+	struct cmd_obj *ph2c;
+	struct drvint_cmd_parm  *pdrvintcmd_param;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	pdrvintcmd_param = (struct drvint_cmd_parm *)_malloc(
+			   sizeof(struct drvint_cmd_parm));
+	if (pdrvintcmd_param == NULL) {
+		kfree((unsigned char *)ph2c);
+		return _FAIL;
+	}
+	pdrvintcmd_param->i_cid = WDG_WK_CID;
+	pdrvintcmd_param->sz = 0;
+	pdrvintcmd_param->pbuf = NULL;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvintcmd_param, _DRV_INT_CMD_);
+	r8712_enqueue_cmd_ex(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
+
+void r8712_survey_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res != H2C_SUCCESS)
+		clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_disassoc_cmd_callback(struct _adapter *padapter,
+				 struct cmd_obj *pcmd)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res != H2C_SUCCESS) {
+		spin_lock_irqsave(&pmlmepriv->lock, irqL);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+		return;
+	}
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_joinbss_cmd_callback(struct _adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if ((pcmd->res != H2C_SUCCESS))
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_createbss_cmd_callback(struct _adapter *padapter,
+				  struct cmd_obj *pcmd)
+{
+	unsigned long irqL;
+	u8 timer_cancelled;
+	struct sta_info *psta = NULL;
+	struct wlan_network *pwlan = NULL;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pnetwork = (struct ndis_wlan_bssid_ex *)
+					      pcmd->parmbuf;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+	if ((pcmd->res != H2C_SUCCESS))
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->
+					Configuration.ATIMWindow);
+	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->
+					Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->
+					Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->
+					Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->
+					   InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((pmlmepriv->fw_state) & WIFI_AP_STATE) {
+		psta = r8712_get_stainfo(&padapter->stapriv,
+					 pnetwork->MacAddress);
+		if (!psta) {
+			psta = r8712_alloc_stainfo(&padapter->stapriv,
+						   pnetwork->MacAddress);
+			if (psta == NULL)
+				goto createbss_cmd_fail ;
+		}
+		r8712_indicate_connect(padapter);
+	} else {
+		pwlan = _r8712_alloc_network(pmlmepriv);
+		if (pwlan == NULL) {
+			pwlan = r8712_get_oldest_wlan_network(
+				&pmlmepriv->scanned_queue);
+			if (pwlan == NULL)
+				goto createbss_cmd_fail;
+			pwlan->last_scanned = jiffies;
+		} else
+			list_insert_tail(&(pwlan->list),
+					 &pmlmepriv->scanned_queue.queue);
+		pnetwork->Length = r8712_get_ndis_wlan_bssid_ex_sz(pnetwork);
+		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+		pwlan->fixed = true;
+		memcpy(&tgt_network->network, pnetwork,
+			(r8712_get_ndis_wlan_bssid_ex_sz(pnetwork)));
+		if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+			pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+		/* we will set _FW_LINKED when there is one more sat to
+		 * join us (stassoc_event_callback) */
+	}
+createbss_cmd_fail:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_setstaKey_cmdrsp_callback(struct _adapter *padapter,
+				     struct cmd_obj *pcmd)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)
+						(pcmd->rsp);
+	struct sta_info *psta = r8712_get_stainfo(pstapriv,
+						  psetstakey_rsp->addr);
+
+	if (psta == NULL)
+		goto exit;
+	psta->aid = psta->mac_id = psetstakey_rsp->keyid; /*CAM_ID(CAM_ENTRY)*/
+exit:
+	r8712_free_cmd_obj(pcmd);
+}
+
+void r8712_setassocsta_cmdrsp_callback(struct _adapter *padapter,
+				       struct cmd_obj *pcmd)
+{
+	unsigned long	irqL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct set_assocsta_parm *passocsta_parm =
+				(struct set_assocsta_parm *)(pcmd->parmbuf);
+	struct set_assocsta_rsp *passocsta_rsp =
+				(struct set_assocsta_rsp *) (pcmd->rsp);
+	struct sta_info *psta = r8712_get_stainfo(pstapriv,
+						  passocsta_parm->addr);
+
+	if (psta == NULL)
+		return;
+	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE)) &&
+	    (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)))
+		pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	r8712_free_cmd_obj(pcmd);
+}
+
+u8 r8712_disconnectCtrlEx_cmd(struct _adapter *adapter, u32 enableDrvCtrl,
+			u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO)
+{
+	struct cmd_obj *ph2c;
+	struct DisconnectCtrlEx_param *param;
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+
+	ph2c = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+	param = (struct DisconnectCtrlEx_param *)
+		_malloc(sizeof(struct DisconnectCtrlEx_param));
+	if (param == NULL) {
+		kfree((unsigned char *) ph2c);
+		return _FAIL;
+	}
+	memset(param, 0, sizeof(struct DisconnectCtrlEx_param));
+
+	param->EnableDrvCtrl = (unsigned char)enableDrvCtrl;
+	param->TryPktCnt = (unsigned char)tryPktCnt;
+	param->TryPktInterval = (unsigned char)tryPktInterval;
+	param->FirstStageTO = (unsigned int)firstStageTO;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, param,
+				GEN_CMD_CODE(_DisconnectCtrlEx));
+	r8712_enqueue_cmd(pcmdpriv, ph2c);
+	return _SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_cmd.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_cmd.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_cmd.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,790 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_CMD_H_
+#define __RTL871X_CMD_H_
+
+#include "wlan_bssdef.h"
+#include "rtl871x_rf.h"
+#define C2H_MEM_SZ (16*1024)
+
+#include "osdep_service.h"
+#include "ieee80211.h"
+
+#define FREE_CMDOBJ_SZ	128
+#define MAX_CMDSZ	512
+#define MAX_RSPSZ	512
+#define MAX_EVTSZ	1024
+#define CMDBUFF_ALIGN_SZ 512
+
+struct cmd_obj {
+	u16	cmdcode;
+	u8	res;
+	u8	*parmbuf;
+	u32	cmdsz;
+	u8	*rsp;
+	u32	rspsz;
+	struct list_head list;
+};
+
+struct cmd_priv {
+	struct semaphore cmd_queue_sema;
+	struct semaphore terminate_cmdthread_sema;
+	struct  __queue	cmd_queue;
+	u8 cmd_seq;
+	u8 *cmd_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8 *cmd_allocated_buf;
+	u8 *rsp_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8 *rsp_allocated_buf;
+	u32 cmd_issued_cnt;
+	u32 cmd_done_cnt;
+	u32 rsp_cnt;
+	struct _adapter *padapter;
+};
+
+struct evt_obj {
+	u16 evtcode;
+	u8 res;
+	u8 *parmbuf;
+	u32 evtsz;
+	struct list_head list;
+};
+
+struct	evt_priv {
+	struct  __queue	evt_queue;
+	u8	event_seq;
+	u8	*evt_buf;	/*shall be non-paged, and 4 bytes aligned*/
+	u8	*evt_allocated_buf;
+	u32	evt_done_cnt;
+	struct tasklet_struct event_tasklet;
+};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	_init_listhead(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof(*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while (0)
+
+u32 r8712_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+u32 r8712_enqueue_cmd_ex(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+struct cmd_obj *r8712_dequeue_cmd(struct  __queue *queue);
+void r8712_free_cmd_obj(struct cmd_obj *pcmd);
+int r8712_cmd_thread(void *context);
+u32 r8712_init_cmd_priv(struct cmd_priv *pcmdpriv);
+void r8712_free_cmd_priv(struct cmd_priv *pcmdpriv);
+u32 r8712_init_evt_priv(struct evt_priv *pevtpriv);
+void r8712_free_evt_priv(struct evt_priv *pevtpriv);
+
+enum rtl871x_drvint_cid {
+	NONE_WK_CID,
+	WDG_WK_CID,
+	MAX_WK_CID
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+ * Caller Mode: Infra, Ad-HoC(C)
+ * Notes: To enter USB suspend mode
+ * Command Mode
+ */
+struct usb_suspend_parm {
+	u32 action; /* 1: sleep, 0:resume */
+};
+
+/*
+ * Caller Mode: Infra, Ad-Hoc
+ * Notes: To join the specified bss
+ * Command Event Mode
+ */
+struct joinbss_parm {
+	struct ndis_wlan_bssid_ex network;
+};
+
+/*
+ * Caller Mode: Infra, Ad-HoC(C)
+ * Notes: To disconnect the current associated BSS
+ * Command Mode
+ */
+struct disconnect_parm {
+	u32 rsvd;
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC(M)
+ * Notes: To create a BSS
+ * Command Mode
+ */
+struct createbss_parm {
+	struct ndis_wlan_bssid_ex network;
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC, Infra
+ * Notes: To set the NIC mode of RTL8711
+ * Command Mode
+ * The definition of mode:
+ *
+ * #define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+ * #define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+ * #define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+ * #define IW_MODE_MASTER	3	// Synchronisation master or AP
+ * #define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+ * #define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+ * #define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+*/
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+ * Caller Mode: AP, Ad-HoC, Infra
+ * Notes: To ask RTL8711 performing site-survey
+ * Command-Event Mode
+ */
+struct sitesurvey_parm {
+	sint passive_mode;	/*active: 1, passive: 0 */
+	sint bsslimit;	/* 1 ~ 48 */
+	sint	ss_ssidlen;
+	u8	ss_ssid[IW_ESSID_MAX_SIZE + 1];
+};
+
+/*
+ * Caller Mode: Any
+ * Notes: To set the auth type of RTL8711. open/shared/802.1x
+ * Command Mode
+ */
+struct setauth_parm {
+	u8 mode;  /*0: legacy open, 1: legacy shared 2: 802.1x*/
+	u8 _1x;   /*0: PSK, 1: TLS*/
+	u8 rsvd[2];
+};
+
+/*
+ * Caller Mode: Infra
+ * a. algorithm: wep40, wep104, tkip & aes
+ * b. keytype: grp key/unicast key
+ * c. key contents
+ *
+ * when shared key ==> keyid is the camid
+ * when 802.1x ==> keyid [0:1] ==> grp key
+ * when 802.1x ==> keyid > 2 ==> unicast key
+ */
+struct setkey_parm {
+	u8	algorithm;	/* encryption algorithm, could be none, wep40,
+				 * TKIP, CCMP, wep104 */
+	u8	keyid;
+	u8	grpkey;		/* 1: this is the grpkey for 802.1x.
+				 * 0: this is the unicast key for 802.1x */
+	u8	key[16];	/* this could be 40 or 104 */
+};
+
+/*
+ * When in AP or Ad-Hoc mode, this is used to
+ * allocate an sw/hw entry for a newly associated sta.
+ * Command
+ * when shared key ==> algorithm/keyid
+ */
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+struct SetMacAddr_param {
+	u8	MacAddr[ETH_ALEN];
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+
+	Command mode
+
+	This is to force fw to del an sta_data entry per driver's request
+
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+	u8	mac_id;
+	u8	datarates[NumRates];
+};
+
+enum _RT_CHANNEL_DOMAIN {
+	RT_CHANNEL_DOMAIN_FCC = 0,
+	RT_CHANNEL_DOMAIN_IC = 1,
+	RT_CHANNEL_DOMAIN_ETSI = 2,
+	RT_CHANNEL_DOMAIN_SPAIN = 3,
+	RT_CHANNEL_DOMAIN_FRANCE = 4,
+	RT_CHANNEL_DOMAIN_MKK = 5,
+	RT_CHANNEL_DOMAIN_MKK1 = 6,
+	RT_CHANNEL_DOMAIN_ISRAEL = 7,
+	RT_CHANNEL_DOMAIN_TELEC = 8,
+
+	/* Be compatible with old channel plan. No good! */
+	RT_CHANNEL_DOMAIN_MIC = 9,
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 10,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 11,
+	RT_CHANNEL_DOMAIN_TELEC_NETGEAR = 12,
+
+	RT_CHANNEL_DOMAIN_NCC = 13,
+	RT_CHANNEL_DOMAIN_5G = 14,
+	RT_CHANNEL_DOMAIN_5G_40M = 15,
+ /*===== Add new channel plan above this line===============*/
+	RT_CHANNEL_DOMAIN_MAX,
+};
+
+
+struct SetChannelPlan_param {
+	enum _RT_CHANNEL_DOMAIN ChannelPlan;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct writePTM_parm {
+	u8	type;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct setrfintfs_parm {
+	u8	rfintfs;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=	swap32(w1);
+		b0		=	b1
+		s2		=	s0 + s1
+		b1		=	b0
+		w1		=	w0
+
+	mac[0] ==	2
+	==> CMD_EVENT mode, return	H2C_SUCCESS
+	The event layout shall be:
+	event:	     parm:
+	mac[0]  =   mac[5];
+	mac[1]  =   mac[4];
+	mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+	mac[3]  =   mac[2];
+	mac[4]  =   mac[1];
+	mac[5]  =   mac[0];
+	s0		=   swap16(s0) - event.mac[2];
+	s1		=   s1 + event.mac[2];
+	w0		=	swap32(w0);
+	b0		=	b1
+	s2		=	s0 + event.mac[2]
+	b1		=	b0
+	w1		=	swap32(w1) - event.mac[2];
+
+	parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+/* CMD param Formart for DRV INTERNAL CMD HDL*/
+struct drvint_cmd_parm {
+	int i_cid; /*internal cmd id*/
+	int sz; /* buf sz*/
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;
+	u8	rx_antset;
+	u8	tx_antenna;
+	u8	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;	/* 0: pure hw, 1: fw */
+};
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct setpwrmode_parm  {
+	u8	mode;
+	u8	flag_low_traffic_en;
+	u8	flag_lpnav_en;
+	u8	flag_rf_low_snr_en;
+	u8	flag_dps_en; /* 1: dps, 0: 32k */
+	u8	bcn_rx_en;
+	u8	bcn_pass_cnt;	  /* fw report one beacon information to
+				   * driver  when it receives bcn_pass_cnt
+				   *  beacons. */
+	u8	bcn_to;		  /* beacon TO (ms). Â¡Â§=0Â¡Â¨ no limit.*/
+	u16	bcn_itv;
+	u8	app_itv; /* only for VOIP mode. */
+	u8	awake_bcn_itv;
+	u8	smart_ps;
+	u8	bcn_pass_time;	/* unit: 100ms */
+};
+
+struct setatim_parm {
+	u8 op;   /*0: add, 1:del*/
+	u8 txid; /* id of dest station.*/
+};
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+	uint rsvd;
+};
+struct getratable_rsp {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+/*to get TX,RX retry count*/
+struct gettxretrycnt_parm {
+	unsigned int rsvd;
+};
+
+struct gettxretrycnt_rsp {
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm {
+	unsigned int rsvd;
+};
+
+struct getrxretrycnt_rsp {
+	unsigned long rx_retrycnt;
+};
+
+/*to get BCNOK,BCNERR count*/
+struct getbcnokcnt_parm {
+	unsigned int rsvd;
+};
+
+struct getbcnokcnt_rsp {
+	unsigned long bcnokcnt;
+};
+
+struct getbcnerrcnt_parm {
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp {
+	unsigned long bcnerrcnt;
+};
+
+/* to get current TX power level*/
+struct getcurtxpwrlevel_parm {
+	unsigned int rsvd;
+};
+
+struct getcurtxpwrlevel_rsp {
+	unsigned short tx_power;
+};
+
+/*dynamic on/off DIG*/
+struct setdig_parm {
+	unsigned char dig_on;	/* 1:on , 0:off */
+};
+
+/*dynamic on/off RA*/
+struct setra_parm {
+	unsigned char ra_on;	/* 1:on , 0:off */
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct addBaReq_parm {
+	unsigned int tid;
+};
+
+/*H2C Handler index: 46 */
+struct SetChannel_parm {
+	u32 curr_ch;
+};
+
+/*H2C Handler index: 61 */
+struct DisconnectCtrlEx_param {
+	/* MAXTIME = (2 * FirstStageTO) + (TryPktCnt * TryPktInterval) */
+	unsigned char EnableDrvCtrl;
+	unsigned char TryPktCnt;
+	unsigned char TryPktInterval; /* Unit: ms */
+	unsigned char rsvd;
+	unsigned int  FirstStageTO; /* Unit: ms */
+};
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+/*
+ * Result:
+ * 0x00: success
+ * 0x01: success, and check Response.
+ * 0x02: cmd ignored due to duplicated sequcne number
+ * 0x03: cmd dropped due to invalid cmd code
+ * 0x04: reserved.
+ */
+
+#define H2C_RSP_OFFSET			512
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+u8 r8712_setMacAddr_cmd(struct _adapter *padapter, u8 *mac_addr);
+u8 r8712_setassocsta_cmd(struct _adapter *padapter, u8 *mac_addr);
+u8 r8712_sitesurvey_cmd(struct _adapter *padapter,
+			struct ndis_802_11_ssid *pssid);
+u8 r8712_createbss_cmd(struct _adapter *padapter);
+u8 r8712_setstakey_cmd(struct _adapter *padapter, u8 *psta, u8 unicast_key);
+u8 r8712_joinbss_cmd(struct _adapter *padapter,
+		     struct wlan_network *pnetwork);
+u8 r8712_disassoc_cmd(struct _adapter *padapter);
+u8 r8712_setopmode_cmd(struct _adapter *padapter,
+		 enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 r8712_setdatarate_cmd(struct _adapter *padapter, u8 *rateset);
+u8 r8712_set_chplan_cmd(struct _adapter  *padapter, int chplan);
+u8 r8712_setbasicrate_cmd(struct _adapter *padapter, u8 *rateset);
+u8 r8712_getrfreg_cmd(struct _adapter *padapter, u8 offset, u8 * pval);
+u8 r8712_setrfintfs_cmd(struct _adapter *padapter, u8 mode);
+u8 r8712_setrfreg_cmd(struct _adapter  *padapter, u8 offset, u32 val);
+u8 r8712_setrttbl_cmd(struct _adapter  *padapter,
+		      struct setratable_parm *prate_table);
+u8 r8712_gettssi_cmd(struct _adapter  *padapter, u8 offset, u8 *pval);
+u8 r8712_setptm_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_setfwdig_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_setfwra_cmd(struct _adapter *padapter, u8 type);
+u8 r8712_addbareq_cmd(struct _adapter *padapter, u8 tid);
+u8 r8712_wdg_wk_cmd(struct _adapter *padapter);
+void r8712_survey_cmd_callback(struct _adapter  *padapter,
+			       struct cmd_obj *pcmd);
+void r8712_disassoc_cmd_callback(struct _adapter  *padapter,
+				 struct cmd_obj *pcmd);
+void r8712_joinbss_cmd_callback(struct _adapter  *padapter,
+				struct cmd_obj *pcmd);
+void r8712_createbss_cmd_callback(struct _adapter *padapter,
+				  struct cmd_obj *pcmd);
+void r8712_getbbrfreg_cmdrsp_callback(struct _adapter *padapter,
+				      struct cmd_obj *pcmd);
+void r8712_readtssi_cmdrsp_callback(struct _adapter *padapter,
+				struct cmd_obj *pcmd);
+void r8712_setstaKey_cmdrsp_callback(struct _adapter  *padapter,
+				     struct cmd_obj *pcmd);
+void r8712_setassocsta_cmdrsp_callback(struct _adapter  *padapter,
+				       struct cmd_obj *pcmd);
+u8 r8712_disconnectCtrlEx_cmd(struct _adapter *adapter, u32 enableDrvCtrl,
+			u32 tryPktCnt, u32 tryPktInterval, u32 firstStageTO);
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(struct _adapter  *padapter, struct cmd_obj *cmd);
+};
+
+#include "rtl8712_cmd.h"
+
+#endif /* _CMD_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_debug.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_debug.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_debug.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,167 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_DEBUG_H__
+#define __RTL871X_DEBUG_H__
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#define _drv_emerg_			1
+#define _drv_alert_			2
+#define _drv_crit_			3
+#define _drv_err_			4
+#define	_drv_warning_			5
+#define _drv_notice_			6
+#define _drv_info_			7
+#define _drv_dump_			8
+#define	_drv_debug_			9
+
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define	_module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_	BIT(6)
+#define _module_rtl871x_cmd_c_		BIT(7)
+#define	_module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_		BIT(9)
+#define	_module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_		BIT(11)
+#define _module_rtl871x_security_c_	BIT(12)
+#define _module_rtl871x_eeprom_c_	BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_	BIT(16)
+#define _module_rtl871x_ioctl_set_c_	BIT(17)
+#define _module_rtl871x_pwrctrl_c_	BIT(19)
+#define _module_hci_intfs_c_		BIT(20)
+#define _module_hci_ops_c_		BIT(21)
+#define _module_osdep_service_c_	BIT(22)
+#define _module_rtl871x_mp_ioctl_c_	BIT(23)
+#define _module_hci_ops_os_c_		BIT(24)
+#define _module_rtl871x_ioctl_os_c	BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+#define _module_rtl871x_mp_c_		BIT(27)
+#define _module_rtl8712_xmit_c_		BIT(28)
+#define _module_rtl8712_efuse_c_	BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTL871X_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_
+#elif defined _RTL871X_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_
+#elif defined _RTL871X_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTL871X_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTL871X_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTL871X_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTL871X_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_
+#elif defined _RTL871X_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
+#elif defined _HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_
+#elif defined _HCI_HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_
+#elif defined _RTL871X_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_ioctl_c_
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c
+#elif defined _RTL871X_MP_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_mp_c_
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_
+#elif defined _RTL8712_XMIT_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_xmit_c_
+#elif defined _RTL8712_EFUSE_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_efuse_c_
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#else
+	#undef	_MODULE_DEFINE_
+#endif
+
+#define _dbgdump	printk
+
+#define MSG_8712(x, ...) {}
+
+#define DBG_8712(x, ...)  {}
+
+#define WRN_8712(x, ...)  {}
+
+#define ERR_8712(x, ...)  {}
+
+#undef MSG_8712
+#define MSG_8712 _dbgdump
+
+#undef DBG_8712
+#define DBG_8712 _dbgdump
+
+#undef WRN_8712
+#define WRN_8712 _dbgdump
+
+#undef ERR_8712
+#define ERR_8712 _dbgdump
+
+#endif	/*__RTL871X_DEBUG_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_eeprom.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_eeprom.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_eeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_eeprom.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,233 @@
+/******************************************************************************
+ * rtl871x_eeprom.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_EEPROM_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+static void up_clk(struct _adapter *padapter, u16 *x)
+{
+	*x = *x | _EESK;
+	r8712_write8(padapter, EE_9346CR, (u8)*x);
+	udelay(CLOCK_RATE);
+}
+
+static void down_clk(struct _adapter *padapter, u16 *x)
+{
+	*x = *x & ~_EESK;
+	r8712_write8(padapter, EE_9346CR, (u8)*x);
+	udelay(CLOCK_RATE);
+}
+
+static void shift_out_bits(struct _adapter *padapter, u16 data, u16 count)
+{
+	u16 x, mask;
+
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	mask = 0x01 << (count - 1);
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDO | _EEDI);
+	do {
+		x &= ~_EEDI;
+		if (data & mask)
+			x |= _EEDI;
+		if (padapter->bSurpriseRemoved == true)
+			goto out;
+		r8712_write8(padapter, EE_9346CR, (u8)x);
+		udelay(CLOCK_RATE);
+		up_clk(padapter, &x);
+		down_clk(padapter, &x);
+		mask = mask >> 1;
+	} while (mask);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x &= ~_EEDI;
+	r8712_write8(padapter, EE_9346CR, (u8)x);
+out:;
+}
+
+static u16 shift_in_bits(struct _adapter *padapter)
+{
+	u16 x, d = 0, i;
+
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDO | _EEDI);
+	d = 0;
+	for (i = 0; i < 16; i++) {
+		d = d << 1;
+		up_clk(padapter, &x);
+		if (padapter->bSurpriseRemoved == true)
+			goto out;
+		x = r8712_read8(padapter, EE_9346CR);
+		x &= ~(_EEDI);
+		if (x & _EEDO)
+			d |= 1;
+		down_clk(padapter, &x);
+	}
+out:
+	return d;
+}
+
+static void standby(struct _adapter *padapter)
+{
+	u8   x;
+
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EECS | _EESK);
+	r8712_write8(padapter, EE_9346CR, x);
+	udelay(CLOCK_RATE);
+	x |= _EECS;
+	r8712_write8(padapter, EE_9346CR, x);
+	udelay(CLOCK_RATE);
+}
+
+static u16 wait_eeprom_cmd_done(struct _adapter *padapter)
+{
+	u8	x;
+	u16	i;
+
+	standby(padapter);
+	for (i = 0; i < 200; i++) {
+		x = r8712_read8(padapter, EE_9346CR);
+		if (x & _EEDO)
+			return true;
+		udelay(CLOCK_RATE);
+	}
+	return false;
+}
+
+static void eeprom_clean(struct _adapter *padapter)
+{
+	u16 x;
+
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	x = r8712_read8(padapter, EE_9346CR);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	x &= ~(_EECS | _EEDI);
+	r8712_write8(padapter, EE_9346CR, (u8)x);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	up_clk(padapter, &x);
+	if (padapter->bSurpriseRemoved == true)
+		return;
+	down_clk(padapter, &x);
+}
+
+void r8712_eeprom_write16(struct _adapter *padapter, u16 reg, u16 data)
+{
+	u8 x;
+	u8 tmp8_ori, tmp8_new, tmp8_clk_ori, tmp8_clk_new;
+
+	tmp8_ori = r8712_read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if (tmp8_ori != tmp8_new)
+		r8712_write8(padapter, 0x102502f1, tmp8_new);
+	tmp8_clk_ori = r8712_read8(padapter, 0x10250003);
+	tmp8_clk_new = tmp8_clk_ori | 0x20;
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_new);
+	x = r8712_read8(padapter, EE_9346CR);
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	r8712_write8(padapter, EE_9346CR, x);
+	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
+	if (padapter->EepromAddressSize == 8)	/*CF+ and SDIO*/
+		shift_out_bits(padapter, 0, 6);
+	else	/* USB */
+		shift_out_bits(padapter, 0, 4);
+	standby(padapter);
+	/* Erase this particular word.  Write the erase opcode and register
+	 * number in that order. The opcode is 3bits in length; reg is 6
+	 * bits long.
+	 */
+	standby(padapter);
+	/* write the new word to the EEPROM
+	 * send the write opcode the EEPORM
+	 */
+	shift_out_bits(padapter, EEPROM_WRITE_OPCODE, 3);
+	/* select which word in the EEPROM that we are writing to. */
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+	/* write the data to the selected EEPROM word. */
+	shift_out_bits(padapter, data, 16);
+	if (wait_eeprom_cmd_done(padapter)) {
+		standby(padapter);
+		shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
+		shift_out_bits(padapter, reg, 4);
+		eeprom_clean(padapter);
+	}
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if (tmp8_new != tmp8_ori)
+		r8712_write8(padapter, 0x102502f1, tmp8_ori);
+}
+
+u16 r8712_eeprom_read16(struct _adapter *padapter, u16 reg) /*ReadEEprom*/
+{
+	u16 x;
+	u16 data = 0;
+	u8 tmp8_ori, tmp8_new, tmp8_clk_ori, tmp8_clk_new;
+
+	tmp8_ori = r8712_read8(padapter, 0x102502f1);
+	tmp8_new = tmp8_ori & 0xf7;
+	if (tmp8_ori != tmp8_new)
+		r8712_write8(padapter, 0x102502f1, tmp8_new);
+	tmp8_clk_ori = r8712_read8(padapter, 0x10250003);
+	tmp8_clk_new = tmp8_clk_ori | 0x20;
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_new);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	/* select EEPROM, reset bits, set _EECS */
+	x = r8712_read8(padapter, EE_9346CR);
+	if (padapter->bSurpriseRemoved == true)
+		goto out;
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	r8712_write8(padapter, EE_9346CR, (unsigned char)x);
+	/* write the read opcode and register number in that order
+	 * The opcode is 3bits in length, reg is 6 bits long
+	 */
+	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
+	/* Now read the data (16 bits) in from the selected EEPROM word */
+	data = shift_in_bits(padapter);
+	eeprom_clean(padapter);
+out:
+	if (tmp8_clk_new != tmp8_clk_ori)
+		r8712_write8(padapter, 0x10250003, tmp8_clk_ori);
+	if (tmp8_new != tmp8_ori)
+		r8712_write8(padapter, 0x102502f1, tmp8_ori);
+	return data;
+}
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_eeprom.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_eeprom.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_eeprom.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_eeprom.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,101 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_EEPROM_H__
+#define __RTL871X_EEPROM_H__
+
+#include "osdep_service.h"
+
+#define	RTL8712_EEPROM_ID		0x8712
+#define	EEPROM_MAX_SIZE			256
+#define	CLOCK_RATE			50	/*100us*/
+
+/*- EEPROM opcodes*/
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      /* Erase/write enable*/
+#define EEPROM_EWDS_OPCODE		16      /* Erase/write disable*/
+
+#define	EEPROM_CID_DEFAULT		0x0
+#define	EEPROM_CID_ALPHA		0x1
+#define	EEPROM_CID_Senao		0x3
+#define	EEPROM_CID_NetCore		0x5
+#define	EEPROM_CID_CAMEO		0X8
+#define	EEPROM_CID_SITECOM		0x9
+#define	EEPROM_CID_COREGA		0xB
+#define	EEPROM_CID_EDIMAX_BELKIN	0xC
+#define	EEPROM_CID_SERCOMM_BELKIN	0xE
+#define	EEPROM_CID_CAMEO1		0xF
+#define	EEPROM_CID_WNC_COREGA		0x12
+#define	EEPROM_CID_CLEVO		0x13
+#define	EEPROM_CID_WHQL			0xFE
+
+enum RT_CUSTOMER_ID {
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_819x_ALPHA = 15,
+	RT_CID_819x_Sitecom = 16,
+	RT_CID_CCX = 17,
+	RT_CID_819x_Lenovo = 18,
+	RT_CID_819x_QMI = 19,
+	RT_CID_819x_Edimax_Belkin = 20,
+	RT_CID_819x_Sercomm_Belkin = 21,
+	RT_CID_819x_CAMEO1 = 22,
+	RT_CID_819x_MSI = 23,
+	RT_CID_819x_Acer = 24,
+	RT_CID_819x_AzWave_ASUS = 25,
+	RT_CID_819x_AzWave = 26,
+	RT_CID_819x_WNC_COREGA = 27,
+	RT_CID_819x_CLEVO = 28,
+};
+
+struct eeprom_priv {
+	u8 bautoload_fail_flag;
+	u8 bempty;
+	u8 sys_config;
+	u8 mac_addr[6];
+	u8 config0;
+	u16 channel_plan;
+	u8 country_string[3];
+	u8 tx_power_b[15];
+	u8 tx_power_g[15];
+	u8 tx_power_a[201];
+	u8 efuse_eeprom_data[EEPROM_MAX_SIZE];
+	enum RT_CUSTOMER_ID CustomerID;
+};
+
+void r8712_eeprom_write16(struct _adapter *padapter, u16 reg, u16 data);
+u16 r8712_eeprom_read16(struct _adapter *padapter, u16 reg);
+
+#endif  /*__RTL871X_EEPROM_H__*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_event.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_event.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_event.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_event.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871x_EVENT_H_
+#define _RTL871x_EVENT_H_
+
+#include "osdep_service.h"
+
+#include "wlan_bssdef.h"
+#include <linux/semaphore.h>
+#include <linux/sem.h>
+
+/*
+ * Used to report a bss has been scanned
+*/
+struct survey_event	{
+	struct ndis_wlan_bssid_ex bss;
+};
+
+/*
+ * Used to report that the requested site survey has been done.
+ * bss_cnt indicates the number of bss that has been reported.
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+ * Used to report the link result of joinning the given bss
+ * join_res:
+ *  -1: authentication fail
+ *  -2: association fail
+ *  > 0: TID
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+ * Used to report a given STA has joinned the created BSS.
+ * It is used in AP/Ad-HoC(M) mode.
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+};
+
+struct stadel_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+};
+
+struct addba_event {
+	unsigned int tid;
+};
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(struct _adapter *dev, u8 *pbuf);
+};
+
+#define C2HEVENT_SZ			32
+struct event_node {
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	/*volatile*/ int *caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	/*volatile*/ int	head;
+	/*volatile*/ int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	/*volatile*/ int	head;
+	/*volatile*/ int	tail;
+	struct wlan_bssid_ex networks[NETWORK_QUEUE_SZ];
+};
+
+struct ADDBA_Req_Report_parm {
+	unsigned char MacAddress[ETH_ALEN];
+	unsigned short StartSeqNum;
+	unsigned char tid;
+};
+#include "rtl8712_event.h"
+
+#endif /* _WLANEVENT_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ht.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ht.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ht.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ht.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,44 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_HT_H_
+#define _RTL871X_HT_H_
+
+#include "osdep_service.h"
+#include "wifi.h"
+
+struct ht_priv {
+	unsigned int	ht_option;
+	unsigned int	ampdu_enable;/*for enable Tx A-MPDU*/
+	unsigned char	baddbareq_issued[16];
+	unsigned int	tx_amsdu_enable;/*for enable Tx A-MSDU */
+	unsigned int	tx_amdsu_maxlen; /* 1: 8k, 0:4k ; default:8k, for tx */
+	unsigned int	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz,
+					  *  updated when join_callback. */
+	struct ieee80211_ht_cap ht_cap;
+};
+
+#endif	/*_RTL871X_HT_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_io.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_io.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_io.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_io.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,161 @@
+/******************************************************************************
+ * rtl871x_io.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+/*
+ *
+ * The purpose of rtl871x_io.c
+ *
+ * a. provides the API
+ * b. provides the protocol engine
+ * c. provides the software interface between caller and the hardware interface
+ *
+ * For r8712u, both sync/async operations are provided.
+ *
+ * Only sync read/write_mem operations are provided.
+ *
+ */
+
+#define _RTL871X_IO_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_io.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+static uint _init_intf_hdl(struct _adapter *padapter,
+			   struct intf_hdl *pintf_hdl)
+{
+	struct	intf_priv	*pintf_priv;
+	void (*set_intf_option)(u32 *poption) = NULL;
+	void (*set_intf_funs)(struct intf_hdl *pintf_hdl);
+	void (*set_intf_ops)(struct _io_ops	*pops);
+	uint (*init_intf_priv)(struct intf_priv *pintfpriv);
+
+	set_intf_option = &(r8712_usb_set_intf_option);
+	set_intf_funs = &(r8712_usb_set_intf_funs);
+	set_intf_ops = &r8712_usb_set_intf_ops;
+	init_intf_priv = &r8712_usb_init_intf_priv;
+	pintf_priv = pintf_hdl->pintfpriv = (struct intf_priv *)
+		     _malloc(sizeof(struct intf_priv));
+	if (pintf_priv == NULL)
+		goto _init_intf_hdl_fail;
+	pintf_hdl->adapter = (u8 *)padapter;
+	set_intf_option(&pintf_hdl->intf_option);
+	set_intf_funs(pintf_hdl);
+	set_intf_ops(&pintf_hdl->io_ops);
+	pintf_priv->intf_dev = (u8 *)&(padapter->dvobjpriv);
+	if (init_intf_priv(pintf_priv) == _FAIL)
+		goto _init_intf_hdl_fail;
+	return _SUCCESS;
+_init_intf_hdl_fail:
+	kfree(pintf_priv);
+	return _FAIL;
+}
+
+static void _unload_intf_hdl(struct intf_priv *pintfpriv)
+{
+	void (*unload_intf_priv)(struct intf_priv *pintfpriv);
+
+	unload_intf_priv = &r8712_usb_unload_intf_priv;
+	unload_intf_priv(pintfpriv);
+	kfree(pintfpriv);
+}
+
+static uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl)
+{
+	struct _adapter *adapter = (struct _adapter *)dev;
+
+	pintfhdl->intf_option = 0;
+	pintfhdl->adapter = dev;
+	pintfhdl->intf_dev = (u8 *)&(adapter->dvobjpriv);
+	if (_init_intf_hdl(adapter, pintfhdl) == false)
+		goto register_intf_hdl_fail;
+	return _SUCCESS;
+register_intf_hdl_fail:
+	return false;
+}
+
+static  void unregister_intf_hdl(struct intf_hdl *pintfhdl)
+{
+	_unload_intf_hdl(pintfhdl->pintfpriv);
+	memset((u8 *)pintfhdl, 0, sizeof(struct intf_hdl));
+}
+
+uint r8712_alloc_io_queue(struct _adapter *adapter)
+{
+	u32 i;
+	struct io_queue *pio_queue;
+	struct io_req *pio_req;
+
+	pio_queue = (struct io_queue *)_malloc(sizeof(struct io_queue));
+	if (pio_queue == NULL)
+		goto alloc_io_queue_fail;
+	_init_listhead(&pio_queue->free_ioreqs);
+	_init_listhead(&pio_queue->processing);
+	_init_listhead(&pio_queue->pending);
+	spin_lock_init(&pio_queue->lock);
+	pio_queue->pallocated_free_ioreqs_buf = (u8 *)_malloc(NUM_IOREQ *
+						(sizeof(struct io_req)) + 4);
+	if ((pio_queue->pallocated_free_ioreqs_buf) == NULL)
+		goto alloc_io_queue_fail;
+	memset(pio_queue->pallocated_free_ioreqs_buf, 0,
+			(NUM_IOREQ * (sizeof(struct io_req)) + 4));
+	pio_queue->free_ioreqs_buf = pio_queue->pallocated_free_ioreqs_buf + 4
+			- ((addr_t)(pio_queue->pallocated_free_ioreqs_buf)
+			& 3);
+	pio_req = (struct io_req *)(pio_queue->free_ioreqs_buf);
+	for (i = 0; i < NUM_IOREQ; i++) {
+		_init_listhead(&pio_req->list);
+		sema_init(&pio_req->sema, 0);
+		list_insert_tail(&pio_req->list, &pio_queue->free_ioreqs);
+		pio_req++;
+	}
+	if ((register_intf_hdl((u8 *)adapter, &(pio_queue->intf))) == _FAIL)
+		goto alloc_io_queue_fail;
+	adapter->pio_queue = pio_queue;
+	return _SUCCESS;
+alloc_io_queue_fail:
+	if (pio_queue) {
+		kfree(pio_queue->pallocated_free_ioreqs_buf);
+		kfree((u8 *)pio_queue);
+	}
+	adapter->pio_queue = NULL;
+	return _FAIL;
+}
+
+void r8712_free_io_queue(struct _adapter *adapter)
+{
+	struct io_queue *pio_queue = (struct io_queue *)(adapter->pio_queue);
+
+	if (pio_queue) {
+		kfree(pio_queue->pallocated_free_ioreqs_buf);
+		adapter->pio_queue = NULL;
+		unregister_intf_hdl(&pio_queue->intf);
+		kfree((u8 *)pio_queue);
+	}
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef __IOCTL_H
+#define __IOCTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+/* For DDK-defined OIDs*/
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+#define SZ_OID_NDIS_SEG1	23
+#define SZ_OID_NDIS_SEG2	3
+#define SZ_OID_NDIS_SEG3	6
+#define SZ_OID_NDIS_SEG4	6
+#define SZ_OID_NDIS_SEG5	4
+#define SZ_OID_NDIS_SEG6	8
+#define SZ_OID_NDIS_SEG7	7
+#define SZ_OID_NDIS_SEG8	36
+#define SZ_OID_NDIS_SEG9	24
+#define SZ_OID_NDIS_SEG10	19
+
+/* For Realtek-defined OIDs*/
+#define OID_MP_SEG1	0xFF871100
+#define OID_MP_SEG2	0xFF818000
+#define OID_MP_SEG3	0xFF818700
+#define OID_MP_SEG4	0xFF011100
+
+enum oid_type {
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; /*the starting number for OID*/
+	unsigned int oid_end; /*the ending number for OID*/
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; /*the size of node_array*/
+	int query_counter; /*count the number of query hits for this segment*/
+	int set_counter; /*count the number of set hits for this segment*/
+};
+
+struct oid_par_priv {
+	void	*adapter_context;
+	uint oid;
+	void *information_buf;
+	unsigned long information_buf_len;
+	unsigned long *bytes_rw;
+	unsigned long *bytes_needed;
+	enum oid_type	type_of_oid;
+	unsigned int dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; /* 0: without OID debug message
+			      * 1: with OID debug message */
+	uint(*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+uint oid_null_function(struct oid_par_priv *poid_par_priv);
+
+extern struct iw_handler_def  r871x_handlers_def;
+
+extern	uint drv_query_info(
+	struct  net_device *MiniportAdapterContext,
+	uint Oid,
+	void *InformationBuffer,
+	u32 InformationBufferLength,
+	u32 *BytesWritten,
+	u32 *BytesNeeded
+);
+
+extern	uint drv_set_info(
+	struct  net_device *MiniportAdapterContext,
+	uint Oid,
+	void *InformationBuffer,
+	u32 InformationBufferLength,
+	u32 *BytesRead,
+	u32 *BytesNeeded
+);
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_linux.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_linux.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_linux.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,2409 @@
+/******************************************************************************
+ * rtl871x_ioctl_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_IOCTL_LINUX_C_
+#define _RTL871X_MP_IOCTL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+#include "rtl871x_debug.h"
+#include "wifi.h"
+#include "rtl871x_mlme.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_set.h"
+#include "rtl871x_mp_ioctl.h"
+#include "mlme_osdep.h"
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/io.h>
+#include <linux/semaphore.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV + 0x1E)
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+
+extern int hex_to_bin(char h);
+
+static const u32 rtl8180_rates[] = {1000000, 2000000, 5500000, 11000000,
+		       6000000, 9000000, 12000000, 18000000,
+		       24000000, 36000000, 48000000, 54000000};
+
+static const long ieee80211_wlan_frequencies[] = {
+	2412, 2417, 2422, 2427,
+	2432, 2437, 2442, 2447,
+	2452, 2457, 2462, 2467,
+	2472, 2484
+};
+
+static const char * const iw_operation_mode[] = {
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary",
+	 "Monitor"
+};
+
+
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex_to_bin(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex_to_bin(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+	return 0;
+}
+
+void r8712_indicate_wx_assoc_event(struct _adapter *padapter)
+{
+	union iwreq_data wrqu;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress,
+		ETH_ALEN);
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void r8712_indicate_wx_disassoc_event(struct _adapter *padapter)
+{
+	union iwreq_data wrqu;
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
+}
+
+static inline void handle_pairwise_key(struct sta_info *psta,
+				       struct ieee_param *param,
+				       struct _adapter *padapter)
+{
+	/* pairwise key */
+	memcpy(psta->x_UncstKey.skey, param->u.crypt.key,
+	       (param->u.crypt. key_len > 16 ? 16 : param->u.crypt.key_len));
+	if (strcmp(param->u.crypt.alg, "TKIP") == 0) { /* set mic key */
+		memcpy(psta->tkiptxmickey. skey, &(param->u.crypt.
+			key[16]), 8);
+		memcpy(psta->tkiprxmickey. skey, &(param->u.crypt.
+			key[24]), 8);
+		padapter->securitypriv. busetkipkey = false;
+		_set_timer(&padapter->securitypriv.tkip_timer, 50);
+	}
+	r8712_setstakey_cmd(padapter, (unsigned char *)psta, true);
+}
+
+static inline void handle_group_key(struct ieee_param *param,
+				    struct _adapter *padapter)
+{
+	if (0 < param->u.crypt.idx &&
+	    param->u.crypt.idx < 3) {
+		/* group key idx is 1 or 2 */
+		memcpy(padapter->securitypriv.XGrpKey[param->u.crypt.
+			idx-1].skey, param->u.crypt.key, (param->u.crypt.key_len
+			> 16 ? 16 : param->u.crypt.key_len));
+		memcpy(padapter->securitypriv.XGrptxmickey[param->
+			u.crypt.idx-1].skey, &(param->u.crypt.key[16]), 8);
+		memcpy(padapter->securitypriv. XGrprxmickey[param->
+			u.crypt.idx-1].skey, &(param->u.crypt.key[24]), 8);
+		padapter->securitypriv.binstallGrpkey = true;
+		r8712_set_key(padapter, &padapter->securitypriv,
+			param->u.crypt.idx);
+		if (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE) {
+			if (padapter->registrypriv.power_mgnt != padapter->
+			    pwrctrlpriv.pwr_mode)
+				_set_timer(&(padapter->mlmepriv.dhcp_timer),
+					   60000);
+		}
+	}
+}
+
+static inline char *translate_scan(struct _adapter *padapter,
+				   struct iw_request_info *info,
+				   struct wlan_network *pnetwork,
+				   char *start, char *stop)
+{
+	struct iw_event iwe;
+	struct ieee80211_ht_cap *pht_capie;
+	char *current_val;
+	s8 *p;
+	u32 i = 0, ht_ielen = 0;
+	u16	cap, ht_cap = false, mcs_rate;
+	u8	rssi, bw_40MHz = 0, short_GI = 0;
+
+	if ((pnetwork->network.Configuration.DSConfig < 1) ||
+	    (pnetwork->network.Configuration.DSConfig > 14)) {
+		if (pnetwork->network.Configuration.DSConfig < 1)
+			pnetwork->network.Configuration.DSConfig = 1;
+		else
+			pnetwork->network.Configuration.DSConfig = 14;
+	}
+	/* AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = (u16)min((u16)pnetwork->network.Ssid.SsidLength,
+			    (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe,
+				     pnetwork->network.Ssid.Ssid);
+	/* parsing HT_CAP_IE */
+	p = r8712_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_,
+			 &ht_ielen, pnetwork->network.IELength - 12);
+	if (p && ht_ielen > 0) {
+		ht_cap = true;
+		pht_capie = (struct ieee80211_ht_cap *)(p + 2);
+		memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH)
+			   ? 1 : 0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20 |
+			    IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
+	}
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((r8712_is_cckratesonly_included((u8 *)&pnetwork->network.
+	     SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	} else if ((r8712_is_cckrates_included((u8 *)&pnetwork->network.
+		    SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	} else {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+	}
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	memcpy((u8 *)&cap, r8712_get_capability_from_ie(pnetwork->network.IEs),
+		2);
+	cap = le16_to_cpu(cap);
+	if (cap & (WLAN_CAPABILITY_IBSS|WLAN_CAPABILITY_BSS)) {
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = (u32)IW_MODE_MASTER;
+		else
+			iwe.u.mode = (u32)IW_MODE_ADHOC;
+		start = iwe_stream_add_event(info, start, stop, &iwe,
+			IW_EV_UINT_LEN);
+	}
+	/* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	{
+		/*  check legel index */
+		u8 dsconfig = pnetwork->network.Configuration.DSConfig;
+		if (dsconfig >= 1 && dsconfig <= sizeof(
+		    ieee80211_wlan_frequencies) / sizeof(long))
+			iwe.u.freq.m = (s32)(ieee80211_wlan_frequencies[
+				       pnetwork->network.Configuration.
+				       DSConfig - 1] * 100000);
+		else
+			iwe.u.freq.m = 0;
+	}
+	iwe.u.freq.e = (s16)1;
+	iwe.u.freq.i = (u8)pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe,
+		IW_EV_FREQ_LEN);
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = (u16)(IW_ENCODE_ENABLED |
+				    IW_ENCODE_NOKEY);
+	else
+		iwe.u.data.flags = (u16)(IW_ENCODE_DISABLED);
+	iwe.u.data.length = (u16)0;
+	start = iwe_stream_add_point(info, start, stop, &iwe,
+		pnetwork->network.Ssid.Ssid);
+	/*Add basic and extended rates */
+	current_val = start + iwe_stream_lcp_len(info);
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = 0;
+	iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = 0;
+	i = 0;
+	while (pnetwork->network.SupportedRates[i] != 0) {
+		/* Bit rate given in 500 kb/s units */
+		iwe.u.bitrate.value = (pnetwork->network.SupportedRates[i++] &
+				      0x7F) * 500000;
+		current_val = iwe_stream_add_value(info, start, current_val,
+			      stop, &iwe, IW_EV_PARAM_LEN);
+	}
+	/* Check if we added any event */
+	if ((current_val - start) > iwe_stream_lcp_len(info))
+		start = current_val;
+	/* parsing WPA/WPA2 IE */
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 wpa_ie[255], rsn_ie[255];
+		u16 wpa_len = 0, rsn_len = 0;
+		int n;
+		sint out_len = 0;
+		out_len = r8712_get_sec_ie(pnetwork->network.IEs,
+					   pnetwork->network.
+					   IELength, rsn_ie, &rsn_len,
+					   wpa_ie, &wpa_len);
+		if (wpa_len > 0) {
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			n = sprintf(buf, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				n += snprintf(buf + n, MAX_WPA_IE_LEN - n,
+							"%02x", wpa_ie[i]);
+				if (n >= MAX_WPA_IE_LEN)
+					break;
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = (u16)strlen(buf);
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, buf);
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = (u16)wpa_len;
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, wpa_ie);
+		}
+		if (rsn_len > 0) {
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			n = sprintf(buf, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				n += snprintf(buf + n, MAX_WPA_IE_LEN - n,
+							"%02x", rsn_ie[i]);
+				if (n >= MAX_WPA_IE_LEN)
+					break;
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop,
+				&iwe, buf);
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe,
+				rsn_ie);
+		}
+	}
+
+	{ /* parsing WPS IE */
+		u8 wps_ie[512];
+		uint wps_ielen;
+
+		if (r8712_get_wps_ie(pnetwork->network.IEs,
+		    pnetwork->network.IELength,
+		    wps_ie, &wps_ielen) == true) {
+			if (wps_ielen > 2) {
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop,
+					&iwe, wps_ie);
+			}
+		}
+	}
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	rssi = r8712_signal_scale_mapping(pnetwork->network.Rssi);
+	/* we only update signal_level (signal strength) that is rssi. */
+	iwe.u.qual.updated = (u8)(IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_UPDATED |
+				  IW_QUAL_NOISE_INVALID);
+	iwe.u.qual.level = rssi;  /* signal strength */
+	iwe.u.qual.qual = 0; /* signal quality */
+	iwe.u.qual.noise = 0; /* noise level */
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	/* how to translate rssi to ?% */
+	return start;
+}
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {
+		padapter->securitypriv.ndisencryptstatus =
+						 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype =
+						 Ndis802_11AuthModeAutoSwitch;
+		padapter->securitypriv.AuthAlgrthm = 3;
+	} else if (value & AUTH_ALG_SHARED_KEY) {
+		padapter->securitypriv.ndisencryptstatus =
+						 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		padapter->securitypriv.AuthAlgrthm = 1;
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
+		if (padapter->securitypriv.ndisauthtype <
+						 Ndis802_11AuthModeWPAPSK) {
+			padapter->securitypriv.ndisauthtype =
+						 Ndis802_11AuthModeOpen;
+			padapter->securitypriv.AuthAlgrthm = 0;
+		}
+	} else
+		ret = -EINVAL;
+	return ret;
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
+			      u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len = 0;
+	struct NDIS_802_11_WEP	 *pwep = NULL;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+	if (param_len != (u32)((u8 *) param->u.crypt.key - (u8 *)param) +
+			 param->u.crypt.key_len)
+		return -EINVAL;
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
+			/* for large key indices, set the default (0) */
+			param->u.crypt.idx = 0;
+		}
+	} else
+		return -EINVAL;
+	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		printk(KERN_INFO "r8712u: wpa_set_encryption, crypt.alg ="
+		       " WEP\n");
+		padapter->securitypriv.ndisencryptstatus =
+			     Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.XGrpPrivacy = _WEP40_;
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+		if (wep_key_idx >= WEP_KEYS)
+			wep_key_idx = 0;
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			pwep = (struct NDIS_802_11_WEP *)_malloc((u32)
+			       (wep_key_len +
+			       FIELD_OFFSET(struct NDIS_802_11_WEP,
+			       KeyMaterial)));
+			if (pwep == NULL)
+				return -ENOMEM;
+			memset(pwep, 0, sizeof(struct NDIS_802_11_WEP));
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_key_len +
+				 FIELD_OFFSET(struct NDIS_802_11_WEP,
+				 KeyMaterial);
+			if (wep_key_len == 13) {
+				padapter->securitypriv.PrivacyAlgrthm =
+					 _WEP104_;
+				padapter->securitypriv.XGrpPrivacy =
+					 _WEP104_;
+			}
+		} else
+			return -EINVAL;
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+		memcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);
+		if (param->u.crypt.set_tx) {
+			if (r8712_set_802_11_add_wep(padapter, pwep) ==
+			    (u8)_FAIL)
+				ret = -EOPNOTSUPP;
+		} else {
+			/* don't update "psecuritypriv->PrivacyAlgrthm" and
+			 * "psecuritypriv->PrivacyKeyIndex=keyid", but can
+			 * r8712_set_key to fw/cam
+			 */
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP;
+				goto exit;
+			}
+			memcpy(&(psecuritypriv->DefKey[wep_key_idx].
+				skey[0]), pwep->KeyMaterial,
+				pwep->KeyLength);
+			psecuritypriv->DefKeylen[wep_key_idx] =
+				pwep->KeyLength;
+			r8712_set_key(padapter, psecuritypriv, wep_key_idx);
+		}
+		goto exit;
+	}
+	if (padapter->securitypriv.AuthAlgrthm == 2) { /* 802_1x */
+		struct sta_info *psta, *pbcmc_sta;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE |
+		    WIFI_MP_STATE) == true) { /* sta mode */
+			psta = r8712_get_stainfo(pstapriv,
+						 get_bssid(pmlmepriv));
+			if (psta) {
+				psta->ieee8021x_blocked = false;
+				if ((padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption2Enabled) ||
+				    (padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption3Enabled))
+					psta->XPrivacy = padapter->
+					    securitypriv.PrivacyAlgrthm;
+				if (param->u.crypt.set_tx == 1)
+					handle_pairwise_key(psta, param,
+							    padapter);
+				else /* group key */
+					handle_group_key(param, padapter);
+			}
+			pbcmc_sta = r8712_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta) {
+				pbcmc_sta->ieee8021x_blocked = false;
+				if ((padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption2Enabled) ||
+				    (padapter->securitypriv.ndisencryptstatus ==
+				    Ndis802_11Encryption3Enabled))
+					pbcmc_sta->XPrivacy =
+					  padapter->securitypriv.
+					  PrivacyAlgrthm;
+			}
+		}
+	}
+exit:
+	kfree((u8 *)pwep);
+	return ret;
+}
+
+static int r871x_set_wpa_ie(struct _adapter *padapter, char *pie,
+			    unsigned short ielen)
+{
+	u8 *buf = NULL, *pos = NULL;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL))
+		return -EINVAL;
+	if (ielen) {
+		buf = _malloc(ielen);
+		if (buf == NULL)
+			return -ENOMEM;
+		memcpy(buf, pie , ielen);
+		pos = buf;
+		if (ielen < RSN_HEADER_LEN) {
+			ret  = -EINVAL;
+			goto exit;
+		}
+		if (r8712_parse_wpa_ie(buf, ielen, &group_cipher,
+		    &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeWPAPSK;
+		}
+		if (r8712_parse_wpa2_ie(buf, ielen, &group_cipher,
+		    &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.AuthAlgrthm = 2;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeWPA2PSK;
+		}
+		switch (group_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.XGrpPrivacy =
+				 _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.XGrpPrivacy = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.XGrpPrivacy = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.XGrpPrivacy = _AES_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.XGrpPrivacy = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		}
+		switch (pairwise_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.PrivacyAlgrthm =
+				 _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.PrivacyAlgrthm = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.PrivacyAlgrthm = _AES_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.PrivacyAlgrthm = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+			break;
+		}
+		padapter->securitypriv.wps_phase = false;
+		{/* set wps_ie */
+			u16 cnt = 0;
+			u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+			while (cnt < ielen) {
+				eid = buf[cnt];
+
+				if ((eid == _VENDOR_SPECIFIC_IE_) &&
+				    (!memcmp(&buf[cnt+2], wps_oui, 4))) {
+					printk(KERN_INFO "r8712u: "
+					       "SET WPS_IE\n");
+					padapter->securitypriv.wps_ie_len =
+					    ((buf[cnt+1] + 2) <
+					    (MAX_WPA_IE_LEN << 2)) ?
+					    (buf[cnt + 1] + 2) :
+					    (MAX_WPA_IE_LEN << 2);
+					memcpy(padapter->securitypriv.wps_ie,
+					    &buf[cnt],
+					    padapter->securitypriv.wps_ie_len);
+					padapter->securitypriv.wps_phase =
+								 true;
+					printk(KERN_INFO "r8712u: SET WPS_IE,"
+					    " wps_phase==true\n");
+					cnt += buf[cnt+1]+2;
+					break;
+				} else
+					cnt += buf[cnt + 1] + 2;
+			}
+		}
+	}
+exit:
+	kfree(buf);
+	return ret;
+}
+
+static int r8711_wx_get_name(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap = false;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct ndis_wlan_bssid_ex  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX *prates = NULL;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) ==
+	    true) {
+		/* parsing HT_CAP_IE */
+		p = r8712_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_,
+				 &ht_ielen, pcur_bss->IELength - 12);
+		if (p && ht_ielen > 0)
+			ht_cap = true;
+		prates = &pcur_bss->SupportedRates;
+		if (r8712_is_cckratesonly_included((u8 *)prates) == true) {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11b");
+		} else if ((r8712_is_cckrates_included((u8 *)prates)) == true) {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11bg");
+		} else {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11gn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ,
+					 "IEEE 802.11g");
+		}
+	} else
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	return 0;
+}
+
+static const long frequency_list[] = {
+	2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462,
+	2467, 2472, 2484, 4915, 4920, 4925, 4935, 4940, 4945, 4960, 4980,
+	5035, 5040, 5045, 5055, 5060, 5080, 5170, 5180, 5190, 5200, 5210,
+	5220, 5230, 5240, 5260, 5280, 5300, 5320, 5500, 5520, 5540, 5560,
+	5580, 5600, 5620, 5640, 5660, 5680, 5700, 5745, 5765, 5785, 5805,
+	5825
+};
+
+static int r8711_wx_set_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_freq *fwrq = &wrqu->freq;
+	int rc = 0;
+
+/* If setting by frequency, convert to a channel */
+	if ((fwrq->e == 1) &&
+	  (fwrq->m >= (int) 2.412e8) &&
+	  (fwrq->m <= (int) 2.487e8)) {
+		int f = fwrq->m / 100000;
+		int c = 0;
+		while ((c < 14) && (f != frequency_list[c]))
+			c++;
+		fwrq->e = 0;
+		fwrq->m = c + 1;
+	}
+	/* Setting by channel number */
+	if ((fwrq->m > 14) || (fwrq->e > 0))
+		rc = -EOPNOTSUPP;
+	else {
+		int channel = fwrq->m;
+		if ((channel < 1) || (channel > 14))
+			rc = -EINVAL;
+		else {
+			/* Yes ! We can set it !!! */
+			padapter->registrypriv.channel = channel;
+		}
+	}
+	return rc;
+}
+
+static int r8711_wx_get_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		wrqu->freq.m = ieee80211_wlan_frequencies[
+			       pcur_bss->Configuration.DSConfig-1] * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+	} else {
+		return -ENOLINK;
+	}
+	return 0;
+}
+
+static int r8711_wx_set_mode(struct net_device *dev,
+			     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;
+
+	switch (wrqu->mode) {
+	case IW_MODE_AUTO:
+		networkType = Ndis802_11AutoUnknown;
+		break;
+	case IW_MODE_ADHOC:
+		networkType = Ndis802_11IBSS;
+		break;
+	case IW_MODE_MASTER:
+		networkType = Ndis802_11APMode;
+		break;
+	case IW_MODE_INFRA:
+		networkType = Ndis802_11Infrastructure;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (Ndis802_11APMode == networkType)
+		r8712_setopmode_cmd(padapter, networkType);
+	else
+		r8712_setopmode_cmd(padapter, Ndis802_11AutoUnknown);
+
+	r8712_set_802_11_infrastructure_mode(padapter, networkType);
+	return 0;
+}
+
+static int r8711_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		wrqu->mode = IW_MODE_INFRA;
+	else if (check_fwstate(pmlmepriv,
+		 WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE) == true)
+		wrqu->mode = IW_MODE_ADHOC;
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		wrqu->mode = IW_MODE_MASTER;
+	else
+		wrqu->mode = IW_MODE_AUTO;
+	return 0;
+}
+
+static int r871x_wx_set_pmkid(struct net_device *dev,
+			     struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct iw_pmksa *pPMK = (struct iw_pmksa *) extra;
+	u8 strZeroMacAddress[ETH_ALEN] = {0x00};
+	u8 strIssueBssid[ETH_ALEN] = {0x00};
+	u8 j, blInserted = false;
+	int intReturn = false;
+
+/*
+	There are the BSSID information in the bssid.sa_data array.
+	If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear
+	 all the PMKID information. If cmd is IW_PMKSA_ADD, it means the
+	  wpa_supplicant wants to add a PMKID/BSSID to driver.
+	If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to
+	  remove a PMKID/BSSID from driver.
+*/
+	if (pPMK == NULL)
+		return -EINVAL;
+	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+	switch (pPMK->cmd) {
+	case IW_PMKSA_ADD:
+		if (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))
+			return intReturn;
+		else
+			intReturn = true;
+		blInserted = false;
+		/* overwrite PMKID */
+		for (j = 0 ; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid,
+			    strIssueBssid, ETH_ALEN)) {
+				/* BSSID is matched, the same AP => rewrite
+				 * with new PMKID. */
+				printk(KERN_INFO "r8712u: r871x_wx_set_pmkid:"
+				    " BSSID exists in the PMKList.\n");
+				memcpy(psecuritypriv->PMKIDList[j].PMKID,
+					pPMK->pmkid, IW_PMKID_LEN);
+				psecuritypriv->PMKIDList[j].bUsed = true;
+				psecuritypriv->PMKIDIndex = j + 1;
+				blInserted = true;
+				break;
+			}
+		}
+		if (!blInserted) {
+			/* Find a new entry */
+			printk(KERN_INFO "r8712u: r871x_wx_set_pmkid: Use the"
+			    " new entry index = %d for this PMKID.\n",
+			    psecuritypriv->PMKIDIndex);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->
+				PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->
+				PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].
+				bUsed = true;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == NUM_PMKID_CACHE)
+				psecuritypriv->PMKIDIndex = 0;
+		}
+		break;
+	case IW_PMKSA_REMOVE:
+		intReturn = true;
+		for (j = 0; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid,
+			    strIssueBssid, ETH_ALEN)) {
+				/* BSSID is matched, the same AP => Remove
+				 * this PMKID information and reset it. */
+				memset(psecuritypriv->PMKIDList[j].Bssid,
+					0x00, ETH_ALEN);
+				psecuritypriv->PMKIDList[j].bUsed = false;
+				break;
+			}
+		}
+		break;
+	case IW_PMKSA_FLUSH:
+		memset(psecuritypriv->PMKIDList, 0,
+			sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		psecuritypriv->PMKIDIndex = 0;
+		intReturn = true;
+		break;
+	default:
+		printk(KERN_INFO "r8712u: r871x_wx_set_pmkid: "
+		       "unknown Command\n");
+		intReturn = false;
+		break;
+	}
+	return intReturn;
+}
+
+static int r8711_wx_get_sens(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	wrqu->sens.value = 0;
+	wrqu->sens.fixed = 0;	/* no auto select */
+	wrqu->sens.disabled = 1;
+	return 0;
+}
+
+static int r8711_wx_get_range(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	u16 val;
+	int i;
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;
+	/* TODO: 8711 sensitivity ? */
+	/* signal level threshold range */
+	/* percent values between 0 and 100. */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + -98;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+	range->num_bitrates = RATE_COUNT;
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)
+		range->bitrate[i] = rtl8180_rates[i];
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+	range->pm_capa = 0;
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+	range->num_channels = 14;
+	for (i = 0, val = 0; i < 14; i++) {
+		/* Include only legal frequencies for some countries */
+		range->freq[val].i = i + 1;
+		range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
+		range->freq[val].e = 1;
+		val++;
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+	range->num_frequency = val;
+	range->enc_capa = IW_ENC_CAPA_WPA |
+			  IW_ENC_CAPA_WPA2 |
+			  IW_ENC_CAPA_CIPHER_TKIP |
+			  IW_ENC_CAPA_CIPHER_CCMP;
+	return 0;
+}
+
+static int r8711_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra);
+
+static int r871x_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+	int ret = 0, len = 0;
+	char *ext;
+	struct _adapter *padapter = netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point *)awrq;
+
+	len = dwrq->length;
+	ext = _malloc(len);
+	if (!ext)
+		return -ENOMEM;
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		kfree(ext);
+		return -EFAULT;
+	}
+
+	if (0 == strcasecmp(ext, "RSSI")) {
+		/*Return received signal strength indicator in -db for */
+		/* current AP */
+		/*<ssid> Rssi xx */
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+		struct wlan_network *pcur_network = &pmlmepriv->cur_network;
+		/*static u8 xxxx; */
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+			sprintf(ext, "%s rssi %d",
+				pcur_network->network.Ssid.Ssid,
+				/*(xxxx=xxxx+10) */
+				((padapter->recvpriv.fw_rssi)>>1)-95
+				/*pcur_network->network.Rssi */
+				);
+		} else {
+			sprintf(ext, "OK");
+		}
+	} else if (0 == strcasecmp(ext, "LINKSPEED")) {
+		/*Return link speed in MBPS */
+		/*LinkSpeed xx */
+		union iwreq_data wrqd;
+		int ret_inner;
+		int mbps;
+
+		ret_inner = r8711_wx_get_rate(dev, info, &wrqd, extra);
+		if (0 != ret_inner)
+			mbps = 0;
+		else
+			mbps = wrqd.bitrate.value / 1000000;
+		sprintf(ext, "LINKSPEED %d", mbps);
+	} else if (0 == strcasecmp(ext, "MACADDR")) {
+		/*Return mac address of the station */
+		/*Macaddr = xx.xx.xx.xx.xx.xx */
+		sprintf(ext,
+			"MACADDR = %02x.%02x.%02x.%02x.%02x.%02x",
+			*(dev->dev_addr), *(dev->dev_addr+1),
+			*(dev->dev_addr+2), *(dev->dev_addr+3),
+			*(dev->dev_addr+4), *(dev->dev_addr+5));
+	} else if (0 == strcasecmp(ext, "SCAN-ACTIVE")) {
+		/*Set scan type to active */
+		/*OK if successful */
+		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+		pmlmepriv->passive_mode = 1;
+		sprintf(ext, "OK");
+	} else if (0 == strcasecmp(ext, "SCAN-PASSIVE")) {
+		/*Set scan type to passive */
+		/*OK if successful */
+		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+		pmlmepriv->passive_mode = 0;
+		sprintf(ext, "OK");
+	} else if (0 == strncmp(ext, "DCE-E", 5)) {
+		/*Set scan type to passive */
+		/*OK if successful */
+		r8712_disconnectCtrlEx_cmd(padapter
+			, 1 /*u32 enableDrvCtrl */
+			, 5 /*u32 tryPktCnt */
+			, 100 /*u32 tryPktInterval */
+			, 5000 /*u32 firstStageTO */
+		);
+		sprintf(ext, "OK");
+	} else if (0 == strncmp(ext, "DCE-D", 5)) {
+		/*Set scan type to passive */
+		/*OK if successfu */
+		r8712_disconnectCtrlEx_cmd(padapter
+			, 0 /*u32 enableDrvCtrl */
+			, 5 /*u32 tryPktCnt */
+			, 100 /*u32 tryPktInterval */
+			, 5000 /*u32 firstStageTO */
+		);
+		sprintf(ext, "OK");
+	} else {
+		printk(KERN_INFO "r8712u: r871x_wx_set_priv: unknown Command"
+		       " %s.\n", ext);
+		goto FREE_EXT;
+	}
+	if (copy_to_user(dwrq->pointer, ext,
+				min(dwrq->length, (__u16)(strlen(ext)+1))))
+		ret = -EFAULT;
+
+FREE_EXT:
+	kfree(ext);
+	return ret;
+}
+
+/* set bssid flow
+ * s1. set_802_11_infrastructure_mode()
+ * s2. set_802_11_authentication_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. set_802_11_bssid()
+ *
+ * This function intends to handle the Set AP command, which specifies the
+ * MAC# of a preferred Access Point.
+ * Currently, the request comes via Wireless Extensions' SIOCSIWAP ioctl.
+ *
+ * For this operation to succeed, there is no need for the interface to be Up.
+ *
+ */
+static int r8711_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	int ret = -EINPROGRESS;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+	unsigned long irqL;
+	struct list_head *phead;
+	u8 *dst_bssid;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		return -EBUSY;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		return ret;
+	if (temp->sa_family != ARPHRD_ETHER)
+		return -EINVAL;
+	authmode = padapter->securitypriv.ndisauthtype;
+	spin_lock_irqsave(&queue->lock, irqL);
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true)
+			break;
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+			   struct wlan_network, list);
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+		dst_bssid = pnetwork->network.MacAddress;
+		if (!memcmp(dst_bssid, temp->sa_data, ETH_ALEN)) {
+			r8712_set_802_11_infrastructure_mode(padapter,
+			    pnetwork->network.InfrastructureMode);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	if (!ret) {
+		if (!r8712_set_802_11_authentication_mode(padapter, authmode))
+			ret = -ENOMEM;
+		else {
+			if (!r8712_set_802_11_bssid(padapter, temp->sa_data))
+				ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int r8711_wx_get_wap(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	if (check_fwstate(pmlmepriv, _FW_LINKED |
+	    WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)) {
+		memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	}
+	return 0;
+}
+
+static int r871x_wx_set_mlme(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	u16 reason;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+	if (mlme == NULL)
+		return -1;
+	reason = cpu_to_le16(mlme->reason_code);
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+		if (!r8712_set_802_11_disassociate(padapter))
+			ret = -1;
+		break;
+	case IW_MLME_DISASSOC:
+		if (!r8712_set_802_11_disassociate(padapter))
+			ret = -1;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return ret;
+}
+
+/**
+ *
+ * This function intends to handle the Set Scan command.
+ * Currently, the request comes via Wireless Extensions' SIOCSIWSCAN ioctl.
+ *
+ * For this operation to succeed, the interface is brought Up beforehand.
+ *
+ */
+static int r8711_wx_set_scan(struct net_device *dev,
+			struct iw_request_info *a,
+			union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 status = true;
+
+	if (padapter->bDriverStopped == true) {
+		printk(KERN_WARNING "r8712u: in r8711_wx_set_scan: "
+		    "bDriverStopped=%d\n", padapter->bDriverStopped);
+		return -1;
+	}
+	if (padapter->bup == false)
+		return -ENETDOWN;
+	if (padapter->hw_init_completed == false)
+		return -1;
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == true))
+		return 0;
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+			struct ndis_802_11_ssid ssid;
+			unsigned long irqL;
+			u32 len = (u32) min((u8)req->essid_len,
+				  (u8)IW_ESSID_MAX_SIZE);
+			memset((unsigned char *)&ssid, 0,
+				 sizeof(struct ndis_802_11_ssid));
+			memcpy(ssid.Ssid, req->essid, len);
+			ssid.SsidLength = len;
+			spin_lock_irqsave(&pmlmepriv->lock, irqL);
+			if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |
+			     _FW_UNDER_LINKING)) ||
+			    (pmlmepriv->sitesurveyctrl.traffic_busy == true)) {
+				if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+					status = false;
+			} else
+				status = r8712_sitesurvey_cmd(padapter, &ssid);
+			spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+		}
+	} else
+		status = r8712_set_802_11_bssid_list_scan(padapter);
+	if (status == false)
+		return -1;
+	return 0;
+}
+
+static int r8711_wx_get_scan(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0, cnt = 0;
+
+	if (padapter->bDriverStopped)
+		return -EINVAL;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		msleep(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+	spin_lock_irqsave(&queue->lock, irqL);
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		ev = translate_scan(padapter, a, pnetwork, ev, stop);
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	wrqu->data.length = ev - extra;
+	wrqu->data.flags = 0;
+	return ret;
+}
+
+/* set ssid flow
+ * s1. set_802_11_infrastructure_mode()
+ * s2. set_802_11_authenticaion_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. set_802_11_ssid()
+ *
+ * This function intends to handle the Set ESSID command.
+ * Currently, the request comes via the Wireless Extensions' SIOCSIWESSID ioctl.
+ *
+ * For this operation to succeed, there is no need for the interface to be Up.
+ *
+ */
+static int r8711_wx_set_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
+	struct ndis_802_11_ssid ndis_ssid;
+	u8 *dst_ssid, *src_ssid;
+	struct list_head *phead;
+	u32 len;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		return -EBUSY;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+		return 0;
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+	authmode = padapter->securitypriv.ndisauthtype;
+	if (wrqu->essid.flags && wrqu->essid.length) {
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ?
+		       wrqu->essid.length : IW_ESSID_MAX_SIZE;
+		memset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));
+		ndis_ssid.SsidLength = len;
+		memcpy(ndis_ssid.Ssid, extra, len);
+		src_ssid = ndis_ssid.Ssid;
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = get_next(phead);
+		while (1) {
+			if (end_of_queue_search(phead, pmlmepriv->pscanned))
+				break;
+			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+				   struct wlan_network, list);
+			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+			if ((!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength))
+			    && (pnetwork->network.Ssid.SsidLength ==
+			     ndis_ssid.SsidLength)) {
+				if (check_fwstate(pmlmepriv,
+							WIFI_ADHOC_STATE)) {
+					if (pnetwork->network.
+						InfrastructureMode
+						!=
+						padapter->mlmepriv.
+						cur_network.network.
+						InfrastructureMode)
+						continue;
+				}
+
+				r8712_set_802_11_infrastructure_mode(
+				     padapter,
+				     pnetwork->network.InfrastructureMode);
+				break;
+			}
+		}
+		r8712_set_802_11_authentication_mode(padapter, authmode);
+		r8712_set_802_11_ssid(padapter, &ndis_ssid);
+	}
+	return -EINPROGRESS;
+}
+
+static int r8711_wx_get_essid(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+	u32 len, ret = 0;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		len = pcur_bss->Ssid.SsidLength;
+		wrqu->essid.length = len;
+		memcpy(extra, pcur_bss->Ssid.Ssid, len);
+		wrqu->essid.flags = 1;
+	} else {
+		ret = -ENOLINK;
+	}
+	return ret;
+}
+
+static int r8711_wx_set_rate(struct net_device *dev,
+				struct iw_request_info *a,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	u32 target_rate = wrqu->bitrate.value;
+	u32 fixed = wrqu->bitrate.fixed;
+	u32 ratevalue = 0;
+	u8 datarates[NumRates];
+	u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+	int i, ret = 0;
+
+	if (target_rate == -1) {
+		ratevalue = 11;
+		goto set_rate;
+	}
+	target_rate = target_rate / 100000;
+	switch (target_rate) {
+	case 10:
+		ratevalue = 0;
+		break;
+	case 20:
+		ratevalue = 1;
+		break;
+	case 55:
+		ratevalue = 2;
+		break;
+	case 60:
+		ratevalue = 3;
+		break;
+	case 90:
+		ratevalue = 4;
+		break;
+	case 110:
+		ratevalue = 5;
+		break;
+	case 120:
+		ratevalue = 6;
+		break;
+	case 180:
+		ratevalue = 7;
+		break;
+	case 240:
+		ratevalue = 8;
+		break;
+	case 360:
+		ratevalue = 9;
+		break;
+	case 480:
+		ratevalue = 10;
+		break;
+	case 540:
+		ratevalue = 11;
+		break;
+	default:
+		ratevalue = 11;
+		break;
+	}
+set_rate:
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+			if (fixed == 0)
+				break;
+		} else
+			datarates[i] = 0xff;
+	}
+	if (r8712_setdatarate_cmd(padapter, datarates) != _SUCCESS)
+		ret = -ENOMEM;
+	return ret;
+}
+
+static int r8711_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+	struct ieee80211_ht_cap *pht_capie;
+	unsigned char rf_type = padapter->registrypriv.rf_config;
+	int i;
+	u8 *p;
+	u16 rate, max_rate = 0, ht_cap = false;
+	u32 ht_ielen = 0;
+	u8 bw_40MHz = 0, short_GI = 0;
+	u16 mcs_rate = 0;
+
+	i = 0;
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		p = r8712_get_ie(&pcur_bss->IEs[12],
+				 _HT_CAPABILITY_IE_, &ht_ielen,
+		    pcur_bss->IELength - 12);
+		if (p && ht_ielen > 0) {
+			ht_cap = true;
+			pht_capie = (struct ieee80211_ht_cap *)(p + 2);
+			memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+			bw_40MHz = (pht_capie->cap_info &
+				    IEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;
+			short_GI = (pht_capie->cap_info &
+				    (IEEE80211_HT_CAP_SGI_20 |
+				    IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
+		}
+		while ((pcur_bss->SupportedRates[i] != 0) &&
+			(pcur_bss->SupportedRates[i] != 0xFF)) {
+			rate = pcur_bss->SupportedRates[i] & 0x7F;
+			if (rate > max_rate)
+				max_rate = rate;
+			wrqu->bitrate.fixed = 0;	/* no auto select */
+			wrqu->bitrate.value = rate*500000;
+			i++;
+		}
+		if (ht_cap == true) {
+			if (mcs_rate & 0x8000 /* MCS15 */
+				&&
+				RTL8712_RF_2T2R == rf_type)
+				max_rate = (bw_40MHz) ? ((short_GI) ? 300 :
+					    270) : ((short_GI) ? 144 : 130);
+			else if (mcs_rate & 0x0080) /* MCS7 */
+				max_rate = (bw_40MHz) ? ((short_GI) ? 150 :
+					    135) : ((short_GI) ? 72 : 65);
+			else /* default MCS7 */
+				max_rate = (bw_40MHz) ? ((short_GI) ? 150 :
+					    135) : ((short_GI) ? 72 : 65);
+			max_rate *= 2; /* Mbps/2 */
+			wrqu->bitrate.value = max_rate * 500000;
+		} else {
+			wrqu->bitrate.value = max_rate * 500000;
+		}
+	} else
+		return -ENOLINK;
+	return 0;
+}
+
+static int r8711_wx_get_rts(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	return 0;
+}
+
+static int r8711_wx_set_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+	return 0;
+}
+
+static int r8711_wx_get_frag(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	return 0;
+}
+
+static int r8711_wx_get_retry(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+	return 0;
+}
+
+static int r8711_wx_set_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	u32 key;
+	u32 keyindex_provided;
+	struct NDIS_802_11_WEP	 wep;
+	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
+	struct iw_point *erq = &(wrqu->encoding);
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	key = erq->flags & IW_ENCODE_INDEX;
+	memset(&wep, 0, sizeof(struct NDIS_802_11_WEP));
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11EncryptionDisabled;
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+		return 0;
+	}
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} else {
+		keyindex_provided = 0;
+		key = padapter->securitypriv.PrivacyKeyIndex;
+	}
+	/* set authentication mode */
+	if (erq->flags & IW_ENCODE_OPEN) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+	} else if (erq->flags & IW_ENCODE_RESTRICTED) {
+		printk(KERN_INFO "r8712u: r8711_wx_set_enc: "
+		       "IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 1; /* shared system */
+		padapter->securitypriv.PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.XGrpPrivacy = _WEP40_;
+		authmode = Ndis802_11AuthModeShared;
+		padapter->securitypriv.ndisauthtype = authmode;
+	} else {
+		padapter->securitypriv.ndisencryptstatus =
+				 Ndis802_11Encryption1Enabled;
+		padapter->securitypriv.AuthAlgrthm = 0; /* open system */
+		padapter->securitypriv.PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.XGrpPrivacy = _NO_PRIVACY_;
+		authmode = Ndis802_11AuthModeOpen;
+		padapter->securitypriv.ndisauthtype = authmode;
+	}
+	wep.KeyIndex = key;
+	if (erq->length > 0) {
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+		wep.Length = wep.KeyLength +
+			     FIELD_OFFSET(struct NDIS_802_11_WEP, KeyMaterial);
+	} else {
+		wep.KeyLength = 0 ;
+		if (keyindex_provided == 1) { /* set key_id only, no given
+					       * KeyMaterial(erq->length==0).*/
+			padapter->securitypriv.PrivacyKeyIndex = key;
+			switch (padapter->securitypriv.DefKeylen[key]) {
+			case 5:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _WEP40_;
+				break;
+			case 13:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _WEP104_;
+				break;
+			default:
+				padapter->securitypriv.PrivacyAlgrthm =
+						 _NO_PRIVACY_;
+				break;
+			}
+			return 0;
+		}
+	}
+	wep.KeyIndex |= 0x80000000;	/* transmit key */
+	memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+	if (r8712_set_802_11_add_wep(padapter, &wep) == _FAIL)
+		return -EOPNOTSUPP;
+	return 0;
+}
+
+static int r8711_wx_get_enc(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false) {
+		if (!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			return 0;
+		}
+	}
+	key = erq->flags & IW_ENCODE_INDEX;
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else {
+		key = padapter->securitypriv.PrivacyKeyIndex;
+	}
+	erq->flags = key + 1;
+	switch (padapter->securitypriv.ndisencryptstatus) {
+	case Ndis802_11EncryptionNotSupported:
+	case Ndis802_11EncryptionDisabled:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		break;
+	case Ndis802_11Encryption1Enabled:
+		erq->length = padapter->securitypriv.DefKeylen[key];
+		if (erq->length) {
+			memcpy(keybuf, padapter->securitypriv.DefKey[
+				key].skey, padapter->securitypriv.
+				DefKeylen[key]);
+			erq->flags |= IW_ENCODE_ENABLED;
+			if (padapter->securitypriv.ndisauthtype ==
+			    Ndis802_11AuthModeOpen)
+				erq->flags |= IW_ENCODE_OPEN;
+			else if (padapter->securitypriv.ndisauthtype ==
+				 Ndis802_11AuthModeShared)
+				erq->flags |= IW_ENCODE_RESTRICTED;
+		} else {
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+		break;
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption3Enabled:
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN |
+			       IW_ENCODE_NOKEY);
+		break;
+	default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		break;
+	}
+	return ret;
+}
+
+static int r8711_wx_get_power(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+	return 0;
+}
+
+static int r871x_wx_set_gen_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+
+	return r871x_set_wpa_ie(padapter, extra, wrqu->data.length);
+}
+
+static int r871x_wx_set_auth(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_param *param = (struct iw_param *)&(wrqu->param);
+	int paramid;
+	int paramval;
+	int ret = 0;
+
+	paramid = param->flags & IW_AUTH_INDEX;
+	paramval = param->value;
+	switch (paramid) {
+	case IW_AUTH_WPA_VERSION:
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		break;
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		if (paramval) {
+			/* wpa_supplicant is enabling tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = true;
+		} else {
+			/* wpa_supplicant is disabling tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = false;
+		}
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		if (padapter->securitypriv.ndisencryptstatus ==
+		    Ndis802_11Encryption1Enabled) {
+				/* it means init value, or using wep,
+				 * ndisencryptstatus =
+				 *	Ndis802_11Encryption1Enabled,
+				 * then it needn't reset it;
+				 */
+				break;
+		}
+
+		if (paramval) {
+			padapter->securitypriv.ndisencryptstatus =
+				   Ndis802_11EncryptionDisabled;
+			padapter->securitypriv.PrivacyAlgrthm =
+				  _NO_PRIVACY_;
+			padapter->securitypriv.XGrpPrivacy =
+				  _NO_PRIVACY_;
+			padapter->securitypriv.AuthAlgrthm = 0;
+			padapter->securitypriv.ndisauthtype =
+				  Ndis802_11AuthModeOpen;
+		}
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		ret = wpa_set_auth_algs(dev, (u32)paramval);
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int r871x_wx_set_enc_ext(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct iw_point *pencoding = &wrqu->encoding;
+	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+	struct ieee_param *param = NULL;
+	char *alg_name;
+	u32 param_len;
+	int ret = 0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)_malloc(param_len);
+	if (param == NULL)
+		return -ENOMEM;
+	memset(param, 0, param_len);
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -EINVAL;
+	}
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+		param->u.crypt.set_tx = 0;
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)
+		param->u.crypt.set_tx = 1;
+	param->u.crypt.idx = (pencoding->flags & 0x00FF) - 1;
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+		memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	if (pext->key_len) {
+		param->u.crypt.key_len = pext->key_len;
+		memcpy(param + 1, pext + 1, pext->key_len);
+	}
+	ret = wpa_set_encryption(dev, param, param_len);
+	kfree(param);
+	return ret;
+}
+
+static int r871x_wx_get_nick(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	if (extra) {
+		wrqu->data.length = 8;
+		wrqu->data.flags = 1;
+		memcpy(extra, "rtl_wifi", 8);
+	}
+	return 0;
+}
+
+static int r8711_wx_read32(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *keybuf)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	data32 = r8712_read32(padapter, addr);
+	put_user(data32, (u32 __user *)wrqu->data.pointer);
+	wrqu->data.length = (data32 & 0xffff0000) >> 16;
+	wrqu->data.flags = data32 & 0xffff;
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	return 0;
+}
+
+static int r8711_wx_write32(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *keybuf)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	u32 addr;
+	u32 data32;
+
+	get_user(addr, (u32 __user *)wrqu->data.pointer);
+	data32 = ((u32)wrqu->data.length<<16) | (u32)wrqu->data.flags ;
+	r8712_write32(padapter, addr, data32);
+	return 0;
+}
+
+static int dummy(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	return -ENOSYS;
+}
+
+static int r8711_drvext_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+static int r871x_mp_ioctl_hdl(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+	struct oid_par_priv oid_par;
+	struct mp_ioctl_handler *phandler;
+	struct mp_ioctl_param *poidparam;
+	unsigned long BytesRead, BytesWritten, BytesNeeded;
+	u8 *pparmbuf = NULL, bset;
+	u16 len;
+	uint status;
+	int ret = 0;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = NULL;
+	pparmbuf = (u8 *)_malloc(len);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	poidparam = (struct mp_ioctl_param *)pparmbuf;
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	phandler = mp_ioctl_hdl + poidparam->subcode;
+	if ((phandler->paramsize != 0) &&
+	    (poidparam->len < phandler->paramsize)) {
+		ret = -EINVAL;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (phandler->oid == 0 && phandler->handler)
+		status = phandler->handler(&oid_par);
+	else if (phandler->handler) {
+		oid_par.adapter_context = padapter;
+		oid_par.oid = phandler->oid;
+		oid_par.information_buf = poidparam->data;
+		oid_par.information_buf_len = poidparam->len;
+		oid_par.dbg = 0;
+		BytesWritten = 0;
+		BytesNeeded = 0;
+		if (bset) {
+			oid_par.bytes_rw = &BytesRead;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = SET_OID;
+		} else {
+			oid_par.bytes_rw = &BytesWritten;
+			oid_par.bytes_needed = &BytesNeeded;
+			oid_par.type_of_oid = QUERY_OID;
+		}
+		status = phandler->handler(&oid_par);
+		/* todo:check status, BytesNeeded, etc. */
+	} else {
+		printk(KERN_INFO "r8712u: r871x_mp_ioctl_hdl(): err!,"
+		    " subcode=%d, oid=%d, handler=%p\n",
+		    poidparam->subcode, phandler->oid, phandler->handler);
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+	if (bset == 0x00) { /* query info */
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+	if (status) {
+		ret = -EFAULT;
+		goto _r871x_mp_ioctl_hdl_exit;
+	}
+_r871x_mp_ioctl_hdl_exit:
+	kfree(pparmbuf);
+	return ret;
+}
+
+static int r871x_get_ap_info(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct iw_point *pdata = &wrqu->data;
+	struct wlan_network *pnetwork = NULL;
+	u32 cnt = 0, wpa_ielen;
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+
+	if (padapter->bDriverStopped || (pdata == NULL))
+		return -EINVAL;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		msleep(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+	pdata->flags = 0;
+	if (pdata->length >= 32) {
+		if (copy_from_user(data, pdata->pointer, 32))
+			return -EINVAL;
+	} else
+		 return -EINVAL;
+	spin_lock_irqsave(&(pmlmepriv->scanned_queue.lock), irqL);
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (hwaddr_aton_i(data, bssid)) {
+			printk(KERN_INFO "r8712u: Invalid BSSID '%s'.\n",
+			       (u8 *)data);
+			spin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock),
+									irqL);
+			return -EINVAL;
+		}
+		printk(KERN_INFO "r8712u: BSSID:%pM\n", bssid);
+		if (!memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN)) {
+			/* BSSID match, then check if supporting wpa/wpa2 */
+			pbuf = r8712_get_wpa_ie(&pnetwork->network.IEs[12],
+			       &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 1;
+				break;
+			}
+			pbuf = r8712_get_wpa2_ie(&pnetwork->network.IEs[12],
+			       &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 2;
+				break;
+			}
+		}
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&(pmlmepriv->scanned_queue.lock), irqL);
+	if (pdata->length >= 34) {
+		if (copy_to_user((u8 __user *)pdata->pointer + 32,
+		    (u8 *)&pdata->flags, 1))
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int r871x_set_pid(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+
+	if ((padapter->bDriverStopped) || (pdata == NULL))
+		return -EINVAL;
+	if (copy_from_user(&padapter->pid, pdata->pointer, sizeof(int)))
+		return -EINVAL;
+	return 0;
+}
+
+static int r871x_set_chplan(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	int ch_plan = -1;
+
+	if ((padapter->bDriverStopped) || (pdata == NULL)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	ch_plan = (int)*extra;
+	r8712_set_chplan_cmd(padapter, ch_plan);
+
+exit:
+
+	return ret;
+}
+
+static int r871x_wps_start(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+
+	if (copy_from_user((void *)&u32wps_start, pdata->pointer, 4))
+		return -EFAULT;
+	if ((padapter->bDriverStopped) || (pdata == NULL))
+		return -EINVAL;
+	if (u32wps_start == 0)
+		u32wps_start = *extra;
+	if (u32wps_start == 1) /* WPS Start */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_START_WPS);
+	else if (u32wps_start == 2) /* WPS Stop because of wps success */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_STOP_WPS);
+	else if (u32wps_start == 3) /* WPS Stop because of wps fail */
+		padapter->ledpriv.LedControlHandler(padapter,
+			   LED_CTL_STOP_WPS_FAIL);
+	return 0;
+}
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	switch (name) {
+	case IEEE_PARAM_WPA_ENABLED:
+		padapter->securitypriv.AuthAlgrthm = 2; /* 802.1x */
+		switch ((value)&0xff) {
+		case 1: /* WPA */
+			padapter->securitypriv.ndisauthtype =
+				Ndis802_11AuthModeWPAPSK; /* WPA_PSK */
+			padapter->securitypriv.ndisencryptstatus =
+				Ndis802_11Encryption2Enabled;
+			break;
+		case 2: /* WPA2 */
+			padapter->securitypriv.ndisauthtype =
+				Ndis802_11AuthModeWPA2PSK; /* WPA2_PSK */
+			padapter->securitypriv.ndisencryptstatus =
+				Ndis802_11Encryption3Enabled;
+			break;
+		}
+		break;
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		break;
+	case IEEE_PARAM_DROP_UNENCRYPTED:
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+		break;
+	case IEEE_PARAM_PRIVACY_INVOKED:
+		break;
+	case IEEE_PARAM_AUTH_ALGS:
+		return wpa_set_auth_algs(dev, value);
+		break;
+	case IEEE_PARAM_IEEE_802_1X:
+		break;
+	case IEEE_PARAM_WPAX_SELECT:
+		/* added for WPA2 mixed mode */
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	switch (command) {
+	case IEEE_MLME_STA_DEAUTH:
+		if (!r8712_set_802_11_disassociate(padapter))
+			return -1;
+		break;
+	case IEEE_MLME_STA_DISASSOC:
+		if (!r8712_set_802_11_disassociate(padapter))
+			return -1;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret = 0;
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer)
+		return -EINVAL;
+	param = (struct ieee_param *)_malloc(p->length);
+	if (param == NULL)
+		return -ENOMEM;
+	if (copy_from_user(param, p->pointer, p->length)) {
+		kfree((u8 *)param);
+		return -EFAULT;
+	}
+	switch (param->cmd) {
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(dev, param->u.wpa_param.name,
+		      param->u.wpa_param.value);
+		break;
+	case IEEE_CMD_SET_WPA_IE:
+		ret =  r871x_set_wpa_ie(padapter, (char *)param->u.wpa_ie.data,
+		       (u16)param->u.wpa_ie.len);
+		break;
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(dev, param, p->length);
+		break;
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(dev, param->u.mlme.command,
+		      param->u.mlme.reason_code);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+	kfree((u8 *)param);
+	return ret;
+}
+
+/* based on "driver_ipw" and for hostapd */
+int r871x_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+
+	switch (cmd) {
+	case RTL_IOCTL_WPA_SUPPLICANT:
+		return wpa_supplicant_ioctl(dev, &wrq->u.data);
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static iw_handler r8711_handlers[] = {
+	NULL,				/* SIOCSIWCOMMIT */
+	r8711_wx_get_name,		/* SIOCGIWNAME */
+	dummy,				/* SIOCSIWNWID */
+	dummy,				/* SIOCGIWNWID */
+	r8711_wx_set_freq,		/* SIOCSIWFREQ */
+	r8711_wx_get_freq,		/* SIOCGIWFREQ */
+	r8711_wx_set_mode,		/* SIOCSIWMODE */
+	r8711_wx_get_mode,		/* SIOCGIWMODE */
+	dummy,				/* SIOCSIWSENS */
+	r8711_wx_get_sens,		/* SIOCGIWSENS */
+	NULL,				/* SIOCSIWRANGE */
+	r8711_wx_get_range,		/* SIOCGIWRANGE */
+	r871x_wx_set_priv,		/* SIOCSIWPRIV */
+	NULL,				/* SIOCGIWPRIV */
+	NULL,				/* SIOCSIWSTATS */
+	NULL,				/* SIOCGIWSTATS */
+	dummy,				/* SIOCSIWSPY */
+	dummy,				/* SIOCGIWSPY */
+	NULL,				/* SIOCGIWTHRSPY */
+	NULL,				/* SIOCWIWTHRSPY */
+	r8711_wx_set_wap,		/* SIOCSIWAP */
+	r8711_wx_get_wap,		/* SIOCGIWAP */
+	r871x_wx_set_mlme,		/* request MLME operation;
+					 *  uses struct iw_mlme */
+	dummy,				/* SIOCGIWAPLIST -- deprecated */
+	r8711_wx_set_scan,		/* SIOCSIWSCAN */
+	r8711_wx_get_scan,		/* SIOCGIWSCAN */
+	r8711_wx_set_essid,		/* SIOCSIWESSID */
+	r8711_wx_get_essid,		/* SIOCGIWESSID */
+	dummy,				/* SIOCSIWNICKN */
+	r871x_wx_get_nick,		/* SIOCGIWNICKN */
+	NULL,				/* -- hole -- */
+	NULL,				/* -- hole -- */
+	r8711_wx_set_rate,		/* SIOCSIWRATE */
+	r8711_wx_get_rate,		/* SIOCGIWRATE */
+	dummy,				/* SIOCSIWRTS */
+	r8711_wx_get_rts,		/* SIOCGIWRTS */
+	r8711_wx_set_frag,		/* SIOCSIWFRAG */
+	r8711_wx_get_frag,		/* SIOCGIWFRAG */
+	dummy,				/* SIOCSIWTXPOW */
+	dummy,				/* SIOCGIWTXPOW */
+	dummy,				/* SIOCSIWRETRY */
+	r8711_wx_get_retry,		/* SIOCGIWRETRY */
+	r8711_wx_set_enc,		/* SIOCSIWENCODE */
+	r8711_wx_get_enc,		/* SIOCGIWENCODE */
+	dummy,				/* SIOCSIWPOWER */
+	r8711_wx_get_power,		/* SIOCGIWPOWER */
+	NULL,				/*---hole---*/
+	NULL,				/*---hole---*/
+	r871x_wx_set_gen_ie,		/* SIOCSIWGENIE */
+	NULL,				/* SIOCGIWGENIE */
+	r871x_wx_set_auth,		/* SIOCSIWAUTH */
+	NULL,				/* SIOCGIWAUTH */
+	r871x_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
+	NULL,				/* SIOCGIWENCODEEXT */
+	r871x_wx_set_pmkid,		/* SIOCSIWPMKSA */
+	NULL,				/*---hole---*/
+};
+
+static const struct iw_priv_args r8711_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "read32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "write32"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "chplan"
+	}
+};
+
+static iw_handler r8711_private_handler[] = {
+	r8711_wx_read32,
+	r8711_wx_write32,
+	r8711_drvext_hdl,
+	r871x_mp_ioctl_hdl,
+	r871x_get_ap_info, /*for MM DTV platform*/
+	r871x_set_pid,
+	r871x_wps_start,
+	r871x_set_chplan
+};
+
+static struct iw_statistics *r871x_get_wireless_stats(struct net_device *dev)
+{
+	struct _adapter *padapter = (struct _adapter *) netdev_priv(dev);
+	struct iw_statistics *piwstats = &padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true) {
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+	} else {
+		/* show percentage, we need transfer dbm to orignal value. */
+		tmp_level = padapter->recvpriv.fw_rssi;
+		tmp_qual = padapter->recvpriv.signal;
+		tmp_noise = padapter->recvpriv.noise;
+		piwstats->qual.level = tmp_level;
+		/*piwstats->qual.qual = tmp_qual;
+		 * The NetworkManager of Fedora 10, 13 will use the link
+		 * quality for its display.
+		 * So, use the fw_rssi on link quality variable because
+		 * fw_rssi will be updated per 2 seconds.
+		 */
+		piwstats->qual.qual = tmp_level;
+		piwstats->qual.noise = tmp_noise;
+	}
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED;
+	return &padapter->iwstats;
+}
+
+struct iw_handler_def r871x_handlers_def = {
+	.standard = r8711_handlers,
+	.num_standard = sizeof(r8711_handlers) / sizeof(iw_handler),
+	.private = r8711_private_handler,
+	.private_args = (struct iw_priv_args *)r8711_private_args,
+	.num_private = sizeof(r8711_private_handler) / sizeof(iw_handler),
+	.num_private_args = sizeof(r8711_private_args) /
+			    sizeof(struct iw_priv_args),
+	.get_wireless_stats = r871x_get_wireless_stats
+};
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_rtl.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,535 @@
+/******************************************************************************
+ * rtl871x_ioctl_rtl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define  _RTL871X_IOCTL_RTL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+#include "wifi.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_set.h"
+#include "rtl871x_ioctl_rtl.h"
+#include "mp_custom_oid.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_mp_ioctl.h"
+
+uint oid_rt_get_signal_quality_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_small_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				padapter->recvpriv.rx_smallpacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				padapter->recvpriv.rx_middlepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_large_packet_crc_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+				 padapter->recvpriv.rx_largepacket_crcerr;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_retry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_retry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_total_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >=  sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					 padapter->recvpriv.rx_pkts +
+					 padapter->recvpriv.rx_drop;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_rx_icv_err_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(uint *)poid_par_priv->information_buf =
+					 padapter->recvpriv.rx_icv_err;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH ;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_preamble_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	u32 preamblemode = 0 ;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		if (padapter->registrypriv.preamble == PREAMBLE_LONG)
+			preamblemode = 0;
+		else if (padapter->registrypriv.preamble == PREAMBLE_AUTO)
+			preamblemode = 1;
+		else if (padapter->registrypriv.preamble == PREAMBLE_SHORT)
+			preamblemode = 2;
+		*(u32 *)poid_par_priv->information_buf = preamblemode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_ap_ip_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channelplan_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct eeprom_priv *peeprompriv = &padapter->eeprompriv;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	*(u16 *)poid_par_priv->information_buf = peeprompriv->channel_plan;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_channelplan_hdl(struct oid_par_priv
+				       *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct eeprom_priv *peeprompriv = &padapter->eeprompriv;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	peeprompriv->channel_plan = *(u16 *)poid_par_priv->information_buf;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_preamble_mode_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	u32 preamblemode = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		preamblemode = *(u32 *)poid_par_priv->information_buf;
+		if (preamblemode == 0)
+			padapter->registrypriv.preamble = PREAMBLE_LONG;
+		else if (preamblemode == 1)
+			padapter->registrypriv.preamble = PREAMBLE_AUTO;
+		else if (preamblemode == 2)
+			padapter->registrypriv.preamble = PREAMBLE_SHORT;
+		*(u32 *)poid_par_priv->information_buf = preamblemode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_bcn_intvl_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_dedicate_probe_hdl(struct oid_par_priv
+				      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+						 padapter->xmitpriv.tx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					   padapter->recvpriv.rx_bytes;
+		*poid_par_priv->bytes_rw = poid_par_priv->
+					   information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_current_tx_power_level_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv
+						  *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channel_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				    (poid_par_priv->adapter_context);
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct NDIS_802_11_CONFIGURATION *pnic_Config;
+	u32   channelnum;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
+		pnic_Config = &pmlmepriv->cur_network.network.Configuration;
+	else
+		pnic_Config = &padapter->registrypriv.dev_network.
+			      Configuration;
+	channelnum = pnic_Config->DSConfig;
+	*(u32 *)poid_par_priv->information_buf = channelnum;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv
+			 *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_key_mismatch_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_supported_wireless_mode_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	u32 ulInfo = 0;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len >= sizeof(u32)) {
+		ulInfo |= 0x0100; /* WIRELESS_MODE_B */
+		ulInfo |= 0x0200; /* WIRELESS_MODE_G */
+		ulInfo |= 0x0400; /* WIRELESS_MODE_A */
+		*(u32 *) poid_par_priv->information_buf = ulInfo;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		return NDIS_STATUS_INVALID_LENGTH;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_channel_list_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_scan_in_progress_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+
+uint oid_rt_forced_data_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv
+						   *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv
+						      *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv*
+					      poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_supported_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_ap_set_passphrase_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv*
+					     poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+			(poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID) /* QUERY_OID */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len ==
+	   (sizeof(unsigned long) * 3)) {
+		if (!r8712_setrfreg_cmd(Adapter,
+			*(unsigned char *)poid_par_priv->information_buf,
+			(unsigned long)(*((unsigned long *)
+					poid_par_priv->information_buf + 2))))
+			status = NDIS_STATUS_NOT_ACCEPTED;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+			(poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID) /* QUERY_OID */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len == (sizeof(unsigned long)*3)) {
+		if (Adapter->mppriv.act_in_progress == true)
+			status = NDIS_STATUS_NOT_ACCEPTED;
+		else {
+			/* init workparam */
+			Adapter->mppriv.act_in_progress = true;
+			Adapter->mppriv.workparam.bcompleted = false;
+			Adapter->mppriv.workparam.act_type = MPT_READ_RF;
+			Adapter->mppriv.workparam.io_offset = *(unsigned long *)
+						poid_par_priv->information_buf;
+			Adapter->mppriv.workparam.io_value = 0xcccccccc;
+
+		/* RegOffsetValue	- The offset of RF register to read.
+		 * RegDataWidth	- The data width of RF register to read.
+		 * RegDataValue	- The value to read.
+		 * RegOffsetValue = *((unsigned long *)InformationBuffer);
+		 * RegDataWidth = *((unsigned long *)InformationBuffer+1);
+		 * RegDataValue =  *((unsigned long *)InformationBuffer+2);
+		 */
+			if (!r8712_getrfreg_cmd(Adapter,
+			    *(unsigned char *)poid_par_priv->information_buf,
+			    (unsigned char *)&Adapter->mppriv.workparam.
+			    io_value))
+				status = NDIS_STATUS_NOT_ACCEPTED;
+		}
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+enum _CONNECT_STATE_ {
+	CHECKINGSTATUS,
+	ASSOCIATED,
+	ADHOCMODE,
+	NOTASSOCIATED
+};
+
+uint oid_rt_get_connect_state_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *padapter = (struct _adapter *)
+				     (poid_par_priv->adapter_context);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u32 ulInfo;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	/* nStatus==0	CheckingStatus
+	 * nStatus==1	Associated
+	 * nStatus==2	AdHocMode
+	 * nStatus==3	NotAssociated
+	 */
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		ulInfo = CHECKINGSTATUS;
+	else if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+		ulInfo = ASSOCIATED;
+	else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+		ulInfo = ADHOCMODE;
+	else
+		ulInfo = NOTASSOCIATED ;
+	*(u32 *)poid_par_priv->information_buf = ulInfo;
+	*poid_par_priv->bytes_rw =  poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_set_default_key_id_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_rtl.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,121 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_IOCTL_RTL_H
+#define _RTL871X_IOCTL_RTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/*************** oid_rtl_seg_01_01 **************/
+uint oid_rt_get_signal_quality_hdl(
+			struct oid_par_priv *poid_par_priv);/*84*/
+uint oid_rt_get_small_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_middle_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_large_packet_crc_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_retry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_retry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_total_packet_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_beacon_ok_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_tx_beacon_err_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_rx_icv_err_hdl(
+			struct oid_par_priv *poid_par_priv);/*93*/
+uint oid_rt_set_encryption_algorithm_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_preamble_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_ap_ip_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channelplan_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_channelplan_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_preamble_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_bcn_intvl_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_dedicate_probe_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_total_tx_bytes_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_total_rx_bytes_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_current_tx_power_level_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_enc_key_mismatch_count_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_enc_key_match_count_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channel_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_hardware_radio_off_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_key_mismatch_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_supported_wireless_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_channel_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_scan_in_progress_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_forced_data_rate_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_wireless_mode_for_scan_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_bss_wireless_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_scan_with_magic_packet_hdl(
+			struct oid_par_priv *poid_par_priv);
+
+/**************  oid_rtl_seg_01_03 section start **************/
+uint oid_rt_ap_get_associated_station_list_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_switch_into_ap_mode_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_supported_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_ap_set_passphrase_hdl(
+			struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_01_11 */
+uint oid_rt_pro_rf_write_registry_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rf_read_registry_hdl(
+			struct oid_par_priv *poid_par_priv);
+/***************  oid_rtl_seg_03_00 section start **************/
+uint oid_rt_get_connect_state_hdl(
+			struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_default_key_id_hdl(
+			struct oid_par_priv *poid_par_priv);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_set.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_set.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_set.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_set.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,381 @@
+/******************************************************************************
+ * rtl871x_ioctl_set.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_IOCTL_SET_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_ioctl_set.h"
+#include "usb_osintf.h"
+#include "usb_ops.h"
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+( \
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
+	 (addr[2] == 0xff) && (addr[3] == 0xff) && \
+	 (addr[4] == 0xff) && (addr[5] == 0xff)) ? true : false \
+)
+
+static u8 validate_ssid(struct ndis_802_11_ssid *ssid)
+{
+	u8 i;
+
+	if (ssid->SsidLength > 32)
+		return false;
+	for (i = 0; i < ssid->SsidLength; i++) {
+		/* wifi, printable ascii code must be supported */
+		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e)))
+			return false;
+	}
+	return true;
+}
+
+static u8 do_join(struct _adapter *padapter)
+{
+	struct list_head *plist, *phead;
+	u8 *pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct  __queue	*queue	= &(pmlmepriv->scanned_queue);
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+	pmlmepriv->cur_network.join_res = -2;
+	pmlmepriv->fw_state |= _FW_UNDER_LINKING;
+	pmlmepriv->pscanned = plist;
+	pmlmepriv->to_join = true;
+
+	/* adhoc mode will start with an empty queue, but skip checking */
+	if (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) &&
+	    _queue_empty(queue)) {
+		if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+			pmlmepriv->fw_state ^= _FW_UNDER_LINKING;
+		/* when set_ssid/set_bssid for do_join(), but scanning queue
+		 * is empty we try to issue sitesurvey firstly
+		 */
+		if (pmlmepriv->sitesurveyctrl.traffic_busy == false)
+			r8712_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid);
+		return true;
+	} else {
+		int ret;
+
+		ret = r8712_select_and_join_from_scan(pmlmepriv);
+		if (ret == _SUCCESS)
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+		else {
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+				/* submit r8712_createbss_cmd to change to an
+				 * ADHOC_MASTER pmlmepriv->lock has been
+				 * acquired by caller...
+				 */
+				struct wlan_bssid_ex *pdev_network =
+					&(padapter->registrypriv.dev_network);
+				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+				pibss = padapter->registrypriv.dev_network.
+					MacAddress;
+				memset(&pdev_network->Ssid, 0,
+					sizeof(struct ndis_802_11_ssid));
+				memcpy(&pdev_network->Ssid,
+					&pmlmepriv->assoc_ssid,
+					sizeof(struct ndis_802_11_ssid));
+				r8712_update_registrypriv_dev_network(padapter);
+				r8712_generate_random_ibss(pibss);
+				if (r8712_createbss_cmd(padapter) != _SUCCESS)
+					return false;
+				pmlmepriv->to_join = false;
+			} else {
+				/* can't associate ; reset under-linking */
+				if (pmlmepriv->fw_state & _FW_UNDER_LINKING)
+					pmlmepriv->fw_state ^=
+							     _FW_UNDER_LINKING;
+				/* when set_ssid/set_bssid for do_join(), but
+				 * there are no desired bss in scanning queue
+				 * we try to issue sitesurvey first
+				 */
+				if (!pmlmepriv->sitesurveyctrl.traffic_busy)
+					r8712_sitesurvey_cmd(padapter,
+						       &pmlmepriv->assoc_ssid);
+			}
+		}
+	}
+	return true;
+}
+
+u8 r8712_set_802_11_bssid(struct _adapter *padapter, u8 *bssid)
+{
+	unsigned long irqL;
+	u8 status = true;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 &&
+	     bssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||
+	    (bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF &&
+	     bssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {
+		status = false;
+		return status;
+	}
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY |
+	    _FW_UNDER_LINKING) == true) {
+		status = check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_BSSID;
+	}
+	if (check_fwstate(pmlmepriv,
+	    _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {
+		if (!memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid,
+		    ETH_ALEN)) {
+			if (check_fwstate(pmlmepriv,
+			    WIFI_STATION_STATE) == false)
+				goto _Abort_Set_BSSID; /* driver is in
+						* WIFI_ADHOC_MASTER_STATE */
+		} else {
+			r8712_disassoc_cmd(padapter);
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				r8712_ind_disconnect(padapter);
+			r8712_free_assoc_resources(padapter);
+			if ((check_fwstate(pmlmepriv,
+			     WIFI_ADHOC_MASTER_STATE))) {
+				_clr_fwstate_(pmlmepriv,
+					      WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+	memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+	pmlmepriv->assoc_by_bssid = true;
+	status = do_join(padapter);
+	goto done;
+_Abort_Set_BSSID:
+done:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return status;
+}
+
+void r8712_set_802_11_ssid(struct _adapter *padapter,
+			   struct ndis_802_11_ssid *ssid)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+
+	if (padapter->hw_init_completed == false)
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {
+		check_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+		goto _Abort_Set_SSID;
+	}
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (!memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid,
+		    ssid->SsidLength))) {
+			if ((check_fwstate(pmlmepriv,
+			     WIFI_STATION_STATE) == false)) {
+				if (r8712_is_same_ibss(padapter,
+				     pnetwork) == false) {
+					/* if in WIFI_ADHOC_MASTER_STATE or
+					 *  WIFI_ADHOC_STATE, create bss or
+					 * rejoin again
+					 */
+					r8712_disassoc_cmd(padapter);
+					if (check_fwstate(pmlmepriv,
+					    _FW_LINKED) == true)
+						r8712_ind_disconnect(padapter);
+					r8712_free_assoc_resources(padapter);
+					if (check_fwstate(pmlmepriv,
+					     WIFI_ADHOC_MASTER_STATE)) {
+						_clr_fwstate_(pmlmepriv,
+						    WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv,
+							    WIFI_ADHOC_STATE);
+					}
+				} else
+					goto _Abort_Set_SSID; /* driver is in
+						  * WIFI_ADHOC_MASTER_STATE */
+			}
+		} else {
+			r8712_disassoc_cmd(padapter);
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				r8712_ind_disconnect(padapter);
+			r8712_free_assoc_resources(padapter);
+			if (check_fwstate(pmlmepriv,
+			    WIFI_ADHOC_MASTER_STATE) == true) {
+				_clr_fwstate_(pmlmepriv,
+					      WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+	if (padapter->securitypriv.btkip_countermeasure == true)
+		goto _Abort_Set_SSID;
+	if (validate_ssid(ssid) == false)
+		goto _Abort_Set_SSID;
+	memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));
+	pmlmepriv->assoc_by_bssid = false;
+	do_join(padapter);
+	goto done;
+_Abort_Set_SSID:
+done:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_set_802_11_infrastructure_mode(struct _adapter *padapter,
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	unsigned long irqL;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state =
+				&(cur_network->network.InfrastructureMode);
+
+	if (*pold_state != networktype) {
+		spin_lock_irqsave(&pmlmepriv->lock, irqL);
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		    (*pold_state == Ndis802_11IBSS))
+			r8712_disassoc_cmd(padapter);
+		if (check_fwstate(pmlmepriv,
+		    _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
+			r8712_free_assoc_resources(padapter);
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		    (*pold_state == Ndis802_11Infrastructure) ||
+		    (*pold_state == Ndis802_11IBSS)) {
+			/* will clr Linked_state before this function,
+			 * we must have chked whether issue dis-assoc_cmd or
+			 * not */
+			r8712_ind_disconnect(padapter);
+		}
+		*pold_state = networktype;
+		/* clear WIFI_STATION_STATE; WIFI_AP_STATE; WIFI_ADHOC_STATE;
+		 * WIFI_ADHOC_MASTER_STATE */
+		_clr_fwstate_(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE |
+			      WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE |
+			      WIFI_AP_STATE);
+		switch (networktype) {
+		case Ndis802_11IBSS:
+			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			break;
+		case Ndis802_11Infrastructure:
+			set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+			break;
+		case Ndis802_11APMode:
+			set_fwstate(pmlmepriv, WIFI_AP_STATE);
+			break;
+		case Ndis802_11AutoUnknown:
+		case Ndis802_11InfrastructureMax:
+			break;
+		}
+		spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	}
+}
+
+u8 r8712_set_802_11_disassociate(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		r8712_disassoc_cmd(padapter);
+		r8712_ind_disconnect(padapter);
+		r8712_free_assoc_resources(padapter);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return true;
+}
+
+u8 r8712_set_802_11_bssid_list_scan(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = NULL;
+	unsigned long irqL;
+	u8 ret = true;
+
+	if (padapter == NULL)
+		return false;
+	pmlmepriv = &padapter->mlmepriv;
+	if (padapter->hw_init_completed == false)
+		return false;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||
+	    (pmlmepriv->sitesurveyctrl.traffic_busy == true)) {
+		/* Scan or linking is in progress, do nothing. */
+		ret = (u8)check_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+	} else {
+		r8712_free_network_queue(padapter);
+		ret = r8712_sitesurvey_cmd(padapter, NULL);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return ret;
+}
+
+u8 r8712_set_802_11_authentication_mode(struct _adapter *padapter,
+				enum NDIS_802_11_AUTHENTICATION_MODE authmode)
+{
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u8 ret;
+
+	psecuritypriv->ndisauthtype = authmode;
+	if (psecuritypriv->ndisauthtype > 3)
+		psecuritypriv->AuthAlgrthm = 2; /* 802.1x */
+	if (r8712_set_auth(padapter, psecuritypriv) == _SUCCESS)
+		ret = true;
+	else
+		ret = false;
+	return ret;
+}
+
+u8 r8712_set_802_11_add_wep(struct _adapter *padapter,
+			    struct NDIS_802_11_WEP *wep)
+{
+	u8	bdefaultkey;
+	u8	btransmitkey;
+	sint	keyid;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	bdefaultkey = (wep->KeyIndex & 0x40000000) > 0 ? false : true;
+	btransmitkey = (wep->KeyIndex & 0x80000000) > 0 ? true : false;
+	keyid = wep->KeyIndex & 0x3fffffff;
+	if (keyid >= WEP_KEYS)
+		return false;
+	switch (wep->KeyLength) {
+	case 5:
+		psecuritypriv->PrivacyAlgrthm = _WEP40_;
+		break;
+	case 13:
+		psecuritypriv->PrivacyAlgrthm = _WEP104_;
+		break;
+	default:
+		psecuritypriv->PrivacyAlgrthm = _NO_PRIVACY_;
+		break;
+	}
+	memcpy(psecuritypriv->DefKey[keyid].skey, &wep->KeyMaterial,
+		wep->KeyLength);
+	psecuritypriv->DefKeylen[keyid] = wep->KeyLength;
+	psecuritypriv->PrivacyKeyIndex = keyid;
+	if (r8712_set_key(padapter, psecuritypriv, keyid) == _FAIL)
+		return false;
+	return _SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_set.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_set.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_ioctl_set.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_ioctl_set.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_SET_H
+#define __IOCTL_SET_H
+
+#include "drv_types.h"
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+struct BSSIDInfo {
+	unsigned char BSSID[6];
+	NDIS_802_11_PMKID_VALUE PMKID;
+};
+
+u8 r8712_set_802_11_authentication_mode(struct _adapter *pdapter,
+			enum NDIS_802_11_AUTHENTICATION_MODE authmode);
+
+u8 r8712_set_802_11_bssid(struct _adapter *padapter, u8 *bssid);
+
+u8 r8712_set_802_11_add_wep(struct _adapter *padapter,
+			    struct NDIS_802_11_WEP *wep);
+
+u8 r8712_set_802_11_disassociate(struct _adapter *padapter);
+
+u8 r8712_set_802_11_bssid_list_scan(struct _adapter *padapter);
+
+void r8712_set_802_11_infrastructure_mode(struct _adapter *padapter,
+			enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+
+void r8712_set_802_11_ssid(struct _adapter *padapter,
+			   struct ndis_802_11_ssid *ssid);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_io.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_io.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_io.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_io.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,258 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _IO_H_
+#define _IO_H_
+
+#include "osdep_service.h"
+#include "osdep_intf.h"
+
+#define NUM_IOREQ		8
+
+#define MAX_PROT_SZ	(64-16)
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+/* IO COMMAND TYPE */
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+/* IO STATUS TYPE */
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+/*
+	Only Sync. burst accessing is provided.
+*/
+#define IO_WR_BURST(x)		(IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | \
+				((x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+/*below is for the intf_option bit defition...*/
+#define _INTF_ASYNC_	BIT(0)	/*support async io*/
+struct intf_priv;
+struct	intf_hdl;
+struct io_queue;
+struct	_io_ops {
+	uint (*_sdbus_read_bytes_to_membuf)(struct intf_priv *pintfpriv,
+					    u32 addr, u32 cnt, u8 *pbuf);
+	uint (*_sdbus_read_blocks_to_membuf)(struct intf_priv *pintfpriv,
+					     u32 addr, u32 cnt, u8 *pbuf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+	uint (*_sdbus_write_blocks_from_membuf)(struct intf_priv *pintfpriv,
+						u32 addr, u32 cnt, u8 *pbuf,
+						u8 async);
+	uint (*_sdbus_write_bytes_from_membuf)(struct intf_priv *pintfpriv,
+					       u32 addr, u32 cnt, u8 *pbuf);
+	u8 (*_cmd52r)(struct intf_priv *pintfpriv, u32 addr);
+	void (*_cmd52w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+	u8 (*_cmdfunc152r)(struct intf_priv *pintfpriv, u32 addr);
+	void (*_cmdfunc152w)(struct intf_priv *pintfpriv, u32 addr, u8 val8);
+	void (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	void (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	void (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+	void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			  u8 *pmem);
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt,
+			   u8 *pmem);
+};
+
+struct io_req {
+	struct list_head list;
+	u32	addr;
+	/*volatile*/ u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;
+	struct semaphore sema;
+	void (*_async_io_callback)(struct _adapter *padater,
+				   struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;
+};
+
+struct	intf_hdl {
+	u32	intf_option;
+	u8	*adapter;
+	u8	*intf_dev;
+	struct intf_priv	*pintfpriv;
+	void (*intf_hdl_init)(u8 *priv);
+	void (*intf_hdl_unload)(u8 *priv);
+	void (*intf_hdl_open)(u8 *priv);
+	void (*intf_hdl_close)(u8 *priv);
+	struct	_io_ops	io_ops;
+};
+
+struct reg_protocol_rd {
+
+#ifdef __LITTLE_ENDIAN
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/*0:read, 1:write*/
+	u32		FixOrContinuous:1;	/*0:continuous, 1: Fix*/
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/*DW3*/
+	u32		BusAddress;
+	/*DW4*/
+#else
+/*DW1*/
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 WriteEnable:1;
+	u32 ByteCount:7;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1 ;
+	u32 FixOrContinuous:1;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+#endif
+};
+
+struct reg_protocol_wt {
+#ifdef __LITTLE_ENDIAN
+	/*DW1*/
+	u32 NumOfTrans:4;
+	u32 Reserved1:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 ByteCount:7;
+	u32 WriteEnable:1;	/*0:read, 1:write*/
+	u32 FixOrContinuous:1;	/*0:continuous, 1: Fix*/
+	u32 BurstMode:1;
+	u32 Byte1Access:1;
+	u32 Byte2Access:1;
+	u32 Byte4Access:1;
+	u32 Reserved3:3;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+	u32 Value;
+#else
+	/*DW1*/
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+	u32 Reserved2:24;
+	/*DW2*/
+	u32 WriteEnable:1;
+	u32 ByteCount:7;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1;
+	u32 FixOrContinuous:1;
+	u32 Reserved4:16;
+	/*DW3*/
+	u32 BusAddress;
+	/*DW4*/
+	u32 Value;
+#endif
+};
+
+/*
+Below is the data structure used by _io_handler
+*/
+
+struct io_queue {
+	spinlock_t lock;
+	struct list_head free_ioreqs;
+	/*The io_req list that will be served in the single protocol r/w.*/
+	struct list_head pending;
+	struct list_head processing;
+	u8 *free_ioreqs_buf; /* 4-byte aligned */
+	u8 *pallocated_free_ioreqs_buf;
+	struct	intf_hdl intf;
+};
+
+static inline u32 _RND4(u32 sz)
+{
+	u32	val;
+	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;
+	return val;
+}
+
+u8 r8712_read8(struct _adapter *adapter, u32 addr);
+u16 r8712_read16(struct _adapter *adapter, u32 addr);
+u32 r8712_read32(struct _adapter *adapter, u32 addr);
+void r8712_read_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_read_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_write8(struct _adapter *adapter, u32 addr, u8 val);
+void r8712_write16(struct _adapter *adapter, u32 addr, u16 val);
+void r8712_write32(struct _adapter *adapter, u32 addr, u32 val);
+void r8712_write_mem(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+void r8712_write_port(struct _adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+/*ioreq */
+uint r8712_alloc_io_queue(struct _adapter *adapter);
+void r8712_free_io_queue(struct _adapter *adapter);
+
+#endif	/*_RTL8711_IO_H_*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_led.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_led.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_led.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_led.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,124 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL8712_LED_H
+#define __RTL8712_LED_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+/*===========================================================================
+ * LED customization.
+ *===========================================================================
+ */
+enum LED_CTL_MODE {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11,
+	LED_CTL_STOP_WPS_FAIL = 12,
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13,
+};
+
+#define IS_LED_WPS_BLINKING(_LED_871x)	\
+	(((struct LED_871x *)_LED_871x)->CurrLedState == LED_BLINK_WPS \
+	|| ((struct LED_871x *)_LED_871x)->CurrLedState == LED_BLINK_WPS_STOP \
+	|| ((struct LED_871x *)_LED_871x)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_871x)	\
+		(((struct LED_871x *)_LED_871x)->bLedWPSBlinkInProgress \
+		|| ((struct LED_871x *)_LED_871x)->bLedScanBlinkInProgress)
+
+enum LED_PIN_871x {
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1
+};
+
+/*===========================================================================
+ * LED customization.
+ *===========================================================================
+ */
+enum LED_STRATEGY_871x {
+	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
+	SW_LED_MODE1, /* 2 LEDs, through LED0 and LED1. For ALPHA. */
+	SW_LED_MODE2, /* SW control 1 LED via GPIO0,
+		       * custom for AzWave 8187 minicard. */
+	SW_LED_MODE3, /* SW control 1 LED via GPIO0,
+		       *  customized for Sercomm Printer Server case.*/
+	SW_LED_MODE4, /*for Edimax / Belkin*/
+	SW_LED_MODE5, /*for Sercomm / Belkin*/
+	SW_LED_MODE6, /*for WNC / Corega*/
+	HW_LED, /* HW control 2 LEDs, LED0 and LED1 (there are 4 different
+		 * control modes, see MAC.CONFIG1 for details.)*/
+};
+
+struct LED_871x {
+	struct _adapter		*padapter;
+	enum LED_PIN_871x	LedPin;	/* Implementation for this SW led. */
+	u32			CurrLedState; /* Current LED state. */
+	u8			bLedOn; /* true if LED is ON */
+	u8			bSWLedCtrl;
+	u8			bLedBlinkInProgress; /*true if blinking */
+	u8			bLedNoLinkBlinkInProgress;
+	u8			bLedLinkBlinkInProgress;
+	u8			bLedStartToLinkBlinkInProgress;
+	u8			bLedScanBlinkInProgress;
+	u8			bLedWPSBlinkInProgress;
+	u32			BlinkTimes; /* No. times to toggle for blink.*/
+	u32			BlinkingLedState; /* Next state for blinking,
+						   * either LED_ON or OFF.*/
+
+	struct timer_list	BlinkTimer; /* Timer object for led blinking.*/
+	_workitem		BlinkWorkItem; /* Workitem used by BlinkTimer */
+};
+
+struct led_priv {
+	/* add for led control */
+	struct LED_871x		SwLed0;
+	struct LED_871x		SwLed1;
+	enum LED_STRATEGY_871x	LedStrategy;
+	u8			bRegUseLed;
+	void (*LedControlHandler)(struct _adapter *padapter,
+				  enum LED_CTL_MODE LedAction);
+	/* add for led control */
+};
+
+/*===========================================================================
+ * Interface to manipulate LED objects.
+ *===========================================================================*/
+void r8712_InitSwLeds(struct _adapter *padapter);
+void r8712_DeInitSwLeds(struct _adapter *padapter);
+void LedControl871x(struct _adapter *padapter, enum LED_CTL_MODE LedAction);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mlme.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mlme.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mlme.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mlme.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1818 @@
+/******************************************************************************
+ * rtl871x_mlme.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_MLME_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "mlme_osdep.h"
+#include "sta_info.h"
+#include "wifi.h"
+#include "wlan_bssdef.h"
+
+static void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len);
+
+static sint _init_mlme_priv(struct _adapter *padapter)
+{
+	sint	i;
+	u8	*pbuf;
+	struct wlan_network	*pnetwork;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	pmlmepriv->nic_hdl = (u8 *)padapter;
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode =
+				 Ndis802_11AutoUnknown;
+	/* Maybe someday we should rename this variable to "active_mode"(Jeff)*/
+	pmlmepriv->passive_mode = 1; /* 1: active, 0: passive. */
+	spin_lock_init(&(pmlmepriv->lock));
+	spin_lock_init(&(pmlmepriv->lock2));
+	_init_queue(&(pmlmepriv->free_bss_pool));
+	_init_queue(&(pmlmepriv->scanned_queue));
+	set_scanned_network_val(pmlmepriv, 0);
+	memset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));
+	pbuf = _malloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+	if (pbuf == NULL)
+		return _FAIL;
+	pmlmepriv->free_bss_buf = pbuf;
+	pnetwork = (struct wlan_network *)pbuf;
+	for (i = 0; i < MAX_BSS_CNT; i++) {
+		_init_listhead(&(pnetwork->list));
+		list_insert_tail(&(pnetwork->list),
+				 &(pmlmepriv->free_bss_pool.queue));
+		pnetwork++;
+	}
+	pmlmepriv->sitesurveyctrl.last_rx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.last_tx_pkts = 0;
+	pmlmepriv->sitesurveyctrl.traffic_busy = false;
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	r8712_init_mlme_timer(padapter);
+	return _SUCCESS;
+}
+
+struct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+	struct wlan_network *pnetwork;
+	struct  __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct list_head *plist = NULL;
+
+	if (_queue_empty(free_queue) == true)
+		return NULL;
+	spin_lock_irqsave(&free_queue->lock, irqL);
+	plist = get_next(&(free_queue->queue));
+	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
+	list_delete(&pnetwork->list);
+	pnetwork->last_scanned = jiffies;
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_irqrestore(&free_queue->lock, irqL);
+	return pnetwork;
+}
+
+static void _free_network(struct mlme_priv *pmlmepriv,
+			  struct wlan_network *pnetwork)
+{
+	u32 curr_time, delta_time;
+	unsigned long irqL;
+	struct  __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		return;
+	if (pnetwork->fixed == true)
+		return;
+	curr_time = jiffies;
+	delta_time = (curr_time - (u32)pnetwork->last_scanned) / HZ;
+	if (delta_time < SCANQUEUE_LIFETIME)
+		return;
+	spin_lock_irqsave(&free_queue->lock, irqL);
+	list_delete(&pnetwork->list);
+	list_insert_tail(&pnetwork->list, &free_queue->queue);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_irqrestore(&free_queue->lock, irqL);
+}
+
+static void _free_network_nolock(struct mlme_priv *pmlmepriv,
+			  struct wlan_network *pnetwork)
+{
+	struct  __queue *free_queue = &pmlmepriv->free_bss_pool;
+
+	if (pnetwork == NULL)
+		return;
+	if (pnetwork->fixed == true)
+		return;
+	list_delete(&pnetwork->list);
+	list_insert_tail(&pnetwork->list, get_list_head(free_queue));
+	pmlmepriv->num_of_scanned--;
+}
+
+
+/*
+	return the wlan_network with the matching addr
+	Shall be calle under atomic context...
+	to avoid possible racing condition...
+*/
+static struct wlan_network *_r8712_find_network(struct  __queue *scanned_queue,
+					 u8 *addr)
+{
+	unsigned long irqL;
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork = NULL;
+	u8 zero_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
+
+	if (!memcmp(zero_addr, addr, ETH_ALEN))
+		return NULL;
+	spin_lock_irqsave(&scanned_queue->lock, irqL);
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (plist != phead) {
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		if (!memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN))
+			break;
+	}
+	spin_unlock_irqrestore(&scanned_queue->lock, irqL);
+	return pnetwork;
+}
+
+static void _free_network_queue(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct  __queue *scanned_queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_irqsave(&scanned_queue->lock, irqL);
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		_free_network(pmlmepriv, pnetwork);
+	}
+	spin_unlock_irqrestore(&scanned_queue->lock, irqL);
+}
+
+sint r8712_if_up(struct _adapter *padapter)
+{
+	sint res;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false)) {
+		res = false;
+	} else
+		res = true;
+	return res;
+}
+
+void r8712_generate_random_ibss(u8 *pibss)
+{
+	u32 curtime = jiffies;
+
+	pibss[0] = 0x02; /*in ad-hoc mode bit1 must set to 1 */
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (u8)(curtime & 0xff);
+	pibss[4] = (u8)((curtime>>8) & 0xff);
+	pibss[5] = (u8)((curtime>>16) & 0xff);
+}
+
+uint r8712_get_ndis_wlan_bssid_ex_sz(struct ndis_wlan_bssid_ex *bss)
+{
+	uint t_len;
+
+	t_len = sizeof(u32) + 6 * sizeof(unsigned long) + 2 +
+			sizeof(struct ndis_802_11_ssid) + sizeof(u32) +
+			sizeof(s32) +
+			sizeof(enum NDIS_802_11_NETWORK_TYPE) +
+			sizeof(struct NDIS_802_11_CONFIGURATION) +
+			sizeof(enum NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof(NDIS_802_11_RATES_EX) +
+			sizeof(u32) + bss->IELength;
+	return t_len;
+}
+
+u8 *r8712_get_capability_from_ie(u8 *ie)
+{
+	return ie + 8 + 2;
+}
+
+int r8712_init_mlme_priv(struct _adapter *padapter)
+{
+	return _init_mlme_priv(padapter);
+}
+
+void r8712_free_mlme_priv(struct mlme_priv *pmlmepriv)
+{
+	kfree(pmlmepriv->free_bss_buf);
+}
+
+static struct	wlan_network *alloc_network(struct mlme_priv *pmlmepriv)
+{
+	return _r8712_alloc_network(pmlmepriv);
+}
+
+static void free_network_nolock(struct mlme_priv *pmlmepriv,
+			 struct wlan_network *pnetwork)
+{
+	_free_network_nolock(pmlmepriv, pnetwork);
+}
+
+void r8712_free_network_queue(struct _adapter *dev)
+{
+	_free_network_queue(dev);
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context...
+	to avoid possible racing condition...
+*/
+static struct wlan_network *r8712_find_network(struct  __queue *scanned_queue,
+					       u8 *addr)
+{
+	struct wlan_network *pnetwork = _r8712_find_network(scanned_queue,
+							    addr);
+
+	return pnetwork;
+}
+
+int r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork)
+{
+	int ret = true;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&
+		    (pnetwork->network.Privacy == 0))
+		ret = false;
+	else if ((psecuritypriv->PrivacyAlgrthm == _NO_PRIVACY_) &&
+		 (pnetwork->network.Privacy == 1))
+		ret = false;
+	else
+		ret = true;
+	return ret;
+
+}
+
+static int is_same_network(struct ndis_wlan_bssid_ex *src,
+			   struct ndis_wlan_bssid_ex *dst)
+{
+	 u16 s_cap, d_cap;
+
+	memcpy((u8 *)&s_cap, r8712_get_capability_from_ie(src->IEs), 2);
+	memcpy((u8 *)&d_cap, r8712_get_capability_from_ie(dst->IEs), 2);
+	return (src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+			(src->Configuration.DSConfig ==
+			dst->Configuration.DSConfig) &&
+			((!memcmp(src->MacAddress, dst->MacAddress,
+			ETH_ALEN))) &&
+			((!memcmp(src->Ssid.Ssid,
+			  dst->Ssid.Ssid,
+			  src->Ssid.SsidLength))) &&
+			((s_cap & WLAN_CAPABILITY_IBSS) ==
+			(d_cap & WLAN_CAPABILITY_IBSS)) &&
+			((s_cap & WLAN_CAPABILITY_BSS) ==
+			(d_cap & WLAN_CAPABILITY_BSS));
+
+}
+
+struct	wlan_network *r8712_get_oldest_wlan_network(
+				struct  __queue *scanned_queue)
+{
+	struct list_head *plist, *phead;
+	struct	wlan_network	*pwlan = NULL;
+	struct	wlan_network	*oldest = NULL;
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, plist) ==  true)
+			break;
+		pwlan = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (pwlan->fixed != true) {
+			if (oldest == NULL ||
+			    time_after((unsigned long)oldest->last_scanned,
+			    (unsigned long)pwlan->last_scanned))
+				oldest = pwlan;
+		}
+		plist = get_next(plist);
+	}
+	return oldest;
+}
+
+static void update_network(struct ndis_wlan_bssid_ex *dst,
+			   struct ndis_wlan_bssid_ex *src,
+			   struct _adapter *padapter)
+{
+	u32 last_evm = 0, tmpVal;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) &&
+	    is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {
+		if (padapter->recvpriv.signal_qual_data.total_num++ >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX) {
+			padapter->recvpriv.signal_qual_data.total_num =
+				   PHY_LINKQUALITY_SLID_WIN_MAX;
+			last_evm = padapter->recvpriv.signal_qual_data.
+				   elements[padapter->recvpriv.
+				   signal_qual_data.index];
+			padapter->recvpriv.signal_qual_data.total_val -=
+				 last_evm;
+		}
+		padapter->recvpriv.signal_qual_data.total_val += src->Rssi;
+
+		padapter->recvpriv.signal_qual_data.
+			  elements[padapter->recvpriv.signal_qual_data.
+			  index++] = src->Rssi;
+		if (padapter->recvpriv.signal_qual_data.index >=
+		    PHY_LINKQUALITY_SLID_WIN_MAX)
+			padapter->recvpriv.signal_qual_data.index = 0;
+		/* <1> Showed on UI for user, in percentage. */
+		tmpVal = padapter->recvpriv.signal_qual_data.total_val /
+			 padapter->recvpriv.signal_qual_data.total_num;
+		padapter->recvpriv.signal = (u8)tmpVal;
+
+		src->Rssi = padapter->recvpriv.signal;
+	} else
+		src->Rssi = (src->Rssi + dst->Rssi) / 2;
+	memcpy((u8 *)dst, (u8 *)src, r8712_get_ndis_wlan_bssid_ex_sz(src));
+}
+
+static void update_current_network(struct _adapter *adapter,
+				   struct ndis_wlan_bssid_ex *pnetwork)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	if (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)) {
+		update_network(&(pmlmepriv->cur_network.network),
+			       pnetwork, adapter);
+		r8712_update_protection(adapter,
+			       (pmlmepriv->cur_network.network.IEs) +
+			       sizeof(struct NDIS_802_11_FIXED_IEs),
+			       pmlmepriv->cur_network.network.IELength);
+	}
+}
+
+/*
+Caller must hold pmlmepriv->lock first.
+*/
+static void update_scanned_network(struct _adapter *adapter,
+			    struct ndis_wlan_bssid_ex *target)
+{
+	struct list_head *plist, *phead;
+
+	u32 bssid_ex_sz;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *oldest = NULL;
+
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1) {
+		if (end_of_queue_search(phead, plist) == true)
+			break;
+
+		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+		if (is_same_network(&pnetwork->network, target))
+			break;
+		if ((oldest == ((struct wlan_network *)0)) ||
+		    time_after((unsigned long)oldest->last_scanned,
+				(unsigned long)pnetwork->last_scanned))
+			oldest = pnetwork;
+
+		plist = get_next(plist);
+	}
+
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (end_of_queue_search(phead, plist) == true) {
+		if (_queue_empty(&pmlmepriv->free_bss_pool) == true) {
+			/* If there are no more slots, expire the oldest */
+			pnetwork = oldest;
+			target->Rssi = (pnetwork->network.Rssi +
+					target->Rssi) / 2;
+			memcpy(&pnetwork->network, target,
+				r8712_get_ndis_wlan_bssid_ex_sz(target));
+			pnetwork->last_scanned = jiffies;
+		} else {
+			/* Otherwise just pull from the free list */
+			/* update scan_time */
+			pnetwork = alloc_network(pmlmepriv);
+			if (pnetwork == NULL)
+				return;
+			bssid_ex_sz = r8712_get_ndis_wlan_bssid_ex_sz(target);
+			target->Length = bssid_ex_sz;
+			memcpy(&pnetwork->network, target, bssid_ex_sz);
+			list_insert_tail(&pnetwork->list, &queue->queue);
+		}
+	} else {
+		/* we have an entry and we are going to update it. But
+		 * this entry may be already expired. In this case we
+		 * do the same as we found a new net and call the new_net
+		 * handler
+		 */
+		update_network(&pnetwork->network, target, adapter);
+		pnetwork->last_scanned = jiffies;
+	}
+}
+
+static void rtl8711_add_network(struct _adapter *adapter,
+			 struct ndis_wlan_bssid_ex *pnetwork)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &(((struct _adapter *)adapter)->mlmepriv);
+	struct  __queue *queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_irqsave(&queue->lock, irqL);
+	update_current_network(adapter, pnetwork);
+	update_scanned_network(adapter, pnetwork);
+	spin_unlock_irqrestore(&queue->lock, irqL);
+}
+
+/*select the desired network based on the capability of the (i)bss.
+ * check items:		(1) security
+ *			(2) network_type
+ *			(3) WMM
+ *			(4) HT
+ *			(5) others
+ */
+static int is_desired_network(struct _adapter *adapter,
+				struct wlan_network *pnetwork)
+{
+	u8 wps_ie[512];
+	uint wps_ielen;
+	int bselected = true;
+	struct	security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if (psecuritypriv->wps_phase == true) {
+		if (r8712_get_wps_ie(pnetwork->network.IEs,
+		    pnetwork->network.IELength, wps_ie,
+		    &wps_ielen) == true)
+			return true;
+		else
+			return false;
+	}
+	if ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&
+		    (pnetwork->network.Privacy == 0))
+		bselected = false;
+	if (check_fwstate(&adapter->mlmepriv, WIFI_ADHOC_STATE) == true) {
+		if (pnetwork->network.InfrastructureMode !=
+			adapter->mlmepriv.cur_network.network.
+			InfrastructureMode)
+			bselected = false;
+	}
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void r8712_atimdone_event_callback(struct _adapter *adapter , u8 *pbuf)
+{
+}
+
+void r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long flags;
+	u32 len;
+	struct ndis_wlan_bssid_ex *pnetwork;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	pnetwork = (struct ndis_wlan_bssid_ex *)pbuf;
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow =
+		 le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	pnetwork->Configuration.BeaconPeriod =
+		 le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =
+		 le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length =
+		 le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length =
+		 le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode =
+		 le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+	len = r8712_get_ndis_wlan_bssid_ex_sz(pnetwork);
+	if (len > sizeof(struct wlan_bssid_ex))
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock2, flags);
+	/* update IBSS_network 's timestamp */
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+		if (!memcmp(&(pmlmepriv->cur_network.network.MacAddress),
+		    pnetwork->MacAddress, ETH_ALEN)) {
+			struct wlan_network *ibss_wlan = NULL;
+
+			memcpy(pmlmepriv->cur_network.network.IEs,
+				pnetwork->IEs, 8);
+			ibss_wlan = r8712_find_network(
+						&pmlmepriv->scanned_queue,
+						pnetwork->MacAddress);
+			if (ibss_wlan) {
+				memcpy(ibss_wlan->network.IEs,
+					pnetwork->IEs, 8);
+				goto exit;
+			}
+		}
+	}
+	/* lock pmlmepriv->lock when you accessing network_q */
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == false) {
+		if (pnetwork->Ssid.Ssid[0] != 0)
+			rtl8711_add_network(adapter, pnetwork);
+		else {
+			pnetwork->Ssid.SsidLength = 8;
+			memcpy(pnetwork->Ssid.Ssid, "<hidden>", 8);
+			rtl8711_add_network(adapter, pnetwork);
+		}
+	}
+exit:
+	spin_unlock_irqrestore(&pmlmepriv->lock2, flags);
+}
+
+void r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		u8 timer_cancelled;
+
+		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	}
+
+	if (pmlmepriv->to_join == true) {
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == false) {
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+				if (r8712_select_and_join_from_scan(pmlmepriv)
+				    == _SUCCESS)
+					_set_timer(&pmlmepriv->assoc_timer,
+						   MAX_JOIN_TIMEOUT);
+				else {
+					struct wlan_bssid_ex *pdev_network =
+					  &(adapter->registrypriv.dev_network);
+					u8 *pibss =
+						 adapter->registrypriv.
+							dev_network.MacAddress;
+					pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;
+					memset(&pdev_network->Ssid, 0,
+						sizeof(struct
+						       ndis_802_11_ssid));
+					memcpy(&pdev_network->Ssid,
+						&pmlmepriv->assoc_ssid,
+						sizeof(struct
+							 ndis_802_11_ssid));
+					r8712_update_registrypriv_dev_network
+						(adapter);
+					r8712_generate_random_ibss(pibss);
+					pmlmepriv->fw_state =
+						 WIFI_ADHOC_MASTER_STATE;
+					pmlmepriv->to_join = false;
+				}
+			}
+		} else {
+			pmlmepriv->to_join = false;
+			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+			if (r8712_select_and_join_from_scan(pmlmepriv) ==
+			    _SUCCESS)
+				_set_timer(&pmlmepriv->assoc_timer,
+					   MAX_JOIN_TIMEOUT);
+			else
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+/*
+ *r8712_free_assoc_resources: the caller has to lock pmlmepriv->lock
+ */
+void r8712_free_assoc_resources(struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct wlan_network *pwlan = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	pwlan = r8712_find_network(&pmlmepriv->scanned_queue,
+				   tgt_network->network.MacAddress);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE)) {
+		struct sta_info *psta;
+
+		psta = r8712_get_stainfo(&adapter->stapriv,
+					 tgt_network->network.MacAddress);
+
+		spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+		r8712_free_stainfo(adapter,  psta);
+		spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+	}
+
+	if (check_fwstate(pmlmepriv,
+	    WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+		r8712_free_all_stainfo(adapter);
+	if (pwlan)
+		pwlan->fixed = false;
+
+	if (((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) &&
+	     (adapter->stapriv.asoc_sta_count == 1)))
+		free_network_nolock(pmlmepriv, pwlan);
+}
+
+/*
+*r8712_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void r8712_indicate_connect(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	pmlmepriv->to_join = false;
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);
+	r8712_os_indicate_connect(padapter);
+	if (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE)
+		_set_timer(&pmlmepriv->dhcp_timer, 60000);
+}
+
+
+/*
+*r8712_ind_disconnect: the caller has to lock pmlmepriv->lock
+*/
+void r8712_ind_disconnect(struct _adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+		padapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);
+		r8712_os_indicate_disconnect(padapter);
+	}
+	if (padapter->pwrctrlpriv.pwr_mode !=
+	    padapter->registrypriv.power_mgnt) {
+		_cancel_timer_ex(&pmlmepriv->dhcp_timer);
+		r8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,
+				  padapter->registrypriv.smart_ps);
+	}
+}
+
+/*Notes:
+ *pnetwork : returns from r8712_joinbss_event_callback
+ *ptarget_wlan: found from scanned_queue
+ *if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if
+ *  "ptarget_sta" & "ptarget_wlan" exist.
+ *if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check
+ * if "ptarget_wlan" exist.
+ *if join_res > 0, update "cur_network->network" from
+ * "pnetwork->network" if (ptarget_wlan !=NULL).
+ */
+void r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL = 0, irqL2;
+	u8 timer_cancelled;
+	struct sta_info	*ptarget_sta = NULL, *pcur_sta = NULL;
+	struct sta_priv	*pstapriv = &adapter->stapriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int		the_same_macaddr = false;
+	struct wlan_network *pnetwork;
+
+	if (sizeof(struct list_head) == 4 * sizeof(u32)) {
+		pnetwork = (struct wlan_network *)
+			_malloc(sizeof(struct wlan_network));
+		memcpy((u8 *)pnetwork+16, (u8 *)pbuf + 8,
+			sizeof(struct wlan_network) - 16);
+	} else
+		pnetwork = (struct wlan_network *)pbuf;
+
+#ifdef __BIG_ENDIAN
+	/* endian_convert */
+	pnetwork->join_res = le32_to_cpu(pnetwork->join_res);
+	pnetwork->network_type = le32_to_cpu(pnetwork->network_type);
+	pnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);
+	pnetwork->network.Ssid.SsidLength =
+		 le32_to_cpu(pnetwork->network.Ssid.SsidLength);
+	pnetwork->network.Privacy = le32_to_cpu(pnetwork->network.Privacy);
+	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
+	pnetwork->network.NetworkTypeInUse =
+		 le32_to_cpu(pnetwork->network.NetworkTypeInUse);
+	pnetwork->network.Configuration.ATIMWindow =
+		 le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
+	pnetwork->network.Configuration.BeaconPeriod =
+		 le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
+	pnetwork->network.Configuration.DSConfig =
+		 le32_to_cpu(pnetwork->network.Configuration.DSConfig);
+	pnetwork->network.Configuration.FHConfig.DwellTime =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.
+			     DwellTime);
+	pnetwork->network.Configuration.FHConfig.HopPattern =
+		 le32_to_cpu(pnetwork->network.Configuration.
+			     FHConfig.HopPattern);
+	pnetwork->network.Configuration.FHConfig.HopSet =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
+	pnetwork->network.Configuration.FHConfig.Length =
+		 le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);
+	pnetwork->network.Configuration.Length =
+		 le32_to_cpu(pnetwork->network.Configuration.Length);
+	pnetwork->network.InfrastructureMode =
+		 le32_to_cpu(pnetwork->network.InfrastructureMode);
+	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength);
+#endif
+
+	the_same_macaddr = !memcmp(pnetwork->network.MacAddress,
+				   cur_network->network.MacAddress, ETH_ALEN);
+	pnetwork->network.Length =
+		 r8712_get_ndis_wlan_bssid_ex_sz(&pnetwork->network);
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex))
+		goto ignore_joinbss_callback;
+	if (pnetwork->join_res > 0) {
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+			/*s1. find ptarget_wlan*/
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+				if (the_same_macaddr == true)
+					ptarget_wlan =
+					    r8712_find_network(&pmlmepriv->
+					    scanned_queue,
+					    cur_network->network.MacAddress);
+				else {
+					pcur_wlan =
+					     r8712_find_network(&pmlmepriv->
+					     scanned_queue,
+					     cur_network->network.MacAddress);
+					pcur_wlan->fixed = false;
+
+					pcur_sta = r8712_get_stainfo(pstapriv,
+					     cur_network->network.MacAddress);
+					spin_lock_irqsave(&pstapriv->
+						sta_hash_lock, irqL2);
+					r8712_free_stainfo(adapter, pcur_sta);
+					spin_unlock_irqrestore(&(pstapriv->
+						sta_hash_lock), irqL2);
+
+					ptarget_wlan =
+						 r8712_find_network(&pmlmepriv->
+						 scanned_queue,
+						 pnetwork->network.
+						 MacAddress);
+					if (ptarget_wlan)
+						ptarget_wlan->fixed = true;
+				}
+			} else {
+				ptarget_wlan = r8712_find_network(&pmlmepriv->
+						scanned_queue,
+						pnetwork->network.MacAddress);
+				if (ptarget_wlan)
+					ptarget_wlan->fixed = true;
+			}
+
+			if (ptarget_wlan == NULL) {
+				if (check_fwstate(pmlmepriv,
+					_FW_UNDER_LINKING))
+					pmlmepriv->fw_state ^=
+						 _FW_UNDER_LINKING;
+				goto ignore_joinbss_callback;
+			}
+
+			/*s2. find ptarget_sta & update ptarget_sta*/
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+				if (the_same_macaddr == true) {
+					ptarget_sta =
+						 r8712_get_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+					if (ptarget_sta == NULL)
+						ptarget_sta =
+						 r8712_alloc_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+				} else
+					ptarget_sta =
+						 r8712_alloc_stainfo(pstapriv,
+						 pnetwork->network.MacAddress);
+				if (ptarget_sta) /*update ptarget_sta*/ {
+					ptarget_sta->aid = pnetwork->join_res;
+					ptarget_sta->qos_option = 1;
+					ptarget_sta->mac_id = 5;
+					if (adapter->securitypriv.
+					    AuthAlgrthm == 2) {
+						adapter->securitypriv.
+							binstallGrpkey =
+							 false;
+						adapter->securitypriv.
+							busetkipkey =
+							 false;
+						adapter->securitypriv.
+							bgrpkey_handshake =
+							 false;
+						ptarget_sta->ieee8021x_blocked
+							 = true;
+						ptarget_sta->XPrivacy =
+							 adapter->securitypriv.
+							 PrivacyAlgrthm;
+						memset((u8 *)&ptarget_sta->
+							 x_UncstKey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 tkiprxmickey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 tkiptxmickey,
+							 0,
+							 sizeof(union Keytype));
+						memset((u8 *)&ptarget_sta->
+							 txpn, 0,
+							 sizeof(union pn48));
+						memset((u8 *)&ptarget_sta->
+							 rxpn, 0,
+							 sizeof(union pn48));
+					}
+				} else {
+					if (check_fwstate(pmlmepriv,
+					    _FW_UNDER_LINKING))
+						pmlmepriv->fw_state ^=
+							 _FW_UNDER_LINKING;
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			/*s3. update cur_network & indicate connect*/
+			memcpy(&cur_network->network, &pnetwork->network,
+				pnetwork->network.Length);
+			cur_network->aid = pnetwork->join_res;
+			/*update fw_state will clr _FW_UNDER_LINKING*/
+			switch (pnetwork->network.InfrastructureMode) {
+			case Ndis802_11Infrastructure:
+				pmlmepriv->fw_state = WIFI_STATION_STATE;
+				break;
+			case Ndis802_11IBSS:
+				pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+				break;
+			default:
+				pmlmepriv->fw_state = WIFI_NULL_STATE;
+				break;
+			}
+			r8712_update_protection(adapter,
+					  (cur_network->network.IEs) +
+					  sizeof(struct NDIS_802_11_FIXED_IEs),
+					  (cur_network->network.IELength));
+			/*TODO: update HT_Capability*/
+			update_ht_cap(adapter, cur_network->network.IEs,
+				      cur_network->network.IELength);
+			/*indicate connect*/
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+				== true)
+				r8712_indicate_connect(adapter);
+			_cancel_timer(&pmlmepriv->assoc_timer,
+				      &timer_cancelled);
+		} else
+			goto ignore_joinbss_callback;
+	} else {
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+			_set_timer(&pmlmepriv->assoc_timer, 1);
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+	}
+ignore_joinbss_callback:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	if (sizeof(struct list_head) == 4 * sizeof(u32))
+		kfree((u8 *)pnetwork);
+}
+
+void r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL;
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stassoc_event *pstassoc	= (struct stassoc_event *)pbuf;
+
+	/* to do: */
+	if (r8712_access_ctrl(&adapter->acl_list, pstassoc->macaddr) == false)
+		return;
+	psta = r8712_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta != NULL) {
+		/*the sta have been in sta_info_queue => do nothing
+		 *(between drv has received this event before and
+		 *  fw have not yet to set key to CAM_ENTRY) */
+		return;
+	}
+
+	psta = r8712_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta == NULL)
+		return;
+	/* to do : init sta_info variable */
+	psta->qos_option = 0;
+	psta->mac_id = le32_to_cpu((uint)pstassoc->cam_id);
+	/* psta->aid = (uint)pstassoc->cam_id; */
+
+	if (adapter->securitypriv.AuthAlgrthm == 2)
+		psta->XPrivacy = adapter->securitypriv.PrivacyAlgrthm;
+	psta->ieee8021x_blocked = false;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+		if (adapter->stapriv.asoc_sta_count == 2) {
+			/* a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			r8712_indicate_connect(adapter);
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	unsigned long irqL, irqL2;
+	struct sta_info *psta;
+	struct wlan_network *pwlan = NULL;
+	struct wlan_bssid_ex *pdev_network = NULL;
+	u8 *pibss = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct stadel_event *pstadel = (struct stadel_event *)pbuf;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL2);
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		r8712_ind_disconnect(adapter);
+		r8712_free_assoc_resources(adapter);
+	}
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE |
+	    WIFI_ADHOC_STATE)) {
+		psta = r8712_get_stainfo(&adapter->stapriv, pstadel->macaddr);
+		spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+		r8712_free_stainfo(adapter, psta);
+		spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+		if (adapter->stapriv.asoc_sta_count == 1) {
+			/*a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			pwlan = r8712_find_network(&pmlmepriv->scanned_queue,
+				tgt_network->network.MacAddress);
+			if (pwlan) {
+				pwlan->fixed = false;
+				free_network_nolock(pmlmepriv, pwlan);
+			}
+			/*re-create ibss*/
+			pdev_network = &(adapter->registrypriv.dev_network);
+			pibss = adapter->registrypriv.dev_network.MacAddress;
+			memcpy(pdev_network, &tgt_network->network,
+				r8712_get_ndis_wlan_bssid_ex_sz(&tgt_network->
+							network));
+			memset(&pdev_network->Ssid, 0,
+				sizeof(struct ndis_802_11_ssid));
+			memcpy(&pdev_network->Ssid,
+				&pmlmepriv->assoc_ssid,
+				sizeof(struct ndis_802_11_ssid));
+			r8712_update_registrypriv_dev_network(adapter);
+			r8712_generate_random_ibss(pibss);
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL2);
+}
+
+void r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	struct reportpwrstate_parm *preportpwrstate =
+			 (struct reportpwrstate_parm *)pbuf;
+
+	preportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);
+	r8712_cpwm_int_hdl(adapter, preportpwrstate);
+}
+
+/*	When the Netgear 3500 AP is with WPA2PSK-AES mode, it will send
+ *	 the ADDBA req frame with start seq control = 0 to wifi client after
+ *	 the WPA handshake and the seqence number of following data packet
+ *	will be 0. In this case, the Rx reorder sequence is not longer than 0
+ *	 and the WiFi client will drop the data with seq number 0.
+ *	So, the 8712 firmware has to inform driver with receiving the
+ *	 ADDBA-Req frame so that the driver can reset the
+ *	sequence value of Rx reorder contorl.
+ */
+void r8712_got_addbareq_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	struct	ADDBA_Req_Report_parm *pAddbareq_pram =
+			 (struct ADDBA_Req_Report_parm *)pbuf;
+	struct	sta_info *psta;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	recv_reorder_ctrl *precvreorder_ctrl = NULL;
+
+	printk(KERN_INFO "r8712u: [%s] mac = %pM, seq = %d, tid = %d\n",
+	     __func__, pAddbareq_pram->MacAddress,
+	    pAddbareq_pram->StartSeqNum, pAddbareq_pram->tid);
+	psta = r8712_get_stainfo(pstapriv, pAddbareq_pram->MacAddress);
+	if (psta) {
+		precvreorder_ctrl =
+			 &psta->recvreorder_ctrl[pAddbareq_pram->tid];
+		/* set the indicate_seq to 0xffff so that the rx reorder
+		 * can store any following data packet.
+		 */
+		precvreorder_ctrl->indicate_seq = 0xffff;
+	}
+}
+
+void r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf)
+{
+	if (adapter->securitypriv.wps_hw_pbc_pressed == false)
+		adapter->securitypriv.wps_hw_pbc_pressed = true;
+}
+
+void _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sitesurvey_ctrl	*psitesurveyctrl = &pmlmepriv->sitesurveyctrl;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	u64 current_tx_pkts;
+	uint current_rx_pkts;
+
+	current_tx_pkts = (adapter->xmitpriv.tx_pkts) -
+			  (psitesurveyctrl->last_tx_pkts);
+	current_rx_pkts = (adapter->recvpriv.rx_pkts) -
+			  (psitesurveyctrl->last_rx_pkts);
+	psitesurveyctrl->last_tx_pkts = adapter->xmitpriv.tx_pkts;
+	psitesurveyctrl->last_rx_pkts = adapter->recvpriv.rx_pkts;
+	if ((current_tx_pkts > pregistrypriv->busy_thresh) ||
+	    (current_rx_pkts > pregistrypriv->busy_thresh))
+		psitesurveyctrl->traffic_busy = true;
+	else
+		psitesurveyctrl->traffic_busy = false;
+}
+
+void _r8712_join_timeout_handler(struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	pmlmepriv->to_join = false;
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		r8712_os_indicate_disconnect(adapter);
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+	}
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {
+		r8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,
+				  adapter->registrypriv.smart_ps);
+	}
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_scan_timeout_handler (struct _adapter *adapter)
+{
+	unsigned long irqL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	pmlmepriv->to_join = false;	/* scan fail, so clear to_join flag */
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void _r8712_dhcp_timeout_handler (struct _adapter *adapter)
+{
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+	if (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt)
+		r8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,
+			    adapter->registrypriv.smart_ps);
+}
+
+void _r8712_wdg_timeout_handler(struct _adapter *adapter)
+{
+	r8712_wdg_wk_cmd(adapter);
+}
+
+int r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv)
+{
+	struct list_head *phead;
+	unsigned char *dst_ssid, *src_ssid;
+	struct _adapter *adapter;
+	struct  __queue *queue = NULL;
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *pnetwork_max_rssi = NULL;
+
+	adapter = (struct _adapter *)pmlmepriv->nic_hdl;
+	queue = &pmlmepriv->scanned_queue;
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
+	while (1) {
+		if (end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
+			if ((pmlmepriv->assoc_by_rssi == true) &&
+			    (pnetwork_max_rssi != NULL)) {
+				pnetwork = pnetwork_max_rssi;
+				goto ask_for_joinbss;
+			}
+			return _FAIL;
+		}
+		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned,
+					  struct wlan_network, list);
+		if (pnetwork == NULL)
+			return _FAIL;
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+		if (pmlmepriv->assoc_by_bssid == true) {
+			dst_ssid = pnetwork->network.MacAddress;
+			src_ssid = pmlmepriv->assoc_bssid;
+			if (!memcmp(dst_ssid, src_ssid, ETH_ALEN)) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+					if (is_same_network(&pmlmepriv->
+					    cur_network.network,
+					    &pnetwork->network)) {
+						_clr_fwstate_(pmlmepriv,
+							_FW_UNDER_LINKING);
+						/*r8712_indicate_connect again*/
+						r8712_indicate_connect(adapter);
+						return 2;
+					}
+					r8712_disassoc_cmd(adapter);
+					r8712_ind_disconnect(adapter);
+					r8712_free_assoc_resources(adapter);
+				}
+				goto ask_for_joinbss;
+			}
+		} else if (pmlmepriv->assoc_ssid.SsidLength == 0)
+			goto ask_for_joinbss;
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		src_ssid = pmlmepriv->assoc_ssid.Ssid;
+		if ((pnetwork->network.Ssid.SsidLength ==
+		    pmlmepriv->assoc_ssid.SsidLength) &&
+		    (!memcmp(dst_ssid, src_ssid,
+		     pmlmepriv->assoc_ssid.SsidLength))) {
+			if (pmlmepriv->assoc_by_rssi == true) {
+				/* if the ssid is the same, select the bss
+				 *  which has the max rssi*/
+				if (pnetwork_max_rssi) {
+					if (pnetwork->network.Rssi >
+					    pnetwork_max_rssi->network.Rssi)
+						pnetwork_max_rssi = pnetwork;
+				} else
+					pnetwork_max_rssi = pnetwork;
+			} else if (is_desired_network(adapter, pnetwork)) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+					r8712_disassoc_cmd(adapter);
+					r8712_free_assoc_resources(adapter);
+				}
+				goto ask_for_joinbss;
+			}
+		}
+	}
+	return _FAIL;
+ask_for_joinbss:
+	return r8712_joinbss_cmd(adapter, pnetwork);
+}
+
+sint r8712_set_auth(struct _adapter *adapter,
+		    struct security_priv *psecuritypriv)
+{
+	struct cmd_priv	*pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setauth_parm *psetauthparm;
+	sint ret = _SUCCESS;
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+
+	psetauthparm = (struct setauth_parm *)_malloc(
+			sizeof(struct setauth_parm));
+	if (psetauthparm == NULL) {
+		kfree((unsigned char *)pcmd);
+		return _FAIL;
+	}
+	memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode = (u8)psecuritypriv->AuthAlgrthm;
+	pcmd->cmdcode = _SetAuth_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;
+	pcmd->cmdsz = sizeof(struct setauth_parm);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	_init_listhead(&pcmd->list);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return ret;
+}
+
+sint r8712_set_key(struct _adapter *adapter,
+		   struct security_priv *psecuritypriv,
+	     sint keyid)
+{
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct setkey_parm *psetkeyparm;
+	u8 keylen;
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return _FAIL;
+	psetkeyparm = (struct setkey_parm *)_malloc(sizeof(struct setkey_parm));
+	if (psetkeyparm == NULL) {
+		kfree((unsigned char *)pcmd);
+		return _FAIL;
+	}
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+	if (psecuritypriv->AuthAlgrthm == 2) { /* 802.1X */
+		psetkeyparm->algorithm =
+			 (u8)psecuritypriv->XGrpPrivacy;
+	} else { /* WEP */
+		psetkeyparm->algorithm =
+			 (u8)psecuritypriv->PrivacyAlgrthm;
+	}
+	psetkeyparm->keyid = (u8)keyid;
+
+	switch (psetkeyparm->algorithm) {
+	case _WEP40_:
+		keylen = 5;
+		memcpy(psetkeyparm->key,
+			psecuritypriv->DefKey[keyid].skey, keylen);
+		break;
+	case _WEP104_:
+		keylen = 13;
+		memcpy(psetkeyparm->key,
+			psecuritypriv->DefKey[keyid].skey, keylen);
+		break;
+	case _TKIP_:
+		if (keyid < 1 || keyid > 2)
+			return _FAIL;
+		keylen = 16;
+		memcpy(psetkeyparm->key,
+			&psecuritypriv->XGrpKey[keyid - 1], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	case _AES_:
+		if (keyid < 1 || keyid > 2)
+			return _FAIL;
+		keylen = 16;
+		memcpy(psetkeyparm->key,
+			&psecuritypriv->XGrpKey[keyid - 1], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	default:
+		return _FAIL;
+	}
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+	_init_listhead(&pcmd->list);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+	return _SUCCESS;
+}
+
+/* adjust IEs for r8712_joinbss_cmd in WMM */
+int r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie, u8 *out_ie,
+		    uint in_len, uint initial_out_len)
+{
+	unsigned int ielength = 0;
+	unsigned int i, j;
+
+	i = 12; /* after the fixed IE */
+	while (i < in_len) {
+		ielength = initial_out_len;
+		if (in_ie[i] == 0xDD && in_ie[i + 2] == 0x00 &&
+		    in_ie[i + 3] == 0x50 && in_ie[i + 4] == 0xF2 &&
+		    in_ie[i + 5] == 0x02 && i + 5 < in_len) {
+			/*WMM element ID and OUI*/
+			for (j = i; j < i + 9; j++) {
+				out_ie[ielength] = in_ie[j];
+				ielength++;
+			}
+			out_ie[initial_out_len + 1] = 0x07;
+			out_ie[initial_out_len + 6] = 0x00;
+			out_ie[initial_out_len + 8] = 0x00;
+			break;
+		}
+		i += (in_ie[i + 1] + 2); /* to the next IE element */
+	}
+	return ielength;
+}
+
+/*
+ * Ported from 8185: IsInPreAuthKeyList().
+ *
+ * Search by BSSID,
+ * Return Value:
+ *	-1		:if there is no pre-auth key in the  table
+ *	>=0		:if there is pre-auth key, and   return the entry id
+ */
+static int SecIsInPMKIDList(struct _adapter *Adapter, u8 *bssid)
+{
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	int i = 0;
+
+	do {
+		if (psecuritypriv->PMKIDList[i].bUsed &&
+		   (!memcmp(psecuritypriv->PMKIDList[i].Bssid,
+			    bssid, ETH_ALEN)))
+			break;
+		else
+			i++;
+	} while (i < NUM_PMKID_CACHE);
+
+	if (i == NUM_PMKID_CACHE) {
+		i = -1; /* Could not find. */
+	} else {
+		; /* There is one Pre-Authentication Key for the
+		   * specific BSSID. */
+	}
+	return i;
+}
+
+sint r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,
+		     u8 *out_ie, uint in_len)
+{
+	u8 authmode = 0, securitytype, match;
+	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint ielength, cnt, remove_cnt;
+	int iEntry;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	uint ndisauthmode = psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+
+	if ((ndisauthmode == Ndis802_11AuthModeWPA) ||
+	    (ndisauthmode == Ndis802_11AuthModeWPAPSK)) {
+		authmode = _WPA_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x50;
+		uncst_oui[2] = 0xf2;
+	}
+	if ((ndisauthmode == Ndis802_11AuthModeWPA2) ||
+	    (ndisauthmode == Ndis802_11AuthModeWPA2PSK)) {
+		authmode = _WPA2_IE_ID_;
+		uncst_oui[0] = 0x0;
+		uncst_oui[1] = 0x0f;
+		uncst_oui[2] = 0xac;
+	}
+	switch (ndissecuritytype) {
+	case Ndis802_11Encryption1Enabled:
+	case Ndis802_11Encryption1KeyAbsent:
+		securitytype = _WEP40_;
+		uncst_oui[3] = 0x1;
+		break;
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption2KeyAbsent:
+		securitytype = _TKIP_;
+		uncst_oui[3] = 0x2;
+		break;
+	case Ndis802_11Encryption3Enabled:
+	case Ndis802_11Encryption3KeyAbsent:
+		securitytype = _AES_;
+		uncst_oui[3] = 0x4;
+		break;
+	default:
+		securitytype = _NO_PRIVACY_;
+		break;
+	}
+	/*Search required WPA or WPA2 IE and copy to sec_ie[] */
+	cnt = 12;
+	match = false;
+	while (cnt < in_len) {
+		if (in_ie[cnt] == authmode) {
+			if ((authmode == _WPA_IE_ID_) &&
+			    (!memcmp(&in_ie[cnt+2], &wpa_oui[0], 4))) {
+				memcpy(&sec_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				match = true;
+				break;
+			}
+			if (authmode == _WPA2_IE_ID_) {
+				memcpy(&sec_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+				match = true;
+				break;
+			}
+			if (((authmode == _WPA_IE_ID_) &&
+			     (!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) ||
+			     (authmode == _WPA2_IE_ID_))
+				memcpy(&bkup_ie[0], &in_ie[cnt],
+					in_ie[cnt + 1] + 2);
+		}
+		cnt += in_ie[cnt+1] + 2; /*get next*/
+	}
+	/*restruct WPA IE or WPA2 IE in sec_ie[] */
+	if (match == true) {
+		if (sec_ie[0] == _WPA_IE_ID_) {
+			/* parsing SSN IE to select required encryption
+			 * algorithm, and set the bc/mc encryption algorithm */
+			while (true) {
+				/*check wpa_oui tag*/
+				if (memcmp(&sec_ie[2], &wpa_oui[0], 4)) {
+					match = false;
+					break;
+				}
+				if ((sec_ie[6] != 0x01) || (sec_ie[7] != 0x0)) {
+					/*IE Ver error*/
+					match = false;
+					break;
+				}
+				if (!memcmp(&sec_ie[8], &wpa_oui[0], 3)) {
+					/* get bc/mc encryption type (group
+					 * key type)*/
+					switch (sec_ie[11]) {
+					case 0x0: /*none*/
+						psecuritypriv->XGrpPrivacy =
+								_NO_PRIVACY_;
+						break;
+					case 0x1: /*WEP_40*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP40_;
+						break;
+					case 0x2: /*TKIP*/
+						psecuritypriv->XGrpPrivacy =
+								_TKIP_;
+						break;
+					case 0x3: /*AESCCMP*/
+					case 0x4:
+						psecuritypriv->XGrpPrivacy =
+								_AES_;
+						break;
+					case 0x5: /*WEP_104*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP104_;
+						break;
+					}
+				} else {
+					match = false;
+					break;
+				}
+				if (sec_ie[12] == 0x01) {
+					/*check the unicast encryption type*/
+					if (memcmp(&sec_ie[14],
+					    &uncst_oui[0], 4)) {
+						match = false;
+						break;
+
+					} /*else the uncst_oui is match*/
+				} else { /*mixed mode, unicast_enc_type > 1*/
+					/*select the uncst_oui and remove
+					 * the other uncst_oui*/
+					cnt = sec_ie[12];
+					remove_cnt = (cnt-1) * 4;
+					sec_ie[12] = 0x01;
+					memcpy(&sec_ie[14], &uncst_oui[0], 4);
+					/*remove the other unicast suit*/
+					memcpy(&sec_ie[18],
+						&sec_ie[18 + remove_cnt],
+						sec_ie[1] - 18 + 2 -
+						remove_cnt);
+					sec_ie[1] = sec_ie[1] - remove_cnt;
+				}
+				break;
+			}
+		}
+		if (authmode == _WPA2_IE_ID_) {
+			/* parsing RSN IE to select required encryption
+			 * algorithm, and set the bc/mc encryption algorithm */
+			while (true) {
+				if ((sec_ie[2] != 0x01) || (sec_ie[3] != 0x0)) {
+					/*IE Ver error*/
+					match = false;
+					break;
+				}
+				if (!memcmp(&sec_ie[4], &uncst_oui[0], 3)) {
+					/*get bc/mc encryption type*/
+					switch (sec_ie[7]) {
+					case 0x1: /*WEP_40*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP40_;
+						break;
+					case 0x2: /*TKIP*/
+						psecuritypriv->XGrpPrivacy =
+								_TKIP_;
+						break;
+					case 0x4: /*AESWRAP*/
+						psecuritypriv->XGrpPrivacy =
+								_AES_;
+						break;
+					case 0x5: /*WEP_104*/
+						psecuritypriv->XGrpPrivacy =
+								_WEP104_;
+						break;
+					default: /*one*/
+						psecuritypriv->XGrpPrivacy =
+								_NO_PRIVACY_;
+						break;
+					}
+				} else {
+					match = false;
+					break;
+				}
+				if (sec_ie[8] == 0x01) {
+					/*check the unicast encryption type*/
+					if (memcmp(&sec_ie[10],
+						     &uncst_oui[0], 4)) {
+						match = false;
+						break;
+					} /*else the uncst_oui is match*/
+				} else { /*mixed mode, unicast_enc_type > 1*/
+					/*select the uncst_oui and remove the
+					 * other uncst_oui*/
+					cnt = sec_ie[8];
+					remove_cnt = (cnt-1)*4;
+					sec_ie[8] = 0x01;
+					memcpy(&sec_ie[10], &uncst_oui[0], 4);
+					/*remove the other unicast suit*/
+					memcpy(&sec_ie[14],
+						&sec_ie[14 + remove_cnt],
+						(sec_ie[1] - 14 + 2 -
+						remove_cnt));
+					sec_ie[1] = sec_ie[1]-remove_cnt;
+				}
+				break;
+			}
+		}
+	}
+	if ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {
+		/*copy fixed ie*/
+		memcpy(out_ie, in_ie, 12);
+		ielength = 12;
+		/*copy RSN or SSN*/
+		if (match == true) {
+			memcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1]+2);
+			ielength += sec_ie[1] + 2;
+			if (authmode == _WPA2_IE_ID_) {
+				/*the Pre-Authentication bit should be zero*/
+				out_ie[ielength - 1] = 0;
+				out_ie[ielength - 2] = 0;
+			}
+			r8712_report_sec_ie(adapter, authmode, sec_ie);
+		}
+	} else {
+		/*copy fixed ie only*/
+		memcpy(out_ie, in_ie, 12);
+		ielength = 12;
+		if (psecuritypriv->wps_phase == true) {
+			memcpy(out_ie+ielength, psecuritypriv->wps_ie,
+				psecuritypriv->wps_ie_len);
+			ielength += psecuritypriv->wps_ie_len;
+		}
+	}
+	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
+	if (iEntry < 0)
+		return ielength;
+	else {
+		if (authmode == _WPA2_IE_ID_) {
+			out_ie[ielength] = 1;
+			ielength++;
+			out_ie[ielength] = 0;	/*PMKID count = 0x0100*/
+			ielength++;
+			memcpy(&out_ie[ielength],
+				&psecuritypriv->PMKIDList[iEntry].PMKID, 16);
+			ielength += 16;
+			out_ie[13] += 18;/*PMKID length = 2+16*/
+		}
+	}
+	return ielength;
+}
+
+void r8712_init_registrypriv_dev_network(struct _adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct eeprom_priv *peepriv = &adapter->eeprompriv;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *myhwaddr = myid(peepriv);
+
+	memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
+	memcpy(&pdev_network->Ssid, &pregistrypriv->ssid,
+		sizeof(struct ndis_802_11_ssid));
+	pdev_network->Configuration.Length =
+			 sizeof(struct NDIS_802_11_CONFIGURATION);
+	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+}
+
+void r8712_update_registrypriv_dev_network(struct _adapter *adapter)
+{
+	int sz = 0;
+	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
+	struct wlan_bssid_ex	*pdev_network = &pregistrypriv->dev_network;
+	struct security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
+
+	pdev_network->Privacy = cpu_to_le32(psecuritypriv->PrivacyAlgrthm
+					    > 0 ? 1 : 0) ; /* adhoc no 802.1x */
+	pdev_network->Rssi = 0;
+	switch (pregistrypriv->wireless_mode) {
+	case WIRELESS_11B:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11DS);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM24);
+		break;
+	case WIRELESS_11A:
+		pdev_network->NetworkTypeInUse = cpu_to_le32(Ndis802_11OFDM5);
+		break;
+	default:
+		/* TODO */
+		break;
+	}
+	pdev_network->Configuration.DSConfig = cpu_to_le32(
+					       pregistrypriv->channel);
+	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+		pdev_network->Configuration.ATIMWindow = cpu_to_le32(3);
+	pdev_network->InfrastructureMode = cpu_to_le32(
+				cur_network->network.InfrastructureMode);
+	/* 1. Supported rates
+	 * 2. IE
+	 */
+	sz = r8712_generate_ie(pregistrypriv);
+	pdev_network->IELength = sz;
+	pdev_network->Length = r8712_get_ndis_wlan_bssid_ex_sz(
+			      (struct ndis_wlan_bssid_ex *)pdev_network);
+}
+
+/*the function is at passive_level*/
+void r8712_joinbss_reset(struct _adapter *padapter)
+{
+	int i;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+
+	/* todo: if you want to do something io/reg/hw setting before join_bss,
+	 * please add code here */
+	phtpriv->ampdu_enable = false;/*reset to disabled*/
+	for (i = 0; i < 16; i++)
+		phtpriv->baddbareq_issued[i] = false;/*reset it*/
+	if (phtpriv->ht_option) {
+		/* validate  usb rx aggregation */
+		r8712_write8(padapter, 0x102500D9, 48);/*TH = 48 pages, 6k*/
+	} else {
+		/* invalidate  usb rx aggregation */
+		/* TH=1 => means that invalidate usb rx aggregation */
+		r8712_write8(padapter, 0x102500D9, 1);
+	}
+}
+
+/*the function is >= passive_level*/
+unsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,
+				     u8 *out_ie, uint in_len, uint *pout_len)
+{
+	u32 ielen, out_len;
+	unsigned char *p, *pframe;
+	struct ieee80211_ht_cap ht_capie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+
+	phtpriv->ht_option = 0;
+	p = r8712_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
+	if (p && (ielen > 0)) {
+		if (pqospriv->qos_option == 0) {
+			out_len = *pout_len;
+			pframe = r8712_set_ie(out_ie+out_len,
+					      _VENDOR_SPECIFIC_IE_,
+					      _WMM_IE_Length_,
+					       WMM_IE, pout_len);
+			pqospriv->qos_option = 1;
+		}
+		out_len = *pout_len;
+		memset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));
+		ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |
+				    IEEE80211_HT_CAP_SGI_20 |
+				    IEEE80211_HT_CAP_SGI_40 |
+				    IEEE80211_HT_CAP_TX_STBC |
+				    IEEE80211_HT_CAP_MAX_AMSDU |
+				    IEEE80211_HT_CAP_DSSSCCK40;
+		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR &
+				0x03) | (IEEE80211_HT_CAP_AMPDU_DENSITY & 0x00);
+		pframe = r8712_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
+				sizeof(struct ieee80211_ht_cap),
+				(unsigned char *)&ht_capie, pout_len);
+		phtpriv->ht_option = 1;
+	}
+	return phtpriv->ht_option;
+}
+
+/* the function is > passive_level (in critical_section) */
+static void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len)
+{
+	u8 *p, max_ampdu_sz;
+	int i, len;
+	struct sta_info *bmc_sta, *psta;
+	struct ieee80211_ht_cap *pht_capie;
+	struct ieee80211_ht_addt_info *pht_addtinfo;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct wlan_network *pcur_network = &(pmlmepriv->cur_network);
+
+	if (!phtpriv->ht_option)
+		return;
+	/* maybe needs check if ap supports rx ampdu. */
+	if ((phtpriv->ampdu_enable == false) &&
+	    (pregistrypriv->ampdu_enable == 1))
+		phtpriv->ampdu_enable = true;
+	/*check Max Rx A-MPDU Size*/
+	len = 0;
+	p = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),
+				_HT_CAPABILITY_IE_,
+				&len, ie_len -
+				sizeof(struct NDIS_802_11_FIXED_IEs));
+	if (p && len > 0) {
+		pht_capie = (struct ieee80211_ht_cap *)(p+2);
+		max_ampdu_sz = (pht_capie->ampdu_params_info &
+				IEEE80211_HT_CAP_AMPDU_FACTOR);
+		/* max_ampdu_sz (kbytes); */
+		max_ampdu_sz = 1 << (max_ampdu_sz+3);
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+	}
+	/* for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
+	 * if A-MPDU Rx is enabled, reseting rx_ordering_ctrl
+	 * wstart_b(indicate_seq) to default value=0xffff
+	 * todo: check if AP can send A-MPDU packets
+	 */
+	bmc_sta = r8712_get_bcmc_stainfo(padapter);
+	if (bmc_sta) {
+		for (i = 0; i < 16; i++) {
+			preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+		}
+	}
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 pcur_network->network.MacAddress);
+	if (psta) {
+		for (i = 0; i < 16 ; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+		}
+	}
+	len = 0;
+	p = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),
+		   _HT_ADD_INFO_IE_, &len,
+		   ie_len-sizeof(struct NDIS_802_11_FIXED_IEs));
+	if (p && len > 0)
+		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p + 2);
+}
+
+void r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv	 *phtpriv = &pmlmepriv->htpriv;
+
+	if ((phtpriv->ht_option == 1) && (phtpriv->ampdu_enable == true)) {
+		if (phtpriv->baddbareq_issued[priority] == false) {
+			r8712_addbareq_cmd(padapter, (u8)priority);
+			phtpriv->baddbareq_issued[priority] = true;
+		}
+	}
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mlme.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mlme.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mlme.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mlme.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MLME_H_
+#define __RTL871X_MLME_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wlan_bssdef.h"
+
+#define	MAX_BSS_CNT	64
+#define   MAX_JOIN_TIMEOUT	6000
+
+#define		SCANNING_TIMEOUT	4500
+
+#define	SCANQUEUE_LIFETIME 20 /* unit:sec */
+
+#define		WIFI_NULL_STATE	0x00000000
+#define	WIFI_ASOC_STATE		0x00000001	/* Under Linked state...*/
+#define		WIFI_REASOC_STATE 0x00000002
+#define	WIFI_SLEEP_STATE	0x00000004
+#define	WIFI_STATION_STATE	0x00000008
+#define	WIFI_AP_STATE		0x00000010
+#define	WIFI_ADHOC_STATE	0x00000020
+#define   WIFI_ADHOC_MASTER_STATE 0x00000040
+#define   WIFI_UNDER_LINKING	0x00000080
+#define WIFI_SITE_MONITOR	0x00000800	/* to indicate the station
+						 * is under site surveying*/
+#define	WIFI_MP_STATE		0x00010000
+#define	WIFI_MP_CTX_BACKGROUND	0x00020000	/* in cont. tx background*/
+#define	WIFI_MP_CTX_ST		0x00040000	/* in cont. tx with
+						 *  single-tone*/
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in cont, tx
+					* background due to out of skb*/
+#define	WIFI_MP_CTX_CCK_HW	0x00100000	/* in continuous tx*/
+#define	WIFI_MP_CTX_CCK_CS	0x00200000	/* in cont, tx with carrier
+						 * suppression*/
+#define   WIFI_MP_LPBK_STATE	0x00400000
+
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED		WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+/*
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+*/
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	struct timer_list sitesurvey_ctrl_timer;
+};
+
+struct mlme_priv {
+
+	spinlock_t lock;
+	spinlock_t lock2;
+	sint	fw_state;	/*shall we protect this variable? */
+	u8 to_join; /*flag*/
+	u8 *nic_hdl;
+	struct list_head *pscanned;
+	struct  __queue free_bss_pool;
+	struct  __queue scanned_queue;
+	u8 *free_bss_buf;
+	unsigned long num_of_scanned;
+	u8 passive_mode; /*add for Android's SCAN-ACTIVE/SCAN-PASSIVE */
+	struct ndis_802_11_ssid	assoc_ssid;
+	u8 assoc_bssid[6];
+	struct wlan_network cur_network;
+	struct sitesurvey_ctrl sitesurveyctrl;
+	struct timer_list assoc_timer;
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+	struct timer_list scan_to_timer; /* driver handles scan_timeout.*/
+	struct timer_list dhcp_timer; /* set dhcp to if driver in ps mode.*/
+	struct qos_priv qospriv;
+	struct ht_priv	htpriv;
+	struct timer_list wdg_timer; /*watchdog periodic timer*/
+};
+
+static inline u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+static inline u8 check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if (pmlmepriv->fw_state & state)
+		return true;
+	return false;
+}
+
+static inline sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * TAKE CARE THAT BEFORE CALLING THIS FUNC, LOCK pmlmepriv->lock
+ */
+static inline void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+}
+
+static inline void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+static inline void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, state) == true)
+		pmlmepriv->fw_state ^= state;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+static inline void set_scanned_network_val(struct mlme_priv *pmlmepriv,
+					     sint val)
+{
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	pmlmepriv->num_of_scanned = val;
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+}
+
+void r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_atimdone_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf);
+void r8712_free_network_queue(struct _adapter *adapter);
+int r8712_init_mlme_priv(struct _adapter *adapter);
+void r8712_free_mlme_priv(struct mlme_priv *pmlmepriv);
+sint r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv);
+sint r8712_set_key(struct _adapter *adapter,
+		   struct security_priv *psecuritypriv, sint keyid);
+sint r8712_set_auth(struct _adapter *adapter,
+		    struct security_priv *psecuritypriv);
+uint r8712_get_ndis_wlan_bssid_ex_sz(struct ndis_wlan_bssid_ex *bss);
+void r8712_generate_random_ibss(u8 *pibss);
+u8 *r8712_get_capability_from_ie(u8 *ie);
+struct wlan_network *r8712_get_oldest_wlan_network(
+				struct  __queue *scanned_queue);
+void r8712_free_assoc_resources(struct _adapter *adapter);
+void r8712_ind_disconnect(struct _adapter *adapter);
+void r8712_indicate_connect(struct _adapter *adapter);
+int r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,
+			  u8 *out_ie, uint in_len);
+int r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie,
+			  u8 *out_ie, uint in_len, uint initial_out_len);
+void r8712_init_registrypriv_dev_network(struct _adapter *adapter);
+void r8712_update_registrypriv_dev_network(struct _adapter *adapter);
+void _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter);
+void _r8712_join_timeout_handler(struct _adapter *adapter);
+void r8712_scan_timeout_handler(struct _adapter *adapter);
+void _r8712_dhcp_timeout_handler(struct _adapter *adapter);
+void _r8712_wdg_timeout_handler(struct _adapter *adapter);
+struct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv);
+sint r8712_if_up(struct _adapter *padapter);
+void r8712_joinbss_reset(struct _adapter *padapter);
+unsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,
+				     u8 *out_ie, uint in_len, uint *pout_len);
+void r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority);
+int r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork);
+
+#endif /*__RTL871X_MLME_H_*/
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,748 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#define _RTL871X_MP_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_mp_phy_regdef.h"
+#include "rtl8712_cmd.h"
+
+static void _init_mp_priv_(struct mp_priv *pmp_priv)
+{
+	pmp_priv->mode = _LOOPBOOK_MODE_;
+	pmp_priv->curr_ch = 1;
+	pmp_priv->curr_modem = MIXED_PHY;
+	pmp_priv->curr_rateidx = 0;
+	pmp_priv->curr_txpoweridx = 0x14;
+	pmp_priv->antenna_tx = ANTENNA_A;
+	pmp_priv->antenna_rx = ANTENNA_AB;
+	pmp_priv->check_mp_pkt = 0;
+	pmp_priv->tx_pktcount = 0;
+	pmp_priv->rx_pktcount = 0;
+	pmp_priv->rx_crcerrpktcount = 0;
+}
+
+static int init_mp_priv(struct mp_priv *pmp_priv)
+{
+	int i, res;
+	struct mp_xmit_frame *pmp_xmitframe;
+
+	_init_mp_priv_(pmp_priv);
+	_init_queue(&pmp_priv->free_mp_xmitqueue);
+	pmp_priv->pallocated_mp_xmitframe_buf = NULL;
+	pmp_priv->pallocated_mp_xmitframe_buf = _malloc(NR_MP_XMITFRAME *
+					 sizeof(struct mp_xmit_frame) + 4);
+	if (pmp_priv->pallocated_mp_xmitframe_buf == NULL) {
+		res = _FAIL;
+		goto _exit_init_mp_priv;
+	}
+	pmp_priv->pmp_xmtframe_buf = pmp_priv->pallocated_mp_xmitframe_buf +
+			 4 -
+			 ((addr_t)(pmp_priv->pallocated_mp_xmitframe_buf) & 3);
+	pmp_xmitframe = (struct mp_xmit_frame *)pmp_priv->pmp_xmtframe_buf;
+	for (i = 0; i < NR_MP_XMITFRAME; i++) {
+		_init_listhead(&(pmp_xmitframe->list));
+		list_insert_tail(&(pmp_xmitframe->list),
+				 &(pmp_priv->free_mp_xmitqueue.queue));
+		pmp_xmitframe->pkt = NULL;
+		pmp_xmitframe->frame_tag = MP_FRAMETAG;
+		pmp_xmitframe->padapter = pmp_priv->papdater;
+		pmp_xmitframe++;
+	}
+	pmp_priv->free_mp_xmitframe_cnt = NR_MP_XMITFRAME;
+	res = _SUCCESS;
+_exit_init_mp_priv:
+	return res;
+}
+
+static int free_mp_priv(struct mp_priv *pmp_priv)
+{
+	int res = 0;
+	kfree(pmp_priv->pallocated_mp_xmitframe_buf);
+	return res;
+}
+
+void mp871xinit(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+
+	pmppriv->papdater = padapter;
+	init_mp_priv(pmppriv);
+}
+
+void mp871xdeinit(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+
+	free_mp_priv(pmppriv);
+}
+
+/*
+ * Special for bb and rf reg read/write
+ */
+static u32 fw_iocmd_read(struct _adapter *pAdapter, struct IOCMD_STRUCT iocmd)
+{
+	u32 cmd32 = 0, val32 = 0;
+	u8 iocmd_class	= iocmd.cmdclass;
+	u16 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	if (r8712_fw_cmd(pAdapter, cmd32))
+		r8712_fw_cmd_data(pAdapter, &val32, 1);
+	else
+		val32 = 0;
+	return val32;
+}
+
+static u8 fw_iocmd_write(struct _adapter *pAdapter,
+			 struct IOCMD_STRUCT iocmd, u32 value)
+{
+	u32 cmd32 = 0;
+	u8 iocmd_class	= iocmd.cmdclass;
+	u32 iocmd_value	= iocmd.value;
+	u8 iocmd_idx	= iocmd.index;
+
+	r8712_fw_cmd_data(pAdapter, &value, 0);
+	msleep(100);
+	cmd32 = (iocmd_class << 24) | (iocmd_value << 8) | iocmd_idx ;
+	return r8712_fw_cmd(pAdapter, cmd32);
+}
+
+/* offset : 0X800~0XFFF */
+u32 r8712_bb_reg_read(struct _adapter *pAdapter, u16 offset)
+{
+	u8 shift = offset & 0x0003;	/* 4 byte access */
+	u16 bb_addr = offset & 0x0FFC;	/* 4 byte access */
+	u32 bb_val = 0;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_READ_IDX;
+	bb_val = fw_iocmd_read(pAdapter, iocmd);
+	if (shift != 0) {
+		u32 bb_val2 = 0;
+		bb_val >>= (shift * 8);
+		iocmd.value += 4;
+		bb_val2 = fw_iocmd_read(pAdapter, iocmd);
+		bb_val2 <<= ((4 - shift) * 8);
+		bb_val |= bb_val2;
+	}
+	return bb_val;
+}
+
+/* offset : 0X800~0XFFF */
+u8 r8712_bb_reg_write(struct _adapter *pAdapter, u16 offset, u32 value)
+{
+	u8 shift = offset & 0x0003;	/* 4 byte access */
+	u16 bb_addr = offset & 0x0FFC;	/* 4 byte access */
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= bb_addr;
+	iocmd.index	= IOCMD_BB_WRITE_IDX;
+	if (shift != 0) {
+		u32 oldValue = 0;
+		u32 newValue = value;
+
+		oldValue = r8712_bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF >> ((4 - shift) * 8));
+		value = oldValue | (newValue << (shift * 8));
+		if (fw_iocmd_write(pAdapter, iocmd, value) == false)
+			return false;
+		iocmd.value += 4;
+		oldValue = r8712_bb_reg_read(pAdapter, iocmd.value);
+		oldValue &= (0xFFFFFFFF << (shift * 8));
+		value = oldValue | (newValue >> ((4 - shift) * 8));
+	}
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+/* offset : 0x00 ~ 0xFF */
+u32 r8712_rf_reg_read(struct _adapter *pAdapter, u8 path, u8 offset)
+{
+	u16 rf_addr = (path << 8) | offset;
+	u32 rf_data;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF ;
+	iocmd.value	= rf_addr ;
+	iocmd.index	= IOCMD_RF_READ_IDX;
+	rf_data = fw_iocmd_read(pAdapter, iocmd);
+	return rf_data;
+}
+
+u8 r8712_rf_reg_write(struct _adapter *pAdapter, u8 path, u8 offset, u32 value)
+{
+	u16 rf_addr = (path << 8) | offset;
+	struct IOCMD_STRUCT iocmd;
+
+	iocmd.cmdclass	= IOCMD_CLASS_BB_RF;
+	iocmd.value	= rf_addr;
+	iocmd.index	= IOCMD_RF_WRIT_IDX;
+	return fw_iocmd_write(pAdapter, iocmd, value);
+}
+
+static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1)
+			break;
+	return i;
+}
+
+static u32 get_bb_reg(struct _adapter *pAdapter, u16 offset, u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = r8712_bb_reg_read(pAdapter, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+	return new_value;
+}
+
+static u8 set_bb_reg(struct _adapter *pAdapter,
+		     u16 offset,
+		     u32 bitmask,
+		     u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = r8712_bb_reg_read(pAdapter, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+	} else
+		new_value = value;
+	return r8712_bb_reg_write(pAdapter, offset, new_value);
+}
+
+static u32 get_rf_reg(struct _adapter *pAdapter, u8 path, u8 offset,
+		      u32 bitmask)
+{
+	u32 org_value, bit_shift, new_value;
+
+	org_value = r8712_rf_reg_read(pAdapter, path, offset);
+	bit_shift = bitshift(bitmask);
+	new_value = (org_value & bitmask) >> bit_shift;
+	return new_value;
+}
+
+static u8 set_rf_reg(struct _adapter *pAdapter, u8 path, u8 offset, u32 bitmask,
+	      u32 value)
+{
+	u32 org_value, bit_shift, new_value;
+
+	if (bitmask != bMaskDWord) {
+		org_value = r8712_rf_reg_read(pAdapter, path, offset);
+		bit_shift = bitshift(bitmask);
+		new_value = ((org_value & (~bitmask)) | (value << bit_shift));
+	} else
+		new_value = value;
+	return r8712_rf_reg_write(pAdapter, path, offset, new_value);
+}
+
+/*
+ * SetChannel
+ * Description
+ *	Use H2C command to change channel,
+ *	not only modify rf register, but also other setting need to be done.
+ */
+void r8712_SetChannel(struct _adapter *pAdapter)
+{
+	struct cmd_priv *pcmdpriv = &pAdapter->cmdpriv;
+	struct cmd_obj *pcmd = NULL;
+	struct SetChannel_parm *pparm = NULL;
+	u16 code = GEN_CMD_CODE(_SetChannel);
+
+	pcmd = (struct cmd_obj *)_malloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL)
+		return;
+	pparm = (struct SetChannel_parm *)_malloc(sizeof(struct
+					 SetChannel_parm));
+	if (pparm == NULL) {
+		kfree(pcmd);
+		return;
+	}
+	pparm->curr_ch = pAdapter->mppriv.curr_ch;
+	init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code);
+	r8712_enqueue_cmd(pcmdpriv, pcmd);
+}
+
+static void SetCCKTxPower(struct _adapter *pAdapter, u8 TxPower)
+{
+	u16 TxAGC = 0;
+
+	TxAGC = TxPower;
+	set_bb_reg(pAdapter, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);
+}
+
+static void SetOFDMTxPower(struct _adapter *pAdapter, u8 TxPower)
+{
+	u32 TxAGC = 0;
+
+	TxAGC |= ((TxPower<<24)|(TxPower<<16)|(TxPower<<8)|TxPower);
+	set_bb_reg(pAdapter, rTxAGC_Rate18_06, bTxAGCRate18_06, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Rate54_24, bTxAGCRate54_24, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs03_Mcs00, bTxAGCRateMCS3_MCS0, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs07_Mcs04, bTxAGCRateMCS7_MCS4, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs11_Mcs08, bTxAGCRateMCS11_MCS8, TxAGC);
+	set_bb_reg(pAdapter, rTxAGC_Mcs15_Mcs12, bTxAGCRateMCS15_MCS12, TxAGC);
+}
+
+void r8712_SetTxPower(struct _adapter *pAdapter)
+{
+	u8 TxPower = pAdapter->mppriv.curr_txpoweridx;
+	SetCCKTxPower(pAdapter, TxPower);
+	SetOFDMTxPower(pAdapter, TxPower);
+}
+
+void r8712_SetTxAGCOffset(struct _adapter *pAdapter, u32 ulTxAGCOffset)
+{
+	u32 TxAGCOffset_B, TxAGCOffset_C, TxAGCOffset_D, tmpAGC;
+
+	TxAGCOffset_B = (ulTxAGCOffset&0x000000ff);
+	TxAGCOffset_C = ((ulTxAGCOffset&0x0000ff00)>>8);
+	TxAGCOffset_D = ((ulTxAGCOffset&0x00ff0000)>>16);
+	tmpAGC = (TxAGCOffset_D<<8 | TxAGCOffset_C<<4 | TxAGCOffset_B);
+	set_bb_reg(pAdapter, rFPGA0_TxGainStage,
+			(bXBTxAGC|bXCTxAGC|bXDTxAGC), tmpAGC);
+}
+
+void r8712_SetDataRate(struct _adapter *pAdapter)
+{
+	u8 path = RF_PATH_A;
+	u8 offset = RF_SYN_G2;
+	u32 value;
+
+	value = (pAdapter->mppriv.curr_rateidx < 4) ? 0x4440 : 0xF200;
+	r8712_rf_reg_write(pAdapter, path, offset, value);
+}
+
+void r8712_SwitchBandwidth(struct _adapter *pAdapter)
+{
+	/* 3 1.Set MAC register : BWOPMODE  bit2:1 20MhzBW */
+	u8 regBwOpMode = 0;
+	u8 Bandwidth = pAdapter->mppriv.curr_bandwidth;
+
+	regBwOpMode = r8712_read8(pAdapter, 0x10250203);
+	if (Bandwidth == HT_CHANNEL_WIDTH_20)
+		regBwOpMode |= BIT(2);
+	else
+		regBwOpMode &= ~(BIT(2));
+	r8712_write8(pAdapter, 0x10250203, regBwOpMode);
+	/* 3 2.Set PHY related register */
+	switch (Bandwidth) {
+	/* 20 MHz channel*/
+	case HT_CHANNEL_WIDTH_20:
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+		set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+		/* Use PHY_REG.txt default value. Do not need to change.
+		 * Correct the tx power for CCK rate in 40M.
+		 * It is set in Tx descriptor for 8192x series
+		 */
+		set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x58);
+		break;
+	/* 40 MHz channel*/
+	case HT_CHANNEL_WIDTH_40:
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+		set_bb_reg(pAdapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+		/* Use PHY_REG.txt default value. Do not need to change.
+		 * Correct the tx power for CCK rate in 40M.
+		 * Set Control channel to upper or lower. These settings are
+		 * required only for 40MHz */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKSideBand,
+			   (HAL_PRIME_CHNL_OFFSET_DONT_CARE>>1));
+		set_bb_reg(pAdapter, rOFDM1_LSTF, 0xC00,
+			   HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_bb_reg(pAdapter, rFPGA0_AnalogParameter2, bMaskDWord, 0x18);
+		break;
+	default:
+		break;
+	}
+
+	/* 3 3.Set RF related register */
+	switch (Bandwidth) {
+	case HT_CHANNEL_WIDTH_20:
+		set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW,
+			   BIT(10) | BIT(11), 0x01);
+		break;
+	case HT_CHANNEL_WIDTH_40:
+		set_rf_reg(pAdapter, RF_PATH_A, RF_CHNLBW,
+			   BIT(10) | BIT(11), 0x00);
+		break;
+	default:
+		break;
+	}
+}
+/*------------------------------Define structure----------------------------*/
+struct R_ANTENNA_SELECT_OFDM {
+	u32	r_tx_antenna:4;
+	u32	r_ant_l:4;
+	u32	r_ant_non_ht:4;
+	u32	r_ant_ht1:4;
+	u32	r_ant_ht2:4;
+	u32	r_ant_ht_s1:4;
+	u32	r_ant_non_ht_s1:4;
+	u32	OFDM_TXSC:2;
+	u32	Reserved:2;
+};
+
+struct R_ANTENNA_SELECT_CCK {
+	u8	r_cckrx_enable_2:2;
+	u8	r_cckrx_enable:2;
+	u8	r_ccktx_enable:4;
+};
+
+void r8712_SwitchAntenna(struct _adapter *pAdapter)
+{
+	u32	ofdm_tx_en_val = 0, ofdm_tx_ant_sel_val = 0;
+	u8	ofdm_rx_ant_sel_val = 0;
+	u8	cck_ant_select_val = 0;
+	u32	cck_ant_sel_val = 0;
+	struct R_ANTENNA_SELECT_CCK *p_cck_txrx;
+
+	p_cck_txrx = (struct R_ANTENNA_SELECT_CCK *)&cck_ant_select_val;
+
+	switch (pAdapter->mppriv.antenna_tx) {
+	case ANTENNA_A:
+		/* From SD3 Willis suggestion !!! Set RF A=TX and B as standby*/
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 1);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x11111111;/* Power save */
+		p_cck_txrx->r_ccktx_enable = 0x8;
+		break;
+	case ANTENNA_B:
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 1);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x22222222;/* Power save */
+		p_cck_txrx->r_ccktx_enable = 0x4;
+		break;
+	case ANTENNA_AB:	/* For 8192S */
+		set_bb_reg(pAdapter, rFPGA0_XA_HSSIParameter2, 0xe, 2);
+		set_bb_reg(pAdapter, rFPGA0_XB_HSSIParameter2, 0xe, 2);
+		ofdm_tx_en_val = 0x3;
+		ofdm_tx_ant_sel_val = 0x3321333; /* Disable Power save */
+		p_cck_txrx->r_ccktx_enable = 0xC;
+		break;
+	default:
+		break;
+	}
+	/*OFDM Tx*/
+	set_bb_reg(pAdapter, rFPGA1_TxInfo, 0xffffffff, ofdm_tx_ant_sel_val);
+	/*OFDM Tx*/
+	set_bb_reg(pAdapter, rFPGA0_TxInfo, 0x0000000f, ofdm_tx_en_val);
+	switch (pAdapter->mppriv.antenna_rx) {
+	case ANTENNA_A:
+		ofdm_rx_ant_sel_val = 0x1;	/* A */
+		p_cck_txrx->r_cckrx_enable = 0x0; /* default: A */
+		p_cck_txrx->r_cckrx_enable_2 = 0x0; /* option: A */
+		break;
+	case ANTENNA_B:
+		ofdm_rx_ant_sel_val = 0x2;	/* B */
+		p_cck_txrx->r_cckrx_enable = 0x1; /* default: B */
+		p_cck_txrx->r_cckrx_enable_2 = 0x1; /* option: B */
+		break;
+	case ANTENNA_AB:
+		ofdm_rx_ant_sel_val = 0x3; /* AB */
+		p_cck_txrx->r_cckrx_enable = 0x0; /* default:A */
+		p_cck_txrx->r_cckrx_enable_2 = 0x1; /* option:B */
+		break;
+	default:
+		break;
+	}
+	/*OFDM Rx*/
+	set_bb_reg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f,
+		   ofdm_rx_ant_sel_val);
+	/*OFDM Rx*/
+	set_bb_reg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f,
+		   ofdm_rx_ant_sel_val);
+
+	cck_ant_sel_val = cck_ant_select_val;
+	/*CCK TxRx*/
+	set_bb_reg(pAdapter, rCCK0_AFESetting, bMaskByte3, cck_ant_sel_val);
+}
+
+void r8712_SetCrystalCap(struct _adapter *pAdapter)
+{
+	set_bb_reg(pAdapter, rFPGA0_AnalogParameter1, bXtalCap,
+		   pAdapter->mppriv.curr_crystalcap);
+}
+
+static void TriggerRFThermalMeter(struct _adapter *pAdapter)
+{
+	/* 0x24: RF Reg[6:5] */
+	set_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+}
+
+static u32 ReadRFThermalMeter(struct _adapter *pAdapter)
+{
+	u32 ThermalValue = 0;
+
+	/* 0x24: RF Reg[4:0] */
+	ThermalValue = get_rf_reg(pAdapter, RF_PATH_A, RF_T_METER, 0x1F);
+	return ThermalValue;
+}
+
+void r8712_GetThermalMeter(struct _adapter *pAdapter, u32 *value)
+{
+	TriggerRFThermalMeter(pAdapter);
+	msleep(1000);
+	*value = ReadRFThermalMeter(pAdapter);
+}
+
+void r8712_SetSingleCarrierTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) { /* Start Single Carrier. */
+		/* 1. if OFDM block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+			/*set OFDM block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		/* 2. set CCK test mode off, set to CCK normal mode */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+		/* 3. turn on scramble setting */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/* 4. Turn On Single Carrier Tx and off the other test modes. */
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else { /* Stop Single Carrier.*/
+		/* Turn off all test modes.*/
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+			   bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		msleep(20);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+}
+
+void r8712_SetSingleToneTx(struct _adapter *pAdapter, u8 bStart)
+{
+	u8 rfPath = pAdapter->mppriv.curr_rfpath;
+	switch (pAdapter->mppriv.antenna_tx) {
+	case ANTENNA_B:
+		rfPath = RF_PATH_B;
+		break;
+	case ANTENNA_A:
+	default:
+		rfPath = RF_PATH_A;
+		break;
+	}
+	if (bStart) { /* Start Single Tone.*/
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bDisable);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bDisable);
+		set_rf_reg(pAdapter, rfPath, RF_TX_G2, bRFRegOffsetMask,
+			   0xd4000);
+		msleep(100);
+		/* PAD all on.*/
+		set_rf_reg(pAdapter, rfPath, RF_AC, bRFRegOffsetMask, 0x2001f);
+		msleep(100);
+	} else { /* Stop Single Tone.*/
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);
+		set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		set_rf_reg(pAdapter, rfPath, RF_TX_G2, bRFRegOffsetMask,
+			   0x54000);
+		msleep(100);
+		/* PAD all on.*/
+		set_rf_reg(pAdapter, rfPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		msleep(100);
+	}
+}
+
+void r8712_SetCarrierSuppressionTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) { /* Start Carrier Suppression.*/
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			/* 1. if CCK block on? */
+			if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn)) {
+				/*set CCK block on*/
+				set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn,
+					   bEnable);
+			}
+			/* Turn Off All Test Mode */
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx,
+				   bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+				   bDisable);
+			set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone,
+				   bDisable);
+			/*transmit mode*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);
+			/*turn off scramble setting*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble,
+				   bDisable);
+			/*Set CCK Tx Test Rate*/
+			/*Set FTxRate to 1Mbps*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, 0x0);
+		}
+	} else { /* Stop Carrier Suppression. */
+		if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M) {
+			/*normal mode*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);
+			/*turn on scramble setting*/
+			set_bb_reg(pAdapter, rCCK0_System, bCCKScramble,
+				   bEnable);
+			/*BB Reset*/
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+			set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+		}
+	}
+}
+
+static void SetCCKContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	u32 cckrate;
+
+	if (bStart) {
+		/* 1. if CCK block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn)) {
+			/*set CCK block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);
+		}
+		/* Turn Off All Test Mode */
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		/*Set CCK Tx Test Rate*/
+		cckrate  = pAdapter->mppriv.curr_rateidx;
+		set_bb_reg(pAdapter, rCCK0_System, bCCKTxRate, cckrate);
+		/*transmit mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);
+		/*turn on scramble setting*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+	} else {
+		/*normal mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);
+		/*turn on scramble setting*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+} /* mpt_StartCckContTx */
+
+static void SetOFDMContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	if (bStart) {
+		/* 1. if OFDM block on? */
+		if (!get_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn)) {
+			/*set OFDM block on*/
+			set_bb_reg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);
+		}
+		/* 2. set CCK test mode off, set to CCK normal mode*/
+		set_bb_reg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
+		/* 3. turn on scramble setting */
+		set_bb_reg(pAdapter, rCCK0_System, bCCKScramble, bEnable);
+		/* 4. Turn On Continue Tx and turn off the other test modes.*/
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bEnable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+	} else {
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier,
+			   bDisable);
+		set_bb_reg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
+		msleep(20);
+		/*BB Reset*/
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
+		set_bb_reg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
+	}
+} /* mpt_StartOfdmContTx */
+
+void r8712_SetContinuousTx(struct _adapter *pAdapter, u8 bStart)
+{
+	/* ADC turn off [bit24-21] adc port0 ~ port1 */
+	if (bStart) {
+		r8712_bb_reg_write(pAdapter, rRx_Wait_CCCA,
+				   r8712_bb_reg_read(pAdapter,
+				   rRx_Wait_CCCA) & 0xFE1FFFFF);
+		msleep(100);
+	}
+	if (pAdapter->mppriv.curr_rateidx <= MPT_RATE_11M)
+		SetCCKContinuousTx(pAdapter, bStart);
+	else if ((pAdapter->mppriv.curr_rateidx >= MPT_RATE_6M) &&
+		 (pAdapter->mppriv.curr_rateidx <= MPT_RATE_MCS15))
+		SetOFDMContinuousTx(pAdapter, bStart);
+	/* ADC turn on [bit24-21] adc port0 ~ port1 */
+	if (!bStart)
+		r8712_bb_reg_write(pAdapter, rRx_Wait_CCCA,
+				   r8712_bb_reg_read(pAdapter,
+				   rRx_Wait_CCCA) | 0x01E00000);
+}
+
+void r8712_ResetPhyRxPktCount(struct _adapter *pAdapter)
+{
+	u32 i, phyrx_set = 0;
+
+	for (i = OFDM_PPDU_BIT; i <= HT_MPDU_FAIL_BIT; i++) {
+		phyrx_set = 0;
+		phyrx_set |= (i << 28);		/*select*/
+		phyrx_set |= 0x08000000;	/* set counter to zero*/
+		r8712_write32(pAdapter, RXERR_RPT, phyrx_set);
+	}
+}
+
+static u32 GetPhyRxPktCounts(struct _adapter *pAdapter, u32 selbit)
+{
+	/*selection*/
+	u32 phyrx_set = 0, count = 0;
+	u32 SelectBit;
+
+	SelectBit = selbit << 28;
+	phyrx_set |= (SelectBit & 0xF0000000);
+	r8712_write32(pAdapter, RXERR_RPT, phyrx_set);
+	/*Read packet count*/
+	count = r8712_read32(pAdapter, RXERR_RPT) & RPTMaxCount;
+	return count;
+}
+
+u32 r8712_GetPhyRxPktReceived(struct _adapter *pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_OK_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_OK_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_OK_BIT);
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
+
+u32 r8712_GetPhyRxPktCRC32Error(struct _adapter *pAdapter)
+{
+	u32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;
+
+	OFDM_cnt = GetPhyRxPktCounts(pAdapter, OFDM_MPDU_FAIL_BIT);
+	CCK_cnt = GetPhyRxPktCounts(pAdapter, CCK_MPDU_FAIL_BIT);
+	HT_cnt = GetPhyRxPktCounts(pAdapter, HT_MPDU_FAIL_BIT);
+	return OFDM_cnt + CCK_cnt + HT_cnt;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,342 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_MP_H_
+#define __RTL871X_MP_H_
+
+/*	00 - Success */
+/*	11 - Error */
+#define STATUS_SUCCESS			(0x00000000L)
+#define STATUS_PENDING			(0x00000103L)
+#define STATUS_UNSUCCESSFUL		(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES	(0xC000009AL)
+#define STATUS_NOT_SUPPORTED		(0xC00000BBL)
+#define NDIS_STATUS_SUCCESS		((uint)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING		((uint) STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED	((uint)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED		((uint)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED	((uint)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE		((uint)0x00010007L)
+#define NDIS_STATUS_FAILURE		((uint) STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES		((uint)\
+					STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING		((uint)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION		((uint)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS	((uint)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND	((uint)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED		((uint)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED	((uint)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL	((uint)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS	((uint)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND	((uint)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED	((uint)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS	((uint)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING	((uint)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED	((uint)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET	((uint)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL	((uint)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY	((uint)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN	((uint)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING	((uint)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH	((uint)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA	((uint)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT	((uint)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID		((uint)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED	((uint)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA	((uint)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE ((uint)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND	((uint)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE	((uint)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED	((uint)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT	((uint)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE		((uint)0xC001001FL)
+#define NDIS_STATUS_INVALID_SAP		((uint)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE		((uint)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS	((uint)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED	((uint)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER	((uint)0xC0010024L) /* cause 27*/
+#define NDIS_STATUS_VC_NOT_AVAILABLE	((uint)0xC0010025L) /* 35,45*/
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE ((uint)0xC0010026L) /* 37*/
+#define NDIS_STATUS_INCOMPATABLE_QOS	((uint)0xC0010027L)  /* 49*/
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED ((uint)0xC0010028L)  /*  93*/
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION ((uint)0xC0010029L)  /*  3*/
+#define MPT_NOOP			0
+#define MPT_READ_MAC_1BYTE		1
+#define MPT_READ_MAC_2BYTE		2
+#define MPT_READ_MAC_4BYTE		3
+#define MPT_WRITE_MAC_1BYTE		4
+#define MPT_WRITE_MAC_2BYTE		5
+#define MPT_WRITE_MAC_4BYTE		6
+#define MPT_READ_BB_CCK			7
+#define MPT_WRITE_BB_CCK		8
+#define MPT_READ_BB_OFDM		9
+#define MPT_WRITE_BB_OFDM		10
+#define MPT_READ_RF			11
+#define MPT_WRITE_RF			12
+#define MPT_READ_EEPROM_1BYTE		13
+#define MPT_WRITE_EEPROM_1BYTE		14
+#define MPT_READ_EEPROM_2BYTE		15
+#define MPT_WRITE_EEPROM_2BYTE		16
+#define MPT_SET_CSTHRESHOLD		21
+#define MPT_SET_INITGAIN		22
+#define MPT_SWITCH_BAND			23
+#define MPT_SWITCH_CHANNEL		24
+#define MPT_SET_DATARATE		25
+#define MPT_SWITCH_ANTENNA		26
+#define MPT_SET_TX_POWER		27
+#define MPT_SET_CONT_TX			28
+#define MPT_SET_SINGLE_CARRIER		29
+#define MPT_SET_CARRIER_SUPPRESSION	30
+#define MPT_GET_RATE_TABLE		31
+#define MPT_READ_TSSI			32
+#define MPT_GET_THERMAL_METER		33
+#define MAX_MP_XMITBUF_SZ	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	_pkt *pkt;
+	int frame_tag;
+	struct _adapter *padapter;
+	u8 *mem_addr;
+	u16 sz[8];
+	struct urb *pxmit_urb[8];
+	u8 bpending[8];
+	u8 last[8];
+};
+
+struct mp_wiparam {
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+struct mp_priv {
+	struct _adapter *papdater;
+	/*OID cmd handler*/
+	struct mp_wiparam workparam;
+	u8 act_in_progress;
+	/*Tx Section*/
+	u8 TID;
+	u32 tx_pktcount;
+	/*Rx Section*/
+	u32 rx_pktcount;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+	struct recv_stat rxstat;
+	/*RF/BB relative*/
+	u32 curr_ch;
+	u32 curr_rateidx;
+	u8 curr_bandwidth;
+	u8 curr_modem;
+	u8 curr_txpoweridx;
+	u32 curr_crystalcap;
+	u16 antenna_tx;
+	u16 antenna_rx;
+	u8 curr_rfpath;
+	u8 check_mp_pkt;
+	uint ForcedDataRate;
+	struct wlan_network mp_network;
+	unsigned char network_macaddr[6];
+	/*Testing Flag*/
+	u32 mode;/*0 for normal type packet,
+		  * 1 for loopback packet (16bytes TXCMD)*/
+	sint prev_fw_state;
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	struct  __queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+};
+
+struct IOCMD_STRUCT {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+};
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+/* ======================================================================= */
+
+#define LOWER	true
+#define RAISE	false
+#define IOCMD_CTRL_REG			0x10250370
+#define IOCMD_DATA_REG			0x10250374
+#define IOCMD_GET_THERMAL_METER		0xFD000028
+#define IOCMD_CLASS_BB_RF		0xF0
+#define IOCMD_BB_READ_IDX		0x00
+#define IOCMD_BB_WRITE_IDX		0x01
+#define IOCMD_RF_READ_IDX		0x02
+#define IOCMD_RF_WRIT_IDX		0x03
+#define BB_REG_BASE_ADDR		0x800
+#define RF_PATH_A	0
+#define RF_PATH_B	1
+#define RF_PATH_C	2
+#define RF_PATH_D	3
+#define MAX_RF_PATH_NUMS	2
+#define _2MAC_MODE_	0
+#define _LOOPBOOK_MODE_	1
+
+/* MP set force data rate base on the definition. */
+enum {
+	/* CCK rate. */
+	MPT_RATE_1M,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_LAST
+};
+
+/* Represent Channel Width in HT Capabilities */
+enum HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+};
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	/* 0x3F */
+
+enum POWER_MODE {
+	POWER_LOW = 0,
+	POWER_NORMAL
+};
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+#define RPTMaxCount 0x000FFFFF;
+
+/* parameter 1 : BitMask
+ *	bit 0  : OFDM PPDU
+ *	bit 1  : OFDM False Alarm
+ *	bit 2  : OFDM MPDU OK
+ *	bit 3  : OFDM MPDU Fail
+ *	bit 4  : CCK PPDU
+ *	bit 5  : CCK False Alarm
+ *	bit 6  : CCK MPDU ok
+ *	bit 7  : CCK MPDU fail
+ *	bit 8  : HT PPDU counter
+ *	bit 9  : HT false alarm
+ *	bit 10 : HT MPDU total
+ *	bit 11 : HT MPDU OK
+ *	bit 12 : HT MPDU fail
+ *	bit 15 : RX full drop
+ */
+enum RXPHY_BITMASK {
+	OFDM_PPDU_BIT = 0,
+	OFDM_MPDU_OK_BIT,
+	OFDM_MPDU_FAIL_BIT,
+	CCK_PPDU_BIT,
+	CCK_MPDU_OK_BIT,
+	CCK_MPDU_FAIL_BIT,
+	HT_PPDU_BIT,
+	HT_MPDU_BIT,
+	HT_MPDU_OK_BIT,
+	HT_MPDU_FAIL_BIT,
+};
+
+enum ENCRY_CTRL_STATE {
+	HW_CONTROL,		/*hw encryption& decryption*/
+	SW_CONTROL,		/*sw encryption& decryption*/
+	HW_ENCRY_SW_DECRY,	/*hw encryption & sw decryption*/
+	SW_ENCRY_HW_DECRY	/*sw encryption & hw decryption*/
+};
+
+/* Bandwidth Offset */
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+/*=======================================================================*/
+void mp871xinit(struct _adapter *padapter);
+void mp871xdeinit(struct _adapter *padapter);
+u32 r8712_bb_reg_read(struct _adapter *Adapter, u16 offset);
+u8 r8712_bb_reg_write(struct _adapter *Adapter, u16 offset, u32 value);
+u32 r8712_rf_reg_read(struct _adapter *Adapter, u8 path, u8 offset);
+u8 r8712_rf_reg_write(struct _adapter *Adapter, u8 path,
+		      u8 offset, u32 value);
+u32 r8712_get_bb_reg(struct _adapter *Adapter, u16 offset, u32 bitmask);
+u8 r8712_set_bb_reg(struct _adapter *Adapter, u16 offset,
+		    u32 bitmask, u32 value);
+u32 r8712_get_rf_reg(struct _adapter *Adapter, u8 path, u8 offset,
+		     u32 bitmask);
+u8 r8712_set_rf_reg(struct _adapter *Adapter, u8 path, u8 offset,
+		    u32 bitmask, u32 value);
+
+void r8712_SetChannel(struct _adapter *pAdapter);
+void r8712_SetTxPower(struct _adapter *pAdapte);
+void r8712_SetTxAGCOffset(struct _adapter *pAdapter, u32 ulTxAGCOffset);
+void r8712_SetDataRate(struct _adapter *pAdapter);
+void r8712_SwitchBandwidth(struct _adapter *pAdapter);
+void r8712_SwitchAntenna(struct _adapter *pAdapter);
+void r8712_SetCrystalCap(struct _adapter *pAdapter);
+void r8712_GetThermalMeter(struct _adapter *pAdapter, u32 *value);
+void r8712_SetContinuousTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetSingleCarrierTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetSingleToneTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_SetCarrierSuppressionTx(struct _adapter *pAdapter, u8 bStart);
+void r8712_ResetPhyRxPktCount(struct _adapter *pAdapter);
+u32 r8712_GetPhyRxPktReceived(struct _adapter *pAdapter);
+u32 r8712_GetPhyRxPktCRC32Error(struct _adapter *pAdapter);
+
+#endif /*__RTL871X_MP_H_*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_ioctl.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_ioctl.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_ioctl.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1473 @@
+/******************************************************************************
+ * rtl871x_mp_ioctl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mlme_osdep.h"
+#include "rtl871x_mp.h"
+#include "rtl871x_mp_ioctl.h"
+
+uint oid_null_function(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		if (poid_par_priv->information_buf_len >= sizeof(u8))
+			Adapter->registrypriv.wireless_mode =
+					*(u8 *)poid_par_priv->information_buf;
+		else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (poid_par_priv->information_buf_len >= sizeof(u8)) {
+			*(u8 *)poid_par_priv->information_buf =
+					 Adapter->registrypriv.wireless_mode;
+			*poid_par_priv->bytes_rw =
+					poid_par_priv->information_buf_len;
+		} else
+			status = NDIS_STATUS_INVALID_LENGTH;
+	} else {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	}
+	return status;
+}
+
+uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+	offset = (u16)(pbbreg->offset) & 0xFFF; /*0ffset :0x800~0xfff*/
+	if (offset < BB_REG_BASE_ADDR)
+		offset |= BB_REG_BASE_ADDR;
+	value = pbbreg->value;
+	r8712_bb_reg_write(Adapter, offset, value);
+	return status;
+}
+
+uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct bb_reg_param *pbbreg;
+	u16 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct bb_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct bb_reg_param *)(poid_par_priv->information_buf);
+	offset = (u16)(pbbreg->offset) & 0xFFF; /*0ffset :0x800~0xfff*/
+	if (offset < BB_REG_BASE_ADDR)
+		offset |= BB_REG_BASE_ADDR;
+	value = r8712_bb_reg_read(Adapter, offset);
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	offset = (u8)pbbreg->offset;
+	value = pbbreg->value;
+	r8712_rf_reg_write(Adapter, path, offset, value);
+	return status;
+}
+
+uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct rf_reg_param *pbbreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct rf_reg_param))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pbbreg = (struct rf_reg_param *)(poid_par_priv->information_buf);
+	path = (u8)pbbreg->path;
+	if (path > RF_PATH_B) /* 1T2R  path_a /path_b */
+		return NDIS_STATUS_NOT_ACCEPTED;
+	offset = (u8)pbbreg->offset;
+	value = r8712_rf_reg_read(Adapter, path, offset);
+	pbbreg->value = value;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+/*This function initializes the DUT to the MP test mode*/
+static int mp_start_test(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct ndis_wlan_bssid_ex bssid;
+	struct sta_info *psta;
+	unsigned long length;
+	unsigned long irqL;
+	int res = _SUCCESS;
+
+	/* 3 1. initialize a new struct ndis_wlan_bssid_ex */
+	memcpy(bssid.MacAddress, pmppriv->network_macaddr, ETH_ALEN);
+	bssid.Ssid.SsidLength = 16;
+	memcpy(bssid.Ssid.Ssid, (unsigned char *)"mp_pseudo_adhoc",
+		bssid.Ssid.SsidLength);
+	bssid.InfrastructureMode = Ndis802_11IBSS;
+	bssid.NetworkTypeInUse = Ndis802_11DS;
+	bssid.IELength = 0;
+	length = r8712_get_ndis_wlan_bssid_ex_sz(&bssid);
+	if (length % 4) {
+		/*round up to multiple of 4 bytes.*/
+		bssid.Length = ((length >> 2) + 1) << 2;
+	} else
+		bssid.Length = length;
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		goto end_of_mp_start_test;
+	/*init mp_start_test status*/
+	pmppriv->prev_fw_state = get_fwstate(pmlmepriv);
+	pmlmepriv->fw_state = WIFI_MP_STATE;
+	if (pmppriv->mode == _LOOPBOOK_MODE_)
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); /*append txdesc*/
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	/* 3 2. create a new psta for mp driver */
+	/* clear psta in the cur_network, if any */
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 tgt_network->network.MacAddress);
+	if (psta)
+		r8712_free_stainfo(padapter, psta);
+	psta = r8712_alloc_stainfo(&padapter->stapriv, bssid.MacAddress);
+	if (psta == NULL) {
+		res = _FAIL;
+		goto end_of_mp_start_test;
+	}
+	/* 3 3. join psudo AdHoc */
+	tgt_network->join_res = 1;
+	tgt_network->aid = psta->aid = 1;
+	memcpy(&tgt_network->network, &bssid, length);
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	r8712_os_indicate_connect(padapter);
+	/* Set to LINKED STATE for MP TRX Testing */
+	set_fwstate(pmlmepriv, _FW_LINKED);
+end_of_mp_start_test:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return res;
+}
+
+/*This function change the DUT from the MP test mode into normal mode */
+static int mp_stop_test(struct _adapter *padapter)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct sta_info *psta;
+	unsigned long irqL;
+
+	spin_lock_irqsave(&pmlmepriv->lock, irqL);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)
+		goto end_of_mp_stop_test;
+	/* 3 1. disconnect psudo AdHoc */
+	r8712_os_indicate_disconnect(padapter);
+	/* 3 2. clear psta used in mp test mode. */
+	psta = r8712_get_stainfo(&padapter->stapriv,
+				 tgt_network->network.MacAddress);
+	if (psta)
+		r8712_free_stainfo(padapter, psta);
+	/* 3 3. return to normal state (default:station mode) */
+	pmlmepriv->fw_state = pmppriv->prev_fw_state; /* WIFI_STATION_STATE;*/
+	/*flush the cur_network*/
+	memset(tgt_network, 0, sizeof(struct wlan_network));
+end_of_mp_stop_test:
+	spin_unlock_irqrestore(&pmlmepriv->lock, irqL);
+	return _SUCCESS;
+}
+
+int mp_start_joinbss(struct _adapter *padapter, struct ndis_802_11_ssid *pssid)
+{
+	struct mp_priv *pmppriv = &padapter->mppriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	unsigned char res = _SUCCESS;
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)
+		return _FAIL;
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
+		return _FAIL;
+	_clr_fwstate_(pmlmepriv, _FW_LINKED);
+	res = r8712_setassocsta_cmd(padapter, pmppriv->network_macaddr);
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	return res;
+}
+
+uint oid_rt_pro_set_data_rate_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 ratevalue;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	ratevalue = *((u32 *)poid_par_priv->information_buf);
+	if (ratevalue >= MPT_RATE_LAST)
+		return NDIS_STATUS_INVALID_DATA;
+	Adapter->mppriv.curr_rateidx = ratevalue;
+	r8712_SetDataRate(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 mode;
+	u8 val8;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return  NDIS_STATUS_NOT_ACCEPTED;
+	mode = *((u32 *)poid_par_priv->information_buf);
+	Adapter->mppriv.mode = mode;/* 1 for loopback*/
+	if (mp_start_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	r8712_write8(Adapter, MSR, 1); /* Link in ad hoc network, 0x1025004C */
+	r8712_write8(Adapter, RCR, 0); /* RCR : disable all pkt, 0x10250048 */
+	/* RCR disable Check BSSID, 0x1025004a */
+	r8712_write8(Adapter, RCR+2, 0x57);
+	/* disable RX filter map , mgt frames will put in RX FIFO 0 */
+	r8712_write16(Adapter, RXFLTMAP0, 0x0);
+	val8 = r8712_read8(Adapter, EE_9346CR);
+	if (!(val8 & _9356SEL)) { /*boot from EFUSE*/
+		r8712_efuse_reg_init(Adapter);
+		r8712_efuse_change_max_size(Adapter);
+		r8712_efuse_reg_uninit(Adapter);
+	}
+	return status;
+}
+
+uint oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (mp_stop_test(Adapter) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv
+						   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		Channel;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	Channel = *((u32 *)poid_par_priv->information_buf);
+	if (Channel > 14)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_ch = Channel;
+	r8712_SetChannel(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 antenna;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	antenna = *((u32 *)poid_par_priv->information_buf);
+	Adapter->mppriv.antenna_tx = (u16)((antenna & 0xFFFF0000) >> 16);
+	Adapter->mppriv.antenna_rx = (u16)(antenna & 0x0000FFFF);
+	r8712_SwitchAntenna(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_set_tx_power_control_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 tx_pwr_idx;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	tx_pwr_idx = *((u32 *)poid_par_priv->information_buf);
+	if (tx_pwr_idx > MAX_TX_PWR_INDEX_N_MODE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_txpoweridx = (u8)tx_pwr_idx;
+	r8712_SetTxPower(Adapter);
+	return status;
+}
+
+uint oid_rt_pro_query_tx_packet_sent_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.tx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_query_rx_packet_received_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.rx_pktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_query_rx_packet_crc32_error_hdl(
+					struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID) {
+		status = NDIS_STATUS_NOT_ACCEPTED;
+		return status;
+	}
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		*(u32 *)poid_par_priv->information_buf =
+					Adapter->mppriv.rx_crcerrpktcount;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.tx_pktcount = 0;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv
+						    *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len == sizeof(u32)) {
+		Adapter->mppriv.rx_pktcount = 0;
+		Adapter->mppriv.rx_crcerrpktcount = 0;
+	} else
+		status = NDIS_STATUS_INVALID_LENGTH;
+	return status;
+}
+
+uint oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv
+						 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	r8712_ResetPhyRxPktCount(Adapter);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv
+						  *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(u32 *)poid_par_priv->information_buf =
+					 r8712_GetPhyRxPktReceived(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv
+						     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len != sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(u32 *)poid_par_priv->information_buf =
+					 r8712_GetPhyRxPktCRC32Error(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_modulation_hdl(struct oid_par_priv
+					  *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	Adapter->mppriv.curr_modem = *((u8 *)poid_par_priv->information_buf);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetContinuousTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv
+						 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetSingleCarrierTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv
+						      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetCarrierSuppressionTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32		bStartTest;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bStartTest = *((u32 *)poid_par_priv->information_buf);
+	r8712_SetSingleToneTx(Adapter, (u8)bStartTest);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct ndis_802_11_ssid *pssid;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed = (u32)sizeof(struct ndis_802_11_ssid);
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pssid = (struct ndis_802_11_ssid *)poid_par_priv->information_buf;
+	if (mp_start_joinbss(Adapter, pssid) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = sizeof(struct ndis_802_11_ssid);
+	return status;
+}
+
+uint oid_rt_pro_read_register_hdl(struct oid_par_priv
+					 *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mp_rw_reg *RegRWStruct;
+	u16		offset;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	RegRWStruct = (struct mp_rw_reg *)poid_par_priv->information_buf;
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF)) {
+		/*baseband register*/
+		/*0ffset :0x800~0xfff*/
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;
+		RegRWStruct->value = r8712_bb_reg_read(Adapter, offset);
+	} else {
+		switch (RegRWStruct->width) {
+		case 1:
+			RegRWStruct->value = r8712_read8(Adapter,
+						   RegRWStruct->offset);
+			break;
+		case 2:
+			RegRWStruct->value = r8712_read16(Adapter,
+						    RegRWStruct->offset);
+			break;
+		case 4:
+			RegRWStruct->value = r8712_read32(Adapter,
+						    RegRWStruct->offset);
+			break;
+		default:
+			status = NDIS_STATUS_NOT_ACCEPTED;
+			break;
+		}
+	}
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mp_rw_reg *RegRWStruct;
+	u16		offset;
+	u32		value;
+	u32 oldValue = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	RegRWStruct = (struct mp_rw_reg *)poid_par_priv->information_buf;
+	if ((RegRWStruct->offset >= 0x10250800) &&
+	    (RegRWStruct->offset <= 0x10250FFF)) {
+		/*baseband register*/
+		offset = (u16)(RegRWStruct->offset) & 0xFFF;
+		value = RegRWStruct->value;
+		switch (RegRWStruct->width) {
+		case 1:
+			oldValue = r8712_bb_reg_read(Adapter, offset);
+			oldValue &= 0xFFFFFF00;
+			value &= 0x000000FF;
+			value |= oldValue;
+			break;
+		case 2:
+			oldValue = r8712_bb_reg_read(Adapter, offset);
+			oldValue &= 0xFFFF0000;
+			value &= 0x0000FFFF;
+			value |= oldValue;
+			break;
+		}
+		r8712_bb_reg_write(Adapter, offset, value);
+	} else {
+		switch (RegRWStruct->width) {
+		case 1:
+			r8712_write8(Adapter, RegRWStruct->offset,
+			       (unsigned char)RegRWStruct->value);
+			break;
+		case 2:
+			r8712_write16(Adapter, RegRWStruct->offset,
+				(unsigned short)RegRWStruct->value);
+			break;
+		case 4:
+			r8712_write32(Adapter, RegRWStruct->offset,
+				(unsigned int)RegRWStruct->value);
+			break;
+		default:
+			status = NDIS_STATUS_NOT_ACCEPTED;
+			break;
+		}
+
+		if ((status == NDIS_STATUS_SUCCESS) &&
+		    (RegRWStruct->offset == HIMR) &&
+		    (RegRWStruct->width == 4))
+			Adapter->ImrContent = RegRWStruct->value;
+	}
+	return status;
+}
+
+uint oid_rt_pro_burst_read_register_hdl(struct oid_par_priv
+					       *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct burst_rw_reg *pBstRwReg;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pBstRwReg = (struct burst_rw_reg *)poid_par_priv->information_buf;
+	r8712_read_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len,
+		 pBstRwReg->Data);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_burst_write_register_hdl(struct oid_par_priv
+						*poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct burst_rw_reg *pBstRwReg;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pBstRwReg = (struct burst_rw_reg *)poid_par_priv->information_buf;
+	r8712_write_mem(Adapter, pBstRwReg->offset, (u32)pBstRwReg->len,
+		  pBstRwReg->Data);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct eeprom_rw_param *pEEPROM;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pEEPROM = (struct eeprom_rw_param *)poid_par_priv->information_buf;
+	pEEPROM->value = r8712_eeprom_read16(Adapter,
+					     (u16)(pEEPROM->offset >> 1));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_write16_eeprom_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct eeprom_rw_param *pEEPROM;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pEEPROM = (struct eeprom_rw_param *)poid_par_priv->information_buf;
+	r8712_eeprom_write16(Adapter, (u16)(pEEPROM->offset >> 1),
+			     pEEPROM->value);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct mp_wiparam *pwi_param;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(struct mp_wiparam))
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (Adapter->mppriv.workparam.bcompleted == false)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	pwi_param = (struct mp_wiparam *)poid_par_priv->information_buf;
+	memcpy(pwi_param, &Adapter->mppriv.workparam,
+		sizeof(struct mp_wiparam));
+	Adapter->mppriv.act_in_progress = false;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(uint) * 2)
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (*(uint *)poid_par_priv->information_buf == 1)
+		Adapter->mppriv.rx_pktloss = 0;
+	*((uint *)poid_par_priv->information_buf+1) =
+					 Adapter->mppriv.rx_pktloss;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_wr_attrib_mem_hdl(struct oid_par_priv *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_setrfintfs_cmd(Adapter, *(unsigned char *)
+	    poid_par_priv->information_buf) == _FAIL)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	memcpy(poid_par_priv->information_buf,
+		(unsigned char *)&Adapter->mppriv.rxstat,
+		sizeof(struct recv_stat));
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv
+					    *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_setdatarate_cmd(Adapter,
+	    poid_par_priv->information_buf) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_get_thermal_meter_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (Adapter->mppriv.act_in_progress == true)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	/*init workparam*/
+	Adapter->mppriv.act_in_progress = true;
+	Adapter->mppriv.workparam.bcompleted = false;
+	Adapter->mppriv.workparam.act_type = MPT_GET_THERMAL_METER;
+	Adapter->mppriv.workparam.io_offset = 0;
+	Adapter->mppriv.workparam.io_value = 0xFFFFFFFF;
+	r8712_GetThermalMeter(Adapter, &Adapter->mppriv.workparam.io_value);
+	Adapter->mppriv.workparam.bcompleted = true;
+	Adapter->mppriv.act_in_progress = false;
+	*(u32 *)poid_par_priv->information_buf =
+				 Adapter->mppriv.workparam.io_value;
+	*poid_par_priv->bytes_rw = sizeof(u32);
+	return status;
+}
+
+uint oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	if (!r8712_setptm_cmd(Adapter, *((u8 *)poid_par_priv->information_buf)))
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+	uint status = NDIS_STATUS_SUCCESS;
+	u32 ratevalue;
+	u8 datarates[NumRates];
+	int i;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	ratevalue = *((u32 *)poid_par_priv->information_buf);
+	for (i = 0; i < NumRates; i++) {
+		if (ratevalue == mpdatarate[i])
+			datarates[i] = mpdatarate[i];
+		else
+			datarates[i] = 0xff;
+	}
+	if (r8712_setbasicrate_cmd(Adapter, datarates) != _SUCCESS)
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+
+uint oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+	*poid_par_priv->bytes_rw = 8;
+	memcpy(poid_par_priv->information_buf,
+		&(Adapter->pwrctrlpriv.pwr_mode), 8);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint pwr_mode, smart_ps;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_rw = 0;
+	*poid_par_priv->bytes_needed = 8;
+	if (poid_par_priv->information_buf_len < 8)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pwr_mode = *(uint *)(poid_par_priv->information_buf);
+	smart_ps = *(uint *)((addr_t)poid_par_priv->information_buf + 4);
+	if (pwr_mode != Adapter->pwrctrlpriv.pwr_mode || smart_ps !=
+			Adapter->pwrctrlpriv.smart_ps)
+		r8712_set_ps_mode(Adapter, pwr_mode, smart_ps);
+	*poid_par_priv->bytes_rw = 8;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct setratable_parm *prate_table;
+	u8 res;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed  = sizeof(struct setratable_parm);
+	if (poid_par_priv->information_buf_len <
+	    sizeof(struct setratable_parm))
+		return NDIS_STATUS_INVALID_LENGTH;
+	prate_table = (struct setratable_parm *)poid_par_priv->information_buf;
+	res = r8712_setrttbl_cmd(Adapter, prate_table);
+	if (res == _FAIL)
+		status = NDIS_STATUS_FAILURE;
+	return status;
+}
+
+uint oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv
+					   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	enum ENCRY_CTRL_STATE encry_mode = 0;
+
+	*poid_par_priv->bytes_needed = sizeof(u8);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	if (poid_par_priv->type_of_oid == SET_OID) {
+		encry_mode = *((u8 *)poid_par_priv->information_buf);
+		switch (encry_mode) {
+		case HW_CONTROL:
+			psecuritypriv->sw_decrypt = false;
+			psecuritypriv->sw_encrypt = false;
+			break;
+		case SW_CONTROL:
+			psecuritypriv->sw_decrypt = true;
+			psecuritypriv->sw_encrypt = true;
+			break;
+		case HW_ENCRY_SW_DECRY:
+			psecuritypriv->sw_decrypt = true;
+			psecuritypriv->sw_encrypt = false;
+			break;
+		case SW_ENCRY_HW_DECRY:
+			psecuritypriv->sw_decrypt = false;
+			psecuritypriv->sw_encrypt = true;
+			break;
+		}
+	} else {
+		if ((psecuritypriv->sw_encrypt == false) &&
+		    (psecuritypriv->sw_decrypt == false))
+			encry_mode = HW_CONTROL;
+		else if ((psecuritypriv->sw_encrypt == false) &&
+			 (psecuritypriv->sw_decrypt == true))
+			encry_mode = HW_ENCRY_SW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == true) &&
+			 (psecuritypriv->sw_decrypt == false))
+			encry_mode = SW_ENCRY_HW_DECRY;
+		else if ((psecuritypriv->sw_encrypt == true) &&
+			 (psecuritypriv->sw_decrypt == true))
+			encry_mode = SW_CONTROL;
+		*(u8 *)poid_par_priv->information_buf =  encry_mode;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	}
+	return NDIS_STATUS_SUCCESS;
+}
+/*----------------------------------------------------------------------*/
+uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info	*psta = NULL;
+	u8	*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	macaddr = (u8 *) poid_par_priv->information_buf;
+	psta = r8712_get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta == NULL) { /* the sta in sta_info_queue => do nothing*/
+		psta = r8712_alloc_stainfo(&Adapter->stapriv, macaddr);
+		if (psta == NULL)
+			status = NDIS_STATUS_FAILURE;
+	}
+	return status;
+}
+/*-------------------------------------------------------------------------*/
+uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	unsigned long			irqL;
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct sta_info		*psta = NULL;
+	u8			*macaddr;
+
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	*poid_par_priv->bytes_needed = ETH_ALEN;
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	macaddr = (u8 *)poid_par_priv->information_buf;
+
+	psta = r8712_get_stainfo(&Adapter->stapriv, macaddr);
+	if (psta != NULL) {
+		spin_lock_irqsave(&(Adapter->stapriv.sta_hash_lock), irqL);
+		r8712_free_stainfo(Adapter, psta);
+		spin_unlock_irqrestore(&(Adapter->stapriv.sta_hash_lock), irqL);
+	}
+
+	return status;
+}
+/*--------------------------------------------------------------------------*/
+static u32 mp_query_drv_var(struct _adapter *padapter, u8 offset, u32 var)
+{
+	return var;
+}
+
+uint oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct DR_VARIABLE_STRUCT *pdrv_var;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	*poid_par_priv->bytes_needed = sizeof(struct DR_VARIABLE_STRUCT);
+	if (poid_par_priv->information_buf_len < *poid_par_priv->bytes_needed)
+		return NDIS_STATUS_INVALID_LENGTH;
+	pdrv_var = (struct DR_VARIABLE_STRUCT *)poid_par_priv->information_buf;
+	pdrv_var->variable = mp_query_drv_var(Adapter, pdrv_var->offset,
+					      pdrv_var->variable);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+/*--------------------------------------------------------------------------*/
+uint oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+/*------------------------------------------------------------------------*/
+uint oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct EFUSE_ACCESS_STRUCT *pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len <
+	    sizeof(struct EFUSE_ACCESS_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+	pefuse = (struct EFUSE_ACCESS_STRUCT *)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+	memset(data, 0xFF, cnts);
+	if ((addr > 511) || (cnts < 1) || (cnts > 512) || (addr + cnts) >
+	     EFUSE_MAX_SIZE)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_efuse_access(Adapter, true, addr, cnts, data) == false)
+		status = NDIS_STATUS_FAILURE;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+/*------------------------------------------------------------------------*/
+uint oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	uint status = NDIS_STATUS_SUCCESS;
+
+	struct EFUSE_ACCESS_STRUCT *pefuse;
+	u8 *data;
+	u16 addr = 0, cnts = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	pefuse = (struct EFUSE_ACCESS_STRUCT *)poid_par_priv->information_buf;
+	addr = pefuse->start_addr;
+	cnts = pefuse->cnts;
+	data = pefuse->data;
+
+	if ((addr > 511) || (cnts < 1) || (cnts > 512) ||
+	    (addr + cnts) > r8712_efuse_get_max_size(Adapter))
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (r8712_efuse_access(Adapter, false, addr, cnts, data) == false)
+		status = NDIS_STATUS_FAILURE;
+	return status;
+}
+/*----------------------------------------------------------------------*/
+uint oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct PGPKT_STRUCT	*ppgpkt;
+
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < sizeof(struct PGPKT_STRUCT))
+		return NDIS_STATUS_INVALID_LENGTH;
+	ppgpkt = (struct PGPKT_STRUCT *)poid_par_priv->information_buf;
+	if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (r8712_efuse_pg_packet_read(Adapter, ppgpkt->offset,
+		    ppgpkt->data) == true)
+			*poid_par_priv->bytes_rw =
+				 poid_par_priv->information_buf_len;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		if (r8712_efuse_reg_init(Adapter) == true) {
+			if (r8712_efuse_pg_packet_write(Adapter, ppgpkt->offset,
+			    ppgpkt->word_en, ppgpkt->data) == true)
+				*poid_par_priv->bytes_rw =
+					 poid_par_priv->information_buf_len;
+			else
+				status = NDIS_STATUS_FAILURE;
+			r8712_efuse_reg_uninit(Adapter);
+		} else
+			status = NDIS_STATUS_FAILURE;
+	}
+	return status;
+}
+
+uint oid_rt_get_efuse_current_size_hdl(struct oid_par_priv
+					      *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(int))
+		return NDIS_STATUS_INVALID_LENGTH;
+	r8712_efuse_reg_init(Adapter);
+	*(int *)poid_par_priv->information_buf =
+				 r8712_efuse_get_current_size(Adapter);
+	r8712_efuse_reg_uninit(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(int *)poid_par_priv->information_buf =
+					 r8712_efuse_get_max_size(Adapter);
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return status;
+}
+
+uint oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv)
+{
+	uint status = NDIS_STATUS_SUCCESS;
+
+	if (poid_par_priv->type_of_oid == QUERY_OID)
+		status = oid_rt_pro_read_efuse_hdl(poid_par_priv);
+	else
+		status = oid_rt_pro_write_efuse_hdl(poid_par_priv);
+	return status;
+}
+
+uint oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u8		*data;
+
+	*poid_par_priv->bytes_rw = 0;
+	if (poid_par_priv->information_buf_len < EFUSE_MAP_MAX_SIZE)
+		return NDIS_STATUS_INVALID_LENGTH;
+	data = (u8 *)poid_par_priv->information_buf;
+	if (poid_par_priv->type_of_oid == QUERY_OID) {
+		if (r8712_efuse_map_read(Adapter, 0, EFUSE_MAP_MAX_SIZE, data))
+			*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+		else
+			status = NDIS_STATUS_FAILURE;
+	} else {
+		/* SET_OID */
+		if (r8712_efuse_reg_init(Adapter) == true) {
+			if (r8712_efuse_map_write(Adapter, 0,
+			    EFUSE_MAP_MAX_SIZE, data))
+				*poid_par_priv->bytes_rw = EFUSE_MAP_MAX_SIZE;
+			else
+				status = NDIS_STATUS_FAILURE;
+			r8712_efuse_reg_uninit(Adapter);
+		} else {
+			status = NDIS_STATUS_FAILURE;
+		}
+	}
+	return status;
+}
+
+uint oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		bandwidth;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	bandwidth = *((u32 *)poid_par_priv->information_buf);/*4*/
+	if (bandwidth != HT_CHANNEL_WIDTH_20)
+		bandwidth = HT_CHANNEL_WIDTH_40;
+	Adapter->mppriv.curr_bandwidth = (u8)bandwidth;
+	r8712_SwitchBandwidth(Adapter);
+	return status;
+}
+
+uint oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	u32		crystal_cap = 0;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	crystal_cap = *((u32 *)poid_par_priv->information_buf);/*4*/
+	if (crystal_cap > 0xf)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	Adapter->mppriv.curr_crystalcap = crystal_cap;
+	r8712_SetCrystalCap(Adapter);
+	return status;
+}
+
+uint oid_rt_set_rx_packet_type_hdl(struct oid_par_priv
+					   *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u8		rx_pkt_type;
+	u32		rcr_val32;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u8))
+		return NDIS_STATUS_INVALID_LENGTH;
+	rx_pkt_type = *((u8 *)poid_par_priv->information_buf);/*4*/
+	rcr_val32 = r8712_read32(Adapter, RCR);/*RCR = 0x10250048*/
+	rcr_val32 &= ~(RCR_CBSSID | RCR_AB | RCR_AM | RCR_APM | RCR_AAP);
+	switch (rx_pkt_type) {
+	case RX_PKT_BROADCAST:
+		rcr_val32 |= (RCR_AB | RCR_AM | RCR_APM | RCR_AAP | RCR_ACRC32);
+		break;
+	case RX_PKT_DEST_ADDR:
+		rcr_val32 |= (RCR_AB | RCR_AM | RCR_APM | RCR_AAP | RCR_ACRC32);
+		break;
+	case RX_PKT_PHY_MATCH:
+		rcr_val32 |= (RCR_APM|RCR_ACRC32);
+		break;
+	default:
+		rcr_val32 &= ~(RCR_AAP |
+			       RCR_APM |
+			       RCR_AM |
+			       RCR_AB |
+			       RCR_ACRC32);
+		break;
+	}
+	if (rx_pkt_type == RX_PKT_DEST_ADDR)
+		Adapter->mppriv.check_mp_pkt = 1;
+	else
+		Adapter->mppriv.check_mp_pkt = 0;
+	r8712_write32(Adapter, RCR, rcr_val32);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	u32 txagc;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	txagc = *(u32 *)poid_par_priv->information_buf;
+	r8712_SetTxAGCOffset(Adapter, txagc);
+	return NDIS_STATUS_SUCCESS;
+}
+
+uint oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv
+					     *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+	uint status = NDIS_STATUS_SUCCESS;
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	struct mp_priv		*pmppriv = &Adapter->mppriv;
+	u32			type;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+
+	type = *(u32 *)poid_par_priv->information_buf;
+
+	if (_LOOPBOOK_MODE_ == type) {
+		pmppriv->mode = type;
+		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); /*append txdesc*/
+	} else if (_2MAC_MODE_ == type) {
+		pmppriv->mode = type;
+		_clr_fwstate_(pmlmepriv, WIFI_MP_LPBK_STATE);
+	} else
+		status = NDIS_STATUS_NOT_ACCEPTED;
+	return status;
+}
+/*--------------------------------------------------------------------------*/
+/*Linux*/
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv)
+{
+	return _SUCCESS;
+}
+/*-------------------------------------------------------------------------*/
+uint oid_rt_set_power_down_hdl(struct oid_par_priv *poid_par_priv)
+{
+	u8	bpwrup;
+
+	if (poid_par_priv->type_of_oid != SET_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	bpwrup = *(u8 *)poid_par_priv->information_buf;
+	/*CALL  the power_down function*/
+	return NDIS_STATUS_SUCCESS;
+}
+
+/*-------------------------------------------------------------------------- */
+uint oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv)
+{
+	struct _adapter *Adapter = (struct _adapter *)
+				   (poid_par_priv->adapter_context);
+
+	if (poid_par_priv->type_of_oid != QUERY_OID)
+		return NDIS_STATUS_NOT_ACCEPTED;
+	if (poid_par_priv->information_buf_len < sizeof(u32))
+		return NDIS_STATUS_INVALID_LENGTH;
+	*(int *)poid_par_priv->information_buf =
+		 Adapter->registrypriv.low_power ? POWER_LOW : POWER_NORMAL;
+	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+	return NDIS_STATUS_SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_ioctl.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_ioctl.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_ioctl.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,480 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_MP_IOCTL_H
+#define _RTL871X_MP_IOCTL_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "mp_custom_oid.h"
+#include "rtl871x_ioctl.h"
+#include "rtl871x_ioctl_rtl.h"
+#include "rtl8712_efuse.h"
+
+#define TESTFWCMDNUMBER			1000000
+#define TEST_H2CINT_WAIT_TIME		500
+#define TEST_C2HINT_WAIT_TIME		500
+#define HCI_TEST_SYSCFG_HWMASK		1
+#define _BUSCLK_40M			(4 << 2)
+
+struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+};
+
+struct mp_rw_reg {
+	uint offset;
+	uint width;
+	u32 value;
+};
+
+/* for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM */
+struct eeprom_rw_param {
+	uint offset;
+	u16 value;
+};
+
+struct EFUSE_ACCESS_STRUCT {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+};
+
+struct burst_rw_reg {
+	uint offset;
+	uint len;
+	u8 Data[256];
+};
+
+struct usb_vendor_req {
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;/*0:OUT, 1:IN */
+	u8	u8InData;
+};
+
+struct DR_VARIABLE_STRUCT {
+	u8 offset;
+	u32 variable;
+};
+
+int mp_start_joinbss(struct _adapter *padapter, struct ndis_802_11_ssid *pssid);
+
+/* oid_rtl_seg_87_11_00 */
+uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_register_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_burst_read_register_hdl(struct oid_par_priv*
+					       poid_par_priv);
+uint oid_rt_pro_burst_write_register_hdl(struct oid_par_priv*
+						poid_par_priv);
+uint oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_wr_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+uint  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_20 */
+uint oid_rt_pro_cfg_debug_message_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_data_rate_ex_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_basic_rate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_power_tracking_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_50 */
+uint oid_rt_pro_qry_pwrstate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_pwrstate_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_F0 */
+uint oid_rt_pro_h2c_set_rate_table_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_h2c_get_rate_table_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_80_00 */
+uint oid_rt_pro_set_data_rate_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_channel_direct_call_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_antenna_bb_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_tx_power_control_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_80_20 */
+uint oid_rt_pro_query_tx_packet_sent_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_rx_packet_crc32_error_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_reset_tx_packet_sent_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_reset_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_modulation_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_continuous_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_single_carrier_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_carrier_suppression_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_single_tone_tx_hdl(
+				struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_87 */
+uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_85 */
+uint oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_12_00 */
+uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_query_dr_variable_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_efuse_current_size_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_tx_agc_offset_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_set_pkt_test_mode_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_thermal_meter_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_reset_phy_rx_packet_count_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_phy_rx_packet_received_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_phy_rx_packet_crc32_error_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_set_power_down_hdl(
+				struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_power_mode_hdl(
+				struct oid_par_priv *poid_par_priv);
+#ifdef _RTL871X_MP_IOCTL_C_ /* CAUTION!!! */
+/* This ifdef _MUST_ be left in!! */
+static const struct oid_obj_priv oid_rtl_seg_81_80_00[] = {
+	{1, &oid_null_function},	/*0x00	OID_RT_PRO_RESET_DUT */
+	{1, &oid_rt_pro_set_data_rate_hdl},	/*0x01*/
+	{1, &oid_rt_pro_start_test_hdl},/*0x02*/
+	{1, &oid_rt_pro_stop_test_hdl},	/*0x03*/
+	{1, &oid_null_function},	/*0x04	OID_RT_PRO_SET_PREAMBLE*/
+	{1, &oid_null_function},	/*0x05	OID_RT_PRO_SET_SCRAMBLER*/
+	{1, &oid_null_function},	/*0x06	OID_RT_PRO_SET_FILTER_BB*/
+	{1, &oid_null_function},	/*0x07
+					 * OID_RT_PRO_SET_MANUAL_DIVERS_BB*/
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	/*0x08*/
+	{1, &oid_null_function},	/*0x09
+				* OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL*/
+	{1, &oid_null_function},	/*0x0A
+				* OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL*/
+	{1, &oid_rt_pro_set_continuous_tx_hdl},	/*0x0B
+				* OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL*/
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl}, /*0x0C
+				* OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS*/
+	{1, &oid_null_function},	/*0x0D
+				* OID_RT_PRO_SET_TX_ANTENNA_BB*/
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		/*0x0E*/
+	{1, &oid_null_function},	/*0x0F	OID_RT_PRO_SET_CR_SCRAMBLER*/
+	{1, &oid_null_function},	/*0x10	OID_RT_PRO_SET_CR_NEW_FILTER*/
+	{1, &oid_rt_pro_set_tx_power_control_hdl}, /*0x11
+				* OID_RT_PRO_SET_TX_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x12	OID_RT_PRO_SET_CR_TX_CONFIG*/
+	{1, &oid_null_function},	/*0x13
+					 * OID_RT_PRO_GET_TX_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x14
+					 * OID_RT_PRO_GET_CR_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x15	OID_RT_PRO_SET_CR_SETPOINT*/
+	{1, &oid_null_function},	/*0x16	OID_RT_PRO_SET_INTEGRATOR*/
+	{1, &oid_null_function},	/*0x17	OID_RT_PRO_SET_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x18	OID_RT_PRO_GET_INTEGRATOR*/
+	{1, &oid_null_function},	/*0x19	OID_RT_PRO_GET_SIGNAL_QUALITY*/
+	{1, &oid_null_function},	/*0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE*/
+	{1, &oid_null_function},	/*0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS*/
+	{1, &oid_null_function},	/*0x1C	OID_RT_PRO_READ_MAC_ADDRESS*/
+	{1, &oid_null_function},	/*0x1D	OID_RT_PRO_WRITE_CIS_DATA*/
+	{1, &oid_null_function},	/*0x1E	OID_RT_PRO_READ_CIS_DATA*/
+	{1, &oid_null_function}		/*0x1F	OID_RT_PRO_WRITE_POWER_CONTROL*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_20[] = {
+	{1, &oid_null_function},	/*0x20	OID_RT_PRO_READ_POWER_CONTROL*/
+	{1, &oid_null_function},	/*0x21	OID_RT_PRO_WRITE_EEPROM*/
+	{1, &oid_null_function},	/*0x22	OID_RT_PRO_READ_EEPROM*/
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	/*0x23*/
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	/*0x24*/
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	/*0x25*/
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	/*0x26*/
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},/*0x27*/
+	{1, &oid_null_function},	/*0x28
+					 *OID_RT_PRO_QUERY_CURRENT_ADDRESS*/
+	{1, &oid_null_function},	/*0x29
+					 *OID_RT_PRO_QUERY_PERMANENT_ADDRESS*/
+	{1, &oid_null_function},	/*0x2A
+				 *OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS*/
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},/*0x2B
+				 *OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX*/
+	{1, &oid_null_function},	/*0x2C	OID_RT_PRO_RECEIVE_PACKET*/
+	{1, &oid_null_function},	/*0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE*/
+	{1, &oid_null_function},	/*0x2E	OID_RT_PRO_READ_EEPROM_BYTE*/
+	{1, &oid_rt_pro_set_modulation_hdl}		/*0x2F*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_40[] = {
+	{1, &oid_null_function},			/*0x40*/
+	{1, &oid_null_function},			/*0x41*/
+	{1, &oid_null_function},			/*0x42*/
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	/*0x43*/
+	{1, &oid_null_function},			/*0x44*/
+	{1, &oid_null_function}				/*0x45*/
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_80_80[] = {
+	{1, &oid_null_function},	/*0x80	OID_RT_DRIVER_OPTION*/
+	{1, &oid_null_function},	/*0x81	OID_RT_RF_OFF*/
+	{1, &oid_null_function}		/*0x82	OID_RT_AUTH_STATUS*/
+
+};
+
+static const struct oid_obj_priv oid_rtl_seg_81_85[] = {
+	{1, &oid_rt_wireless_mode_hdl}	/*0x00	OID_RT_WIRELESS_MODE*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+
+enum MP_MODE {
+	MP_START_MODE,
+	MP_STOP_MODE,
+	MP_ERR_MODE
+};
+
+struct rwreg_param {
+	unsigned int offset;
+	unsigned int width;
+	unsigned int value;
+};
+
+struct bbreg_param {
+	unsigned int offset;
+	unsigned int phymask;
+	unsigned int value;
+};
+
+struct txpower_param {
+	unsigned int pwr_index;
+};
+
+struct datarate_param {
+	unsigned int rate_index;
+};
+
+struct rfintfs_parm {
+	unsigned int rfintfs;
+};
+
+struct mp_xmit_packet {
+	unsigned int len;
+};
+
+struct psmode_param {
+	unsigned int ps_mode;
+	unsigned int smart_ps;
+};
+
+struct mp_ioctl_handler {
+	unsigned int paramsize;
+	unsigned int (*handler)(struct oid_par_priv *poid_par_priv);
+	unsigned int oid;
+};
+
+struct mp_ioctl_param {
+	unsigned int subcode;
+	unsigned int len;
+	unsigned char data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START),			/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP),			/*1*/
+	GEN_MP_IOCTL_SUBCODE(READ_REG),			/*2*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),		/*4*/
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*6*/
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),		/*7*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),		/*9*/
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_RF_INTFS),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),	/*12*/
+	GEN_MP_IOCTL_SUBCODE(PS_STATE),			/*13*/
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),		/*14*/
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),		/*15*/
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),			/*16*/
+	GEN_MP_IOCTL_SUBCODE(READ_TSSI),		/*17*/
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),			/*18*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),		/*19*/
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),		/*20*/
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),	/*21*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*22*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),	/*23*/
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*24*/
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),	/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_POWER_MODE),		/*26*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE),			/*27*/
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*28*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),	/*29*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),	/*30*/
+	GEN_MP_IOCTL_SUBCODE(SC_TX),			/*31*/
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*32*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),			/*33*/
+	GEN_MP_IOCTL_SUBCODE(SET_ANTENNA),		/*34*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+unsigned int mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTL871X_MP_IOCTL_C_ /* CAUTION!!! */
+/* This ifdef _MUST_ be left in!! */
+
+static struct mp_ioctl_handler mp_ioctl_hdl[] = {
+	{sizeof(u32), oid_rt_pro_start_test_hdl,
+			     OID_RT_PRO_START_TEST},/*0*/
+	{sizeof(u32), oid_rt_pro_stop_test_hdl,
+			     OID_RT_PRO_STOP_TEST},/*1*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_read_register_hdl,
+			     OID_RT_PRO_READ_REGISTER},/*2*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_write_register_hdl,
+			     OID_RT_PRO_WRITE_REGISTER},
+	{sizeof(u32),
+			     oid_rt_pro_set_channel_direct_call_hdl,
+			     OID_RT_PRO_SET_CHANNEL_DIRECT_CALL},
+	{sizeof(struct txpower_param),
+			     oid_rt_pro_set_tx_power_control_hdl,
+			     OID_RT_PRO_SET_TX_POWER_CONTROL},
+	{sizeof(u32),
+			     oid_rt_pro_set_data_rate_hdl,
+			     OID_RT_PRO_SET_DATA_RATE},
+	{sizeof(struct bb_reg_param),
+			     oid_rt_pro_read_bb_reg_hdl,
+			     OID_RT_PRO_READ_BB_REG},/*7*/
+	{sizeof(struct bb_reg_param),
+			     oid_rt_pro_write_bb_reg_hdl,
+			     OID_RT_PRO_WRITE_BB_REG},
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_read_rf_reg_hdl,
+			     OID_RT_PRO_RF_READ_REGISTRY},/*9*/
+	{sizeof(struct rwreg_param),
+			     oid_rt_pro_write_rf_reg_hdl,
+			     OID_RT_PRO_RF_WRITE_REGISTRY},
+	{sizeof(struct rfintfs_parm), NULL, 0},
+	{0, &mp_ioctl_xmit_packet_hdl, 0},/*12*/
+	{sizeof(struct psmode_param), NULL, 0},/*13*/
+	{sizeof(struct eeprom_rw_param), NULL, 0},/*14*/
+	{sizeof(struct eeprom_rw_param), NULL, 0},/*15*/
+	{sizeof(unsigned char), NULL, 0},/*16*/
+	{sizeof(u32), NULL, 0},/*17*/
+	{sizeof(u32), oid_rt_pro_set_continuous_tx_hdl,
+			     OID_RT_PRO_SET_CONTINUOUS_TX},/*18*/
+	{sizeof(u32), oid_rt_set_bandwidth_hdl,
+			     OID_RT_SET_BANDWIDTH},/*19*/
+	{sizeof(u32), oid_rt_set_rx_packet_type_hdl,
+			     OID_RT_SET_RX_PACKET_TYPE},/*20*/
+	{0, oid_rt_reset_phy_rx_packet_count_hdl,
+			     OID_RT_RESET_PHY_RX_PACKET_COUNT},/*21*/
+	{sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl,
+			     OID_RT_GET_PHY_RX_PACKET_RECEIVED},/*22*/
+	{sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl,
+			     OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR},/*23*/
+	{sizeof(unsigned char), oid_rt_set_power_down_hdl,
+			     OID_RT_SET_POWER_DOWN},/*24*/
+	{sizeof(u32), oid_rt_get_thermal_meter_hdl,
+			     OID_RT_PRO_GET_THERMAL_METER},/*25*/
+	{sizeof(u32), oid_rt_get_power_mode_hdl,
+			     OID_RT_GET_POWER_MODE},/*26*/
+	{sizeof(struct EFUSE_ACCESS_STRUCT),
+			     oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE},/*27*/
+	{EFUSE_MAP_MAX_SIZE, oid_rt_pro_efuse_map_hdl,
+			     OID_RT_PRO_EFUSE_MAP},/*28*/
+	{sizeof(u32), oid_rt_get_efuse_max_size_hdl,
+			     OID_RT_GET_EFUSE_MAX_SIZE},/*29*/
+	{sizeof(u32), oid_rt_get_efuse_current_size_hdl,
+			     OID_RT_GET_EFUSE_CURRENT_SIZE},/*30*/
+	{sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl,
+			     OID_RT_PRO_SET_SINGLE_CARRIER_TX},/*31*/
+	{sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl,
+			     OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX},/*32*/
+	{sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl,
+			     OID_RT_PRO_SET_SINGLE_TONE_TX},/*33*/
+	{sizeof(u32), oid_rt_pro_set_antenna_bb_hdl,
+			     OID_RT_PRO_SET_ANTENNA_BB},/*34*/
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1025 @@
+/*****************************************************************************
+ *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+ *
+ * Module:	__INC_HAL8192SPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *	Data			Who		Remark
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __RTL871X_MP_PHY_REGDEF_H
+#define __RTL871X_MP_PHY_REGDEF_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*============================================================
+ *       8192S Regsiter offset definition
+ *============================================================
+ *
+ *
+ * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+ * 3. RF register 0x00-2E
+ * 4. Bit Mask for BB/RF register
+ * 5. Other definition for BB/RF R/W
+ *
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 1. Page1(0x100)
+ */
+#define	rPMAC_Reset			0x100
+#define	rPMAC_TxStart			0x104
+#define	rPMAC_TxLegacySIG		0x108
+#define	rPMAC_TxHTSIG1			0x10c
+#define	rPMAC_TxHTSIG2			0x110
+#define	rPMAC_PHYDebug			0x114
+#define	rPMAC_TxPacketNum		0x118
+#define	rPMAC_TxIdle			0x11c
+#define	rPMAC_TxMACHeader0		0x120
+#define	rPMAC_TxMACHeader1		0x124
+#define	rPMAC_TxMACHeader2		0x128
+#define	rPMAC_TxMACHeader3		0x12c
+#define	rPMAC_TxMACHeader4		0x130
+#define	rPMAC_TxMACHeader5		0x134
+#define	rPMAC_TxDataType		0x138
+#define	rPMAC_TxRandomSeed		0x13c
+#define	rPMAC_CCKPLCPPreamble		0x140
+#define	rPMAC_CCKPLCPHeader		0x144
+#define	rPMAC_CCKCRC16			0x148
+#define	rPMAC_OFDMRxCRC32OK		0x170
+#define	rPMAC_OFDMRxCRC32Er		0x174
+#define	rPMAC_OFDMRxParityEr		0x178
+#define	rPMAC_OFDMRxCRC8Er		0x17c
+#define	rPMAC_CCKCRxRC16Er		0x180
+#define	rPMAC_CCKCRxRC32Er		0x184
+#define	rPMAC_CCKCRxRC32OK		0x188
+#define	rPMAC_TxStatus			0x18c
+
+/*
+ * 2. Page2(0x200)
+ *
+ * The following two definition are only used for USB interface.
+ *#define RF_BB_CMD_ADDR	0x02c0	// RF/BB read/write command address.
+ *#define RF_BB_CMD_DATA	0x02c4	// RF/BB read/write command data.
+ *
+ *
+ * 3. Page8(0x800)
+ */
+#define	rFPGA0_RFMOD			0x800	/*RF mode & CCK TxSC RF
+						 * BW Setting?? */
+#define	rFPGA0_TxInfo			0x804	/* Status report?? */
+#define	rFPGA0_PSDFunction		0x808
+#define	rFPGA0_TxGainStage		0x80c	/* Set TX PWR init gain? */
+#define	rFPGA0_RFTiming1		0x810	/* Useless now */
+#define	rFPGA0_RFTiming2		0x814
+#define	rFPGA0_XA_HSSIParameter1	0x820	/* RF 3 wire register */
+#define	rFPGA0_XA_HSSIParameter2	0x824
+#define	rFPGA0_XB_HSSIParameter1	0x828
+#define	rFPGA0_XB_HSSIParameter2	0x82c
+#define	rFPGA0_XC_HSSIParameter1	0x830
+#define	rFPGA0_XC_HSSIParameter2	0x834
+#define	rFPGA0_XD_HSSIParameter1	0x838
+#define	rFPGA0_XD_HSSIParameter2	0x83c
+#define	rFPGA0_XA_LSSIParameter		0x840
+#define	rFPGA0_XB_LSSIParameter		0x844
+#define	rFPGA0_XC_LSSIParameter		0x848
+#define	rFPGA0_XD_LSSIParameter		0x84c
+
+#define	rFPGA0_RFWakeUpParameter	0x850	/* Useless now */
+#define	rFPGA0_RFSleepUpParameter	0x854
+
+#define	rFPGA0_XAB_SwitchControl	0x858	/* RF Channel switch */
+#define	rFPGA0_XCD_SwitchControl	0x85c
+
+#define	rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
+#define	rFPGA0_XB_RFInterfaceOE		0x864
+#define	rFPGA0_XC_RFInterfaceOE		0x868
+#define	rFPGA0_XD_RFInterfaceOE		0x86c
+#define	rFPGA0_XAB_RFInterfaceSW	0x870	/* RF Interface Software Ctrl */
+#define	rFPGA0_XCD_RFInterfaceSW	0x874
+
+#define	rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
+#define	rFPGA0_XCD_RFParameter		0x87c
+
+#define	rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting
+						 * RF-R/W protection
+						 * for parameter4?? */
+#define	rFPGA0_AnalogParameter2		0x884
+#define	rFPGA0_AnalogParameter3		0x888	/* Useless now */
+#define	rFPGA0_AnalogParameter4		0x88c
+
+#define	rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
+#define	rFPGA0_XB_LSSIReadBack		0x8a4
+#define	rFPGA0_XC_LSSIReadBack		0x8a8
+#define	rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define	rFPGA0_PSDReport		0x8b4	/* Useless now */
+#define	rFPGA0_XAB_RFInterfaceRB	0x8e0	/* Useless now */
+#define	rFPGA0_XCD_RFInterfaceRB	0x8e4	/* Useless now */
+
+/*
+ * 4. Page9(0x900)
+ */
+#define	rFPGA1_RFMOD			0x900	/* RF mode & OFDM TxSC */
+
+#define	rFPGA1_TxBlock			0x904	/* Useless now */
+#define	rFPGA1_DebugSelect		0x908	/* Useless now */
+#define	rFPGA1_TxInfo			0x90c	/* Useless now */
+
+/*
+ * 5. PageA(0xA00)
+ *
+ * Set Control channel to upper or lower.
+ * These settings are required only for 40MHz */
+#define	rCCK0_System			0xa00
+
+#define	rCCK0_AFESetting		0xa04	/* Disable init gain now */
+#define	rCCK0_CCA			0xa08	/* Disable init gain now */
+
+#define	rCCK0_RxAGC1			0xa0c
+/* AGC default value, saturation level
+ * Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now.
+ * Not the same as 90 series */
+#define	rCCK0_RxAGC2			0xa10	/* AGC & DAGC */
+
+#define	rCCK0_RxHP			0xa14
+
+#define	rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel
+						 * estimation threshold */
+#define	rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define	rCCK0_TxFilter1			0xa20
+#define	rCCK0_TxFilter2			0xa24
+#define	rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define	rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d useless now 0xa30-a4f
+						 * channel report */
+#define	rCCK0_TRSSIReport		0xa50
+#define	rCCK0_RxReport			0xa54   /* 0xa57 */
+#define	rCCK0_FACounterLower		0xa5c   /* 0xa5b */
+#define	rCCK0_FACounterUpper		0xa58   /* 0xa5c */
+
+/*
+ * 6. PageC(0xC00)
+ */
+#define	rOFDM0_LSTF			0xc00
+#define	rOFDM0_TRxPathEnable		0xc04
+#define	rOFDM0_TRMuxPar			0xc08
+#define	rOFDM0_TRSWIsolation		0xc0c
+
+/*RxIQ DC offset, Rx digital filter, DC notch filter */
+#define	rOFDM0_XARxAFE			0xc10
+#define	rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
+#define	rOFDM0_XBRxAFE			0xc18
+#define	rOFDM0_XBRxIQImbalance		0xc1c
+#define	rOFDM0_XCRxAFE			0xc20
+#define	rOFDM0_XCRxIQImbalance		0xc24
+#define	rOFDM0_XDRxAFE			0xc28
+#define	rOFDM0_XDRxIQImbalance		0xc2c
+
+#define	rOFDM0_RxDetector1		0xc30  /* PD,BW & SBD DM tune
+						* init gain */
+#define	rOFDM0_RxDetector2		0xc34  /* SBD & Fame Sync. */
+#define	rOFDM0_RxDetector3		0xc38  /* Frame Sync. */
+#define	rOFDM0_RxDetector4		0xc3c  /* PD, SBD, Frame Sync &
+						* Short-GI */
+
+#define	rOFDM0_RxDSP			0xc40  /* Rx Sync Path */
+#define	rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define	rOFDM0_CCADropThreshold		0xc48 /* CCA Drop threshold */
+#define	rOFDM0_ECCAThreshold		0xc4c /* energy CCA */
+
+#define	rOFDM0_XAAGCCore1		0xc50	/* DIG */
+#define	rOFDM0_XAAGCCore2		0xc54
+#define	rOFDM0_XBAGCCore1		0xc58
+#define	rOFDM0_XBAGCCore2		0xc5c
+#define	rOFDM0_XCAGCCore1		0xc60
+#define	rOFDM0_XCAGCCore2		0xc64
+#define	rOFDM0_XDAGCCore1		0xc68
+#define	rOFDM0_XDAGCCore2		0xc6c
+#define	rOFDM0_AGCParameter1		0xc70
+#define	rOFDM0_AGCParameter2		0xc74
+#define	rOFDM0_AGCRSSITable		0xc78
+#define	rOFDM0_HTSTFAGC			0xc7c
+
+#define	rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
+#define	rOFDM0_XATxAFE			0xc84
+#define	rOFDM0_XBTxIQImbalance		0xc88
+#define	rOFDM0_XBTxAFE			0xc8c
+#define	rOFDM0_XCTxIQImbalance		0xc90
+#define	rOFDM0_XCTxAFE			0xc94
+#define	rOFDM0_XDTxIQImbalance		0xc98
+#define	rOFDM0_XDTxAFE			0xc9c
+
+#define	rOFDM0_RxHPParameter		0xce0
+#define	rOFDM0_TxPseudoNoiseWgt		0xce4
+#define	rOFDM0_FrameSync		0xcf0
+#define	rOFDM0_DFSReport		0xcf4
+#define	rOFDM0_TxCoeff1			0xca4
+#define	rOFDM0_TxCoeff2			0xca8
+#define	rOFDM0_TxCoeff3			0xcac
+#define	rOFDM0_TxCoeff4			0xcb0
+#define	rOFDM0_TxCoeff5			0xcb4
+#define	rOFDM0_TxCoeff6			0xcb8
+
+/*
+ * 7. PageD(0xD00)
+ */
+#define	rOFDM1_LSTF			0xd00
+#define	rOFDM1_TRxPathEnable		0xd04
+
+#define	rOFDM1_CFO			0xd08	/* No setting now */
+#define	rOFDM1_CSI1			0xd10
+#define	rOFDM1_SBD			0xd14
+#define	rOFDM1_CSI2			0xd18
+#define	rOFDM1_CFOTracking		0xd2c
+#define	rOFDM1_TRxMesaure1		0xd34
+#define	rOFDM1_IntfDet			0xd3c
+#define	rOFDM1_PseudoNoiseStateAB	0xd50
+#define	rOFDM1_PseudoNoiseStateCD	0xd54
+#define	rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define	rOFDM_PHYCounter1		0xda0  /* cca, parity fail */
+#define	rOFDM_PHYCounter2		0xda4  /* rate illegal, crc8 fail */
+#define	rOFDM_PHYCounter3		0xda8  /* MCS not support */
+#define	rOFDM_ShortCFOAB		0xdac  /* No setting now */
+#define	rOFDM_ShortCFOCD		0xdb0
+#define	rOFDM_LongCFOAB			0xdb4
+#define	rOFDM_LongCFOCD			0xdb8
+#define	rOFDM_TailCFOAB			0xdbc
+#define	rOFDM_TailCFOCD			0xdc0
+#define	rOFDM_PWMeasure1		0xdc4
+#define	rOFDM_PWMeasure2		0xdc8
+#define	rOFDM_BWReport			0xdcc
+#define	rOFDM_AGCReport			0xdd0
+#define	rOFDM_RxSNR			0xdd4
+#define	rOFDM_RxEVMCSI			0xdd8
+#define	rOFDM_SIGReport			0xddc
+
+/*
+ * 8. PageE(0xE00)
+ */
+#define	rTxAGC_Rate18_06		0xe00
+#define	rTxAGC_Rate54_24		0xe04
+#define	rTxAGC_CCK_Mcs32		0xe08
+#define	rTxAGC_Mcs03_Mcs00		0xe10
+#define	rTxAGC_Mcs07_Mcs04		0xe14
+#define	rTxAGC_Mcs11_Mcs08		0xe18
+#define	rTxAGC_Mcs15_Mcs12		0xe1c
+
+/* Analog- control in RX_WAIT_CCA : REG: EE0
+ * [Analog- Power & Control Register] */
+#define		rRx_Wait_CCCA		0xe70
+#define	rAnapar_Ctrl_BB			0xee0
+
+/*
+ * 7. RF Register 0x00-0x2E (RF 8256)
+ *    RF-0222D 0x00-3F
+ *
+ * Zebra1
+ */
+#define	rZebra1_HSSIEnable		0x0	/* Useless now */
+#define	rZebra1_TRxEnable1		0x1
+#define	rZebra1_TRxEnable2		0x2
+#define	rZebra1_AGC			0x4
+#define	rZebra1_ChargePump		0x5
+#define	rZebra1_Channel			0x7	/* RF channel switch */
+#define	rZebra1_TxGain			0x8	/* Useless now */
+#define	rZebra1_TxLPF			0x9
+#define	rZebra1_RxLPF			0xb
+#define	rZebra1_RxHPFCorner		0xc
+
+/* Zebra4 */
+#define	rGlobalCtrl			0	/* Useless now */
+#define	rRTL8256_TxLPF			19
+#define	rRTL8256_RxLPF			11
+
+/* RTL8258 */
+#define	rRTL8258_TxLPF			0x11	/* Useless now */
+#define	rRTL8258_RxLPF			0x13
+#define	rRTL8258_RSSILPF		0xa
+
+/* RL6052 Register definition */
+#define	RF_AC				0x00
+#define	RF_IQADJ_G1			0x01
+#define	RF_IQADJ_G2			0x02
+#define	RF_POW_TRSW			0x05
+
+#define	RF_GAIN_RX			0x06
+#define	RF_GAIN_TX			0x07
+
+#define	RF_TXM_IDAC			0x08
+#define	RF_BS_IQGEN			0x0F
+
+#define	RF_MODE1			0x10
+#define	RF_MODE2			0x11
+
+#define	RF_RX_AGC_HP			0x12
+#define	RF_TX_AGC			0x13
+#define	RF_BIAS				0x14
+#define	RF_IPA				0x15
+#define	RF_POW_ABILITY			0x17
+#define	RF_MODE_AG			0x18
+#define	rRfChannel			0x18	/* RF channel and BW switch */
+#define	RF_CHNLBW			0x18	/* RF channel and BW switch */
+#define	RF_TOP				0x19
+#define	RF_RX_G1			0x1A
+#define	RF_RX_G2			0x1B
+#define	RF_RX_BB2			0x1C
+#define	RF_RX_BB1			0x1D
+
+#define	RF_RCK1				0x1E
+#define	RF_RCK2				0x1F
+
+#define	RF_TX_G1			0x20
+#define	RF_TX_G2			0x21
+#define	RF_TX_G3			0x22
+
+#define	RF_TX_BB1			0x23
+#define	RF_T_METER			0x24
+
+#define	RF_SYN_G1			0x25	/* RF TX Power control */
+#define	RF_SYN_G2			0x26	/* RF TX Power control */
+#define	RF_SYN_G3			0x27	/* RF TX Power control */
+#define	RF_SYN_G4			0x28	/* RF TX Power control */
+#define	RF_SYN_G5			0x29	/* RF TX Power control */
+#define	RF_SYN_G6			0x2A	/* RF TX Power control */
+#define	RF_SYN_G7			0x2B	/* RF TX Power control */
+#define	RF_SYN_G8			0x2C	/* RF TX Power control */
+
+#define	RF_RCK_OS			0x30	/* RF TX PA control */
+
+#define	RF_TXPA_G1			0x31	/* RF TX PA control */
+#define	RF_TXPA_G2			0x32	/* RF TX PA control */
+#define	RF_TXPA_G3			0x33	/* RF TX PA control */
+
+/*
+ * Bit Mask
+ *
+ * 1. Page1(0x100) */
+#define	bBBResetB			0x100	/* Useless now? */
+#define	bGlobalResetB			0x200
+#define	bOFDMTxStart			0x4
+#define	bCCKTxStart			0x8
+#define	bCRC32Debug			0x100
+#define	bPMACLoopback			0x10
+#define	bTxLSIG				0xffffff
+#define	bOFDMTxRate			0xf
+#define	bOFDMTxReserved			0x10
+#define	bOFDMTxLength			0x1ffe0
+#define	bOFDMTxParity			0x20000
+#define	bTxHTSIG1			0xffffff
+#define	bTxHTMCSRate			0x7f
+#define	bTxHTBW				0x80
+#define	bTxHTLength			0xffff00
+#define	bTxHTSIG2			0xffffff
+#define	bTxHTSmoothing			0x1
+#define	bTxHTSounding			0x2
+#define	bTxHTReserved			0x4
+#define	bTxHTAggreation			0x8
+#define	bTxHTSTBC			0x30
+#define	bTxHTAdvanceCoding		0x40
+#define	bTxHTShortGI			0x80
+#define	bTxHTNumberHT_LTF		0x300
+#define	bTxHTCRC8			0x3fc00
+#define	bCounterReset			0x10000
+#define	bNumOfOFDMTx			0xffff
+#define	bNumOfCCKTx			0xffff0000
+#define	bTxIdleInterval			0xffff
+#define	bOFDMService			0xffff0000
+#define	bTxMACHeader			0xffffffff
+#define	bTxDataInit			0xff
+#define	bTxHTMode			0x100
+#define	bTxDataType			0x30000
+#define	bTxRandomSeed			0xffffffff
+#define	bCCKTxPreamble			0x1
+#define	bCCKTxSFD			0xffff0000
+#define	bCCKTxSIG			0xff
+#define	bCCKTxService			0xff00
+#define	bCCKLengthExt			0x8000
+#define	bCCKTxLength			0xffff0000
+#define	bCCKTxCRC16			0xffff
+#define	bCCKTxStatus			0x1
+#define	bOFDMTxStatus			0x2
+#define IS_BB_REG_OFFSET_92S(_Offset)	((_Offset >= 0x800) && \
+					(_Offset <= 0xfff))
+
+/* 2. Page8(0x800) */
+#define	bRFMOD			0x1	/* Reg 0x800 rFPGA0_RFMOD */
+#define	bJapanMode		0x2
+#define	bCCKTxSC		0x30
+#define	bCCKEn			0x1000000
+#define	bOFDMEn			0x2000000
+
+#define	bOFDMRxADCPhase         0x10000	/* Useless now */
+#define	bOFDMTxDACPhase         0x40000
+#define	bXATxAGC                0x3f
+#define	bXBTxAGC                0xf00	/* Reg 80c rFPGA0_TxGainStage */
+#define	bXCTxAGC                0xf000
+#define	bXDTxAGC                0xf0000
+
+#define	bPAStart		0xf0000000	/* Useless now */
+#define	bTRStart		0x00f00000
+#define	bRFStart		0x0000f000
+#define	bBBStart		0x000000f0
+#define	bBBCCKStart		0x0000000f
+#define	bPAEnd			0xf          /* Reg0x814 */
+#define	bTREnd			0x0f000000
+#define	bRFEnd			0x000f0000
+#define	bCCAMask		0x000000f0   /* T2R */
+#define	bR2RCCAMask		0x00000f00
+#define	bHSSI_R2TDelay		0xf8000000
+#define	bHSSI_T2RDelay		0xf80000
+#define	bContTxHSSI		0x400     /* change gain at continue Tx */
+#define	bIGFromCCK		0x200
+#define	bAGCAddress		0x3f
+#define	bRxHPTx			0x7000
+#define	bRxHPT2R		0x38000
+#define	bRxHPCCKIni		0xc0000
+#define	bAGCTxCode		0xc00000
+#define	bAGCRxCode		0x300000
+#define	b3WireDataLength	0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParm1 */
+#define	b3WireAddressLength	0x400
+#define	b3WireRFPowerDown	0x1	/* Useless now */
+#define	b5GPAPEPolarity		0x40000000
+#define	b2GPAPEPolarity		0x80000000
+#define	bRFSW_TxDefaultAnt	0x3
+#define	bRFSW_TxOptionAnt	0x30
+#define	bRFSW_RxDefaultAnt	0x300
+#define	bRFSW_RxOptionAnt	0x3000
+#define	bRFSI_3WireData		0x1
+#define	bRFSI_3WireClock	0x2
+#define	bRFSI_3WireLoad		0x4
+#define	bRFSI_3WireRW		0x8
+#define	bRFSI_3Wire		0xf
+#define	bRFSI_RFENV		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+#define	bRFSI_TRSW		0x20	/* Useless now */
+#define	bRFSI_TRSWB		0x40
+#define	bRFSI_ANTSW		0x100
+#define	bRFSI_ANTSWB		0x200
+#define	bRFSI_PAPE		0x400
+#define	bRFSI_PAPE5G		0x800
+#define	bBandSelect		0x1
+#define	bHTSIG2_GI		0x80
+#define	bHTSIG2_Smoothing	0x01
+#define	bHTSIG2_Sounding	0x02
+#define	bHTSIG2_Aggreaton	0x08
+#define	bHTSIG2_STBC		0x30
+#define	bHTSIG2_AdvCoding	0x40
+#define	bHTSIG2_NumOfHTLTF	0x300
+#define	bHTSIG2_CRC8		0x3fc
+#define	bHTSIG1_MCS		0x7f
+#define	bHTSIG1_BandWidth	0x80
+#define	bHTSIG1_HTLength	0xffff
+#define	bLSIG_Rate		0xf
+#define	bLSIG_Reserved		0x10
+#define	bLSIG_Length		0x1fffe
+#define	bLSIG_Parity		0x20
+#define	bCCKRxPhase		0x4
+#define	bLSSIReadAddress	0x7f800000   /* T65 RF */
+#define	bLSSIReadEdge		0x80000000   /* LSSI "Read" edge signal */
+#define	bLSSIReadBackData	0xfffff		/* T65 RF */
+#define	bLSSIReadOKFlag		0x1000	/* Useless now */
+#define	bCCKSampleRate		0x8       /*0: 44MHz, 1:88MHz*/
+#define	bRegulator0Standby	0x1
+#define	bRegulatorPLLStandby	0x2
+#define	bRegulator1Standby	0x4
+#define	bPLLPowerUp		0x8
+#define	bDPLLPowerUp		0x10
+#define	bDA10PowerUp		0x20
+#define	bAD7PowerUp		0x200
+#define	bDA6PowerUp		0x2000
+#define	bXtalPowerUp		0x4000
+#define	b40MDClkPowerUP		0x8000
+#define	bDA6DebugMode		0x20000
+#define	bDA6Swing		0x380000
+
+/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+#define	bADClkPhase		0x4000000
+
+#define	b80MClkDelay		0x18000000	/* Useless */
+#define	bAFEWatchDogEnable	0x20000000
+
+/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define	bXtalCap01		0xc0000000
+#define	bXtalCap23		0x3
+#define	bXtalCap92x		0x0f000000
+#define bXtalCap		0x0f000000
+#define	bIntDifClkEnable	0x400	/* Useless */
+#define	bExtSigClkEnable	0x800
+#define	bBandgapMbiasPowerUp	0x10000
+#define	bAD11SHGain		0xc0000
+#define	bAD11InputRange		0x700000
+#define	bAD11OPCurrent		0x3800000
+#define	bIPathLoopback		0x4000000
+#define	bQPathLoopback		0x8000000
+#define	bAFELoopback		0x10000000
+#define	bDA10Swing		0x7e0
+#define	bDA10Reverse		0x800
+#define	bDAClkSource		0x1000
+#define	bAD7InputRange		0x6000
+#define	bAD7Gain		0x38000
+#define	bAD7OutputCMMode	0x40000
+#define	bAD7InputCMMode		0x380000
+#define	bAD7Current		0xc00000
+#define	bRegulatorAdjust	0x7000000
+#define	bAD11PowerUpAtTx	0x1
+#define	bDA10PSAtTx		0x10
+#define	bAD11PowerUpAtRx	0x100
+#define	bDA10PSAtRx		0x1000
+#define	bCCKRxAGCFormat		0x200
+#define	bPSDFFTSamplepPoint	0xc000
+#define	bPSDAverageNum		0x3000
+#define	bIQPathControl		0xc00
+#define	bPSDFreq		0x3ff
+#define	bPSDAntennaPath		0x30
+#define	bPSDIQSwitch		0x40
+#define	bPSDRxTrigger		0x400000
+#define	bPSDTxTrigger		0x80000000
+#define	bPSDSineToneScale	0x7f000000
+#define	bPSDReport		0xffff
+
+/* 3. Page9(0x900) */
+#define	bOFDMTxSC		0x30000000	/* Useless */
+#define	bCCKTxOn		0x1
+#define	bOFDMTxOn		0x2
+#define	bDebugPage		0xfff  /* reset debug page and HWord, LWord */
+#define	bDebugItem		0xff   /* reset debug page and LWord */
+#define	bAntL			0x10
+#define	bAntNonHT		0x100
+#define	bAntHT1			0x1000
+#define	bAntHT2			0x10000
+#define	bAntHT1S1		0x100000
+#define	bAntNonHTS1		0x1000000
+
+/* 4. PageA(0xA00) */
+#define	bCCKBBMode		0x3	/* Useless */
+#define	bCCKTxPowerSaving	0x80
+#define	bCCKRxPowerSaving	0x40
+
+#define	bCCKSideBand		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch*/
+#define	bCCKScramble		0x8	/* Useless */
+#define	bCCKAntDiversity	0x8000
+#define	bCCKCarrierRecovery	0x4000
+#define	bCCKTxRate		0x3000
+#define	bCCKDCCancel		0x0800
+#define	bCCKISICancel		0x0400
+#define	bCCKMatchFilter		0x0200
+#define	bCCKEqualizer		0x0100
+#define	bCCKPreambleDetect	0x800000
+#define	bCCKFastFalseCCA	0x400000
+#define	bCCKChEstStart		0x300000
+#define	bCCKCCACount		0x080000
+#define	bCCKcs_lim		0x070000
+#define	bCCKBistMode		0x80000000
+#define	bCCKCCAMask		0x40000000
+#define	bCCKTxDACPhase		0x4
+#define	bCCKRxADCPhase		0x20000000   /* r_rx_clk */
+#define	bCCKr_cp_mode0		0x0100
+#define	bCCKTxDCOffset		0xf0
+#define	bCCKRxDCOffset		0xf
+#define	bCCKCCAMode		0xc000
+#define	bCCKFalseCS_lim		0x3f00
+#define	bCCKCS_ratio		0xc00000
+#define	bCCKCorgBit_sel		0x300000
+#define	bCCKPD_lim		0x0f0000
+#define	bCCKNewCCA		0x80000000
+#define	bCCKRxHPofIG		0x8000
+#define	bCCKRxIG		0x7f00
+#define	bCCKLNAPolarity		0x800000
+#define	bCCKRx1stGain		0x7f0000
+#define	bCCKRFExtend		0x20000000 /* CCK Rx Iinital gain polarity */
+#define	bCCKRxAGCSatLevel	0x1f000000
+#define	bCCKRxAGCSatCount       0xe0
+#define	bCCKRxRFSettle          0x1f       /* AGCsamp_dly */
+#define	bCCKFixedRxAGC          0x8000
+#define	bCCKAntennaPolarity     0x2000
+#define	bCCKTxFilterType        0x0c00
+#define	bCCKRxAGCReportType	0x0300
+#define	bCCKRxDAGCEn            0x80000000
+#define	bCCKRxDAGCPeriod        0x20000000
+#define	bCCKRxDAGCSatLevel	0x1f000000
+#define	bCCKTimingRecovery      0x800000
+#define	bCCKTxC0                0x3f0000
+#define	bCCKTxC1                0x3f000000
+#define	bCCKTxC2                0x3f
+#define	bCCKTxC3                0x3f00
+#define	bCCKTxC4                0x3f0000
+#define	bCCKTxC5		0x3f000000
+#define	bCCKTxC6		0x3f
+#define	bCCKTxC7		0x3f00
+#define	bCCKDebugPort		0xff0000
+#define	bCCKDACDebug		0x0f000000
+#define	bCCKFalseAlarmEnable	0x8000
+#define	bCCKFalseAlarmRead	0x4000
+#define	bCCKTRSSI		0x7f
+#define	bCCKRxAGCReport		0xfe
+#define	bCCKRxReport_AntSel	0x80000000
+#define	bCCKRxReport_MFOff	0x40000000
+#define	bCCKRxRxReport_SQLoss	0x20000000
+#define	bCCKRxReport_Pktloss	0x10000000
+#define	bCCKRxReport_Lockedbit	0x08000000
+#define	bCCKRxReport_RateError	0x04000000
+#define	bCCKRxReport_RxRate	0x03000000
+#define	bCCKRxFACounterLower	0xff
+#define	bCCKRxFACounterUpper	0xff000000
+#define	bCCKRxHPAGCStart	0xe000
+#define	bCCKRxHPAGCFinal	0x1c00
+#define	bCCKRxFalseAlarmEnable	0x8000
+#define	bCCKFACounterFreeze	0x4000
+#define	bCCKTxPathSel		0x10000000
+#define	bCCKDefaultRxPath	0xc000000
+#define	bCCKOptionRxPath	0x3000000
+
+/* 5. PageC(0xC00) */
+#define	bNumOfSTF		0x3	/* Useless */
+#define	bShift_L                0xc0
+#define	bGI_TH			0xc
+#define	bRxPathA		0x1
+#define	bRxPathB		0x2
+#define	bRxPathC		0x4
+#define	bRxPathD		0x8
+#define	bTxPathA		0x1
+#define	bTxPathB		0x2
+#define	bTxPathC		0x4
+#define	bTxPathD		0x8
+#define	bTRSSIFreq		0x200
+#define	bADCBackoff		0x3000
+#define	bDFIRBackoff		0xc000
+#define	bTRSSILatchPhase	0x10000
+#define	bRxIDCOffset		0xff
+#define	bRxQDCOffset		0xff00
+#define	bRxDFIRMode		0x1800000
+#define	bRxDCNFType		0xe000000
+#define	bRXIQImb_A		0x3ff
+#define	bRXIQImb_B		0xfc00
+#define	bRXIQImb_C		0x3f0000
+#define	bRXIQImb_D		0xffc00000
+#define	bDC_dc_Notch		0x60000
+#define	bRxNBINotch		0x1f000000
+#define	bPD_TH			0xf
+#define	bPD_TH_Opt2		0xc000
+#define	bPWED_TH		0x700
+#define	bIfMF_Win_L		0x800
+#define	bPD_Option		0x1000
+#define	bMF_Win_L		0xe000
+#define	bBW_Search_L		0x30000
+#define	bwin_enh_L		0xc0000
+#define	bBW_TH			0x700000
+#define	bED_TH2			0x3800000
+#define	bBW_option		0x4000000
+#define	bRatio_TH		0x18000000
+#define	bWindow_L		0xe0000000
+#define	bSBD_Option		0x1
+#define	bFrame_TH		0x1c
+#define	bFS_Option		0x60
+#define	bDC_Slope_check		0x80
+#define	bFGuard_Counter_DC_L	0xe00
+#define	bFrame_Weight_Short	0x7000
+#define	bSub_Tune		0xe00000
+#define	bFrame_DC_Length	0xe000000
+#define	bSBD_start_offset	0x30000000
+#define	bFrame_TH_2		0x7
+#define	bFrame_GI2_TH		0x38
+#define	bGI2_Sync_en		0x40
+#define	bSarch_Short_Early	0x300
+#define	bSarch_Short_Late	0xc00
+#define	bSarch_GI2_Late		0x70000
+#define	bCFOAntSum		0x1
+#define	bCFOAcc			0x2
+#define	bCFOStartOffset		0xc
+#define	bCFOLookBack		0x70
+#define	bCFOSumWeight		0x80
+#define	bDAGCEnable		0x10000
+#define	bTXIQImb_A		0x3ff
+#define	bTXIQImb_B		0xfc00
+#define	bTXIQImb_C		0x3f0000
+#define	bTXIQImb_D		0xffc00000
+#define	bTxIDCOffset		0xff
+#define	bTxQDCOffset		0xff00
+#define	bTxDFIRMode		0x10000
+#define	bTxPesudoNoiseOn	0x4000000
+#define	bTxPesudoNoise_A	0xff
+#define	bTxPesudoNoise_B	0xff00
+#define	bTxPesudoNoise_C	0xff0000
+#define	bTxPesudoNoise_D	0xff000000
+#define	bCCADropOption		0x20000
+#define	bCCADropThres		0xfff00000
+#define	bEDCCA_H		0xf
+#define	bEDCCA_L		0xf0
+#define	bLambda_ED              0x300
+#define	bRxInitialGain          0x7f
+#define	bRxAntDivEn             0x80
+#define	bRxAGCAddressForLNA     0x7f00
+#define	bRxHighPowerFlow        0x8000
+#define	bRxAGCFreezeThres       0xc0000
+#define	bRxFreezeStep_AGC1      0x300000
+#define	bRxFreezeStep_AGC2      0xc00000
+#define	bRxFreezeStep_AGC3      0x3000000
+#define	bRxFreezeStep_AGC0      0xc000000
+#define	bRxRssi_Cmp_En          0x10000000
+#define	bRxQuickAGCEn           0x20000000
+#define	bRxAGCFreezeThresMode   0x40000000
+#define	bRxOverFlowCheckType    0x80000000
+#define	bRxAGCShift             0x7f
+#define	bTRSW_Tri_Only          0x80
+#define	bPowerThres             0x300
+#define	bRxAGCEn                0x1
+#define	bRxAGCTogetherEn        0x2
+#define	bRxAGCMin               0x4
+#define	bRxHP_Ini               0x7
+#define	bRxHP_TRLNA             0x70
+#define	bRxHP_RSSI              0x700
+#define	bRxHP_BBP1              0x7000
+#define	bRxHP_BBP2              0x70000
+#define	bRxHP_BBP3              0x700000
+#define	bRSSI_H                 0x7f0000     /* the threshold for high power */
+#define	bRSSI_Gen               0x7f000000   /* the threshold for ant divers */
+#define	bRxSettle_TRSW          0x7
+#define	bRxSettle_LNA           0x38
+#define	bRxSettle_RSSI          0x1c0
+#define	bRxSettle_BBP           0xe00
+#define	bRxSettle_RxHP          0x7000
+#define	bRxSettle_AntSW_RSSI    0x38000
+#define	bRxSettle_AntSW         0xc0000
+#define	bRxProcessTime_DAGC     0x300000
+#define	bRxSettle_HSSI          0x400000
+#define	bRxProcessTime_BBPPW    0x800000
+#define	bRxAntennaPowerShift    0x3000000
+#define	bRSSITableSelect        0xc000000
+#define	bRxHP_Final             0x7000000
+#define	bRxHTSettle_BBP         0x7
+#define	bRxHTSettle_HSSI        0x8
+#define	bRxHTSettle_RxHP        0x70
+#define	bRxHTSettle_BBPPW       0x80
+#define	bRxHTSettle_Idle        0x300
+#define	bRxHTSettle_Reserved    0x1c00
+#define	bRxHTRxHPEn             0x8000
+#define	bRxHTAGCFreezeThres     0x30000
+#define	bRxHTAGCTogetherEn      0x40000
+#define	bRxHTAGCMin             0x80000
+#define	bRxHTAGCEn              0x100000
+#define	bRxHTDAGCEn             0x200000
+#define	bRxHTRxHP_BBP           0x1c00000
+#define	bRxHTRxHP_Final         0xe0000000
+#define	bRxPWRatioTH            0x3
+#define	bRxPWRatioEn            0x4
+#define	bRxMFHold               0x3800
+#define	bRxPD_Delay_TH1         0x38
+#define	bRxPD_Delay_TH2         0x1c0
+#define	bRxPD_DC_COUNT_MAX      0x600
+#define	bRxPD_Delay_TH          0x8000
+#define	bRxProcess_Delay        0xf0000
+#define	bRxSearchrange_GI2_Early 0x700000
+#define	bRxFrame_Guard_Counter_L 0x3800000
+#define	bRxSGI_Guard_L          0xc000000
+#define	bRxSGI_Search_L         0x30000000
+#define	bRxSGI_TH               0xc0000000
+#define	bDFSCnt0                0xff
+#define	bDFSCnt1                0xff00
+#define	bDFSFlag                0xf0000
+#define	bMFWeightSum            0x300000
+#define	bMinIdxTH               0x7f000000
+#define	bDAFormat               0x40000
+#define	bTxChEmuEnable          0x01000000
+#define	bTRSWIsolation_A        0x7f
+#define	bTRSWIsolation_B        0x7f00
+#define	bTRSWIsolation_C        0x7f0000
+#define	bTRSWIsolation_D        0x7f000000
+#define	bExtLNAGain             0x7c00
+
+/* 6. PageE(0xE00) */
+#define	bSTBCEn                 0x4	/* Useless */
+#define	bAntennaMapping         0x10
+#define	bNss                    0x20
+#define	bCFOAntSumD             0x200
+#define	bPHYCounterReset        0x8000000
+#define	bCFOReportGet           0x4000000
+#define	bOFDMContinueTx         0x10000000
+#define	bOFDMSingleCarrier      0x20000000
+#define	bOFDMSingleTone         0x40000000
+#define	bHTDetect               0x100
+#define	bCFOEn                  0x10000
+#define	bCFOValue               0xfff00000
+#define	bSigTone_Re             0x3f
+#define	bSigTone_Im             0x7f00
+#define	bCounter_CCA            0xffff
+#define	bCounter_ParityFail     0xffff0000
+#define	bCounter_RateIllegal    0xffff
+#define	bCounter_CRC8Fail       0xffff0000
+#define	bCounter_MCSNoSupport   0xffff
+#define	bCounter_FastSync       0xffff
+#define	bShortCFO               0xfff
+#define	bShortCFOTLength        12   /* total */
+#define	bShortCFOFLength        11   /* fraction */
+#define	bLongCFO                0x7ff
+#define	bLongCFOTLength         11
+#define	bLongCFOFLength         11
+#define	bTailCFO                0x1fff
+#define	bTailCFOTLength         13
+#define	bTailCFOFLength         12
+#define	bmax_en_pwdB            0xffff
+#define	bCC_power_dB            0xffff0000
+#define	bnoise_pwdB             0xffff
+#define	bPowerMeasTLength       10
+#define	bPowerMeasFLength       3
+#define	bRx_HT_BW               0x1
+#define	bRxSC                   0x6
+#define	bRx_HT                  0x8
+#define	bNB_intf_det_on         0x1
+#define	bIntf_win_len_cfg       0x30
+#define	bNB_Intf_TH_cfg         0x1c0
+#define	bRFGain                 0x3f
+#define	bTableSel               0x40
+#define	bTRSW                   0x80
+#define	bRxSNR_A                0xff
+#define	bRxSNR_B                0xff00
+#define	bRxSNR_C                0xff0000
+#define	bRxSNR_D                0xff000000
+#define	bSNREVMTLength          8
+#define	bSNREVMFLength          1
+#define	bCSI1st                 0xff
+#define	bCSI2nd                 0xff00
+#define	bRxEVM1st               0xff0000
+#define	bRxEVM2nd               0xff000000
+#define	bSIGEVM                 0xff
+#define	bPWDB                   0xff00
+#define	bSGIEN                  0x10000
+
+#define	bSFactorQAM1            0xf	/* Useless */
+#define	bSFactorQAM2            0xf0
+#define	bSFactorQAM3            0xf00
+#define	bSFactorQAM4            0xf000
+#define	bSFactorQAM5            0xf0000
+#define	bSFactorQAM6            0xf0000
+#define	bSFactorQAM7            0xf00000
+#define	bSFactorQAM8            0xf000000
+#define	bSFactorQAM9            0xf0000000
+#define	bCSIScheme              0x100000
+
+#define	bNoiseLvlTopSet         0x3	/* Useless */
+#define	bChSmooth               0x4
+#define	bChSmoothCfg1           0x38
+#define	bChSmoothCfg2           0x1c0
+#define	bChSmoothCfg3           0xe00
+#define	bChSmoothCfg4           0x7000
+#define	bMRCMode                0x800000
+#define	bTHEVMCfg               0x7000000
+
+#define	bLoopFitType            0x1	/* Useless */
+#define	bUpdCFO                 0x40
+#define	bUpdCFOOffData          0x80
+#define	bAdvUpdCFO              0x100
+#define	bAdvTimeCtrl            0x800
+#define	bUpdClko                0x1000
+#define	bFC                     0x6000
+#define	bTrackingMode           0x8000
+#define	bPhCmpEnable            0x10000
+#define	bUpdClkoLTF             0x20000
+#define	bComChCFO               0x40000
+#define	bCSIEstiMode            0x80000
+#define	bAdvUpdEqz              0x100000
+#define	bUChCfg                 0x7000000
+#define	bUpdEqz			0x8000000
+
+#define	bTxAGCRate18_06		0x7f7f7f7f	/* Useless */
+#define	bTxAGCRate54_24		0x7f7f7f7f
+#define	bTxAGCRateMCS32		0x7f
+#define	bTxAGCRateCCK		0x7f00
+#define	bTxAGCRateMCS3_MCS0	0x7f7f7f7f
+#define	bTxAGCRateMCS7_MCS4	0x7f7f7f7f
+#define	bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define	bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+/* Rx Pseduo noise */
+#define	bRxPesudoNoiseOn         0x20000000	/* Useless */
+#define	bRxPesudoNoise_A         0xff
+#define	bRxPesudoNoise_B         0xff00
+#define	bRxPesudoNoise_C         0xff0000
+#define	bRxPesudoNoise_D         0xff000000
+#define	bPesudoNoiseState_A      0xffff
+#define	bPesudoNoiseState_B      0xffff0000
+#define	bPesudoNoiseState_C      0xffff
+#define	bPesudoNoiseState_D      0xffff0000
+
+/* 7. RF Register
+ * Zebra1 */
+#define	bZebra1_HSSIEnable        0x8		/* Useless */
+#define	bZebra1_TRxControl        0xc00
+#define	bZebra1_TRxGainSetting    0x07f
+#define	bZebra1_RxCorner          0xc00
+#define	bZebra1_TxChargePump      0x38
+#define	bZebra1_RxChargePump      0x7
+#define	bZebra1_ChannelNum        0xf80
+#define	bZebra1_TxLPFBW           0x400
+#define	bZebra1_RxLPFBW           0x600
+
+/*Zebra4 */
+#define	bRTL8256RegModeCtrl1      0x100	/* Useless */
+#define	bRTL8256RegModeCtrl0      0x40
+#define	bRTL8256_TxLPFBW          0x18
+#define	bRTL8256_RxLPFBW          0x600
+
+/* RTL8258 */
+#define	bRTL8258_TxLPFBW          0xc	/* Useless */
+#define	bRTL8258_RxLPFBW          0xc00
+#define	bRTL8258_RSSILPFBW        0xc0
+
+/*
+ * Other Definition
+ */
+
+/* byte endable for sb_write */
+#define	bByte0                    0x1	/* Useless */
+#define	bByte1                    0x2
+#define	bByte2                    0x4
+#define	bByte3                    0x8
+#define	bWord0                    0x3
+#define	bWord1                    0xc
+#define	bDWord                    0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define	bMaskByte0                0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define	bMaskByte1                0xff00
+#define	bMaskByte2                0xff0000
+#define	bMaskByte3                0xff000000
+#define	bMaskHWord                0xffff0000
+#define	bMaskLWord                0x0000ffff
+#define	bMaskDWord                0xffffffff
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
+#define	bRFRegOffsetMask	0xfffff
+#define	bEnable                   0x1	/* Useless */
+#define	bDisable                  0x0
+
+#define	LeftAntenna               0x0	/* Useless */
+#define	RightAntenna              0x1
+
+#define	tCheckTxStatus            500   /* 500ms Useless */
+#define	tUpdateRxCounter          100   /* 100ms */
+
+#define	rateCCK     0	/* Useless */
+#define	rateOFDM    1
+#define	rateHT      2
+
+/* define Register-End */
+#define	bPMAC_End       0x1ff	/* Useless */
+#define	bFPGAPHY0_End   0x8ff
+#define	bFPGAPHY1_End   0x9ff
+#define	bCCKPHY0_End    0xaff
+#define	bOFDMPHY0_End   0xcff
+#define	bOFDMPHY1_End   0xdff
+
+#define	bPMACControl	0x0	/* Useless */
+#define	bWMACControl	0x1
+#define	bWNICControl	0x2
+
+#define	ANTENNA_A	0x1	/* Useless */
+#define	ANTENNA_B	0x2
+#define	ANTENNA_AB	0x3	/* ANTENNA_A |ANTENNA_B */
+
+#define	ANTENNA_C	0x4
+#define	ANTENNA_D	0x8
+
+
+/* accept all physical address */
+#define RCR_AAP		BIT(0)
+#define RCR_APM		BIT(1)		/* accept physical match */
+#define RCR_AM		BIT(2)		/* accept multicast */
+#define RCR_AB		BIT(3)		/* accept broadcast */
+#define RCR_ACRC32	BIT(5)		/* accept error packet */
+#define RCR_9356SEL	BIT(6)
+#define RCR_AICV	BIT(12)		/* Accept ICV error packet */
+#define RCR_RXFTH0	(BIT(13)|BIT(14)|BIT(15))	/* Rx FIFO threshold */
+#define RCR_ADF		BIT(18)		/* Accept Data(frame type) frame */
+#define RCR_ACF		BIT(19)		/* Accept control frame */
+#define RCR_AMF		BIT(20)		/* Accept management frame */
+#define RCR_ADD3	BIT(21)
+#define RCR_APWRMGT	BIT(22)		/* Accept power management packet */
+#define RCR_CBSSID	BIT(23)		/* Accept BSSID match packet */
+#define RCR_ENMARP	BIT(28)		/* enable mac auto reset phy */
+#define RCR_EnCS1	BIT(29)		/* enable carrier sense method 1 */
+#define RCR_EnCS2	BIT(30)		/* enable carrier sense method 2 */
+/* Rx Early mode is performed for packet size greater than 1536 */
+#define RCR_OnlyErlPkt	BIT(31)
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	/*__INC_HAL8192SPHYREG_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_pwrctrl.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_pwrctrl.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_pwrctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_pwrctrl.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,250 @@
+/******************************************************************************
+ * rtl871x_pwrctrl.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_PWRCTRL_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+
+#define RTL8712_SDIO_LOCAL_BASE 0X10100000
+#define SDIO_HCPWM (RTL8712_SDIO_LOCAL_BASE + 0x0081)
+
+void r8712_set_rpwm(struct _adapter *padapter, u8 val8)
+{
+	u8	rpwm;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (pwrpriv->rpwm == val8) {
+		if (pwrpriv->rpwm_retry == 0)
+			return;
+	}
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
+		return;
+	rpwm = val8 | pwrpriv->tog;
+	switch (val8) {
+	case PS_STATE_S1:
+		pwrpriv->cpwm = val8;
+		break;
+	case PS_STATE_S2:/* only for USB normal powersave mode use,
+			  * temp mark some code. */
+	case PS_STATE_S3:
+	case PS_STATE_S4:
+		pwrpriv->cpwm = val8;
+		break;
+	default:
+		break;
+	}
+	pwrpriv->rpwm_retry = 0;
+	pwrpriv->rpwm = val8;
+	r8712_write8(padapter, 0x1025FE58, rpwm);
+	pwrpriv->tog += 0x80;
+}
+
+void r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode, uint smart_ps)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (ps_mode > PM_Card_Disable)
+		return;
+	/* if driver is in active state, we dont need set smart_ps.*/
+	if (ps_mode == PS_MODE_ACTIVE)
+		smart_ps = 0;
+	if ((pwrpriv->pwr_mode != ps_mode) || (pwrpriv->smart_ps != smart_ps)) {
+		if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			pwrpriv->bSleep = true;
+		else
+			pwrpriv->bSleep = false;
+		pwrpriv->pwr_mode = ps_mode;
+		pwrpriv->smart_ps = smart_ps;
+		_set_workitem(&(pwrpriv->SetPSModeWorkItem));
+	}
+}
+
+/*
+ * Caller:ISR handler...
+ *
+ * This will be called when CPWM interrupt is up.
+ *
+ * using to update cpwn of drv; and drv will make a decision to up or
+ * down pwr level
+ */
+void r8712_cpwm_int_hdl(struct _adapter *padapter,
+			struct reportpwrstate_parm *preportpwrstate)
+{
+	struct pwrctrl_priv *pwrpriv = &(padapter->pwrctrlpriv);
+	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+
+	if (pwrpriv->cpwm_tog == ((preportpwrstate->state) & 0x80))
+		return;
+	_cancel_timer_ex(&padapter->pwrctrlpriv. rpwm_check_timer);
+	_enter_pwrlock(&pwrpriv->lock);
+	pwrpriv->cpwm = (preportpwrstate->state) & 0xf;
+	if (pwrpriv->cpwm >= PS_STATE_S2) {
+		if (pwrpriv->alives & CMD_ALIVE)
+			up(&(pcmdpriv->cmd_queue_sema));
+		if (pwrpriv->alives & XMIT_ALIVE)
+			up(&(pxmitpriv->xmit_sema));
+	}
+	pwrpriv->cpwm_tog = (preportpwrstate->state) & 0x80;
+	up(&pwrpriv->lock);
+}
+
+static inline void register_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+		pwrctrl->alives |= tag;
+}
+
+static inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl, uint tag)
+{
+	if (pwrctrl->alives & tag)
+		pwrctrl->alives ^= tag;
+}
+
+static void _rpwm_check_handler (struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	if (padapter->bDriverStopped == true ||
+	    padapter->bSurpriseRemoved == true)
+		return;
+	if (pwrpriv->cpwm != pwrpriv->rpwm)
+		_set_workitem(&(pwrpriv->rpwm_workitem));
+}
+
+static void SetPSModeWorkItemCallback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work,
+				       struct pwrctrl_priv, SetPSModeWorkItem);
+	struct _adapter *padapter = container_of(pwrpriv,
+				    struct _adapter, pwrctrlpriv);
+	_enter_pwrlock(&pwrpriv->lock);
+	if (!pwrpriv->bSleep) {
+		if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			r8712_set_rpwm(padapter, PS_STATE_S4);
+	}
+	up(&pwrpriv->lock);
+}
+
+static void rpwm_workitem_callback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv = container_of(work,
+				       struct pwrctrl_priv, rpwm_workitem);
+	struct _adapter *padapter = container_of(pwrpriv,
+				    struct _adapter, pwrctrlpriv);
+	u8 cpwm = pwrpriv->cpwm;
+	_enter_pwrlock(&pwrpriv->lock);
+	if (pwrpriv->cpwm != pwrpriv->rpwm) {
+		cpwm = r8712_read8(padapter, SDIO_HCPWM);
+		pwrpriv->rpwm_retry = 1;
+		r8712_set_rpwm(padapter, pwrpriv->rpwm);
+	}
+	up(&pwrpriv->lock);
+}
+
+static void rpwm_check_handler (void *FunctionContext)
+{
+	struct _adapter *adapter = (struct _adapter *)FunctionContext;
+	_rpwm_check_handler(adapter);
+}
+
+void r8712_init_pwrctrl_priv(struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+	sema_init(&pwrctrlpriv->lock, 1);
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+	pwrctrlpriv->smart_ps = 0;
+	pwrctrlpriv->tog = 0x80;
+/* clear RPWM to ensure driver and fw back to initial state. */
+	r8712_write8(padapter, 0x1025FE58, 0);
+	_init_workitem(&(pwrctrlpriv->SetPSModeWorkItem),
+		       SetPSModeWorkItemCallback, padapter);
+	_init_workitem(&(pwrctrlpriv->rpwm_workitem),
+		       rpwm_workitem_callback, padapter);
+	_init_timer(&(pwrctrlpriv->rpwm_check_timer),
+		    padapter->pnetdev, rpwm_check_handler, (u8 *)padapter);
+}
+
+/*
+Caller: r8712_cmd_thread
+
+Check if the fw_pwrstate is okay for issuing cmd.
+If not (cpwm should be is less than P2 state), then the sub-routine
+will raise the cpwm to be greater than or equal to P2.
+
+Calling Context: Passive
+
+Return Value:
+
+_SUCCESS: r8712_cmd_thread can issue cmds to firmware afterwards.
+_FAIL: r8712_cmd_thread can not do anything.
+*/
+sint r8712_register_cmd_alive(struct _adapter *padapter)
+{
+	uint res = _SUCCESS;
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+	register_task_alive(pwrctrl, CMD_ALIVE);
+	if (pwrctrl->cpwm < PS_STATE_S2) {
+		r8712_set_rpwm(padapter, PS_STATE_S3);
+		res = _FAIL;
+	}
+	up(&pwrctrl->lock);
+	return res;
+}
+
+/*
+Caller: ISR
+
+If ISR's txdone,
+No more pkts for TX,
+Then driver shall call this fun. to power down firmware again.
+*/
+
+void r8712_unregister_cmd_alive(struct _adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+	unregister_task_alive(pwrctrl, CMD_ALIVE);
+	if ((pwrctrl->cpwm > PS_STATE_S2) &&
+	   (pwrctrl->pwr_mode > PS_MODE_ACTIVE)) {
+		if ((pwrctrl->alives == 0) &&
+		    (check_fwstate(&padapter->mlmepriv,
+		     _FW_UNDER_LINKING) != true)) {
+			r8712_set_rpwm(padapter, PS_STATE_S0);
+		}
+	}
+	up(&pwrctrl->lock);
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_pwrctrl.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_pwrctrl.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_pwrctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_pwrctrl.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,152 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_PWRCTRL_H_
+#define __RTL871X_PWRCTRL_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#define FW_PWR0	0
+#define FW_PWR1		1
+#define FW_PWR2		2
+#define FW_PWR3		3
+
+
+#define HW_PWR0	7
+#define HW_PWR1		6
+#define HW_PWR2		2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt {
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state, 0: register active state,
+				    1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define		PS_DPS				BIT(0)
+#define		PS_LCLK				(PS_DPS)
+#define	PS_RF_OFF			BIT(1)
+#define	PS_ALL_ON			BIT(2)
+#define	PS_ST_ACTIVE		BIT(3)
+#define	PS_LP				BIT(4)	/* low performance */
+
+#define	PS_STATE_MASK		(0x0F)
+#define	PS_STATE_HW_MASK	(0x07)
+#define		PS_SEQ_MASK		(0xc0)
+
+#define	PS_STATE(x)			(PS_STATE_MASK & (x))
+#define	PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define	PS_SEQ(x)			(PS_SEQ_MASK & (x))
+
+#define	PS_STATE_S0		(PS_DPS)
+#define		PS_STATE_S1		(PS_LCLK)
+#define	PS_STATE_S2		(PS_RF_OFF)
+#define		PS_STATE_S3		(PS_ALL_ON)
+#define	PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define		PS_IS_RF_ON(x)		((x) & (PS_ALL_ON))
+#define		PS_IS_ACTIVE(x)		((x) & (PS_ST_ACTIVE))
+#define		CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; /* the CPWM value */
+	unsigned short rsvd;
+};
+
+static inline void _enter_pwrlock(struct semaphore *plock)
+{
+	_down_sema(plock);
+}
+
+struct	pwrctrl_priv {
+	struct semaphore lock;
+	/*volatile*/ u8 rpwm; /* requested power state for fw */
+	/* fw current power state. updated when 1. read from HCPWM or
+	 * 2. driver lowers power level */
+	/*volatile*/ u8 cpwm;
+	/*volatile*/ u8 tog; /* toggling */
+	/*volatile*/ u8 cpwm_tog; /* toggling */
+	/*volatile*/ u8 tgt_rpwm; /* wanted power state */
+	uint pwr_mode;
+	uint smart_ps;
+	uint alives;
+	uint ImrContent;	/* used to store original imr. */
+	uint bSleep; /* sleep -> active is different from active -> sleep. */
+
+	_workitem SetPSModeWorkItem;
+	_workitem rpwm_workitem;
+	struct timer_list rpwm_check_timer;
+	u8	rpwm_retry;
+	uint	bSetPSModeWorkItemInProgress;
+
+	struct semaphore pnp_pwr_mgnt_sema;
+	spinlock_t pnp_pwr_mgnt_lock;
+	s32	pnp_current_pwr_state;
+	u8	pnp_bstop_trx;
+	u8	pnp_wwirp_pending;
+};
+
+void r8712_init_pwrctrl_priv(struct _adapter *adapter);
+sint r8712_register_cmd_alive(struct _adapter *padapter);
+void r8712_unregister_cmd_alive(struct _adapter *padapter);
+void r8712_cpwm_int_hdl(struct _adapter *padapter,
+			struct reportpwrstate_parm *preportpwrstate);
+void r8712_set_ps_mode(struct _adapter *padapter, uint ps_mode,
+			uint smart_ps);
+void r8712_set_rpwm(struct _adapter *padapter, u8 val8);
+
+#endif  /* __RTL871X_PWRCTRL_H_ */
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_recv.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_recv.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_recv.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_recv.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,699 @@
+/******************************************************************************
+ * rtl871x_recv.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_RECV_C_
+
+#include <linux/slab.h>
+#include <linux/kmemleak.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "mlme_osdep.h"
+#include "ip.h"
+#include "if_ether.h"
+#include "ethernet.h"
+#include "usb_ops.h"
+#include "wifi.h"
+
+static const u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+/* Datagram Delivery Protocol */
+static const u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static const u8 bridge_tunnel_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};
+
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static const u8 rfc1042_header[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+
+void _r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{
+	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
+	spin_lock_init(&psta_recvpriv->lock);
+	_init_queue(&psta_recvpriv->defrag_q);
+}
+
+sint _r8712_init_recv_priv(struct recv_priv *precvpriv,
+			   struct _adapter *padapter)
+{
+	sint i;
+	union recv_frame *precvframe;
+
+	 memset((unsigned char *)precvpriv, 0, sizeof(struct  recv_priv));
+	spin_lock_init(&precvpriv->lock);
+	_init_queue(&precvpriv->free_recv_queue);
+	_init_queue(&precvpriv->recv_pending_queue);
+	precvpriv->adapter = padapter;
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+	precvpriv->pallocated_frame_buf = _malloc(NR_RECVFRAME *
+					   sizeof(union recv_frame) +
+					   RXFRAME_ALIGN_SZ);
+	if (precvpriv->pallocated_frame_buf == NULL)
+		return _FAIL;
+	kmemleak_not_leak(precvpriv->pallocated_frame_buf);
+	memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME *
+		sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf +
+				    RXFRAME_ALIGN_SZ -
+				    ((addr_t)(precvpriv->pallocated_frame_buf) &
+				    (RXFRAME_ALIGN_SZ-1));
+	precvframe = (union recv_frame *)precvpriv->precv_frame_buf;
+	for (i = 0; i < NR_RECVFRAME; i++) {
+		_init_listhead(&(precvframe->u.list));
+		list_insert_tail(&(precvframe->u.list),
+				 &(precvpriv->free_recv_queue.queue));
+		r8712_os_recv_resource_alloc(padapter, precvframe);
+		precvframe->u.hdr.adapter = padapter;
+		precvframe++;
+	}
+	precvpriv->rx_pending_cnt = 1;
+	sema_init(&precvpriv->allrxreturnevt, 0);
+	return r8712_init_recv_priv(precvpriv, padapter);
+}
+
+void _r8712_free_recv_priv(struct recv_priv *precvpriv)
+{
+	kfree(precvpriv->pallocated_frame_buf);
+	r8712_free_recv_priv(precvpriv);
+}
+
+union recv_frame *r8712_alloc_recvframe(struct  __queue *pfree_recv_queue)
+{
+	unsigned long irqL;
+	union recv_frame  *precvframe;
+	struct list_head *plist, *phead;
+	struct _adapter *padapter;
+	struct recv_priv *precvpriv;
+
+	spin_lock_irqsave(&pfree_recv_queue->lock, irqL);
+	if (_queue_empty(pfree_recv_queue) == true)
+		precvframe = NULL;
+	else {
+		phead = get_list_head(pfree_recv_queue);
+		plist = get_next(phead);
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		list_delete(&precvframe->u.hdr.list);
+		padapter = precvframe->u.hdr.adapter;
+		if (padapter != NULL) {
+			precvpriv = &padapter->recvpriv;
+			if (pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+	spin_unlock_irqrestore(&pfree_recv_queue->lock, irqL);
+	return precvframe;
+}
+
+/*
+caller : defrag; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spin_lock to protect
+
+*/
+
+void r8712_free_recvframe_queue(struct  __queue *pframequeue,
+				struct  __queue *pfree_recv_queue)
+{
+	union	recv_frame *precvframe;
+	struct list_head *plist, *phead;
+
+	spin_lock(&pframequeue->lock);
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
+		plist = get_next(plist);
+		r8712_free_recvframe(precvframe, pfree_recv_queue);
+	}
+	spin_unlock(&pframequeue->lock);
+}
+
+sint r8712_recvframe_chkmic(struct _adapter *adapter,
+			    union recv_frame *precvframe)
+{
+	sint i, res = _SUCCESS;
+	u32	datalen;
+	u8 miccode[8];
+	u8 bmic_err = false;
+	u8 *pframe, *payload, *pframemic;
+	u8   *mickey, idx, *iv;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &precvframe->u.hdr.attrib;
+	struct	security_priv *psecuritypriv = &adapter->securitypriv;
+
+	stainfo = r8712_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);
+	if (prxattrib->encrypt == _TKIP_) {
+		/* calculate mic code */
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				iv = precvframe->u.hdr.rx_data +
+				     prxattrib->hdrlen;
+				idx = iv[3];
+				mickey = &psecuritypriv->XGrprxmickey[(((idx >>
+					 6) & 0x3)) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+			} else
+				mickey = &stainfo->tkiprxmickey.skey[0];
+			/*icv_len included the mic code*/
+			datalen = precvframe->u.hdr.len - prxattrib->hdrlen -
+				  prxattrib->iv_len - prxattrib->icv_len - 8;
+			pframe = precvframe->u.hdr.rx_data;
+			payload = pframe + prxattrib->hdrlen +
+				  prxattrib->iv_len;
+			seccalctkipmic(mickey, pframe, payload, datalen,
+				       &miccode[0],
+				       (unsigned char)prxattrib->priority);
+			pframemic = payload + datalen;
+			bmic_err = false;
+			for (i = 0; i < 8; i++) {
+				if (miccode[i] != *(pframemic + i))
+					bmic_err = true;
+			}
+			if (bmic_err == true) {
+				if (prxattrib->bdecrypted == true)
+					r8712_handle_tkip_mic_err(adapter,
+						(u8)IS_MCAST(prxattrib->ra));
+				res = _FAIL;
+			} else {
+				/* mic checked ok */
+				if ((psecuritypriv->bcheck_grpkey ==
+				     false) && (IS_MCAST(prxattrib->ra) ==
+				     true))
+					psecuritypriv->bcheck_grpkey = true;
+			}
+			recvframe_pull_tail(precvframe, 8);
+		}
+	}
+	return res;
+}
+
+/* decrypt and set the ivlen,icvlen of the recv_frame */
+union recv_frame *r8712_decryptor(struct _adapter *padapter,
+			    union recv_frame *precv_frame)
+{
+	struct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	union recv_frame *return_packet = precv_frame;
+
+	if ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0) ||
+	   (psecuritypriv->sw_decrypt == true))) {
+		psecuritypriv->hw_decrypted = false;
+		switch (prxattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			r8712_wep_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _TKIP_:
+			r8712_tkip_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _AES_:
+			r8712_aes_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		default:
+				break;
+		}
+	} else if (prxattrib->bdecrypted == 1)
+		psecuritypriv->hw_decrypted = true;
+	return return_packet;
+}
+/*###set the security information in the recv_frame */
+union recv_frame *r8712_portctrl(struct _adapter *adapter,
+				 union recv_frame *precv_frame)
+{
+	u8 *psta_addr, *ptr;
+	uint auth_alg;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct	sta_priv *pstapriv;
+	union recv_frame *prtnframe;
+	u16 ether_type = 0;
+
+	pstapriv = &adapter->stapriv;
+	ptr = get_recvframe_data(precv_frame);
+	pfhdr = &precv_frame->u.hdr;
+	psta_addr = pfhdr->attrib.ta;
+	psta = r8712_get_stainfo(pstapriv, psta_addr);
+	auth_alg = adapter->securitypriv.AuthAlgrthm;
+	if (auth_alg == 2) {
+		if ((psta != NULL) && (psta->ieee8021x_blocked)) {
+			/* blocked
+			 * only accept EAPOL frame */
+			prtnframe = precv_frame;
+			/*get ether_type */
+			ptr = ptr + pfhdr->attrib.hdrlen +
+			      pfhdr->attrib.iv_len + LLC_HEADER_SIZE;
+			memcpy(&ether_type, ptr, 2);
+			ether_type = ntohs((unsigned short)ether_type);
+			if (ether_type == 0x888e)
+				prtnframe = precv_frame;
+			else {
+				/*free this frame*/
+				r8712_free_recvframe(precv_frame,
+					 &adapter->recvpriv.free_recv_queue);
+				prtnframe = NULL;
+			}
+		} else {
+			/* allowed
+			 * check decryption status, and decrypt the
+			 * frame if needed */
+			prtnframe = precv_frame;
+			/* check is the EAPOL frame or not (Rekey) */
+			if (ether_type == 0x888e) {
+				/* check Rekey */
+				prtnframe = precv_frame;
+			}
+		}
+	} else
+		prtnframe = precv_frame;
+	return prtnframe;
+}
+
+static sint recv_decache(union recv_frame *precv_frame, u8 bretry,
+		  struct stainfo_rxcache *prxcache)
+{
+	sint tid = precv_frame->u.hdr.attrib.priority;
+	u16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
+			(precv_frame->u.hdr.attrib.frag_num & 0xf);
+
+	if (tid > 15)
+		return _FAIL;
+	if (seq_ctrl == prxcache->tid_rxseq[tid])
+		return _FAIL;
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+	return _SUCCESS;
+}
+
+static sint sta2sta_data_frame(struct _adapter *adapter,
+			       union recv_frame *precv_frame,
+			       struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	sint ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	u8 *sta_addr = NULL;
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		/* filter packets that SA is myself or multicast or broadcast */
+		if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))
+			return _FAIL;
+		if ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))
+			return _FAIL;
+		if (!memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    !memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
+			return _FAIL;
+		sta_addr = pattrib->src;
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		/* For Station mode, sa and bssid should always be BSSID,
+		 * and DA is my mac-address */
+		if (memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))
+			return _FAIL;
+	       sta_addr = pattrib->bssid;
+	 } else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		if (bmcast) {
+			/* For AP mode, if DA == MCAST, then BSSID should
+			 * be also MCAST */
+			if (!IS_MCAST(pattrib->bssid))
+				return _FAIL;
+		} else { /* not mc-frame */
+			/* For AP mode, if DA is non-MCAST, then it must be
+			 *  BSSID, and bssid == BSSID */
+			if (memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN))
+				return _FAIL;
+			sta_addr = pattrib->src;
+		}
+	  } else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		sta_addr = mybssid;
+	  } else
+		ret  = _FAIL;
+	if (bmcast)
+		*psta = r8712_get_bcmc_stainfo(adapter);
+	else
+		*psta = r8712_get_stainfo(pstapriv, sta_addr); /* get ap_info */
+	if (*psta == NULL) {
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+			adapter->mppriv.rx_pktloss++;
+		return _FAIL;
+	}
+	return ret;
+}
+
+static sint ap2sta_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame,
+			      struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid  = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	sint bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	     && (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		/* if NULL-frame, drop packet */
+		if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
+			return _FAIL;
+		/* drop QoS-SubType Data, including QoS NULL,
+		 * excluding QoS-Data */
+		if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) ==
+		     WIFI_QOS_DATA_TYPE) {
+			if (GetFrameSubType(ptr) & (BIT(4) | BIT(5) | BIT(6)))
+				return _FAIL;
+		}
+
+		/* filter packets that SA is myself or multicast or broadcast */
+	       if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN))
+			return _FAIL;
+
+		/* da should be for me */
+		if ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast))
+			return _FAIL;
+		/* check BSSID */
+		if (!memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     !memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     (memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
+			return _FAIL;
+		if (bmcast)
+			*psta = r8712_get_bcmc_stainfo(adapter);
+		else
+		       *psta = r8712_get_stainfo(pstapriv, pattrib->bssid);
+		if (*psta == NULL)
+			return _FAIL;
+	} else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+		*psta = r8712_get_stainfo(pstapriv, pattrib->bssid);
+		if (*psta == NULL)
+			return _FAIL;
+	} else
+		return _FAIL;
+	return _SUCCESS;
+}
+
+static sint sta2ap_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame,
+			      struct sta_info **psta)
+{
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	unsigned char *mybssid  = get_bssid(pmlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		/* For AP mode, if DA is non-MCAST, then it must be BSSID,
+		 * and bssid == BSSID
+		 * For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
+		if (memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+			return _FAIL;
+		*psta = r8712_get_stainfo(pstapriv, pattrib->src);
+		if (*psta == NULL)
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+static sint validate_recv_ctrl_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	return _FAIL;
+}
+
+static sint validate_recv_mgnt_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	return _FAIL;
+}
+
+
+static sint validate_recv_data_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame)
+{
+	int res;
+	u8 bretry;
+	u8 *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+	if (pbssid == NULL)
+		return _FAIL;
+	memcpy(pattrib->dst, pda, ETH_ALEN);
+	memcpy(pattrib->src, psa, ETH_ALEN);
+	memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+	switch (pattrib->to_fr_ds) {
+	case 0:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		res = sta2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 1:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, pbssid, ETH_ALEN);
+		res = ap2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 2:
+		memcpy(pattrib->ra, pbssid, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		res = sta2ap_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 3:
+		memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+		return _FAIL;
+	default:
+		return _FAIL;
+	}
+	if (res == _FAIL)
+		return _FAIL;
+	if (psta == NULL)
+		return _FAIL;
+	else
+		precv_frame->u.hdr.psta = psta;
+	pattrib->amsdu = 0;
+	/* parsing QC field */
+	if (pattrib->qos == 1) {
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy = GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));
+		pattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;
+	} else {
+		pattrib->priority = 0;
+		pattrib->hdrlen = (pattrib->to_fr_ds == 3) ? 30 : 24;
+	}
+
+	if (pattrib->order)/*HT-CTRL 11n*/
+		pattrib->hdrlen += 4;
+	precv_frame->u.hdr.preorder_ctrl =
+			 &psta->recvreorder_ctrl[pattrib->priority];
+
+	/* decache, drop duplicate recv packets */
+	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==
+	    _FAIL)
+		return _FAIL;
+
+	if (pattrib->privacy) {
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,
+			       IS_MCAST(pattrib->ra));
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len,
+			       pattrib->encrypt);
+	} else {
+		pattrib->encrypt = 0;
+		pattrib->iv_len = pattrib->icv_len = 0;
+	}
+	return _SUCCESS;
+}
+
+sint r8712_validate_recv_frame(struct _adapter *adapter,
+			       union recv_frame *precv_frame)
+{
+	/*shall check frame subtype, to / from ds, da, bssid */
+	/*then call check if rx seq/frag. duplicated.*/
+
+	u8 type;
+	u8 subtype;
+	sint retval = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+
+	u8 *ptr = precv_frame->u.hdr.rx_data;
+	u8  ver = (unsigned char)(*ptr) & 0x3;
+
+	/*add version chk*/
+	if (ver != 0)
+		return _FAIL;
+	type =  GetFrameType(ptr);
+	subtype = GetFrameSubType(ptr); /*bit(7)~bit(2)*/
+	pattrib->to_fr_ds = get_tofr_ds(ptr);
+	pattrib->frag_num = GetFragNum(ptr);
+	pattrib->seq_num = GetSequence(ptr);
+	pattrib->pw_save = GetPwrMgt(ptr);
+	pattrib->mfrag = GetMFrag(ptr);
+	pattrib->mdata = GetMData(ptr);
+	pattrib->privacy =  GetPrivacy(ptr);
+	pattrib->order = GetOrder(ptr);
+	switch (type) {
+	case WIFI_MGT_TYPE: /*mgnt*/
+		retval = validate_recv_mgnt_frame(adapter, precv_frame);
+		break;
+	case WIFI_CTRL_TYPE:/*ctrl*/
+		retval = validate_recv_ctrl_frame(adapter, precv_frame);
+		break;
+	case WIFI_DATA_TYPE: /*data*/
+		pattrib->qos = (subtype & BIT(7)) ? 1 : 0;
+		retval = validate_recv_data_frame(adapter, precv_frame);
+		break;
+	default:
+		return _FAIL;
+	}
+	return retval;
+}
+
+sint r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe)
+{
+	/*remove the wlanhdr and add the eth_hdr*/
+	sint	rmv_len;
+	u16	eth_type, len;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr *psnap;
+
+	sint ret = _SUCCESS;
+	struct _adapter	*adapter = precvframe->u.hdr.adapter;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	u8 *ptr = get_recvframe_data(precvframe); /*point to frame_ctrl field*/
+	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;
+
+	if (pattrib->encrypt)
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+	psnap = (struct ieee80211_snap_hdr *)(ptr + pattrib->hdrlen +
+		 pattrib->iv_len);
+	psnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	if ((!memcmp(psnap, (void *)rfc1042_header, SNAP_SIZE) &&
+	    (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_IPX, 2)) &&
+	    (memcmp(psnap_type, (void *)SNAP_ETH_TYPE_APPLETALK_AARP, 2))) ||
+	     !memcmp(psnap, (void *)bridge_tunnel_header, SNAP_SIZE)) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and
+		 * replace EtherType */
+		bsnaphdr = true;
+	} else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = false;
+	}
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +
+		  (bsnaphdr ? SNAP_SIZE : 0);
+	len = precvframe->u.hdr.len - rmv_len;
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		ptr += rmv_len;
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+		eth_type = 0x8712;
+		/* append rx status for mp test packets */
+		ptr = recvframe_pull(precvframe, (rmv_len -
+		      sizeof(struct ethhdr) + 2) - 24);
+		memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr += 24;
+	} else
+		ptr = recvframe_pull(precvframe, (rmv_len -
+		      sizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));
+
+	memcpy(ptr, pattrib->dst, ETH_ALEN);
+	memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+	if (!bsnaphdr) {
+		len = htons(len);
+		memcpy(ptr + 12, &len, 2);
+	}
+	return ret;
+}
+
+s32 r8712_recv_entry(union recv_frame *precvframe)
+{
+	struct _adapter *padapter;
+	struct recv_priv *precvpriv;
+	struct	mlme_priv *pmlmepriv;
+	struct recv_stat *prxstat;
+	struct dvobj_priv *pdev;
+	u8 *phead, *pdata, *ptail, *pend;
+
+	struct  __queue *pfree_recv_queue, *ppending_recv_queue;
+	s32 ret = _SUCCESS;
+	struct intf_hdl *pintfhdl;
+
+	padapter = precvframe->u.hdr.adapter;
+	pintfhdl = &padapter->pio_queue->intf;
+	pmlmepriv = &padapter->mlmepriv;
+	precvpriv = &(padapter->recvpriv);
+	pdev = &padapter->dvobjpriv;
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+	ppending_recv_queue = &(precvpriv->recv_pending_queue);
+	phead = precvframe->u.hdr.rx_head;
+	pdata = precvframe->u.hdr.rx_data;
+	ptail = precvframe->u.hdr.rx_tail;
+	pend = precvframe->u.hdr.rx_end;
+	prxstat = (struct recv_stat *)phead;
+
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_RX);
+
+	ret = recv_func(padapter, precvframe);
+	if (ret == _FAIL)
+		goto _recv_entry_drop;
+	precvpriv->rx_pkts++;
+	precvpriv->rx_bytes += (uint)(precvframe->u.hdr.rx_tail -
+				precvframe->u.hdr.rx_data);
+	return ret;
+_recv_entry_drop:
+	precvpriv->rx_drop++;
+	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
+	return ret;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_recv.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_recv.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_recv.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_recv.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,330 @@
+#ifndef _RTL871X_RECV_H_
+#define _RTL871X_RECV_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define NR_RECVFRAME 256
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1 << RXFRAME_ALIGN)
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+#define MAX_SUBFRAME_COUNT	64
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+/* for Rx reordering buffer control */
+struct recv_reorder_ctrl {
+	struct _adapter	*padapter;
+	u16 indicate_seq; /* =wstart_b, init_value=0xffff */
+	u16 wend_b;
+	u8 wsize_b;
+	struct  __queue pending_recvframe_queue;
+	struct timer_list reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16	tid_rxseq[16];
+};
+
+#define		PHY_RSSI_SLID_WIN_MAX			100
+#define		PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	/* array to store values */
+	u32	index;		/* index to current array to store */
+	u32	total_num;	/* num of valid elements */
+	u32	total_val;	/* sum of valid elements */
+};
+
+struct rx_pkt_attrib {
+
+	u8	amsdu;
+	u8	order;
+	u8	qos;
+	u8	to_fr_ds;
+	u8	frag_num;
+	u16	seq_num;
+	u8   pw_save;
+	u8    mfrag;
+	u8    mdata;
+	u8	privacy; /* in frame_ctrl field */
+	u8	bdecrypted;
+	int	hdrlen;	 /* the WLAN Header Len */
+	int	encrypt; /* 0 no encrypt. != 0 encrypt algorith */
+	int	iv_len;
+	int	icv_len;
+	int	priority;
+	int	ack_policy;
+	u8	crc_err;
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	bssid[ETH_ALEN];
+	u8	tcpchk_valid; /* 0: invalid, 1: valid */
+	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
+	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	u8	mcs_rate;
+	u8	htc;
+	u8	signal_strength;
+};
+
+/*
+accesser of recv_priv: recv_entry(dispatch / passive level);
+recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv {
+	spinlock_t lock;
+	struct semaphore recv_sema;
+	struct semaphore terminate_recvthread_sema;
+	struct  __queue	free_recv_queue;
+	struct  __queue	recv_pending_queue;
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf;
+	uint free_recvframe_cnt;
+	struct _adapter	*adapter;
+	uint	rx_bytes;
+	uint	rx_pkts;
+	uint	rx_drop;
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+	struct semaphore allrxreturnevt;
+	u8  rx_pending_cnt;
+	uint	ff_hwaddr;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    /* 4 alignment */
+	struct  __queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+	/* For the phy informatiom */
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 fw_rssi;
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+};
+
+struct sta_recv_priv {
+	spinlock_t lock;
+	sint	option;
+	struct  __queue defrag_q; /* keeping the fragment frame until defrag */
+	struct	stainfo_rxcache rxcache;
+	uint	sta_rx_bytes;
+	uint	sta_rx_pkts;
+	uint	sta_rx_fail;
+};
+
+#include "rtl8712_recv.h"
+
+/* get a free recv_frame from pfree_recv_queue */
+union recv_frame *r8712_alloc_recvframe(struct  __queue *pfree_recv_queue);
+union recv_frame *r8712_dequeue_recvframe(struct  __queue *queue);
+int r8712_enqueue_recvframe(union recv_frame *precvframe,
+			     struct  __queue *queue);
+int r8712_free_recvframe(union recv_frame *precvframe,
+			  struct  __queue *pfree_recv_queue);
+void r8712_free_recvframe_queue(struct  __queue *pframequeue,
+				 struct  __queue *pfree_recv_queue);
+void r8712_init_recvframe(union recv_frame *precvframe,
+			   struct recv_priv *precvpriv);
+int r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe);
+int recv_func(struct _adapter *padapter, void *pcontext);
+
+static inline u8 *get_rxmem(union recv_frame *precvframe)
+{
+	/* always return rx_head... */
+	if (precvframe == NULL)
+		return NULL;
+	return precvframe->u.hdr.rx_head;
+}
+
+static inline u8 *get_rx_status(union recv_frame *precvframe)
+{
+	return get_rxmem(precvframe);
+}
+
+static inline u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+	/* always return rx_data */
+	if (precvframe == NULL)
+		return NULL;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{
+	/* append data before rx_data */
+
+	/* add data to the start of recv_frame
+	 *
+	 * This function extends the used data area of the recv_frame at the
+	 * buffer start. rx_data must be still larger than rx_head, after
+	 * pushing.
+	 */
+
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_data -= sz ;
+	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head) {
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+	precvframe->u.hdr.len += sz;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	/* used for extract sz bytes from rx_data, update rx_data and return
+	 *  the updated rx_data to the caller */
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_data += sz;
+	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len -= sz;
+	return precvframe->u.hdr.rx_data;
+}
+
+static inline u8 *recvframe_put(union recv_frame *precvframe, sint sz)
+{
+	/* used for append sz bytes from ptr to rx_tail, update rx_tail and
+	 * return the updated rx_tail to the caller
+	 * after putting, rx_tail must be still larger than rx_end. */
+	unsigned char *prev_rx_tail;
+
+	if (precvframe == NULL)
+		return NULL;
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+	precvframe->u.hdr.rx_tail += sz;
+	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len += sz;
+	return precvframe->u.hdr.rx_tail;
+}
+
+static inline u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	/* rmv data from rx_tail (by yitsen)
+	 * used for extract sz bytes from rx_end, update rx_end and return the
+	 * updated rx_end to the caller
+	 * after pulling, rx_end must be still larger than rx_data. */
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->u.hdr.rx_tail -= sz;
+	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+	precvframe->u.hdr.len -= sz;
+	return precvframe->u.hdr.rx_tail;
+}
+
+static inline _buffer *get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer *buf_desc;
+	if (precvframe == NULL)
+		return NULL;
+	return buf_desc;
+}
+
+static inline union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	/* due to the design of 2048 bytes alignment of recv_frame, we can
+	 * reference the union recv_frame from any given member of recv_frame.
+	 * rxmem indicates the any member/address in recv_frame */
+	return (union recv_frame *)(((addr_t)rxmem >> RXFRAME_ALIGN) <<
+				  RXFRAME_ALIGN);
+}
+
+static inline union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+	u8 *buf_star;
+	union recv_frame *precv_frame;
+
+	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);
+	return precv_frame;
+}
+
+static inline u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	/* return the rx_head */
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_head;
+}
+
+static inline u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	/* return the rx_data */
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_data;
+}
+
+static inline sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+struct sta_info;
+
+void	_r8712_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+sint r8712_recvframe_chkmic(struct _adapter *adapter,
+			    union recv_frame *precvframe);
+union recv_frame *r8712_decryptor(struct _adapter *adapter,
+				  union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_chk_defrag(struct _adapter *adapter,
+					     union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_defrag(struct _adapter *adapter,
+					 struct  __queue *defrag_q);
+union recv_frame *r8712_recvframe_chk_defrag_new(struct _adapter *adapter,
+					union recv_frame *precv_frame);
+union recv_frame *r8712_recvframe_defrag_new(struct _adapter *adapter,
+					struct  __queue *defrag_q,
+					union recv_frame *precv_frame);
+int r8712_recv_decache(union recv_frame *precv_frame, u8 bretry,
+		       struct stainfo_rxcache *prxcache);
+int r8712_sta2sta_data_frame(struct _adapter *adapter,
+			     union recv_frame *precv_frame,
+			     struct sta_info **psta);
+int r8712_ap2sta_data_frame(struct _adapter *adapter,
+			    union recv_frame *precv_frame,
+			    struct sta_info **psta);
+int r8712_sta2ap_data_frame(struct _adapter *adapter,
+			    union recv_frame *precv_frame,
+			    struct sta_info **psta);
+int r8712_validate_recv_ctrl_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_mgnt_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_data_frame(struct _adapter *adapter,
+				   union recv_frame *precv_frame);
+int r8712_validate_recv_frame(struct _adapter *adapter,
+			      union recv_frame *precv_frame);
+union recv_frame *r8712_portctrl(struct _adapter *adapter,
+				 union recv_frame *precv_frame);
+void  r8712_mgt_dispatcher(struct _adapter *padapter, u8 *pframe, uint len);
+int r8712_amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_rf.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_rf.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_rf.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_rf.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef	__RTL871X_RF_H_
+#define __RTL871X_RF_H_
+
+#include "rtl871x_cmd.h"
+#include "rtl871x_mp_phy_regdef.h"
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+#define NumRates	(13)
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+#define NUM_CHANNELS	15
+
+struct	regulatory_class {
+	u32	starting_freq;		/*MHz, */
+	u8	channel_set[NUM_CHANNELS];
+	u8	channel_cck_power[NUM_CHANNELS]; /*dbm*/
+	u8	channel_ofdm_power[NUM_CHANNELS];/*dbm*/
+	u8	txpower_limit;		/*dbm*/
+	u8	channel_spacing;	/*MHz*/
+	u8	modem;
+};
+
+enum	_REG_PREAMBLE_MODE {
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+enum {
+	RTL8712_RFC_1T = 0x10,
+	RTL8712_RFC_2T = 0x20,
+	RTL8712_RFC_1R = 0x01,
+	RTL8712_RFC_2R = 0x02,
+	RTL8712_RFC_1T1R = 0x11,
+	RTL8712_RFC_1T2R = 0x12,
+	RTL8712_RFC_TURBO = 0x92,
+	RTL8712_RFC_2T2R = 0x22
+};
+
+#endif /*_RTL8711_RF_H_*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_security.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_security.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_security.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_security.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1404 @@
+/******************************************************************************
+ * rtl871x_security.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define  _RTL871X_SECURITY_C_
+
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <linux/uaccess.h>
+#include <asm/byteorder.h>
+#include <linux/atomic.h>
+#include <linux/semaphore.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+
+/* =====WEP related===== */
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context {
+	u32 x;
+	u32 y;
+	u8 state[256];
+};
+
+static void arcfour_init(struct arc4context *parc4ctx, u8 * key, u32 key_len)
+{
+	u32	t, u;
+	u32	keyindex;
+	u32	stateindex;
+	u8 *state;
+	u32	counter;
+
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (u8)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++) {
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (u8)t;
+		state[counter] = (u8)u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+}
+
+static u32 arcfour_byte(struct arc4context *parc4ctx)
+{
+	u32 x;
+	u32 y;
+	u32 sx, sy;
+	u8 *state;
+
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (u8)sx;
+	state[x] = (u8)sy;
+	return state[(sx + sy) & 0xff];
+}
+
+static void arcfour_encrypt(struct arc4context	*parc4ctx,
+		     u8 *dest, u8 *src, u32 len)
+{
+	u32 i;
+
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+}
+
+static sint bcrc32initialized;
+static u32 crc32_table[256];
+
+static u8 crc32_reverseBit(u8 data)
+{
+	return ((u8)(data << 7) & 0x80) | ((data << 5) & 0x40) | ((data << 3)
+		 & 0x20) | ((data << 1) & 0x10) | ((data >> 1) & 0x08) |
+		 ((data >> 3) & 0x04) | ((data >> 5) & 0x02) | ((data >> 7) &
+		 0x01);
+}
+
+static void crc32_init(void)
+{
+	if (bcrc32initialized == 1)
+		return;
+	else {
+		sint i, j;
+		u32 c;
+		u8 *p = (u8 *)&c, *p1;
+		u8 k;
+
+		c = 0x12340000;
+		for (i = 0; i < 256; ++i) {
+			k = crc32_reverseBit((u8)i);
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j)
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY :
+				    (c << 1);
+			p1 = (u8 *)&crc32_table[i];
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized = 1;
+	}
+}
+
+static u32 getcrc32(u8 *buf, u32 len)
+{
+	u8 *p;
+	u32  crc;
+
+	if (bcrc32initialized == 0)
+		crc32_init();
+	crc = 0xffffffff; /* preload shift register, per CRC-32 spec */
+	for (p = buf; len > 0; ++p, --len)
+		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
+	return ~crc;    /* transmit complement, per CRC-32 spec */
+}
+
+/*
+	Need to consider the fragment  situation
+*/
+void r8712_wep_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/* exclude ICV */
+	unsigned char	crc[4];
+	struct arc4context  mycontext;
+	u32 curfragnum, length, keylength;
+	u8 *pframe, *payload, *iv;    /*,*wepkey*/
+	u8 wepkey[16];
+	struct	pkt_attrib  *pattrib = &((struct xmit_frame *)
+				       pxmitframe)->attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return;
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;
+	/*start to encrypt each fragment*/
+	if ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {
+		keylength = psecuritypriv->DefKeylen[psecuritypriv->
+			    PrivacyKeyIndex];
+		for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+		     curfragnum++) {
+			iv = pframe+pattrib->hdrlen;
+			memcpy(&wepkey[0], iv, 3);
+			memcpy(&wepkey[3], &psecuritypriv->DefKey[
+				psecuritypriv->PrivacyKeyIndex].skey[0],
+				keylength);
+			payload = pframe+pattrib->iv_len+pattrib->hdrlen;
+			if ((curfragnum + 1) == pattrib->nr_frags) {
+				length = pattrib->last_txcmdsz-pattrib->
+					 hdrlen-pattrib->iv_len -
+					 pattrib->icv_len;
+				*((u32 *)crc) = cpu_to_le32(getcrc32(
+						payload, length));
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload + length,
+						crc, 4);
+			} else {
+				length = pxmitpriv->frag_len-pattrib->hdrlen -
+					 pattrib->iv_len-pattrib->icv_len;
+				*((u32 *)crc) = cpu_to_le32(getcrc32(
+						payload, length));
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload+length,
+						crc, 4);
+				pframe += pxmitpriv->frag_len;
+				pframe = (u8 *)RND4((addr_t)(pframe));
+			}
+		}
+	}
+}
+
+void r8712_wep_decrypt(struct _adapter  *padapter, u8 *precvframe)
+{
+	/* exclude ICV */
+	u8 crc[4];
+	struct arc4context  mycontext;
+	u32 length, keylength;
+	u8 *pframe, *payload, *iv, wepkey[16];
+	u8  keyindex;
+	struct rx_pkt_attrib  *prxattrib = &(((union recv_frame *)
+					  precvframe)->u.hdr.attrib);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame *)precvframe)->
+		  u.hdr.rx_data;
+	/* start to decrypt recvframe */
+	if ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt ==
+	     _WEP104_)) {
+		iv = pframe + prxattrib->hdrlen;
+		keyindex = (iv[3] & 0x3);
+		keylength = psecuritypriv->DefKeylen[keyindex];
+		memcpy(&wepkey[0], iv, 3);
+		memcpy(&wepkey[3], &psecuritypriv->DefKey[
+			psecuritypriv->PrivacyKeyIndex].skey[0],
+			keylength);
+		length = ((union recv_frame *)precvframe)->
+			   u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+		payload = pframe+prxattrib->iv_len+prxattrib->hdrlen;
+		/* decrypt payload include icv */
+		arcfour_init(&mycontext, wepkey, 3 + keylength);
+		arcfour_encrypt(&mycontext, payload, payload,  length);
+		/* calculate icv and compare the icv */
+		*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length - 4));
+	}
+	return;
+}
+
+/* 3 =====TKIP related===== */
+
+static u32 secmicgetuint32(u8 *p)
+/* Convert from Byte[] to Us4Byte32 in a portable way */
+{
+	s32 i;
+	u32 res = 0;
+
+	for (i = 0; i < 4; i++)
+		res |= ((u32)(*p++)) << (8 * i);
+	return res;
+}
+
+static void secmicputuint32(u8 *p, u32 val)
+/* Convert from Us4Byte32 to Byte[] in a portable way */
+{
+	long i;
+	for (i = 0; i < 4; i++) {
+		*p++ = (u8) (val & 0xff);
+		val >>= 8;
+	}
+}
+
+static void secmicclear(struct mic_data *pmicdata)
+{
+/* Reset the state to the empty message. */
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+}
+
+void r8712_secmicsetkey(struct mic_data *pmicdata, u8 * key)
+{
+	/* Set the key */
+	pmicdata->K0 = secmicgetuint32(key);
+	pmicdata->K1 = secmicgetuint32(key + 4);
+	/* and reset the message */
+	secmicclear(pmicdata);
+}
+
+static void secmicappendbyte(struct mic_data *pmicdata, u8 b)
+{
+	/* Append the byte to our word-sized buffer */
+	pmicdata->M |= ((u32)b) << (8 * pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	/* Process the word if it is full. */
+	if (pmicdata->nBytesInM >= 4) {
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32(pmicdata->L, 17);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) |
+			       ((pmicdata->L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32(pmicdata->L, 3);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32(pmicdata->L, 2);
+		pmicdata->L += pmicdata->R;
+		/* Clear the buffer */
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+}
+
+void r8712_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes)
+{
+	/* This is simple */
+	while (nbytes > 0) {
+		secmicappendbyte(pmicdata, *src++);
+		nbytes--;
+	}
+}
+
+void r8712_secgetmic(struct mic_data *pmicdata, u8 *dst)
+{
+	/* Append the minimum padding */
+	secmicappendbyte(pmicdata, 0x5a);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	secmicappendbyte(pmicdata, 0);
+	/* and then zeroes until the length is a multiple of 4 */
+	while (pmicdata->nBytesInM != 0)
+		secmicappendbyte(pmicdata, 0);
+	/* The appendByte function has already computed the result. */
+	secmicputuint32(dst, pmicdata->L);
+	secmicputuint32(dst + 4, pmicdata->R);
+	/* Reset to the empty message. */
+	secmicclear(pmicdata);
+}
+
+void seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code,
+		    u8 pri)
+{
+
+	struct mic_data	micdata;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
+
+	r8712_secmicsetkey(&micdata, key);
+	priority[0] = pri;
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if (header[1] & 1) {   /* ToDS==1 */
+		r8712_secmicappend(&micdata, &header[16], 6);  /* DA */
+		if (header[1] & 2)  /* From Ds==1 */
+			r8712_secmicappend(&micdata, &header[24], 6);
+		else
+			r8712_secmicappend(&micdata, &header[10], 6);
+	} else {	/* ToDS==0 */
+		r8712_secmicappend(&micdata, &header[4], 6);   /* DA */
+		if (header[1] & 2)  /* From Ds==1 */
+			r8712_secmicappend(&micdata, &header[16], 6);
+		else
+			r8712_secmicappend(&micdata, &header[10], 6);
+	}
+	r8712_secmicappend(&micdata, &priority[0], 4);
+	r8712_secmicappend(&micdata, data, data_len);
+	r8712_secgetmic(&micdata, mic_code);
+}
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((u8)((v16) & 0x00FF))
+#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)((v32) & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >> 16) & 0xFFFF))
+#define  Mk16(hi, lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)  Mk16(tk[2 * (N) + 1], tk[2 * (N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)  (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8    /* this needs to be "big enough"     */
+#define TA_SIZE           6    /*  48-bit transmitter address       */
+#define TK_SIZE          16    /* 128-bit temporal key              */
+#define P1K_SIZE         10    /*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16    /* 128-bit RC4KEY (104 bits unknown) */
+
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+static const unsigned short Sbox1[2][256] = {/* Sbox for hash (can be in ROM) */
+	{
+	0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,
+	0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,
+	0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,
+	0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,
+	0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,
+	0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,
+	0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,
+	0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,
+	0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,
+	0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,
+	0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,
+	0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,
+	0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,
+	0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,
+	0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,
+	0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,
+	0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,
+	0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,
+	0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,
+	0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,
+	0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,
+	0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,
+	0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,
+	0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,
+	0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,
+	0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,
+	0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,
+	0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,
+	0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,
+	0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,
+	0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,
+	0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,
+	},
+	{  /* second half is unsigned char-reversed version of first! */
+	0xA5C6, 0x84F8, 0x99EE, 0x8DF6, 0x0DFF, 0xBDD6, 0xB1DE, 0x5491,
+	0x5060, 0x0302, 0xA9CE, 0x7D56, 0x19E7, 0x62B5, 0xE64D, 0x9AEC,
+	0x458F, 0x9D1F, 0x4089, 0x87FA, 0x15EF, 0xEBB2, 0xC98E, 0x0BFB,
+	0xEC41, 0x67B3, 0xFD5F, 0xEA45, 0xBF23, 0xF753, 0x96E4, 0x5B9B,
+	0xC275, 0x1CE1, 0xAE3D, 0x6A4C, 0x5A6C, 0x417E, 0x02F5, 0x4F83,
+	0x5C68, 0xF451, 0x34D1, 0x08F9, 0x93E2, 0x73AB, 0x5362, 0x3F2A,
+	0x0C08, 0x5295, 0x6546, 0x5E9D, 0x2830, 0xA137, 0x0F0A, 0xB52F,
+	0x090E, 0x3624, 0x9B1B, 0x3DDF, 0x26CD, 0x694E, 0xCD7F, 0x9FEA,
+	0x1B12, 0x9E1D, 0x7458, 0x2E34, 0x2D36, 0xB2DC, 0xEEB4, 0xFB5B,
+	0xF6A4, 0x4D76, 0x61B7, 0xCE7D, 0x7B52, 0x3EDD, 0x715E, 0x9713,
+	0xF5A6, 0x68B9, 0x0000, 0x2CC1, 0x6040, 0x1FE3, 0xC879, 0xEDB6,
+	0xBED4, 0x468D, 0xD967, 0x4B72, 0xDE94, 0xD498, 0xE8B0, 0x4A85,
+	0x6BBB, 0x2AC5, 0xE54F, 0x16ED, 0xC586, 0xD79A, 0x5566, 0x9411,
+	0xCF8A, 0x10E9, 0x0604, 0x81FE, 0xF0A0, 0x4478, 0xBA25, 0xE34B,
+	0xF3A2, 0xFE5D, 0xC080, 0x8A05, 0xAD3F, 0xBC21, 0x4870, 0x04F1,
+	0xDF63, 0xC177, 0x75AF, 0x6342, 0x3020, 0x1AE5, 0x0EFD, 0x6DBF,
+	0x4C81, 0x1418, 0x3526, 0x2FC3, 0xE1BE, 0xA235, 0xCC88, 0x392E,
+	0x5793, 0xF255, 0x82FC, 0x477A, 0xACC8, 0xE7BA, 0x2B32, 0x95E6,
+	0xA0C0, 0x9819, 0xD19E, 0x7FA3, 0x6644, 0x7E54, 0xAB3B, 0x830B,
+	0xCA8C, 0x29C7, 0xD36B, 0x3C28, 0x79A7, 0xE2BC, 0x1D16, 0x76AD,
+	0x3BDB, 0x5664, 0x4E74, 0x1E14, 0xDB92, 0x0A0C, 0x6C48, 0xE4B8,
+	0x5D9F, 0x6EBD, 0xEF43, 0xA6C4, 0xA839, 0xA431, 0x37D3, 0x8BF2,
+	0x32D5, 0x438B, 0x596E, 0xB7DA, 0x8C01, 0x64B1, 0xD29C, 0xE049,
+	0xB4D8, 0xFAAC, 0x07F3, 0x25CF, 0xAFCA, 0x8EF4, 0xE947, 0x1810,
+	0xD56F, 0x88F0, 0x6F4A, 0x725C, 0x2438, 0xF157, 0xC773, 0x5197,
+	0x23CB, 0x7CA1, 0x9CE8, 0x213E, 0xDD96, 0xDC61, 0x860D, 0x850F,
+	0x90E0, 0x427C, 0xC471, 0xAACC, 0xD890, 0x0506, 0x01F7, 0x121C,
+	0xA3C2, 0x5F6A, 0xF9AE, 0xD069, 0x9117, 0x5899, 0x273A, 0xB927,
+	0x38D9, 0x13EB, 0xB32B, 0x3322, 0xBBD2, 0x70A9, 0x8907, 0xA733,
+	0xB62D, 0x223C, 0x9215, 0x20C9, 0x4987, 0xFFAA, 0x7850, 0x7AA5,
+	0x8F03, 0xF859, 0x8009, 0x171A, 0xDA65, 0x31D7, 0xC684, 0xB8D0,
+	0xC382, 0xB029, 0x775A, 0x111E, 0xCB7B, 0xFCA8, 0xD66D, 0x3A2C,
+	}
+};
+
+/*
+**********************************************************************
+* Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+*
+* Inputs:
+*     tk[]      = temporal key                         [128 bits]
+*     ta[]      = transmitter's MAC address            [ 48 bits]
+*     iv32      = upper 32 bits of IV                  [ 32 bits]
+* Output:
+*     p1k[]     = Phase 1 key                          [ 80 bits]
+*
+* Note:
+*     This function only needs to be called every 2**16 packets,
+*     although in theory it could be called every packet.
+*
+**********************************************************************
+*/
+static void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)
+{
+	sint  i;
+
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0] = Lo16(iv32);
+	p1k[1] = Hi16(iv32);
+	p1k[2] = Mk16(ta[1], ta[0]); /* use TA[] as little-endian */
+	p1k[3] = Mk16(ta[3], ta[2]);
+	p1k[4] = Mk16(ta[5], ta[4]);
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i = 0; i < PHASE1_LOOP_CNT; i++) {  /* Each add is mod 2**16 */
+		p1k[0] += _S_(p1k[4] ^ TK16((i&1) + 0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i&1) + 2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i&1) + 4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i&1) + 6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i&1) + 0));
+		p1k[4] +=  (unsigned short)i;	/* avoid "slide attacks" */
+	}
+}
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [ 80 bits]
+*     iv16      = low 16 bits of IV counter            [ 16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA,IV32,IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+static void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)
+{
+	sint  i;
+	u16 PPK[6];			/* temporary key for mixing    */
+
+	/* Note: all adds in the PPK[] equations below are mod 2**16 */
+	for (i = 0; i < 5; i++)
+		PPK[i] = p1k[i]; /* first, copy P1K to PPK */
+	PPK[5]  =  p1k[4] + iv16; /* next,  add in IV16 */
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5] */
+	PPK[0] += _S_(PPK[5] ^ TK16(0));   /* Mix key in each "round" */
+	PPK[1] += _S_(PPK[0] ^ TK16(1));
+	PPK[2] += _S_(PPK[1] ^ TK16(2));
+	PPK[3] += _S_(PPK[2] ^ TK16(3));
+	PPK[4] += _S_(PPK[3] ^ TK16(4));
+	PPK[5] += _S_(PPK[4] ^ TK16(5));   /* Total # S-box lookups == 6  */
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] +=  RotR1(PPK[5] ^ TK16(6));
+	PPK[1] +=  RotR1(PPK[0] ^ TK16(7));   /* Use all of TK[] in Phase2   */
+	PPK[2] +=  RotR1(PPK[1]);
+	PPK[3] +=  RotR1(PPK[2]);
+	PPK[4] +=  RotR1(PPK[3]);
+	PPK[5] +=  RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/* value PPK[0..5] is guaranteed to be unique, as a function   */
+	/* of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  */
+	/* is now a keyed permutation of {TA,IV32,IV16}. */
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16); /* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] = (Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian) */
+	for (i = 0; i < 6; i++) {
+		rc4key[4 + 2 * i] = Lo8(PPK[i]);
+		rc4key[5 + 2 * i] = Hi8(PPK[i]);
+	}
+}
+
+/*The hlen isn't include the IV*/
+u32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/*  exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	u32 curfragnum, length, prwskeylen;
+
+	u8 *pframe, *payload, *iv, *prwskey;
+	union pn48 txpn;
+	struct sta_info *stainfo;
+	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;
+	/* 4 start to encrypt each fragment */
+	if (pattrib->encrypt == _TKIP_) {
+		if (pattrib->psta)
+			stainfo = pattrib->psta;
+		else
+			stainfo = r8712_get_stainfo(&padapter->stapriv,
+				  &pattrib->ra[0]);
+		if (stainfo != NULL) {
+			prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				iv = pframe + pattrib->hdrlen;
+				payload = pframe+pattrib->iv_len +
+					  pattrib->hdrlen;
+				GET_TKIP_PN(iv, txpn);
+				pnl = (u16)(txpn.val);
+				pnh = (u32)(txpn.val >> 16);
+				phase1((u16 *)&ttkey[0], prwskey, &pattrib->
+				       ta[0], pnh);
+				phase2(&rc4key[0], prwskey, (u16 *)&ttkey[0],
+				       pnl);
+				if ((curfragnum + 1) == pattrib->nr_frags) {
+					/* 4 the last fragment */
+					length = pattrib->last_txcmdsz -
+					     pattrib->hdrlen-pattrib->iv_len -
+					     pattrib->icv_len;
+					*((u32 *)crc) = cpu_to_le32(
+						getcrc32(payload, length));
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							payload, length);
+					arcfour_encrypt(&mycontext, payload +
+							length, crc, 4);
+				} else {
+					length = pxmitpriv->frag_len-pattrib->
+						 hdrlen-pattrib->
+						 iv_len-pattrib->icv_len;
+					*((u32 *)crc) = cpu_to_le32(getcrc32(
+							payload, length));
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							 payload, length);
+					arcfour_encrypt(&mycontext,
+							payload+length, crc, 4);
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((addr_t)(pframe));
+				}
+			}
+		} else
+			res = _FAIL;
+	}
+	return res;
+}
+
+/* The hlen doesn't include the IV */
+u32 r8712_tkip_decrypt(struct _adapter *padapter, u8 *precvframe)
+{	/* exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	u32 length, prwskeylen;
+	u8 *pframe, *payload, *iv, *prwskey, idx = 0;
+	union pn48 txpn;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &((union recv_frame *)
+					   precvframe)->u.hdr.attrib;
+	struct	security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame *)
+				   precvframe)->u.hdr.rx_data;
+	/* 4 start to decrypt recvframe */
+	if (prxattrib->encrypt == _TKIP_) {
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			iv = pframe+prxattrib->hdrlen;
+			payload = pframe+prxattrib->iv_len + prxattrib->hdrlen;
+			length = ((union recv_frame *)precvframe)->
+				 u.hdr.len - prxattrib->hdrlen -
+				 prxattrib->iv_len;
+			if (IS_MCAST(prxattrib->ra)) {
+				idx = iv[3];
+				prwskey = &psecuritypriv->XGrpKey[
+					 ((idx >> 6) & 0x3) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+			} else
+				prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			GET_TKIP_PN(iv, txpn);
+			pnl = (u16)(txpn.val);
+			pnh = (u32)(txpn.val >> 16);
+			phase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0],
+				pnh);
+			phase2(&rc4key[0], prwskey, (unsigned short *)
+			       &ttkey[0], pnl);
+			/* 4 decrypt payload include icv */
+			arcfour_init(&mycontext, rc4key, 16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+			*((u32 *)crc) = cpu_to_le32(getcrc32(payload,
+					length - 4));
+			if (crc[3] != payload[length - 1] ||
+			    crc[2] != payload[length - 2] ||
+			    crc[1] != payload[length - 3] ||
+			    crc[0] != payload[length - 4])
+				return _FAIL;
+		} else
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+/* 3 =====AES related===== */
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+static const u8 sbox_table[256] = {
+	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+};
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+static void xor_128(u8 *a, u8 *b, u8 *out)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = a[i] ^ b[i];
+}
+
+static void xor_32(u8 *a, u8 *b, u8 *out)
+{
+	sint i;
+	for (i = 0; i < 4; i++)
+		out[i] = a[i] ^ b[i];
+}
+
+static u8 sbox(u8 a)
+{
+	return sbox_table[(sint)a];
+}
+
+static void next_key(u8 *key, sint round)
+{
+	u8 rcon;
+	u8 sbox_key[4];
+	u8 rcon_table[12] = {
+		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+		0x1b, 0x36, 0x36, 0x36
+	};
+
+	sbox_key[0] = sbox(key[13]);
+	sbox_key[1] = sbox(key[14]);
+	sbox_key[2] = sbox(key[15]);
+	sbox_key[3] = sbox(key[12]);
+	rcon = rcon_table[round];
+	xor_32(&key[0], sbox_key, &key[0]);
+	key[0] = key[0] ^ rcon;
+	xor_32(&key[4], &key[0], &key[4]);
+	xor_32(&key[8], &key[4], &key[8]);
+	xor_32(&key[12], &key[8], &key[12]);
+}
+
+static void byte_sub(u8 *in, u8 *out)
+{
+	sint i;
+	for (i = 0; i < 16; i++)
+		out[i] = sbox(in[i]);
+}
+
+static void shift_row(u8 *in, u8 *out)
+{
+	out[0] =  in[0];
+	out[1] =  in[5];
+	out[2] =  in[10];
+	out[3] =  in[15];
+	out[4] =  in[4];
+	out[5] =  in[9];
+	out[6] =  in[14];
+	out[7] =  in[3];
+	out[8] =  in[8];
+	out[9] =  in[13];
+	out[10] = in[2];
+	out[11] = in[7];
+	out[12] = in[12];
+	out[13] = in[1];
+	out[14] = in[6];
+	out[15] = in[11];
+}
+
+static void mix_column(u8 *in, u8 *out)
+{
+	sint i;
+	u8 add1b[4];
+	u8 add1bf7[4];
+	u8 rotl[4];
+	u8 swap_halfs[4];
+	u8 andf7[4];
+	u8 rotr[4];
+	u8 temp[4];
+	u8 tempb[4];
+
+	for (i = 0 ; i < 4; i++) {
+		if ((in[i] & 0x80) == 0x80)
+			add1b[i] = 0x1b;
+		else
+			add1b[i] = 0x00;
+	}
+	swap_halfs[0] = in[2];    /* Swap halves */
+	swap_halfs[1] = in[3];
+	swap_halfs[2] = in[0];
+	swap_halfs[3] = in[1];
+	rotl[0] = in[3];        /* Rotate left 8 bits */
+	rotl[1] = in[0];
+	rotl[2] = in[1];
+	rotl[3] = in[2];
+	andf7[0] = in[0] & 0x7f;
+	andf7[1] = in[1] & 0x7f;
+	andf7[2] = in[2] & 0x7f;
+	andf7[3] = in[3] & 0x7f;
+	for (i = 3; i > 0; i--) {   /* logical shift left 1 bit */
+		andf7[i] = andf7[i] << 1;
+		if ((andf7[i-1] & 0x80) == 0x80)
+			andf7[i] = (andf7[i] | 0x01);
+	}
+	andf7[0] = andf7[0] << 1;
+	andf7[0] = andf7[0] & 0xfe;
+	xor_32(add1b, andf7, add1bf7);
+	xor_32(in, add1bf7, rotr);
+	temp[0] = rotr[0];         /* Rotate right 8 bits */
+	rotr[0] = rotr[1];
+	rotr[1] = rotr[2];
+	rotr[2] = rotr[3];
+	rotr[3] = temp[0];
+	xor_32(add1bf7, rotr, temp);
+	xor_32(swap_halfs, rotl, tempb);
+	xor_32(temp, tempb, out);
+}
+
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
+{
+	sint round;
+	sint i;
+	u8 intermediatea[16];
+	u8 intermediateb[16];
+	u8 round_key[16];
+
+	for (i = 0; i < 16; i++)
+		round_key[i] = key[i];
+	for (round = 0; round < 11; round++) {
+		if (round == 0) {
+			xor_128(round_key, data, ciphertext);
+			next_key(round_key, round);
+		} else if (round == 10) {
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			xor_128(intermediateb, round_key, ciphertext);
+		} else {   /* 1 - 9 */
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			mix_column(&intermediateb[0], &intermediatea[0]);
+			mix_column(&intermediateb[4], &intermediatea[4]);
+			mix_column(&intermediateb[8], &intermediatea[8]);
+			mix_column(&intermediateb[12], &intermediatea[12]);
+			xor_128(intermediatea, round_key, ciphertext);
+			next_key(round_key, round);
+		}
+	}
+}
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+static void construct_mic_iv(u8 *mic_iv, sint qc_exists, sint a4_exists,
+			     u8 *mpdu, uint payload_length, u8 *pn_vector)
+{
+	sint i;
+
+	mic_iv[0] = 0x59;
+	if (qc_exists && a4_exists)
+		mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+	if (qc_exists && !a4_exists)
+		mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+	if (!qc_exists)
+		mic_iv[1] = 0x00;
+	for (i = 2; i < 8; i++)
+		mic_iv[i] = mpdu[i + 8];
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[13 - i]; /* mic_iv[8:13] = PN[5:0] */
+	mic_iv[14] = (unsigned char) (payload_length / 256);
+	mic_iv[15] = (unsigned char) (payload_length % 256);
+}
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header1(u8 *mic_header1, sint header_length, u8 *mpdu)
+{
+	mic_header1[0] = (u8)((header_length - 2) / 256);
+	mic_header1[1] = (u8)((header_length - 2) % 256);
+	mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
+	/* Mute retry, more data and pwr mgt bits */
+	mic_header1[3] = mpdu[1] & 0xc7;
+	mic_header1[4] = mpdu[4];       /* A1 */
+	mic_header1[5] = mpdu[5];
+	mic_header1[6] = mpdu[6];
+	mic_header1[7] = mpdu[7];
+	mic_header1[8] = mpdu[8];
+	mic_header1[9] = mpdu[9];
+	mic_header1[10] = mpdu[10];     /* A2 */
+	mic_header1[11] = mpdu[11];
+	mic_header1[12] = mpdu[12];
+	mic_header1[13] = mpdu[13];
+	mic_header1[14] = mpdu[14];
+	mic_header1[15] = mpdu[15];
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header2(u8 *mic_header2, u8 *mpdu, sint a4_exists,
+			   sint qc_exists)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		mic_header2[i] = 0x00;
+	mic_header2[0] = mpdu[16];    /* A3 */
+	mic_header2[1] = mpdu[17];
+	mic_header2[2] = mpdu[18];
+	mic_header2[3] = mpdu[19];
+	mic_header2[4] = mpdu[20];
+	mic_header2[5] = mpdu[21];
+	mic_header2[6] = 0x00;
+	mic_header2[7] = 0x00; /* mpdu[23]; */
+	if (!qc_exists && a4_exists)
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];   /* A4 */
+	if (qc_exists && !a4_exists) {
+		mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+		mic_header2[9] = mpdu[25] & 0x00;
+	}
+	if (qc_exists && a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];   /* A4 */
+		mic_header2[14] = mpdu[30] & 0x0f;
+		mic_header2[15] = mpdu[31] & 0x00;
+	}
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_ctr_preload(u8 *ctr_preload, sint a4_exists, sint qc_exists,
+			   u8 *mpdu, u8 *pn_vector, sint c)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		ctr_preload[i] = 0x00;
+	i = 0;
+	ctr_preload[0] = 0x01;    /* flag */
+	if (qc_exists && a4_exists)
+		ctr_preload[1] = mpdu[30] & 0x0f;
+	if (qc_exists && !a4_exists)
+		ctr_preload[1] = mpdu[24] & 0x0f;
+	for (i = 2; i < 8; i++)
+		ctr_preload[i] = mpdu[i + 8];
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[13 - i];
+	ctr_preload[14] = (unsigned char) (c / 256); /* Ctr */
+	ctr_preload[15] = (unsigned char) (c % 256);
+}
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
+{
+	sint i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = ina[i] ^ inb[i];
+}
+
+static sint aes_cipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	uint qc_exists, a4_exists, i, j, payload_remainder;
+	uint num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if ((frtype == WIFI_DATA_CFACK) ||
+	     (frtype == WIFI_DATA_CFPOLL) ||
+	     (frtype == WIFI_DATA_CFACKPOLL)) {
+			qc_exists = 1;
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+	} else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) ||
+		   (frsubtype == 0x0b)) {
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+			qc_exists = 1;
+	} else
+		qc_exists = 0;
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);
+	construct_mic_header1(mic_header1, hdrlen, pframe);
+	construct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);
+	payload_remainder = plen % 16;
+	num_blocks = plen / 16;
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	for (j = 0; j < 8; j++)
+		mic[j] = aes_out[j];
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		pframe[payload_index+j] = mic[j];
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) {  /* If short final block, then pad it,*/
+				      /* encrypt and copy unpadded part back */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index+j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+			      pframe, pn_vector, 0);
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = pframe[j+hdrlen+8+plen];
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		pframe[payload_index++] = chain_buffer[j];
+	return _SUCCESS;
+}
+
+u32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe)
+{	/* exclude ICV */
+	/* Intermediate Buffers */
+	sint	curfragnum, length;
+	u32	prwskeylen;
+	u8	*pframe, *prwskey;
+	struct	sta_info *stainfo;
+	struct	pkt_attrib  *pattrib = &((struct xmit_frame *)
+				       pxmitframe)->attrib;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;
+	/* 4 start to encrypt each fragment */
+	if ((pattrib->encrypt == _AES_)) {
+		if (pattrib->psta)
+			stainfo = pattrib->psta;
+		else
+			stainfo = r8712_get_stainfo(&padapter->stapriv,
+				  &pattrib->ra[0]);
+		if (stainfo != NULL) {
+			prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				if ((curfragnum + 1) == pattrib->nr_frags) {\
+					length = pattrib->last_txcmdsz -
+						 pattrib->hdrlen -
+						 pattrib->iv_len -
+						 pattrib->icv_len;
+					aes_cipher(prwskey, pattrib->
+						  hdrlen, pframe, length);
+				} else {
+					length = pxmitpriv->frag_len -
+						 pattrib->hdrlen -
+						 pattrib->iv_len -
+						 pattrib->icv_len ;
+					aes_cipher(prwskey, pattrib->
+						   hdrlen, pframe, length);
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((addr_t)(pframe));
+				}
+			}
+		} else
+			res = _FAIL;
+	}
+	return res;
+}
+
+static sint aes_decipher(u8 *key, uint	hdrlen,
+			u8 *pframe, uint plen)
+{
+	static u8 message[MAX_MSG_SIZE];
+	uint qc_exists, a4_exists, i, j, payload_remainder;
+	uint num_blocks, payload_index;
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint frtype  = GetFrameType(pframe);
+	uint frsubtype  = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+	/* start to decrypt the payload */
+	/*(plen including llc, payload and mic) */
+	num_blocks = (plen - 8) / 16;
+	payload_remainder = (plen-8) % 16;
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+	if ((frtype == WIFI_DATA_CFACK) ||
+	    (frtype == WIFI_DATA_CFPOLL) ||
+	    (frtype == WIFI_DATA_CFACKPOLL)) {
+		qc_exists = 1;
+		if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+		}  else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) ||
+		   (frsubtype == 0x0b)) {
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN)
+				hdrlen += 2;
+			qc_exists = 1;
+	} else
+		qc_exists = 0;
+	/* now, decrypt pframe with hdrlen offset and plen long */
+	payload_index = hdrlen + 8; /* 8 is for extiv */
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) {  /* If short final block, pad it,*/
+		/* encrypt it and copy the unpadded part back   */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      pframe, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+	/* start to calculate the mic */
+	memcpy((void *)message, pframe, (hdrlen + plen + 8));
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen+1];
+	pn_vector[2] = pframe[hdrlen+4];
+	pn_vector[3] = pframe[hdrlen+5];
+	pn_vector[4] = pframe[hdrlen+6];
+	pn_vector[5] = pframe[hdrlen+7];
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, message, plen-8,
+			 pn_vector);
+	construct_mic_header1(mic_header1, hdrlen, message);
+	construct_mic_header2(mic_header2, message, a4_exists, qc_exists);
+	payload_remainder = (plen - 8) % 16;
+	num_blocks = (plen - 8) / 16;
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+	for (j = 0 ; j < 8; j++)
+		mic[j] = aes_out[j];
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		message[payload_index+j] = mic[j];
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      message, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+	if (payload_remainder > 0) { /* If short final block, pad it,*/
+				     /* encrypt and copy unpadded part back */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists,
+				      message, pn_vector, num_blocks+1);
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, message,
+			      pn_vector, 0);
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = message[j + hdrlen + plen];
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		message[payload_index++] = chain_buffer[j];
+	/* compare the mic */
+	return _SUCCESS;
+}
+
+u32 r8712_aes_decrypt(struct _adapter *padapter, u8 *precvframe)
+{	/* exclude ICV */
+	/* Intermediate Buffers */
+	sint		length;
+	u32	prwskeylen;
+	u8	*pframe, *prwskey, *iv, idx;
+	struct	sta_info *stainfo;
+	struct	rx_pkt_attrib *prxattrib = &((union recv_frame *)
+					   precvframe)->u.hdr.attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+
+	pframe = (unsigned char *)((union recv_frame*)precvframe)->
+		 u.hdr.rx_data;
+	/* 4 start to encrypt each fragment */
+	if ((prxattrib->encrypt == _AES_)) {
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				iv = pframe+prxattrib->hdrlen;
+				idx = iv[3];
+				prwskey = &psecuritypriv->XGrpKey[
+					  ((idx >> 6) & 0x3) - 1].skey[0];
+				if (psecuritypriv->binstallGrpkey == false)
+					return _FAIL;
+
+			} else
+				prwskey = &stainfo->x_UncstKey.skey[0];
+			prwskeylen = 16;
+			length = ((union recv_frame *)precvframe)->
+				 u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
+			aes_decipher(prwskey, prxattrib->hdrlen, pframe,
+				     length);
+		} else
+			return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+void r8712_use_tkipkey_handler(void *FunctionContext)
+{
+	struct _adapter *padapter = (struct _adapter *)FunctionContext;
+
+	padapter->securitypriv.busetkipkey = true;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_security.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_security.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_security.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_security.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,222 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __RTL871X_SECURITY_H_
+#define __RTL871X_SECURITY_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+#define _NO_PRIVACY_	0x0
+#define _WEP40_		0x1
+#define _TKIP_		0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_		0x4
+#define _WEP104_	0x5
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48 {
+	u64 val;
+#if defined(__BIG_ENDIAN)
+	struct {
+		u8 TSC7;
+		u8 TSC6;
+		u8 TSC5;
+		u8 TSC4;
+		u8 TSC3;
+		u8 TSC2;
+		u8 TSC1;
+		u8 TSC0;
+	} _byte_;
+#else
+	struct {
+		u8 TSC0;
+		u8 TSC1;
+		u8 TSC2;
+		u8 TSC3;
+		u8 TSC4;
+		u8 TSC5;
+		u8 TSC6;
+		u8 TSC7;
+	} _byte_;
+#endif
+};
+
+union Keytype {
+	u8 skey[16];
+	u32 lkey[4];
+};
+
+struct RT_PMKID_LIST {
+	u8 bUsed;
+	u8 Bssid[6];
+	u8 PMKID[16];
+	u8 SsidBuf[33];
+	u8 *ssid_octet;
+	u16 ssid_length;
+};
+
+struct security_priv {
+	u32 AuthAlgrthm;		/* 802.11 auth, could be open, shared,
+					 * 8021x and authswitch */
+	u32 PrivacyAlgrthm;		/* This specify the privacy for shared
+					 * auth. algorithm. */
+	u32 PrivacyKeyIndex;		/* this is only valid for legendary
+					 * wep, 0~3 for key id. */
+	union Keytype DefKey[4];	/* this is only valid for def. key */
+	u32 DefKeylen[4];
+	u32 XGrpPrivacy;		/* This specify the privacy algthm.
+					 * used for Grp key */
+	u32 XGrpKeyid;			/* key id used for Grp Key */
+	union Keytype	XGrpKey[2];	/* 802.1x Group Key, for
+					 * inx0 and inx1 */
+	union Keytype	XGrptxmickey[2];
+	union Keytype	XGrprxmickey[2];
+	union pn48 Grptxpn;		/* PN48 used for Grp Key xmit. */
+	union pn48 Grprxpn;		/* PN48 used for Grp Key recv. */
+	u8 wps_hw_pbc_pressed;/*for hw pbc pressed*/
+	u8 wps_phase;/*for wps*/
+	u8 wps_ie[MAX_WPA_IE_LEN<<2];
+	int wps_ie_len;
+	u8	binstallGrpkey;
+	u8	busetkipkey;
+	struct timer_list tkip_timer;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+	s32	sw_encrypt;	/* from registry_priv */
+	s32	sw_decrypt;	/* from registry_priv */
+	s32	hw_decrypted;	/* if the rx packets is hw_decrypted==false,
+				 * it means the hw has not been ready. */
+	u32 ndisauthtype;	/* keeps the auth_type & enc_status from upper
+				 * layer ioctl(wpa_supplicant or wzc) */
+	u32 ndisencryptstatus;
+	struct wlan_bssid_ex sec_bss;  /* for joinbss (h2c buffer) usage */
+	struct NDIS_802_11_WEP ndiswep;
+	u8 assoc_info[600];
+	u8 szofcapability[256]; /* for wpa2 usage */
+	u8 oidassociation[512]; /* for wpa/wpa2 usage */
+	u8 authenticator_ie[256];  /* store ap security information element */
+	u8 supplicant_ie[256];  /* store sta security information element */
+	/* for tkip countermeasure */
+	u32 last_mic_err_time;
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+	/*-------------------------------------------------------------------
+	 * For WPA2 Pre-Authentication.
+	 *------------------------------------------------------------------ */
+	struct RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];
+	u8				PMKIDIndex;
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst) \
+do { \
+	switch (psecuritypriv->AuthAlgrthm) { \
+	case 0: \
+	case 1: \
+	case 3: \
+		encry_algo = (u8)psecuritypriv->PrivacyAlgrthm; \
+		break; \
+	case 2: \
+		if (bmcst) \
+			encry_algo = (u8)psecuritypriv->XGrpPrivacy; \
+		else \
+			encry_algo = (u8)psta->XPrivacy; \
+		break; \
+	} \
+} while (0)
+#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
+do {\
+	switch (encrypt) { \
+	case _WEP40_: \
+	case _WEP104_: \
+		iv_len = 4; \
+		icv_len = 4; \
+		break; \
+	case _TKIP_: \
+		iv_len = 8; \
+		icv_len = 4; \
+		break; \
+	case _AES_: \
+		iv_len = 8; \
+		icv_len = 8; \
+		break; \
+	default: \
+		iv_len = 0; \
+		icv_len = 0; \
+		break; \
+	} \
+} while (0)
+#define GET_TKIP_PN(iv, txpn) \
+do {\
+	txpn._byte_.TSC0 = iv[2];\
+	txpn._byte_.TSC1 = iv[0];\
+	txpn._byte_.TSC2 = iv[4];\
+	txpn._byte_.TSC3 = iv[5];\
+	txpn._byte_.TSC4 = iv[6];\
+	txpn._byte_.TSC5 = iv[7];\
+} while (0)
+
+#define ROL32(A, n) (((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
+#define ROR32(A, n) ROL32((A), 32 - (n))
+
+struct mic_data {
+	u32  K0, K1;         /* Key */
+	u32  L, R;           /* Current state */
+	u32  M;              /* Message accumulator (single word) */
+	u32  nBytesInM;      /* # bytes in M */
+};
+
+void seccalctkipmic(
+	u8  *key,
+	u8  *header,
+	u8  *data,
+	u32  data_len,
+	u8  *Miccode,
+	u8   priority);
+
+void r8712_secmicsetkey(struct mic_data *pmicdata, u8 * key);
+void r8712_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes);
+void r8712_secgetmic(struct mic_data *pmicdata, u8 * dst);
+u32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe);
+u32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe);
+void r8712_wep_encrypt(struct _adapter *padapter, u8  *pxmitframe);
+u32 r8712_aes_decrypt(struct _adapter *padapter, u8  *precvframe);
+u32 r8712_tkip_decrypt(struct _adapter *padapter, u8  *precvframe);
+void r8712_wep_decrypt(struct _adapter *padapter, u8  *precvframe);
+void r8712_use_tkipkey_handler(void *FunctionContext);
+
+#endif	/*__RTL871X_SECURITY_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_sta_mgt.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_sta_mgt.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_sta_mgt.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_sta_mgt.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,300 @@
+/******************************************************************************
+ * rtl871x_sta_mgt.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_STA_MGT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "sta_info.h"
+
+static void _init_stainfo(struct sta_info *psta)
+{
+	memset((u8 *)psta, 0, sizeof(struct sta_info));
+	 spin_lock_init(&psta->lock);
+	_init_listhead(&psta->list);
+	_init_listhead(&psta->hash_list);
+	_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_r8712_init_sta_recv_priv(&psta->sta_recvpriv);
+#ifdef CONFIG_R8712_AP
+	_init_listhead(&psta->asoc_list);
+	_init_listhead(&psta->auth_list);
+#endif
+}
+
+u32 _r8712_init_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	s32 i;
+
+	pstapriv->pallocated_stainfo_buf = _malloc(sizeof(struct sta_info) *
+						   NUM_STA + 4);
+	if (pstapriv->pallocated_stainfo_buf == NULL)
+		return _FAIL;
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
+		((addr_t)(pstapriv->pallocated_stainfo_buf) & 3);
+	_init_queue(&pstapriv->free_sta_queue);
+	spin_lock_init(&pstapriv->sta_hash_lock);
+	pstapriv->asoc_sta_count = 0;
+	_init_queue(&pstapriv->sleep_q);
+	_init_queue(&pstapriv->wakeup_q);
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+	for (i = 0; i < NUM_STA; i++) {
+		_init_stainfo(psta);
+		_init_listhead(&(pstapriv->sta_hash[i]));
+		list_insert_tail(&psta->list,
+				 get_list_head(&pstapriv->free_sta_queue));
+		psta++;
+	}
+#ifdef CONFIG_R8712_AP
+	_init_listhead(&pstapriv->asoc_list);
+	_init_listhead(&pstapriv->auth_list);
+#endif
+	return _SUCCESS;
+}
+
+/* this function is used to free the memory of lock || sema for all stainfos */
+static void mfree_all_stainfo(struct sta_priv *pstapriv)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = get_next(phead);
+	while ((end_of_queue_search(phead, plist)) == false) {
+		psta = LIST_CONTAINOR(plist, struct sta_info, list);
+		plist = get_next(plist);
+	}
+
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+}
+
+
+static void mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+	 mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
+}
+
+u32 _r8712_free_sta_priv(struct sta_priv *pstapriv)
+{
+	if (pstapriv) {
+		mfree_sta_priv_lock(pstapriv);
+		kfree(pstapriv->pallocated_stainfo_buf);
+	}
+	return _SUCCESS;
+}
+
+struct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	uint tmp_aid;
+	s32	index;
+	struct list_head *phash_list;
+	struct sta_info	*psta;
+	struct  __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+	unsigned long flags;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	spin_lock_irqsave(&(pfree_sta_queue->lock), flags);
+	if (_queue_empty(pfree_sta_queue) == true)
+		psta = NULL;
+	else {
+		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue),
+				      struct sta_info, list);
+		list_delete(&(psta->list));
+		tmp_aid = psta->aid;
+		_init_stainfo(psta);
+		memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+		index = wifi_mac_hash(hwaddr);
+		if (index >= NUM_STA) {
+			psta = NULL;
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+		list_insert_tail(&psta->hash_list, phash_list);
+		pstapriv->asoc_sta_count++ ;
+
+/* For the SMC router, the sequence number of first packet of WPS handshake
+ * will be 0. In this case, this packet will be dropped by recv_decache function
+ * if we use the 0x00 as the default value for tid_rxseq variable. So, we
+ * initialize the tid_rxseq variable as the 0xffff.
+ */
+		for (i = 0; i < 16; i++)
+			memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],
+				&wRxSeqInitialValue, 2);
+		/* for A-MPDU Rx reordering buffer control */
+		for (i = 0; i < 16 ; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->padapter = pstapriv->padapter;
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b = 0xffff;
+			preorder_ctrl->wsize_b = 64;
+			_init_queue(&preorder_ctrl->pending_recvframe_queue);
+			r8712_init_recv_timer(preorder_ctrl);
+		}
+	}
+exit:
+	spin_unlock_irqrestore(&(pfree_sta_queue->lock), flags);
+	return psta;
+}
+
+/* using pstapriv->sta_hash_lock to protect */
+void r8712_free_stainfo(struct _adapter *padapter, struct sta_info *psta)
+{
+	int i;
+	unsigned long irqL0;
+	struct  __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct	sta_xmit_priv *pstaxmitpriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	if (psta == NULL)
+		return;
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+	pstaxmitpriv = &psta->sta_xmitpriv;
+	spin_lock_irqsave(&(pxmitpriv->vo_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+	list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->vo_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->vi_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+	list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->vi_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->bk_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+	list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->bk_pending.lock), irqL0);
+	spin_lock_irqsave(&(pxmitpriv->be_pending.lock), irqL0);
+	r8712_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+	list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	spin_unlock_irqrestore(&(pxmitpriv->be_pending.lock), irqL0);
+	list_delete(&psta->hash_list);
+	pstapriv->asoc_sta_count--;
+	/* re-init sta_info; 20061114 */
+	_r8712_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_r8712_init_sta_recv_priv(&psta->sta_recvpriv);
+	/* for A-MPDU Rx reordering buffer control,
+	 * cancel reordering_ctrl_timer */
+	for (i = 0; i < 16; i++) {
+		preorder_ctrl = &psta->recvreorder_ctrl[i];
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+	spin_lock(&(pfree_sta_queue->lock));
+	/* insert into free_sta_queue; 20061114 */
+	list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	spin_unlock(&(pfree_sta_queue->lock));
+}
+
+/* free all stainfo which in sta_hash[all] */
+void r8712_free_all_stainfo(struct _adapter *padapter)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	s32 index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *pbcmc_stainfo = r8712_get_bcmc_stainfo(padapter);
+
+	if (pstapriv->asoc_sta_count == 1)
+		return;
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	for (index = 0; index < NUM_STA; index++) {
+		phead = &(pstapriv->sta_hash[index]);
+		plist = get_next(phead);
+		while ((end_of_queue_search(phead, plist)) == false) {
+			psta = LIST_CONTAINOR(plist,
+					      struct sta_info, hash_list);
+			plist = get_next(plist);
+			if (pbcmc_stainfo != psta)
+				r8712_free_stainfo(padapter , psta);
+		}
+	}
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	unsigned long	 irqL;
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+	u32	index;
+
+	if (hwaddr == NULL)
+		return NULL;
+	index = wifi_mac_hash(hwaddr);
+	spin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);
+	phead = &(pstapriv->sta_hash[index]);
+	plist = get_next(phead);
+	while ((end_of_queue_search(phead, plist)) == false) {
+		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+		if ((!memcmp(psta->hwaddr, hwaddr, ETH_ALEN))) {
+			/* if found the matched address */
+			break;
+		}
+		psta = NULL;
+		plist = get_next(plist);
+	}
+	spin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);
+	return psta;
+}
+
+void r8712_init_bcmc_stainfo(struct _adapter *padapter)
+{
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	unsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	psta = r8712_alloc_stainfo(pstapriv, bcast_addr);
+	if (psta == NULL)
+		return;
+	ptxservq = &(psta->sta_xmitpriv.be_q);
+}
+
+struct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter)
+{
+	struct sta_info *psta;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	psta = r8712_get_stainfo(pstapriv, bc_addr);
+	return psta;
+}
+
+
+u8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 *mac_addr)
+{
+	return true;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_wlan_sme.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_wlan_sme.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_wlan_sme.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_wlan_sme.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_WLAN_SME_H_
+#define _RTL871X_WLAN_SME_H_
+
+#define MSR_APMODE		0x0C
+#define MSR_STAMODE	0x08
+#define MSR_ADHOCMODE	0x04
+#define MSR_NOLINKMODE	0x00
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_xmit.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_xmit.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_xmit.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_xmit.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,1066 @@
+/******************************************************************************
+ * rtl871x_xmit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _RTL871X_XMIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+
+static const u8 P802_1H_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0xf8};
+static const u8 RFC1042_OUI[P80211_OUI_LEN] = {0x00, 0x00, 0x00};
+static void init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+static void alloc_hwxmits(struct _adapter *padapter);
+static void free_hwxmits(struct _adapter *padapter);
+
+static void _init_txservq(struct tx_servq *ptxservq)
+{
+	_init_listhead(&ptxservq->tx_pending);
+	_init_queue(&ptxservq->sta_pending);
+	ptxservq->qcnt = 0;
+}
+
+void _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{
+	memset((unsigned char *)psta_xmitpriv, 0,
+		 sizeof(struct sta_xmit_priv));
+	spin_lock_init(&psta_xmitpriv->lock);
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	_init_listhead(&psta_xmitpriv->legacy_dz);
+	_init_listhead(&psta_xmitpriv->apsd);
+}
+
+sint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,
+			   struct _adapter *padapter)
+{
+	sint i;
+	struct xmit_buf *pxmitbuf;
+	struct xmit_frame *pxframe;
+
+	memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	spin_lock_init(&pxmitpriv->lock);
+	sema_init(&pxmitpriv->xmit_sema, 0);
+	sema_init(&pxmitpriv->terminate_xmitthread_sema, 0);
+	/*
+	Please insert all the queue initializaiton using _init_queue below
+	*/
+	pxmitpriv->adapter = padapter;
+	_init_queue(&pxmitpriv->be_pending);
+	_init_queue(&pxmitpriv->bk_pending);
+	_init_queue(&pxmitpriv->vi_pending);
+	_init_queue(&pxmitpriv->vo_pending);
+	_init_queue(&pxmitpriv->bm_pending);
+	_init_queue(&pxmitpriv->legacy_dz_queue);
+	_init_queue(&pxmitpriv->apsd_queue);
+	_init_queue(&pxmitpriv->free_xmit_queue);
+	/*
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+	pxmitpriv->pallocated_frame_buf = _malloc(NR_XMITFRAME *
+					  sizeof(struct xmit_frame) + 4);
+	if (pxmitpriv->pallocated_frame_buf == NULL) {
+		pxmitpriv->pxmit_frame_buf = NULL;
+		return _FAIL;
+	}
+	pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
+			((addr_t) (pxmitpriv->pallocated_frame_buf) & 3);
+	pxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		_init_listhead(&(pxframe->list));
+		pxframe->padapter = padapter;
+		pxframe->frame_tag = DATA_FRAMETAG;
+		pxframe->pkt = NULL;
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+		list_insert_tail(&(pxframe->list),
+				 &(pxmitpriv->free_xmit_queue.queue));
+		pxframe++;
+	}
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+	/*
+		init xmit hw_txqueue
+	*/
+	_r8712_init_hw_txqueue(&pxmitpriv->be_txqueue, BE_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->bk_txqueue, BK_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->vi_txqueue, VI_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->vo_txqueue, VO_QUEUE_INX);
+	_r8712_init_hw_txqueue(&pxmitpriv->bmc_txqueue, BMC_QUEUE_INX);
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+	pxmitpriv->txirp_cnt = 1;
+	sema_init(&(pxmitpriv->tx_retevt), 0);
+	/*per AC pending irp*/
+	pxmitpriv->beq_cnt = 0;
+	pxmitpriv->bkq_cnt = 0;
+	pxmitpriv->viq_cnt = 0;
+	pxmitpriv->voq_cnt = 0;
+	/*init xmit_buf*/
+	_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+	pxmitpriv->pallocated_xmitbuf = _malloc(NR_XMITBUFF *
+					sizeof(struct xmit_buf) + 4);
+	if (pxmitpriv->pallocated_xmitbuf  == NULL)
+		return _FAIL;
+	pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
+			      ((addr_t)(pxmitpriv->pallocated_xmitbuf) & 3);
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		_init_listhead(&pxmitbuf->list);
+		pxmitbuf->pallocated_buf = _malloc(MAX_XMITBUF_SZ +
+					   XMITBUF_ALIGN_SZ);
+		if (pxmitbuf->pallocated_buf == NULL)
+			return _FAIL;
+		pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -
+				 ((addr_t) (pxmitbuf->pallocated_buf) &
+				 (XMITBUF_ALIGN_SZ - 1));
+		r8712_xmit_resource_alloc(padapter, pxmitbuf);
+		list_insert_tail(&pxmitbuf->list,
+				 &(pxmitpriv->free_xmitbuf_queue.queue));
+		pxmitbuf++;
+	}
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+	_init_workitem(&padapter->wkFilterRxFF0, r8712_SetFilter, padapter);
+	alloc_hwxmits(padapter);
+	init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+		(void(*)(unsigned long))r8712_xmit_bh,
+		(unsigned long)padapter);
+	return _SUCCESS;
+}
+
+void _free_xmit_priv(struct xmit_priv *pxmitpriv)
+{
+	int i;
+	struct _adapter *padapter = pxmitpriv->adapter;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)
+					pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+	if (pxmitpriv->pxmit_frame_buf == NULL)
+		return;
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		r8712_xmit_complete(padapter, pxmitframe);
+		pxmitframe++;
+	}
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		r8712_xmit_resource_free(padapter, pxmitbuf);
+		kfree(pxmitbuf->pallocated_buf);
+		pxmitbuf++;
+	}
+	kfree(pxmitpriv->pallocated_frame_buf);
+	kfree(pxmitpriv->pallocated_xmitbuf);
+	free_hwxmits(padapter);
+}
+
+sint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,
+		   struct pkt_attrib *pattrib)
+{
+	uint i;
+	struct pkt_file pktfile;
+	struct sta_info *psta = NULL;
+	struct ethhdr etherhdr;
+
+	struct tx_cmd txdesc;
+
+	sint bmcast;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+
+	_r8712_open_pktfile(pkt, &pktfile);
+
+	i = _r8712_pktfile_read(&pktfile, (unsigned char *)&etherhdr, ETH_HLEN);
+
+	pattrib->ether_type = ntohs(etherhdr.h_proto);
+
+{
+	u8 bool;
+	/*If driver xmit ARP packet, driver can set ps mode to initial
+	 * setting. It stands for getting DHCP or fix IP.*/
+	if (pattrib->ether_type == 0x0806) {
+		if (padapter->pwrctrlpriv.pwr_mode !=
+		    padapter->registrypriv.power_mgnt) {
+			_cancel_timer(&(pmlmepriv->dhcp_timer), &bool);
+			r8712_set_ps_mode(padapter, padapter->registrypriv.
+				power_mgnt, padapter->registrypriv.smart_ps);
+		}
+	}
+}
+	memcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);
+	memcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);
+	pattrib->pctrl = 0;
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		/*firstly, filter packet not belongs to mp*/
+		if (pattrib->ether_type != 0x8712)
+			return _FAIL;
+		/* for mp storing the txcmd per packet,
+		 * according to the info of txcmd to update pattrib */
+		/*get MP_TXDESC_SIZE bytes txcmd per packet*/
+		i = _r8712_pktfile_read(&pktfile, (u8 *)&txdesc, TXDESC_SIZE);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		pattrib->pctrl = 1;
+	}
+	/* r8712_xmitframe_coalesce() overwrite this!*/
+	pattrib->pktlen = pktfile.pkt_len;
+	if (ETH_P_IP == pattrib->ether_type) {
+		/* The following is for DHCP and ARP packet, we use cck1M to
+		 * tx these packets and let LPS awake some time
+		 * to prevent DHCP protocol fail */
+		u8 tmp[24];
+		_r8712_pktfile_read(&pktfile, &tmp[0], 24);
+		pattrib->dhcp_pkt = 0;
+		if (pktfile.pkt_len > 282) {/*MINIMUM_DHCP_PACKET_SIZE)*/
+			if (ETH_P_IP == pattrib->ether_type) {/* IP header*/
+				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
+					((tmp[21] == 67) && (tmp[23] == 68))) {
+					/* 68 : UDP BOOTP client
+					 * 67 : UDP BOOTP server
+					 * Use low rate to send DHCP packet.*/
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	}
+	bmcast = IS_MCAST(pattrib->ra);
+	/* get sta_info*/
+	if (bmcast) {
+		psta = r8712_get_bcmc_stainfo(padapter);
+		pattrib->mac_id = 4;
+	} else {
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+			psta = r8712_get_stainfo(pstapriv,
+						 get_bssid(pmlmepriv));
+			pattrib->mac_id = 5;
+		} else {
+			psta = r8712_get_stainfo(pstapriv, pattrib->ra);
+			if (psta == NULL)  /* drop the pkt */
+				return _FAIL;
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+				pattrib->mac_id = 5;
+			else
+				pattrib->mac_id = psta->mac_id;
+		}
+	}
+
+	if (psta) {
+		pattrib->psta = psta;
+	} else {
+		/* if we cannot get psta => drrp the pkt */
+		return _FAIL;
+	}
+
+	pattrib->ack_policy = 0;
+	/* get ether_hdr_len */
+	pattrib->pkt_hdrlen = ETH_HLEN;
+
+	if (pqospriv->qos_option)
+		r8712_set_qos(&pktfile, pattrib);
+	else {
+		pattrib->hdrlen = WLAN_HDR_A3_LEN;
+		pattrib->subtype = WIFI_DATA_TYPE;
+		pattrib->priority = 0;
+	}
+	if (psta->ieee8021x_blocked == true) {
+		pattrib->encrypt = 0;
+		if ((pattrib->ether_type != 0x888e) &&
+		    (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
+			return _FAIL;
+	} else
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+	switch (pattrib->encrypt) {
+	case _WEP40_:
+	case _WEP104_:
+		pattrib->iv_len = 4;
+		pattrib->icv_len = 4;
+		break;
+	case _TKIP_:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 4;
+		if (padapter->securitypriv.busetkipkey == _FAIL)
+			return _FAIL;
+		break;
+	case _AES_:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 8;
+		break;
+	default:
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+		break;
+	}
+
+	if (pattrib->encrypt &&
+	    ((padapter->securitypriv.sw_encrypt == true) ||
+	     (psecuritypriv->hw_decrypted == false)))
+		pattrib->bswenc = true;
+	else
+		pattrib->bswenc = false;
+	/* if in MP_STATE, update pkt_attrib from mp_txcmd, and overwrite
+	 * some settings above.*/
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		pattrib->priority = (txdesc.txdw1 >> QSEL_SHT) & 0x1f;
+	return _SUCCESS;
+}
+
+static sint xmitframe_addmic(struct _adapter *padapter,
+			     struct xmit_frame *pxmitframe)
+{
+	u32	curfragnum, length, datalen;
+	u8	*pframe, *payload, mic[8];
+	struct	mic_data micdata;
+	struct	sta_info *stainfo;
+	struct	qos_priv *pqospriv = &(padapter->mlmepriv.qospriv);
+	struct	pkt_attrib  *pattrib = &pxmitframe->attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta)
+		stainfo = pattrib->psta;
+	else
+		stainfo = r8712_get_stainfo(&padapter->stapriv,
+					    &pattrib->ra[0]);
+	if (pattrib->encrypt == _TKIP_) {
+		/*encode mic code*/
+		if (stainfo != NULL) {
+			u8 null_key[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+					   0x0, 0x0};
+			datalen = pattrib->pktlen - pattrib->hdrlen;
+			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
+			if (bmcst) {
+				if (!memcmp(psecuritypriv->XGrptxmickey
+				   [psecuritypriv->XGrpKeyid].skey,
+				   null_key, 16))
+					return _FAIL;
+				/*start to calculate the mic code*/
+				r8712_secmicsetkey(&micdata,
+					 psecuritypriv->
+					 XGrptxmickey[psecuritypriv->
+					XGrpKeyid].skey);
+			} else {
+				if (!memcmp(&stainfo->tkiptxmickey.skey[0],
+					    null_key, 16))
+					return _FAIL;
+				/* start to calculate the mic code */
+				r8712_secmicsetkey(&micdata,
+					     &stainfo->tkiptxmickey.skey[0]);
+			}
+			if (pframe[1] & 1) {   /* ToDS==1 */
+				r8712_secmicappend(&micdata,
+						   &pframe[16], 6); /*DA*/
+				if (pframe[1]&2)  /* From Ds==1 */
+					r8712_secmicappend(&micdata,
+							   &pframe[24], 6);
+				else
+					r8712_secmicappend(&micdata,
+							   &pframe[10], 6);
+			} else {	/* ToDS==0 */
+				r8712_secmicappend(&micdata,
+						   &pframe[4], 6); /* DA */
+				if (pframe[1]&2)  /* From Ds==1 */
+					r8712_secmicappend(&micdata,
+							   &pframe[16], 6);
+				else
+					r8712_secmicappend(&micdata,
+							   &pframe[10], 6);
+			}
+			if (pqospriv->qos_option == 1)
+					priority[0] = (u8)pxmitframe->
+						      attrib.priority;
+			r8712_secmicappend(&micdata, &priority[0], 4);
+			payload = pframe;
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				payload = (u8 *)RND4((addr_t)(payload));
+				payload = payload+pattrib->
+					  hdrlen+pattrib->iv_len;
+				if ((curfragnum + 1) == pattrib->nr_frags) {
+					length = pattrib->last_txcmdsz -
+						  pattrib->hdrlen -
+						  pattrib->iv_len -
+						  ((psecuritypriv->sw_encrypt)
+						  ? pattrib->icv_len : 0);
+					r8712_secmicappend(&micdata, payload,
+							   length);
+					payload = payload+length;
+				} else{
+					length = pxmitpriv->frag_len -
+					    pattrib->hdrlen-pattrib->iv_len -
+					    ((psecuritypriv->sw_encrypt) ?
+					    pattrib->icv_len : 0);
+					r8712_secmicappend(&micdata, payload,
+							   length);
+					payload = payload + length +
+						  pattrib->icv_len;
+				}
+			}
+			r8712_secgetmic(&micdata, &(mic[0]));
+			/* add mic code  and add the mic code length in
+			 * last_txcmdsz */
+			memcpy(payload, &(mic[0]), 8);
+			pattrib->last_txcmdsz += 8;
+			payload = payload-pattrib->last_txcmdsz + 8;
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint xmitframe_swencrypt(struct _adapter *padapter,
+				struct xmit_frame *pxmitframe)
+{
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+
+	if (pattrib->bswenc) {
+		switch (pattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			r8712_wep_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _TKIP_:
+			r8712_tkip_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _AES_:
+			r8712_aes_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		default:
+				break;
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint make_wlanhdr(struct _adapter *padapter , u8 *hdr,
+			 struct pkt_attrib *pattrib)
+{
+	u16 *qc;
+
+	struct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	u16 *fctrl = &pwlanhdr->frame_ctl;
+	memset(hdr, 0, WLANHDR_OFFSET);
+	SetFrameSubType(fctrl, pattrib->subtype);
+	if (pattrib->subtype & WIFI_DATA_TYPE) {
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
+			/* to_ds = 1, fr_ds = 0; */
+			SetToDs(fctrl);
+			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv),
+				ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+		} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)) {
+			/* to_ds = 0, fr_ds = 1; */
+			SetFrDs(fctrl);
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv),
+				ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+		} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+			   || (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
+			   == true)) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),
+				ETH_ALEN);
+		} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),
+				ETH_ALEN);
+		} else
+			return _FAIL;
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+		if (pqospriv->qos_option) {
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+			if (pattrib->priority)
+				SetPriority(qc, pattrib->priority);
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+		/* TODO: fill HT Control Field */
+		/* Update Seq Num will be handled by f/w */
+		{
+			struct sta_info *psta;
+
+			sint bmcst = IS_MCAST(pattrib->ra);
+			if (pattrib->psta)
+				psta = pattrib->psta;
+			else {
+				if (bmcst)
+					psta = r8712_get_bcmc_stainfo(padapter);
+				else
+					psta =
+					 r8712_get_stainfo(&padapter->stapriv,
+					 pattrib->ra);
+			}
+			if (psta) {
+				psta->sta_xmitpriv.txseq_tid
+						  [pattrib->priority]++;
+				psta->sta_xmitpriv.txseq_tid[pattrib->priority]
+						   &= 0xFFF;
+				pattrib->seqnum = psta->sta_xmitpriv.
+						  txseq_tid[pattrib->priority];
+				SetSeqNum(hdr, pattrib->seqnum);
+			}
+		}
+	}
+	return _SUCCESS;
+}
+
+static sint r8712_put_snap(u8 *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	const u8 *oui;
+
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+	return SNAP_SIZE + sizeof(u16);
+}
+
+/*
+ * This sub-routine will perform all the following:
+ * 1. remove 802.3 header.
+ * 2. create wlan_header, based on the info in pxmitframe
+ * 3. append sta's iv/ext-iv
+ * 4. append LLC
+ * 5. move frag chunk from pframe to pxmitframe->mem
+ * 6. apply sw-encrypt, if necessary.
+ */
+sint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,
+			struct xmit_frame *pxmitframe)
+{
+	struct pkt_file pktfile;
+
+	sint	frg_len, mpdu_len, llc_sz;
+	u32	mem_sz;
+	u8	frg_inx;
+	addr_t addr;
+	u8 *pframe, *mem_start, *ptxdesc;
+	struct sta_info		*psta;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	u8 *pbuf_start;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta == NULL)
+		return _FAIL;
+	psta = pattrib->psta;
+	if (pxmitframe->buf_addr == NULL)
+		return _FAIL;
+	pbuf_start = pxmitframe->buf_addr;
+	ptxdesc = pbuf_start;
+	mem_start = pbuf_start + TXDESC_OFFSET;
+	if (make_wlanhdr(padapter, mem_start, pattrib) == _FAIL)
+		return _FAIL;
+	_r8712_open_pktfile(pkt, &pktfile);
+	_r8712_pktfile_read(&pktfile, NULL, (uint) pattrib->pkt_hdrlen);
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		/* truncate TXDESC_SIZE bytes txcmd if at mp mode for 871x */
+		if (pattrib->ether_type == 0x8712) {
+			/* take care -  update_txdesc overwrite this */
+			_r8712_pktfile_read(&pktfile, ptxdesc, TXDESC_SIZE);
+		}
+	}
+	pattrib->pktlen = pktfile.pkt_len;
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;
+	while (1) {
+		llc_sz = 0;
+		mpdu_len = frg_len;
+		pframe = mem_start;
+		SetMFrag(mem_start);
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+		/* adding icv, if necessary...*/
+		if (pattrib->iv_len) {
+			if (psta != NULL) {
+				switch (pattrib->encrypt) {
+				case _WEP40_:
+				case _WEP104_:
+					WEP_IV(pattrib->iv, psta->txpn,
+					       (u8)psecuritypriv->
+					       PrivacyKeyIndex);
+					break;
+				case _TKIP_:
+					if (bmcst)
+						TKIP_IV(pattrib->iv,
+						    psta->txpn,
+						    (u8)psecuritypriv->
+						    XGrpKeyid);
+					else
+						TKIP_IV(pattrib->iv, psta->txpn,
+							0);
+					break;
+				case _AES_:
+					if (bmcst)
+						AES_IV(pattrib->iv, psta->txpn,
+						    (u8)psecuritypriv->
+						    XGrpKeyid);
+					else
+						AES_IV(pattrib->iv, psta->txpn,
+						       0);
+					break;
+				}
+			}
+			memcpy(pframe, pattrib->iv, pattrib->iv_len);
+			pframe += pattrib->iv_len;
+			mpdu_len -= pattrib->iv_len;
+		}
+		if (frg_inx == 0) {
+			llc_sz = r8712_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc))
+			mpdu_len -= pattrib->icv_len;
+		if (bmcst)
+			mem_sz = _r8712_pktfile_read(&pktfile, pframe,
+				 pattrib->pktlen);
+		else
+			mem_sz = _r8712_pktfile_read(&pktfile, pframe,
+				 mpdu_len);
+		pframe += mem_sz;
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
+			memcpy(pframe, pattrib->icv, pattrib->icv_len);
+			pframe += pattrib->icv_len;
+		}
+		frg_inx++;
+		if (bmcst || (r8712_endofpktfile(&pktfile) == true)) {
+			pattrib->nr_frags = frg_inx;
+			pattrib->last_txcmdsz = pattrib->hdrlen +
+						pattrib->iv_len +
+						((pattrib->nr_frags == 1) ?
+						llc_sz : 0) +
+						((pattrib->bswenc) ?
+						pattrib->icv_len : 0) + mem_sz;
+			ClearMFrag(mem_start);
+			break;
+		}
+		addr = (addr_t)(pframe);
+		mem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;
+		memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
+	}
+
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
+		return _FAIL;
+	xmitframe_swencrypt(padapter, pxmitframe);
+	return _SUCCESS;
+}
+
+void r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len)
+{
+	uint	protection;
+	u8	*perp;
+	sint	 erp_len;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	switch (pxmitpriv->vcs_setting) {
+	case DISABLE_VCS:
+		pxmitpriv->vcs = NONE_VCS;
+		break;
+	case ENABLE_VCS:
+		break;
+	case AUTO_VCS:
+	default:
+		perp = r8712_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+		if (perp == NULL)
+			pxmitpriv->vcs = NONE_VCS;
+		else {
+			protection = (*(perp + 2)) & BIT(1);
+			if (protection) {
+				if (pregistrypriv->vcs_type == RTS_CTS)
+					pxmitpriv->vcs = RTS_CTS;
+				else
+					pxmitpriv->vcs = CTS_TO_SELF;
+			} else
+				pxmitpriv->vcs = NONE_VCS;
+		}
+		break;
+	}
+}
+
+struct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	unsigned long irqL;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	if (_queue_empty(pfree_xmitbuf_queue) == true)
+		pxmitbuf = NULL;
+	else {
+		phead = get_list_head(pfree_xmitbuf_queue);
+		plist = get_next(phead);
+		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
+		list_delete(&(pxmitbuf->list));
+	}
+	if (pxmitbuf !=  NULL)
+		pxmitpriv->free_xmitbuf_cnt--;
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+	return pxmitbuf;
+}
+
+int r8712_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	unsigned long irqL;
+	struct  __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	if (pxmitbuf == NULL)
+		return _FAIL;
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	list_delete(&pxmitbuf->list);
+	list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+	pxmitpriv->free_xmitbuf_cnt++;
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+	return _SUCCESS;
+}
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+
+struct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv)
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect
+		pfree_xmit_queue
+	*/
+	unsigned long irqL;
+	struct xmit_frame *pxframe = NULL;
+	struct list_head *plist, *phead;
+	struct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+
+	spin_lock_irqsave(&pfree_xmit_queue->lock, irqL);
+	if (_queue_empty(pfree_xmit_queue) == true)
+		pxframe =  NULL;
+	else {
+		phead = get_list_head(pfree_xmit_queue);
+		plist = get_next(phead);
+		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+		list_delete(&(pxframe->list));
+	}
+	if (pxframe !=  NULL) {
+		pxmitpriv->free_xmitframe_cnt--;
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+		pxframe->attrib.psta = NULL;
+		pxframe->pkt = NULL;
+	}
+	spin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);
+	return pxframe;
+}
+
+void r8712_free_xmitframe(struct xmit_priv *pxmitpriv,
+			  struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL;
+	struct  __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+	struct _adapter *padapter = pxmitpriv->adapter;
+	struct sk_buff *pndis_pkt = NULL;
+
+	if (pxmitframe == NULL)
+		return;
+	spin_lock_irqsave(&pfree_xmit_queue->lock, irqL);
+	list_delete(&pxmitframe->list);
+	if (pxmitframe->pkt) {
+		pndis_pkt = pxmitframe->pkt;
+		pxmitframe->pkt = NULL;
+	}
+	list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
+	pxmitpriv->free_xmitframe_cnt++;
+	spin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);
+}
+
+void r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,
+		      struct xmit_frame *pxmitframe)
+{
+	if (pxmitframe == NULL)
+		return;
+	if (pxmitframe->frame_tag == DATA_FRAMETAG)
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+}
+
+void r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,
+				struct  __queue *pframequeue)
+{
+	unsigned long irqL;
+	struct list_head *plist, *phead;
+	struct	xmit_frame	*pxmitframe;
+
+	spin_lock_irqsave(&(pframequeue->lock), irqL);
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+	while (end_of_queue_search(phead, plist) == false) {
+		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
+		plist = get_next(plist);
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+	}
+	spin_unlock_irqrestore(&(pframequeue->lock), irqL);
+}
+
+static inline struct tx_servq *get_sta_pending(struct _adapter *padapter,
+					       struct  __queue **ppstapending,
+					       struct sta_info *psta, sint up)
+{
+
+	struct tx_servq *ptxservq;
+	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
+
+	switch (up) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		*ppstapending = &padapter->xmitpriv.bk_pending;
+		(phwxmits+3)->accnt++;
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		*ppstapending = &padapter->xmitpriv.vi_pending;
+		(phwxmits+1)->accnt++;
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		*ppstapending = &padapter->xmitpriv.vo_pending;
+		(phwxmits+0)->accnt++;
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+		*ppstapending = &padapter->xmitpriv.be_pending;
+		(phwxmits + 2)->accnt++;
+		break;
+	}
+	return ptxservq;
+}
+
+/*
+ * Will enqueue pxmitframe to the proper queue, and indicate it
+ * to xx_pending list.....
+ */
+sint r8712_xmit_classifier(struct _adapter *padapter,
+			   struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL0;
+	struct  __queue *pstapending;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	sint bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else {
+		if (bmcst)
+			psta = r8712_get_bcmc_stainfo(padapter);
+		else {
+			if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+				psta = r8712_get_stainfo(pstapriv,
+				       get_bssid(pmlmepriv));
+			else
+				psta = r8712_get_stainfo(pstapriv, pattrib->ra);
+		}
+	}
+	if (psta == NULL)
+		return _FAIL;
+	ptxservq = get_sta_pending(padapter, &pstapending,
+		   psta, pattrib->priority);
+	spin_lock_irqsave(&pstapending->lock, irqL0);
+	if (is_list_empty(&ptxservq->tx_pending))
+		list_insert_tail(&ptxservq->tx_pending,
+				 get_list_head(pstapending));
+	list_insert_tail(&pxmitframe->list,
+			 get_list_head(&ptxservq->sta_pending));
+	ptxservq->qcnt++;
+	spin_unlock_irqrestore(&pstapending->lock, irqL0);
+	return _SUCCESS;
+}
+
+static void alloc_hwxmits(struct _adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
+	pxmitpriv->hwxmits = (struct hw_xmit *)_malloc(sizeof(struct hw_xmit) *
+			     pxmitpriv->hwxmit_entry);
+	if (pxmitpriv->hwxmits == NULL)
+		return;
+	hwxmits = pxmitpriv->hwxmits;
+	if (pxmitpriv->hwxmit_entry == 5) {
+		pxmitpriv->bmc_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
+	pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
+	} else if (pxmitpriv->hwxmit_entry == 4) {
+		pxmitpriv->vo_txqueue.head = 0;
+		hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
+		pxmitpriv->vi_txqueue.head = 0;
+		hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
+		pxmitpriv->be_txqueue.head = 0;
+		hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
+		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
+		pxmitpriv->bk_txqueue.head = 0;
+		hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+	}
+}
+
+static void free_hwxmits(struct _adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	kfree(pxmitpriv->hwxmits);
+}
+
+static void init_hwxmits(struct hw_xmit *phwxmit, sint entry)
+{
+	sint i;
+
+	for (i = 0; i < entry; i++, phwxmit++) {
+		spin_lock_init(&phwxmit->xmit_lock);
+		_init_listhead(&phwxmit->pending);
+		phwxmit->txcmdcnt = 0;
+		phwxmit->accnt = 0;
+	}
+}
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,
+			struct xmit_buf *pxmitbuf)
+{
+	/* pxmitbuf attach to pxmitframe */
+	pxmitframe->pxmitbuf = pxmitbuf;
+	/* urb and irp connection */
+	pxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];
+	/* buffer addr assoc */
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+	/* pxmitframe attach to pxmitbuf */
+	pxmitbuf->priv_data = pxmitframe;
+}
+
+/*
+ * tx_action == 0 == no frames to transmit
+ * tx_action > 0 ==> we have frames to transmit
+ * tx_action < 0 ==> we have frames to transmit, but TXFF is not even enough
+ *						 to transmit 1 frame.
+ */
+
+int r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	unsigned long irqL;
+	int ret;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	r8712_do_queue_select(padapter, pattrib);
+	spin_lock_irqsave(&pxmitpriv->lock, irqL);
+	if (r8712_txframes_sta_ac_pending(padapter, pattrib) > 0) {
+		ret = false;
+		r8712_xmit_enqueue(padapter, pxmitframe);
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+		return ret;
+	}
+	pxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);
+	if (pxmitbuf == NULL) { /*enqueue packet*/
+		ret = false;
+		r8712_xmit_enqueue(padapter, pxmitframe);
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+	} else { /*dump packet directly*/
+		spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+		ret = true;
+		xmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);
+		r8712_xmit_direct(padapter, pxmitframe);
+	}
+	return ret;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_xmit.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_xmit.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/rtl871x_xmit.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/rtl871x_xmit.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _RTL871X_XMIT_H_
+#define _RTL871X_XMIT_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "xmit_osdep.h"
+
+#ifdef CONFIG_R8712_TX_AGGR
+#define MAX_XMITBUF_SZ  (16384)
+#else
+#define MAX_XMITBUF_SZ  (2048)
+#endif
+
+#define NR_XMITBUFF     (4)
+
+#ifdef CONFIG_R8712_TX_AGGR
+#define AGGR_NR_HIGH_BOUND      (4) /*(8) */
+#define AGGR_NR_LOW_BOUND       (2)
+#endif
+
+#define XMITBUF_ALIGN_SZ 512
+#define TX_GUARD_BAND		5
+#define MAX_NUMBLKS		(1)
+
+/* Fixed the Big Endian bug when using the software driver encryption.*/
+#define WEP_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC0;\
+	pattrib_iv[1] = txpn._byte_.TSC1;\
+	pattrib_iv[2] = txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	txpn.val = (txpn.val == 0xffffff) ? 0 : (txpn.val+1);\
+} while (0)
+
+/* Fixed the Big Endian bug when doing the Tx.
+ * The Linksys WRH54G will check this.*/
+#define TKIP_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC1;\
+	pattrib_iv[1] = (txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = txpn._byte_.TSC2;\
+	pattrib_iv[5] = txpn._byte_.TSC3;\
+	pattrib_iv[6] = txpn._byte_.TSC4;\
+	pattrib_iv[7] = txpn._byte_.TSC5;\
+	txpn.val = txpn.val == 0xffffffffffffULL ? 0 : \
+	(txpn.val+1);\
+} while (0)
+
+#define AES_IV(pattrib_iv, txpn, keyidx)\
+do { \
+	pattrib_iv[0] = txpn._byte_.TSC0;\
+	pattrib_iv[1] = txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = txpn._byte_.TSC2;\
+	pattrib_iv[5] = txpn._byte_.TSC3;\
+	pattrib_iv[6] = txpn._byte_.TSC4;\
+	pattrib_iv[7] = txpn._byte_.TSC5;\
+	txpn.val = txpn.val == 0xffffffffffffULL ? 0 : \
+	(txpn.val+1);\
+} while (0)
+
+struct hw_xmit {
+	spinlock_t xmit_lock;
+	struct list_head pending;
+	struct  __queue *sta_queue;
+	struct hw_txqueue *phwtxqueue;
+	sint	txcmdcnt;
+	int	accnt;
+};
+
+struct pkt_attrib {
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+
+	u16	seqnum;
+	u16	ether_type;
+	u16	pktlen;		/* the original 802.3 pkt raw_data len
+				 * (not include ether_hdr data) */
+	u16	last_txcmdsz;
+
+	u8	pkt_hdrlen;	/*the original 802.3 pkt header len*/
+	u8	hdrlen;		/*the WLAN Header Len*/
+	u8	nr_frags;
+	u8	ack_policy;
+	u8	mac_id;
+	u8	vcs_mode;	/*virtual carrier sense method*/
+	u8	pctrl;/*per packet txdesc control enable*/
+	u8	qsel;
+
+	u8	priority;
+	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero,
+				 * indicate the encrypt algorith*/
+	u8	iv_len;
+	u8	icv_len;
+	unsigned char iv[8];
+	unsigned char icv[8];
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	struct sta_info *psta;
+};
+
+#define WLANHDR_OFFSET	64
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+#define MP_FRAMETAG		0x07
+#define TXAGG_FRAMETAG	0x08
+
+struct xmit_buf {
+	struct list_head list;
+
+	u8 *pallocated_buf;
+	u8 *pbuf;
+	void *priv_data;
+	struct urb *pxmit_urb[8];
+	u32 aggr_nr;
+};
+
+struct xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	_pkt *pkt;
+	int frame_tag;
+	struct _adapter *padapter;
+	 u8 *buf_addr;
+	 struct xmit_buf *pxmitbuf;
+	u8 *mem_addr;
+	u16 sz[8];
+	struct urb *pxmit_urb[8];
+	u8 bpending[8];
+	u8 last[8];
+};
+
+struct tx_servq {
+	struct list_head tx_pending;
+	struct  __queue	sta_pending;
+	int qcnt;
+};
+
+struct sta_xmit_priv {
+	spinlock_t lock;
+	sint	option;
+	sint	apsd_setting;	/* When bit mask is on, the associated edca
+				 * queue supports APSD.*/
+	struct tx_servq	be_q;	/* priority == 0,3 */
+	struct tx_servq	bk_q;	/* priority == 1,2*/
+	struct tx_servq	vi_q;	/*priority == 4,5*/
+	struct tx_servq	vo_q;	/*priority == 6,7*/
+	struct list_head  legacy_dz;
+	struct list_head apsd;
+	u16 txseq_tid[16];
+	uint	sta_tx_bytes;
+	u64	sta_tx_pkts;
+	uint	sta_tx_fail;
+};
+
+struct	hw_txqueue {
+	/*volatile*/ sint	head;
+	/*volatile*/ sint	tail;
+	/*volatile*/ sint	free_sz;	/*in units of 64 bytes*/
+	/*volatile*/ sint      free_cmdsz;
+	/*volatile*/ sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+struct	xmit_priv {
+	spinlock_t lock;
+	struct semaphore xmit_sema;
+	struct semaphore terminate_xmitthread_sema;
+	struct  __queue	be_pending;
+	struct  __queue	bk_pending;
+	struct  __queue	vi_pending;
+	struct  __queue	vo_pending;
+	struct  __queue	bm_pending;
+	struct  __queue	legacy_dz_queue;
+	struct  __queue	apsd_queue;
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+	uint mapping_addr;
+	uint pkt_sz;
+	struct  __queue	free_xmit_queue;
+	struct	hw_txqueue	be_txqueue;
+	struct	hw_txqueue	bk_txqueue;
+	struct	hw_txqueue	vi_txqueue;
+	struct	hw_txqueue	vo_txqueue;
+	struct	hw_txqueue	bmc_txqueue;
+	uint	frag_len;
+	struct _adapter	*adapter;
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	u16  rts_thresh;
+	uint	tx_bytes;
+	u64	tx_pkts;
+	uint	tx_drop;
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+	struct semaphore tx_retevt;/*all tx return event;*/
+	u8	txirp_cnt;
+	struct tasklet_struct xmit_tasklet;
+	_workitem xmit_pipe4_reset_wi;
+	_workitem xmit_pipe6_reset_wi;
+	_workitem xmit_piped_reset_wi;
+	/*per AC pending irp*/
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+	struct  __queue	free_amsdu_xmit_queue;
+	u8 *pallocated_amsdu_frame_buf;
+	u8 *pxmit_amsdu_frame_buf;
+	uint free_amsdu_xmitframe_cnt;
+	struct  __queue free_txagg_xmit_queue;
+	u8 *pallocated_txagg_frame_buf;
+	u8 *pxmit_txagg_frame_buf;
+	uint free_txagg_xmitframe_cnt;
+	int cmdseq;
+	struct  __queue free_xmitbuf_queue;
+	struct  __queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;
+};
+
+static inline struct  __queue *get_free_xmit_queue(
+				struct xmit_priv *pxmitpriv)
+{
+	return &(pxmitpriv->free_xmit_queue);
+}
+
+int r8712_free_xmitbuf(struct xmit_priv *pxmitpriv,
+		       struct xmit_buf *pxmitbuf);
+struct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+void r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len);
+struct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+void r8712_free_xmitframe(struct xmit_priv *pxmitpriv,
+			  struct xmit_frame *pxmitframe);
+void r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,
+				struct  __queue *pframequeue);
+sint r8712_xmit_classifier(struct _adapter *padapter,
+			    struct xmit_frame *pxmitframe);
+sint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,
+			      struct xmit_frame *pxmitframe);
+sint _r8712_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag);
+void _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+sint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,
+			 struct pkt_attrib *pattrib);
+int r8712_txframes_sta_ac_pending(struct _adapter *padapter,
+				  struct pkt_attrib *pattrib);
+sint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,
+			   struct _adapter *padapter);
+void _free_xmit_priv(struct xmit_priv *pxmitpriv);
+void r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,
+			     struct xmit_frame *pxmitframe);
+int r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe);
+int r8712_xmit_enqueue(struct _adapter *padapter,
+		       struct xmit_frame *pxmitframe);
+int r8712_xmit_direct(struct _adapter *padapter, struct xmit_frame *pxmitframe);
+void r8712_xmit_bh(void *priv);
+
+void xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,
+			struct xmit_buf *pxmitbuf);
+
+#include "rtl8712_xmit.h"
+
+#endif	/*_RTL871X_XMIT_H_*/
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/sta_info.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/sta_info.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/sta_info.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/sta_info.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "wifi.h"
+
+#define NUM_STA 32
+#define NUM_ACL 64
+
+
+/* if mode ==0, then the sta is allowed once the addr is hit.
+ * if mode ==1, then the sta is rejected once the addr is non-hit.
+ */
+struct wlan_acl_node {
+	struct list_head list;
+	u8       addr[ETH_ALEN];
+	u8       mode;
+};
+
+struct wlan_acl_pool {
+	struct wlan_acl_node aclnode[NUM_ACL];
+};
+
+struct	stainfo_stats {
+
+	uint	rx_pkts;
+	uint	rx_bytes;
+	u64	tx_pkts;
+	uint	tx_bytes;
+};
+
+struct sta_info {
+	spinlock_t lock;
+	struct list_head list; /*free_sta_queue*/
+	struct list_head hash_list; /*sta_hash*/
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+	uint state;
+	uint aid;
+	uint	mac_id;
+	uint	qos_option;
+	u8	hwaddr[ETH_ALEN];
+	uint	ieee8021x_blocked;	/*0: allowed, 1:blocked */
+	uint	XPrivacy; /*aes, tkip...*/
+	union Keytype	tkiptxmickey;
+	union Keytype	tkiprxmickey;
+	union Keytype	x_UncstKey;
+	union pn48		txpn;	/* PN48 used for Unicast xmit.*/
+	union pn48		rxpn;	/* PN48 used for Unicast recv.*/
+	u8	bssrateset[16];
+	uint	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+	struct stainfo_stats sta_stats;
+	/*for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+	struct ht_priv	htpriv;
+	/* Notes:
+	 * STA_Mode:
+	 * curr_network(mlme_priv/security_priv/qos/ht)
+	 *   + sta_info: (STA & AP) CAP/INFO
+	 * scan_q: AP CAP/INFO
+	 * AP_Mode:
+	 * curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	 * sta_info: (AP & STA) CAP/INFO
+	 */
+#ifdef CONFIG_R8712_AP
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+	unsigned int tx_ra_bitmap;
+#endif
+};
+
+struct	sta_priv {
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	struct  __queue	free_sta_queue;
+	spinlock_t sta_hash_lock;
+	struct list_head sta_hash[NUM_STA];
+	int asoc_sta_count;
+	struct  __queue sleep_q;
+	struct  __queue wakeup_q;
+	struct _adapter *padapter;
+#ifdef CONFIG_R8712_AP
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	unsigned int auth_to;  /* sec, time to expire in authenticating. */
+	unsigned int assoc_to; /* sec, time to expire before associating. */
+	unsigned int expire_to; /* sec , time to expire after associated. */
+#endif
+};
+
+static inline u32 wifi_mac_hash(u8 *mac)
+{
+	u32 x;
+
+	x = mac[0];
+	x = (x << 2) ^ mac[1];
+	x = (x << 2) ^ mac[2];
+	x = (x << 2) ^ mac[3];
+	x = (x << 2) ^ mac[4];
+	x = (x << 2) ^ mac[5];
+	x ^= x >> 8;
+	x  = x & (NUM_STA - 1);
+	return x;
+}
+
+u32 _r8712_init_sta_priv(struct sta_priv *pstapriv);
+u32 _r8712_free_sta_priv(struct sta_priv *pstapriv);
+struct sta_info *r8712_alloc_stainfo(struct sta_priv *pstapriv,
+				     u8 *hwaddr);
+void r8712_free_stainfo(struct _adapter *padapter , struct sta_info *psta);
+void r8712_free_all_stainfo(struct _adapter *padapter);
+struct sta_info *r8712_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+void r8712_init_bcmc_stainfo(struct _adapter *padapter);
+struct sta_info *r8712_get_bcmc_stainfo(struct _adapter *padapter);
+u8 r8712_access_ctrl(struct wlan_acl_pool *pacl_list, u8 * mac_addr);
+
+#endif /* _STA_INFO_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/swab.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/swab.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/swab.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/swab.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,131 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _LINUX_BYTEORDER_SWAB_H
+#define _LINUX_BYTEORDER_SWAB_H
+
+#ifndef __u16
+ #define __u16 unsigned short
+#endif
+
+#ifndef __u32
+ #define __u32 unsigned int
+#endif
+
+#ifndef __u8
+ #define __u8 unsigned char
+#endif
+
+#ifndef __u64
+ #define __u64 unsigned long long
+#endif
+
+
+static inline __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x;
+	return (__u16)(
+		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
+		(((__u16)(__x) & (__u16)0xff00U) >> 8));
+
+}
+
+static inline __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return (__u32)(
+		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24));
+}
+
+static inline __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+
+	return (__u64)( \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56));
+}
+
+#ifndef __arch__swab16
+static inline __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+static inline __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ;
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+static inline __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ;
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+
+static inline const __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+static inline const __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+
+#define swab16 __swab16
+#define swab32 __swab32
+#define swab64 __swab64
+#define swab16p __swab16p
+#define swab32p __swab32p
+#define swab64p __swab64p
+#define swab16s __swab16s
+#define swab32s __swab32s
+#define swab64s __swab64s
+
+#endif /* _LINUX_BYTEORDER_SWAB_H */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/TODO ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/TODO
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/TODO	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/TODO	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,13 @@
+TODO:
+- merge Realtek's bugfixes and new features into the driver
+- switch to use LIB80211
+- switch to use MAC80211
+- checkpatch.pl fixes - only a few remain
+
+Please send any patches to Greg Kroah-Hartman <greg@kroah.com>,
+Larry Finger <Larry.Finger@lwfinger.net> and
+Florian Schilhabel <florian.c.schilhabel@googlemail.com>.
+
+
+
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_halinit.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_halinit.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_halinit.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_halinit.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,317 @@
+/******************************************************************************
+ * usb_halinit.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_HAL_INIT_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "usb_ops.h"
+#include "usb_osintf.h"
+
+u8 r8712_usb_hal_bus_init(struct _adapter *padapter)
+{
+	u8 val8 = 0;
+	u8 ret = _SUCCESS;
+	int PollingCnt = 20;
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	if (pregistrypriv->chip_version == RTL8712_FPGA) {
+		val8 = 0x01;
+		/* switch to 80M clock */
+		r8712_write8(padapter, SYS_CLKR, val8);
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		val8 = val8 | 0x01;
+		/* enable VSPS12 LDO Macro block */
+		r8712_write8(padapter, SPS1_CTRL, val8);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		val8 = val8 | 0x01;
+		/* Enable AFE Macro Block's Bandgap */
+		r8712_write8(padapter, AFE_MISC, val8);
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		val8 = val8 | 0x01;
+		/* enable LDOA15 block */
+		r8712_write8(padapter, LDOA15_CTRL, val8);
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		val8 = val8 | 0x02;
+		/* Enable VSPS12_SW Macro Block */
+		r8712_write8(padapter, SPS1_CTRL, val8);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		val8 = val8 | 0x02;
+		/* Enable AFE Macro Block's Mbias */
+		r8712_write8(padapter, AFE_MISC, val8);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		val8 = val8 | 0x08;
+		/* isolate PCIe Analog 1.2V to PCIe 3.3V and PCIE Digital */
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		val8 = val8 & 0xEF;
+		/* attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		val8 = val8 & 0xFB;
+		/* enable AFE clock */
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, val8);
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		val8 = val8 | 0x01;
+		/* Enable AFE PLL Macro Block */
+		r8712_write8(padapter, AFE_PLL_CTRL, val8);
+		val8 = 0xEE;
+		/* release isolation AFE PLL & MD */
+		r8712_write8(padapter, SYS_ISO_CTRL, val8);
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		val8 = val8 | 0x08;
+		/* enable MAC clock */
+		r8712_write8(padapter, SYS_CLKR + 1, val8);
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		val8 = val8 | 0x08;
+		/* enable Core digital and enable IOREG R/W */
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		val8 = val8 | 0x80;
+		/* enable REG_EN */
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		val8 = (val8 | 0x80) & 0xBF;
+		/* switch the control path */
+		r8712_write8(padapter, SYS_CLKR + 1, val8);
+		val8 = 0xFC;
+		r8712_write8(padapter, CR, val8);
+		val8 = 0x37;
+		r8712_write8(padapter, CR + 1, val8);
+		/* reduce EndPoint & init it */
+		r8712_write8(padapter, 0x102500ab, r8712_read8(padapter,
+			     0x102500ab) | BIT(6) | BIT(7));
+		/* consideration of power consumption - init */
+		r8712_write8(padapter, 0x10250008, r8712_read8(padapter,
+			     0x10250008) & 0xfffffffb);
+	} else if (pregistrypriv->chip_version == RTL8712_1stCUT) {
+		/* Initialization for power on sequence, */
+		r8712_write8(padapter, SPS0_CTRL + 1, 0x53);
+		r8712_write8(padapter, SPS0_CTRL, 0x57);
+		/* Enable AFE Macro Block's Bandgap and Enable AFE Macro
+		 * Block's Mbias
+		 */
+		val8 = r8712_read8(padapter, AFE_MISC);
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN |
+			     AFE_MISC_MBEN));
+		/* Enable LDOA15 block */
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		r8712_write8(padapter, LDOA15_CTRL, (val8 | LDA15_EN));
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		r8712_write8(padapter, SPS1_CTRL, (val8 | SPS1_LDEN));
+		msleep(20);
+		/* Enable Switch Regulator Block */
+		val8 = r8712_read8(padapter, SPS1_CTRL);
+		r8712_write8(padapter, SPS1_CTRL, (val8 | SPS1_SWEN));
+		r8712_write32(padapter, SPS1_CTRL, 0x00a7b267);
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 | 0x08));
+		/* Engineer Packet CP test Enable */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x20));
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 & 0x6F));
+		/* Enable AFE clock */
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, (val8 & 0xfb));
+		/* Enable AFE PLL Macro Block */
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		/* Attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL);
+		r8712_write8(padapter, SYS_ISO_CTRL, (val8 & 0xEE));
+		/* Switch to 40M clock */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8 & (~SYS_CLKSEL));
+		/* SSC Disable */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		/* Enable MAC clock */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x18));
+		/* Revised POS, */
+		r8712_write8(padapter, PMC_FSM, 0x02);
+		/* Enable Core digital and enable IOREG R/W */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x08));
+		/* Enable REG_EN */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x80));
+		/* Switch the control path to FW */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x80) & 0xBF);
+		r8712_write8(padapter, CR, 0xFC);
+		r8712_write8(padapter, CR + 1, 0x37);
+		/* Fix the RX FIFO issue(usb error), */
+		val8 = r8712_read8(padapter, 0x1025FE5c);
+		r8712_write8(padapter, 0x1025FE5c, (val8|BIT(7)));
+		val8 = r8712_read8(padapter, 0x102500ab);
+		r8712_write8(padapter, 0x102500ab, (val8|BIT(6)|BIT(7)));
+		/* For power save, used this in the bit file after 970621 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8&(~CPU_CLKSEL));
+	} else if (pregistrypriv->chip_version == RTL8712_2ndCUT ||
+		  pregistrypriv->chip_version == RTL8712_3rdCUT) {
+		/* Initialization for power on sequence,
+		 * E-Fuse leakage prevention sequence
+		 */
+		r8712_write8(padapter, 0x37, 0xb0);
+		msleep(20);
+		r8712_write8(padapter, 0x37, 0x30);
+		/* Set control path switch to HW control and reset Digital Core,
+		 * CPU Core and MAC I/O to solve FW download fail when system
+		 * from resume sate.
+		 */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		if (val8 & 0x80) {
+			val8 &= 0x3f;
+			r8712_write8(padapter, SYS_CLKR + 1, val8);
+		}
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		val8 &= 0x73;
+		r8712_write8(padapter, SYS_FUNC_EN + 1, val8);
+		msleep(20);
+		/* Revised POS, */
+		/* Enable AFE Macro Block's Bandgap and Enable AFE Macro
+		 * Block's Mbias */
+		r8712_write8(padapter, SPS0_CTRL + 1, 0x53);
+		r8712_write8(padapter, SPS0_CTRL, 0x57);
+		val8 = r8712_read8(padapter, AFE_MISC);
+		/*Bandgap*/
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN));
+		r8712_write8(padapter, AFE_MISC, (val8 | AFE_MISC_BGEN |
+			     AFE_MISC_MBEN | AFE_MISC_I32_EN));
+		/* Enable PLL Power (LDOA15V) */
+		val8 = r8712_read8(padapter, LDOA15_CTRL);
+		r8712_write8(padapter, LDOA15_CTRL, (val8 | LDA15_EN));
+		/* Enable LDOV12D block */
+		val8 = r8712_read8(padapter, LDOV12D_CTRL);
+		r8712_write8(padapter, LDOV12D_CTRL, (val8 | LDV12_EN));
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 | 0x08));
+		/* Engineer Packet CP test Enable */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x20));
+		/* Support 64k IMEM */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL + 1);
+		r8712_write8(padapter, SYS_ISO_CTRL + 1, (val8 & 0x68));
+		/* Enable AFE clock */
+		val8 = r8712_read8(padapter, AFE_XTAL_CTRL + 1);
+		r8712_write8(padapter, AFE_XTAL_CTRL + 1, (val8 & 0xfb));
+		/* Enable AFE PLL Macro Block */
+		val8 = r8712_read8(padapter, AFE_PLL_CTRL);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		/* Some sample will download fw failure. The clock will be
+		 * stable with 500 us delay after reset the PLL
+		 * TODO: When usleep is added to kernel, change next 3
+		 * udelay(500) to usleep(500)
+		 */
+		udelay(500);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x51));
+		udelay(500);
+		r8712_write8(padapter, AFE_PLL_CTRL, (val8 | 0x11));
+		udelay(500);
+		/* Attatch AFE PLL to MACTOP/BB/PCIe Digital */
+		val8 = r8712_read8(padapter, SYS_ISO_CTRL);
+		r8712_write8(padapter, SYS_ISO_CTRL, (val8 & 0xEE));
+		/* Switch to 40M clock */
+		r8712_write8(padapter, SYS_CLKR, 0x00);
+		/* CPU Clock and 80M Clock SSC Disable to overcome FW download
+		 * fail timing issue.
+		 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, (val8 | 0xa0));
+		/* Enable MAC clock */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x18));
+		/* Revised POS, */
+		r8712_write8(padapter, PMC_FSM, 0x02);
+		/* Enable Core digital and enable IOREG R/W */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x08));
+		/* Enable REG_EN */
+		val8 = r8712_read8(padapter, SYS_FUNC_EN + 1);
+		r8712_write8(padapter, SYS_FUNC_EN + 1, (val8 | 0x80));
+		/* Switch the control path to FW */
+		val8 = r8712_read8(padapter, SYS_CLKR + 1);
+		r8712_write8(padapter, SYS_CLKR + 1, (val8 | 0x80) & 0xBF);
+		r8712_write8(padapter, CR, 0xFC);
+		r8712_write8(padapter, CR + 1, 0x37);
+		/* Fix the RX FIFO issue(usb error), 970410 */
+		val8 = r8712_read8(padapter, 0x1025FE5c);
+		r8712_write8(padapter, 0x1025FE5c, (val8 | BIT(7)));
+		/* For power save, used this in the bit file after 970621 */
+		val8 = r8712_read8(padapter, SYS_CLKR);
+		r8712_write8(padapter, SYS_CLKR, val8 & (~CPU_CLKSEL));
+		/* Revised for 8051 ROM code wrong operation. */
+		r8712_write8(padapter, 0x1025fe1c, 0x80);
+		/* To make sure that TxDMA can ready to download FW.
+		 * We should reset TxDMA if IMEM RPT was not ready.
+		 */
+		do {
+			val8 = r8712_read8(padapter, TCR);
+			if ((val8 & _TXDMA_INIT_VALUE) == _TXDMA_INIT_VALUE)
+				break;
+			udelay(5); /* PlatformStallExecution(5); */
+		} while (PollingCnt--);	/* Delay 1ms */
+
+		if (PollingCnt <= 0) {
+			val8 = r8712_read8(padapter, CR);
+			r8712_write8(padapter, CR, val8&(~_TXDMA_EN));
+			udelay(2); /* PlatformStallExecution(2); */
+			/* Reset TxDMA */
+			r8712_write8(padapter, CR, val8|_TXDMA_EN);
+		}
+	} else
+		ret = _FAIL;
+	return ret;
+}
+
+unsigned int r8712_usb_inirp_init(struct _adapter *padapter)
+{
+	u8 i;
+	struct recv_buf *precvbuf;
+	struct intf_hdl *pintfhdl = &padapter->pio_queue->intf;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	precvpriv->ff_hwaddr = RTL8712_DMA_RX0FF; /* mapping rx fifo address */
+	/* issue Rx irp to receive data */
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		if (r8712_usb_read_port(pintfhdl, precvpriv->ff_hwaddr, 0,
+		   (unsigned char *)precvbuf) == false)
+			return _FAIL;
+		precvbuf++;
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+	return _SUCCESS;
+}
+
+unsigned int r8712_usb_inirp_deinit(struct _adapter *padapter)
+{
+	r8712_usb_read_port_cancel(padapter);
+	return _SUCCESS;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_intf.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_intf.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_intf.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_intf.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,668 @@
+/******************************************************************************
+ * usb_intf.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_INTF_C_
+
+#include <linux/usb.h>
+#include <linux/module.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "recv_osdep.h"
+#include "xmit_osdep.h"
+#include "rtl8712_efuse.h"
+#include "usb_vendor_req.h"
+#include "usb_ops.h"
+#include "usb_osintf.h"
+
+#define DRVER  "v7_0.20100831"
+
+extern int hex_to_bin(char ch);
+
+static struct usb_interface *pintf;
+
+static int r871xu_drv_init(struct usb_interface *pusb_intf,
+			   const struct usb_device_id *pdid);
+
+static void r871xu_dev_remove(struct usb_interface *pusb_intf);
+
+static struct usb_device_id rtl871x_usb_id_tbl[] = {
+
+/* RTL8188SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8171)},
+	{USB_DEVICE(0x0bda, 0x8173)},
+	{USB_DEVICE(0x0bda, 0x8712)},
+	{USB_DEVICE(0x0bda, 0x8713)},
+	{USB_DEVICE(0x0bda, 0xC512)},
+	/* Abocom */
+	{USB_DEVICE(0x07B8, 0x8188)},
+	/* ASUS */
+	{USB_DEVICE(0x0B05, 0x1786)},
+	{USB_DEVICE(0x0B05, 0x1791)}, /* 11n mode disable */
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x945A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0047)},
+	/* D-Link */
+	{USB_DEVICE(0x2001, 0x3306)},
+	{USB_DEVICE(0x07D1, 0x3306)}, /* 11n mode disable */
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7611)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9603)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0016)},
+	/* Hercules */
+	{USB_DEVICE(0x06F8, 0xE034)},
+	{USB_DEVICE(0x06F8, 0xE032)},
+	/* Logitec */
+	{USB_DEVICE(0x0789, 0x0167)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xAB28)},
+	{USB_DEVICE(0x2019, 0xED16)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0057)},
+	{USB_DEVICE(0x0DF6, 0x0045)},
+	{USB_DEVICE(0x0DF6, 0x0059)}, /* 11n mode disable */
+	{USB_DEVICE(0x0DF6, 0x004B)},
+	{USB_DEVICE(0x0DF6, 0x005B)},
+	{USB_DEVICE(0x0DF6, 0x005D)},
+	{USB_DEVICE(0x0DF6, 0x0063)},
+	/* Sweex */
+	{USB_DEVICE(0x177F, 0x0154)},
+	/* Thinkware */
+	{USB_DEVICE(0x0BDA, 0x5077)},
+	/* Toshiba */
+	{USB_DEVICE(0x1690, 0x0752)},
+	/* - */
+	{USB_DEVICE(0x20F4, 0x646B)},
+	{USB_DEVICE(0x083A, 0xC512)},
+
+/* RTL8191SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	/* Amigo */
+	{USB_DEVICE(0x0EB0, 0x9061)},
+	/* ASUS/EKB */
+	{USB_DEVICE(0x0BDA, 0x8172)},
+	{USB_DEVICE(0x13D3, 0x3323)},
+	{USB_DEVICE(0x13D3, 0x3311)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3342)},
+	/* ASUS/EKBLenovo */
+	{USB_DEVICE(0x13D3, 0x3333)},
+	{USB_DEVICE(0x13D3, 0x3334)},
+	{USB_DEVICE(0x13D3, 0x3335)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3336)}, /* 11n mode disable */
+	/* ASUS/Media BOX */
+	{USB_DEVICE(0x13D3, 0x3309)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x815F)},
+	/* D-Link */
+	{USB_DEVICE(0x07D1, 0x3302)},
+	{USB_DEVICE(0x07D1, 0x3300)},
+	{USB_DEVICE(0x07D1, 0x3303)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7612)},
+	/* EnGenius */
+	{USB_DEVICE(0x1740, 0x9605)},
+	/* Guillemot */
+	{USB_DEVICE(0x06F8, 0xE031)},
+	/* Hawking */
+	{USB_DEVICE(0x0E66, 0x0015)},
+	/* Mediao */
+	{USB_DEVICE(0x13D3, 0x3306)},
+	/* PCI */
+	{USB_DEVICE(0x2019, 0xED18)},
+	{USB_DEVICE(0x2019, 0x4901)},
+	/* Sitecom */
+	{USB_DEVICE(0x0DF6, 0x0058)},
+	{USB_DEVICE(0x0DF6, 0x0049)},
+	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x0064)},
+	/* Skyworth */
+	{USB_DEVICE(0x14b2, 0x3300)},
+	{USB_DEVICE(0x14b2, 0x3301)},
+	{USB_DEVICE(0x14B2, 0x3302)},
+	/* - */
+	{USB_DEVICE(0x04F2, 0xAFF2)},
+	{USB_DEVICE(0x04F2, 0xAFF5)},
+	{USB_DEVICE(0x04F2, 0xAFF6)},
+	{USB_DEVICE(0x13D3, 0x3339)},
+	{USB_DEVICE(0x13D3, 0x3340)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3341)}, /* 11n mode disable */
+	{USB_DEVICE(0x13D3, 0x3310)},
+	{USB_DEVICE(0x13D3, 0x3325)},
+
+/* RTL8192SU */
+	/* Realtek */
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	{USB_DEVICE(0x0BDA, 0x8174)},
+	/* Belkin */
+	{USB_DEVICE(0x050D, 0x845A)},
+	/* Corega */
+	{USB_DEVICE(0x07AA, 0x0051)},
+	/* Edimax */
+	{USB_DEVICE(0x7392, 0x7622)},
+	/* NEC */
+	{USB_DEVICE(0x0409, 0x02B6)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, rtl871x_usb_id_tbl);
+
+static struct specific_device_id specific_device_id_tbl[] = {
+	{.idVendor = 0x0b05, .idProduct = 0x1791,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x0df6, .idProduct = 0x0059,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3306,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13D3, .idProduct = 0x3311,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3335,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3336,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3340,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor = 0x13d3, .idProduct = 0x3341,
+		 .flags = SPEC_DEV_ID_DISABLE_HT},
+	{}
+};
+
+struct drv_priv {
+	struct usb_driver r871xu_drv;
+	int drv_registered;
+};
+
+#ifdef CONFIG_PM
+static int r871x_suspend(struct usb_interface *pusb_intf, pm_message_t state)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+
+	printk(KERN_INFO "r8712: suspending...\n");
+	if (!pnetdev || !netif_running(pnetdev)) {
+		printk(KERN_INFO "r8712: unable to suspend\n");
+		return 0;
+	}
+	if (pnetdev->netdev_ops->ndo_stop)
+		pnetdev->netdev_ops->ndo_stop(pnetdev);
+	mdelay(10);
+	netif_device_detach(pnetdev);
+	return 0;
+}
+
+static int r871x_resume(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+
+	printk(KERN_INFO "r8712: resuming...\n");
+	if (!pnetdev || !netif_running(pnetdev)) {
+		printk(KERN_INFO "r8712: unable to resume\n");
+		return 0;
+	}
+	netif_device_attach(pnetdev);
+	if (pnetdev->netdev_ops->ndo_open)
+		pnetdev->netdev_ops->ndo_open(pnetdev);
+	return 0;
+}
+
+static int r871x_reset_resume(struct usb_interface *pusb_intf)
+{
+	/* dummy routine */
+	return 0;
+}
+
+#endif
+
+static struct drv_priv drvpriv = {
+	.r871xu_drv.name = "r8712u",
+	.r871xu_drv.id_table = rtl871x_usb_id_tbl,
+	.r871xu_drv.probe = r871xu_drv_init,
+	.r871xu_drv.disconnect = r871xu_dev_remove,
+#ifdef CONFIG_PM
+	.r871xu_drv.suspend = r871x_suspend,
+	.r871xu_drv.resume = r871x_resume,
+	.r871xu_drv.reset_resume = r871x_reset_resume,
+#endif
+};
+
+static uint r8712_usb_dvobj_init(struct _adapter *padapter)
+{
+	uint	status = _SUCCESS;
+	struct	usb_device_descriptor		*pdev_desc;
+	struct	usb_host_config			*phost_conf;
+	struct	usb_config_descriptor		*pconf_desc;
+	struct	usb_host_interface		*phost_iface;
+	struct	usb_interface_descriptor	*piface_desc;
+	struct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;
+	struct usb_device *pusbd = pdvobjpriv->pusbdev;
+
+	pdvobjpriv->padapter = padapter;
+	padapter->EepromAddressSize = 6;
+	pdev_desc = &pusbd->descriptor;
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+	phost_iface = &pintf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+	pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
+	if (pusbd->speed == USB_SPEED_HIGH) {
+		pdvobjpriv->ishighspeed = true;
+		printk(KERN_INFO "r8712u: USB_SPEED_HIGH with %d endpoints\n",
+		       pdvobjpriv->nr_endpoint);
+	} else {
+		pdvobjpriv->ishighspeed = false;
+		printk(KERN_INFO "r8712u: USB_SPEED_LOW with %d endpoints\n",
+		       pdvobjpriv->nr_endpoint);
+	}
+	if ((r8712_alloc_io_queue(padapter)) == _FAIL)
+		status = _FAIL;
+	sema_init(&(padapter->dvobjpriv.usb_suspend_sema), 0);
+	return status;
+}
+
+static void r8712_usb_dvobj_deinit(struct _adapter *padapter)
+{
+}
+
+void rtl871x_intf_stop(struct _adapter *padapter)
+{
+	/*disable_hw_interrupt*/
+	if (padapter->bSurpriseRemoved == false) {
+		/*device still exists, so driver can do i/o operation
+		 * TODO: */
+	}
+
+	/* cancel in irp */
+	if (padapter->dvobjpriv.inirp_deinit != NULL)
+		padapter->dvobjpriv.inirp_deinit(padapter);
+	/* cancel out irp */
+	r8712_usb_write_port_cancel(padapter);
+	/* TODO:cancel other irps */
+}
+
+void r871x_dev_unload(struct _adapter *padapter)
+{
+	if (padapter->bup == true) {
+		/*s1.*/
+		padapter->bDriverStopped = true;
+
+		/*s3.*/
+		rtl871x_intf_stop(padapter);
+
+		/*s4.*/
+		r8712_stop_drv_threads(padapter);
+
+		/*s5.*/
+		if (padapter->bSurpriseRemoved == false) {
+			padapter->hw_init_completed = false;
+			rtl8712_hal_deinit(padapter);
+		}
+
+		/*s6.*/
+		if (padapter->dvobj_deinit)
+			padapter->dvobj_deinit(padapter);
+		padapter->bup = false;
+	}
+}
+
+static void disable_ht_for_spec_devid(const struct usb_device_id *pdid,
+				      struct _adapter *padapter)
+{
+	u16 vid, pid;
+	u32 flags;
+	int i;
+	int num = sizeof(specific_device_id_tbl) /
+		  sizeof(struct specific_device_id);
+
+	for (i = 0; i < num; i++) {
+		vid = specific_device_id_tbl[i].idVendor;
+		pid = specific_device_id_tbl[i].idProduct;
+		flags = specific_device_id_tbl[i].flags;
+
+		if ((pdid->idVendor == vid) && (pdid->idProduct == pid) &&
+		    (flags&SPEC_DEV_ID_DISABLE_HT)) {
+			padapter->registrypriv.ht_enable = 0;
+			padapter->registrypriv.cbw40_enable = 0;
+			padapter->registrypriv.ampdu_enable = 0;
+		}
+	}
+}
+
+static u8 key_2char2num(u8 hch, u8 lch)
+{
+	return (hex_to_bin(hch) << 4) | hex_to_bin(lch);
+}
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us
+ * to support. We accept the new device by returning 0.
+*/
+static int r871xu_drv_init(struct usb_interface *pusb_intf,
+			   const struct usb_device_id *pdid)
+{
+	uint status;
+	struct _adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	struct net_device *pnetdev;
+	struct usb_device *udev;
+
+	printk(KERN_INFO "r8712u: DriverVersion: %s\n", DRVER);
+	/* In this probe function, O.S. will provide the usb interface pointer
+	 * to driver. We have to increase the reference count of the usb device
+	 * structure by using the usb_get_dev function.
+	 */
+	udev = interface_to_usbdev(pusb_intf);
+	usb_get_dev(udev);
+	pintf = pusb_intf;
+	/* step 1. */
+	pnetdev = r8712_init_netdev();
+	if (!pnetdev)
+		goto error;
+	padapter = netdev_priv(pnetdev);
+	disable_ht_for_spec_devid(pdid, padapter);
+	pdvobjpriv = &padapter->dvobjpriv;
+	pdvobjpriv->padapter = padapter;
+	padapter->dvobjpriv.pusbdev = udev;
+	padapter->pusb_intf = pusb_intf;
+	usb_set_intfdata(pusb_intf, pnetdev);
+	SET_NETDEV_DEV(pnetdev, &pusb_intf->dev);
+	/* step 2. */
+	padapter->dvobj_init = &r8712_usb_dvobj_init;
+	padapter->dvobj_deinit = &r8712_usb_dvobj_deinit;
+	padapter->halpriv.hal_bus_init = &r8712_usb_hal_bus_init;
+	padapter->dvobjpriv.inirp_init = &r8712_usb_inirp_init;
+	padapter->dvobjpriv.inirp_deinit = &r8712_usb_inirp_deinit;
+	/* step 3.
+	 * initialize the dvobj_priv
+	 */
+	if (padapter->dvobj_init == NULL)
+			goto error;
+	else {
+		status = padapter->dvobj_init(padapter);
+		if (status != _SUCCESS)
+			goto error;
+	}
+	/* step 4. */
+	status = r8712_init_drv_sw(padapter);
+	if (status == _FAIL)
+		goto error;
+	/* step 5. read efuse/eeprom data and get mac_addr */
+	{
+		int i, offset;
+		u8 mac[6];
+		u8 tmpU1b, AutoloadFail, eeprom_CustomerID;
+		u8 *pdata = padapter->eeprompriv.efuse_eeprom_data;
+
+		tmpU1b = r8712_read8(padapter, EE_9346CR);/*CR9346*/
+
+		/* To check system boot selection.*/
+		printk(KERN_INFO "r8712u: Boot from %s: Autoload %s\n",
+		       (tmpU1b & _9356SEL) ? "EEPROM" : "EFUSE",
+		       (tmpU1b & _EEPROM_EN) ? "OK" : "Failed");
+
+		/* To check autoload success or not.*/
+		if (tmpU1b & _EEPROM_EN) {
+			AutoloadFail = true;
+			/* The following operations prevent Efuse leakage by
+			 * turning on 2.5V.
+			 */
+			tmpU1b = r8712_read8(padapter, EFUSE_TEST+3);
+			r8712_write8(padapter, EFUSE_TEST + 3, tmpU1b | 0x80);
+			msleep(20);
+			r8712_write8(padapter, EFUSE_TEST + 3,
+				     (tmpU1b & (~BIT(7))));
+
+			/* Retrieve Chip version.
+			 * Recognize IC version by Reg0x4 BIT15.
+			 */
+			tmpU1b = (u8)((r8712_read32(padapter, PMC_FSM) >> 15) &
+						    0x1F);
+			if (tmpU1b == 0x3)
+				padapter->registrypriv.chip_version =
+				     RTL8712_3rdCUT;
+			else
+				padapter->registrypriv.chip_version =
+				     (tmpU1b >> 1) + 1;
+			switch (padapter->registrypriv.chip_version) {
+			case RTL8712_1stCUT:
+			case RTL8712_2ndCUT:
+			case RTL8712_3rdCUT:
+				break;
+			default:
+				padapter->registrypriv.chip_version =
+				     RTL8712_2ndCUT;
+				break;
+			}
+
+			for (i = 0, offset = 0; i < 128; i += 8, offset++)
+				r8712_efuse_pg_packet_read(padapter, offset,
+						     &pdata[i]);
+
+			if (r8712_initmac) {
+				/* Users specify the mac address */
+				int jj, kk;
+
+				for (jj = 0, kk = 0; jj < ETH_ALEN;
+				     jj++, kk += 3)
+					mac[jj] =
+					   key_2char2num(r8712_initmac[kk],
+					   r8712_initmac[kk + 1]);
+			} else {
+				/* Use the mac address stored in the Efuse
+				 * offset = 0x12 for usb in efuse
+				 */
+				memcpy(mac, &pdata[0x12], ETH_ALEN);
+			}
+			eeprom_CustomerID = pdata[0x52];
+			switch (eeprom_CustomerID) {
+			case EEPROM_CID_ALPHA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_ALPHA;
+				break;
+			case EEPROM_CID_CAMEO:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CAMEO;
+				break;
+			case EEPROM_CID_SITECOM:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Sitecom;
+				break;
+			case EEPROM_CID_COREGA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_COREGA;
+				break;
+			case EEPROM_CID_Senao:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Senao;
+				break;
+			case EEPROM_CID_EDIMAX_BELKIN:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Edimax_Belkin;
+				break;
+			case EEPROM_CID_SERCOMM_BELKIN:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Sercomm_Belkin;
+				break;
+			case EEPROM_CID_WNC_COREGA:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_WNC_COREGA;
+				break;
+			case EEPROM_CID_WHQL:
+				break;
+			case EEPROM_CID_NetCore:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_Netcore;
+				break;
+			case EEPROM_CID_CAMEO1:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CAMEO1;
+				break;
+			case EEPROM_CID_CLEVO:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_819x_CLEVO;
+				break;
+			default:
+				padapter->eeprompriv.CustomerID =
+						 RT_CID_DEFAULT;
+				break;
+			}
+			printk(KERN_INFO "r8712u: CustomerID = 0x%.4x\n",
+			     padapter->eeprompriv.CustomerID);
+			/* Led mode */
+			switch (padapter->eeprompriv.CustomerID) {
+			case RT_CID_DEFAULT:
+			case RT_CID_819x_ALPHA:
+			case RT_CID_819x_CAMEO:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE1;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Sitecom:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE2;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_COREGA:
+			case RT_CID_819x_Senao:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE3;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Edimax_Belkin:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE4;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_Sercomm_Belkin:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE5;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			case RT_CID_819x_WNC_COREGA:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE6;
+				padapter->ledpriv.bRegUseLed = true;
+				break;
+			default:
+				padapter->ledpriv.LedStrategy = SW_LED_MODE0;
+				padapter->ledpriv.bRegUseLed = false;
+				break;
+			}
+		} else
+			AutoloadFail = false;
+		if (((mac[0] == 0xff) && (mac[1] == 0xff) &&
+		     (mac[2] == 0xff) && (mac[3] == 0xff) &&
+		     (mac[4] == 0xff) && (mac[5] == 0xff)) ||
+		    ((mac[0] == 0x00) && (mac[1] == 0x00) &&
+		     (mac[2] == 0x00) && (mac[3] == 0x00) &&
+		     (mac[4] == 0x00) && (mac[5] == 0x00)) ||
+		     (AutoloadFail == false)) {
+			mac[0] = 0x00;
+			mac[1] = 0xe0;
+			mac[2] = 0x4c;
+			mac[3] = 0x87;
+			mac[4] = 0x00;
+			mac[5] = 0x00;
+		}
+		if (r8712_initmac) {
+			/* Make sure the user did not select a multicast
+			 * address by setting bit 1 of first octet.
+			 */
+			mac[0] &= 0xFE;
+			printk(KERN_INFO "r8712u: MAC Address from user = "
+			       "%pM\n", mac);
+		} else
+			printk(KERN_INFO "r8712u: MAC Address from efuse = "
+			       "%pM\n", mac);
+		memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+	}
+	/* step 6. Load the firmware asynchronously */
+	if (rtl871x_load_fw(padapter))
+		goto error;
+	spin_lock_init(&padapter->lockRxFF0Filter);
+	mutex_init(&padapter->mutex_start);
+	return 0;
+error:
+	usb_put_dev(udev);
+	usb_set_intfdata(pusb_intf, NULL);
+	if (padapter->dvobj_deinit != NULL)
+		padapter->dvobj_deinit(padapter);
+	if (pnetdev)
+		free_netdev(pnetdev);
+	return -ENODEV;
+}
+
+/* rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove()
+ * => how to recognize both */
+static void r871xu_dev_remove(struct usb_interface *pusb_intf)
+{
+	struct net_device *pnetdev = usb_get_intfdata(pusb_intf);
+	struct _adapter *padapter = netdev_priv(pnetdev);
+	struct usb_device *udev = interface_to_usbdev(pusb_intf);
+
+	usb_set_intfdata(pusb_intf, NULL);
+	if (padapter) {
+		if (drvpriv.drv_registered == true)
+			padapter->bSurpriseRemoved = true;
+		if (pnetdev != NULL) {
+			/* will call netdev_close() */
+			unregister_netdev(pnetdev);
+		}
+		flush_scheduled_work();
+		udelay(1);
+		/*Stop driver mlme relation timer */
+		if (padapter->fw_found)
+			r8712_stop_drv_timers(padapter);
+		r871x_dev_unload(padapter);
+		r8712_free_drv_sw(padapter);
+	}
+	usb_set_intfdata(pusb_intf, NULL);
+	/* decrease the reference count of the usb device structure
+	 * when disconnect */
+	usb_put_dev(udev);
+	/* If we didn't unplug usb dongle and remove/insert modlue, driver
+	 * fails on sitesurvey for the first time when device is up.
+	 * Reset usb port for sitesurvey fail issue. */
+	if (udev->state != USB_STATE_NOTATTACHED)
+		usb_reset_device(udev);
+	return;
+}
+
+static int __init r8712u_drv_entry(void)
+{
+	drvpriv.drv_registered = true;
+	return usb_register(&drvpriv.r871xu_drv);
+}
+
+static void __exit r8712u_drv_halt(void)
+{
+	drvpriv.drv_registered = false;
+	usb_deregister(&drvpriv.r871xu_drv);
+	printk(KERN_INFO "r8712u: Driver unloaded\n");
+}
+
+module_init(r8712u_drv_entry);
+module_exit(r8712u_drv_halt);
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,201 @@
+/******************************************************************************
+ * usb_ops.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_OPS_C_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+#include "recv_osdep.h"
+#include "rtl871x_byteorder.h"
+
+static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return (u8)(le32_to_cpu(data)&0x0ff);
+}
+
+static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return (u16)(le32_to_cpu(data)&0xffff);
+}
+
+static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x01; /* read_in */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+	return le32_to_cpu(data);
+}
+
+static void usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+	data = val;
+	data = cpu_to_le32(data&0x000000ff);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+static void usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+	data = val;
+	data = cpu_to_le32(data&0x0000ffff);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+static void usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{
+	u8 request;
+	u8 requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u32 data;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+
+	request = 0x05;
+	requesttype = 0x00; /* write_out */
+	index = 0;
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = cpu_to_le32(val);
+	r8712_usbctrl_vendorreq(pintfpriv, request, wvalue, index, &data, len,
+			  requesttype);
+}
+
+void r8712_usb_set_intf_option(u32 *poption)
+{
+	*poption = ((*poption) | _INTF_ASYNC_);
+}
+
+static void usb_intf_hdl_init(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_unload(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_open(u8 *priv)
+{
+}
+
+static void usb_intf_hdl_close(u8 *priv)
+{
+}
+
+void r8712_usb_set_intf_funs(struct intf_hdl *pintf_hdl)
+{
+	pintf_hdl->intf_hdl_init = &usb_intf_hdl_init;
+	pintf_hdl->intf_hdl_unload = &usb_intf_hdl_unload;
+	pintf_hdl->intf_hdl_open = &usb_intf_hdl_open;
+	pintf_hdl->intf_hdl_close = &usb_intf_hdl_close;
+}
+
+void r8712_usb_set_intf_ops(struct _io_ops	*pops)
+{
+	memset((u8 *)pops, 0, sizeof(struct _io_ops));
+	pops->_read8 = &usb_read8;
+	pops->_read16 = &usb_read16;
+	pops->_read32 = &usb_read32;
+	pops->_read_port = &r8712_usb_read_port;
+	pops->_write8 = &usb_write8;
+	pops->_write16 = &usb_write16;
+	pops->_write32 = &usb_write32;
+	pops->_write_mem = &r8712_usb_write_mem;
+	pops->_write_port = &r8712_usb_write_port;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+
+void r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr,
+			 u32 cnt, u8 *wmem);
+u32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr,
+			  u32 cnt, u8 *wmem);
+u32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr,
+			 u32 cnt, u8 *rmem);
+void r8712_usb_set_intf_option(u32 *poption);
+void r8712_usb_set_intf_funs(struct intf_hdl *pintf_hdl);
+uint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv);
+void r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv);
+void r8712_usb_set_intf_ops(struct _io_ops *pops);
+void r8712_usb_read_port_cancel(struct _adapter *padapter);
+void r8712_usb_write_port_cancel(struct _adapter *padapter);
+int r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,
+		      u16 index, void *pdata, u16 len, u8 requesttype);
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops_linux.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops_linux.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_ops_linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_ops_linux.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,530 @@
+/******************************************************************************
+ * usb_ops_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _HCI_OPS_OS_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "osdep_intf.h"
+#include "usb_ops.h"
+
+#define	RTL871X_VENQT_READ	0xc0
+#define	RTL871X_VENQT_WRITE	0x40
+
+struct zero_bulkout_context {
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+#define usb_write_cmd r8712_usb_write_mem
+#define usb_write_cmd_complete usb_write_mem_complete
+
+uint r8712_usb_init_intf_priv(struct intf_priv *pintfpriv)
+{
+	pintfpriv->piorw_urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!pintfpriv->piorw_urb)
+		return _FAIL;
+	sema_init(&(pintfpriv->io_retevt), 0);
+	return _SUCCESS;
+}
+
+void r8712_usb_unload_intf_priv(struct intf_priv *pintfpriv)
+{
+	if (pintfpriv->piorw_urb) {
+		usb_kill_urb(pintfpriv->piorw_urb);
+		usb_free_urb(pintfpriv->piorw_urb);
+	}
+}
+
+static unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
+{
+	unsigned int pipe = 0;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	if (pdvobj->nr_endpoint == 11) {
+		switch (addr) {
+		case RTL8712_DMA_BKQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x07);
+			break;
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VIQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x05);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_BCNQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0a);
+			break;
+		case RTL8712_DMA_BMCQ:	/* HI Queue */
+			pipe = usb_sndbulkpipe(pusbd, 0x0b);
+			break;
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0c);
+			break;
+		case RTL8712_DMA_RX0FF:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x09); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 6) {
+		switch (addr) {
+		case RTL8712_DMA_BKQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x07);
+			break;
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VIQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x05);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_RX0FF:
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+		case RTL8712_DMA_BCNQ:
+		case RTL8712_DMA_BMCQ:
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else if (pdvobj->nr_endpoint == 4) {
+		switch (addr) {
+		case RTL8712_DMA_BEQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x06);
+			break;
+		case RTL8712_DMA_VOQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x04);
+			break;
+		case RTL8712_DMA_RX0FF:
+		case RTL8712_DMA_C2HCMD:
+			pipe = usb_rcvbulkpipe(pusbd, 0x03); /* in */
+			break;
+		case RTL8712_DMA_H2CCMD:
+		case RTL8712_DMA_BCNQ:
+		case RTL8712_DMA_BMCQ:
+		case RTL8712_DMA_MGTQ:
+			pipe = usb_sndbulkpipe(pusbd, 0x0d);
+			break;
+		}
+	} else
+	   pipe = 0;
+	return pipe;
+}
+
+static void usb_write_mem_complete(struct urb *purb)
+{
+	struct io_queue *pio_q = (struct io_queue *)purb->context;
+	struct intf_hdl *pintf = &(pio_q->intf);
+	struct intf_priv *pintfpriv = pintf->pintfpriv;
+	struct _adapter *padapter = (struct _adapter *)pintf->adapter;
+
+	if (purb->status != 0) {
+		if (purb->status == (-ESHUTDOWN))
+			padapter->bDriverStopped = true;
+		else
+			padapter->bSurpriseRemoved = true;
+	}
+	up(&pintfpriv->io_retevt);
+}
+
+void r8712_usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	unsigned int pipe;
+	int status;
+	struct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct io_queue *pio_queue = (struct io_queue *)padapter->pio_queue;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct urb *piorw_urb = pintfpriv->piorw_urb;
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
+		return;
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+	if (pipe == 0)
+		return;
+	usb_fill_bulk_urb(piorw_urb, pusbd, pipe,
+			  wmem, cnt, usb_write_mem_complete,
+			  pio_queue);
+	status = usb_submit_urb(piorw_urb, GFP_ATOMIC);
+	_down_sema(&pintfpriv->io_retevt);
+}
+
+static void r8712_usb_read_port_complete(struct urb *purb)
+{
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
+	struct _adapter *padapter = (struct _adapter *)precvbuf->adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped)
+		return;
+	if (purb->status == 0) { /* SUCCESS */
+		if ((purb->actual_length > (MAX_RECVBUF_SZ)) ||
+		    (purb->actual_length < RXDESC_SIZE)) {
+			precvbuf->reuse = true;
+			r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+				  (unsigned char *)precvbuf);
+		} else {
+			precvbuf->transfer_len = purb->actual_length;
+			pbuf = (uint *)precvbuf->pbuf;
+			isevt = le32_to_cpu(*(pbuf + 1)) & 0x1ff;
+			if ((isevt & 0x1ff) == 0x1ff) {
+				r8712_rxcmd_event_hdl(padapter, pbuf);
+				precvbuf->reuse = true;
+				r8712_read_port(padapter, precvpriv->ff_hwaddr,
+						0, (unsigned char *)precvbuf);
+			} else {
+				_pkt *pskb = precvbuf->pskb;
+				skb_put(pskb, purb->actual_length);
+				skb_queue_tail(&precvpriv->rx_skb_queue, pskb);
+				tasklet_hi_schedule(&precvpriv->recv_tasklet);
+				precvbuf->pskb = NULL;
+				precvbuf->reuse = false;
+				r8712_read_port(padapter, precvpriv->ff_hwaddr,
+						0, (unsigned char *)precvbuf);
+			}
+		}
+	} else {
+		switch (purb->status) {
+		case -EINVAL:
+		case -EPIPE:
+		case -ENODEV:
+		case -ESHUTDOWN:
+		case -ENOENT:
+			padapter->bDriverStopped = true;
+			break;
+		case -EPROTO:
+			precvbuf->reuse = true;
+			r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
+				  (unsigned char *)precvbuf);
+			break;
+		case -EINPROGRESS:
+			printk(KERN_ERR "r8712u: ERROR: URB IS IN"
+			       " PROGRESS!/n");
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+u32 r8712_usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	unsigned int pipe;
+	int err;
+	u32 tmpaddr = 0;
+	int alignment = 0;
+	u32 ret = _SUCCESS;
+	struct urb *purb = NULL;
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv *)pintfpriv->intf_dev;
+	struct _adapter *adapter = (struct _adapter *)pdvobj->padapter;
+	struct recv_priv *precvpriv = &adapter->recvpriv;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||
+	    adapter->pwrctrlpriv.pnp_bstop_trx)
+		return _FAIL;
+	if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+		precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue);
+		if (NULL != precvbuf->pskb)
+			precvbuf->reuse = true;
+	}
+	if (precvbuf != NULL) {
+		r8712_init_recvbuf(adapter, precvbuf);
+		/* re-assign for linux based on skb */
+		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev,
+					 MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+			if (precvbuf->pskb == NULL)
+				return _FAIL;
+			tmpaddr = (addr_t)precvbuf->pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(precvbuf->pskb,
+				    (RECVBUFF_ALIGN_SZ - alignment));
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+		} else { /* reuse skb */
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+			precvbuf->reuse = false;
+		}
+		purb = precvbuf->purb;
+		/* translate DMA FIFO addr to pipehandle */
+		pipe = ffaddr2pipehdl(pdvobj, addr);
+		usb_fill_bulk_urb(purb, pusbd, pipe,
+				  precvbuf->pbuf, MAX_RECVBUF_SZ,
+				  r8712_usb_read_port_complete,
+				  precvbuf);
+		err = usb_submit_urb(purb, GFP_ATOMIC);
+		if ((err) && (err != (-EPERM)))
+			ret = _FAIL;
+	} else
+		ret = _FAIL;
+	return ret;
+}
+
+void r8712_usb_read_port_cancel(struct _adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+
+	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		if (precvbuf->purb)
+			usb_kill_urb(precvbuf->purb);
+		precvbuf++;
+	}
+}
+
+void r8712_xmit_bh(void *priv)
+{
+	int ret = false;
+	struct _adapter *padapter = (struct _adapter *)priv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true)) {
+		printk(KERN_ERR "r8712u: xmit_bh => bDriverStopped"
+		       " or bSurpriseRemoved\n");
+		return;
+	}
+	ret = r8712_xmitframe_complete(padapter, pxmitpriv, NULL);
+	if (ret == false)
+		return;
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+}
+
+static void usb_write_port_complete(struct urb *purb)
+{
+	int i;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)purb->context;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	struct _adapter *padapter = pxmitframe->padapter;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	switch (pattrib->priority) {
+	case 1:
+	case 2:
+		pxmitpriv->bkq_cnt--;
+		break;
+	case 4:
+	case 5:
+		pxmitpriv->viq_cnt--;
+		break;
+	case 6:
+	case 7:
+		pxmitpriv->voq_cnt--;
+		break;
+	case 0:
+	case 3:
+	default:
+		pxmitpriv->beq_cnt--;
+		break;
+	}
+	pxmitpriv->txirp_cnt--;
+	for (i = 0; i < 8; i++) {
+		if (purb == pxmitframe->pxmit_urb[i]) {
+			pxmitframe->bpending[i] = false;
+			break;
+		}
+	}
+	if (padapter->bSurpriseRemoved)
+		return;
+	switch (purb->status) {
+	case 0:
+		break;
+	default:
+		printk(KERN_WARNING "r8712u: pipe error: (%d)\n", purb->status);
+		break;
+	}
+	/* not to consider tx fragment */
+	r8712_free_xmitframe_ex(pxmitpriv, pxmitframe);
+	r8712_free_xmitbuf(pxmitpriv, pxmitbuf);
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+}
+
+u32 r8712_usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	unsigned long irqL;
+	int i, status;
+	unsigned int pipe;
+	u32 ret, bwritezero;
+	struct urb *purb = NULL;
+	struct _adapter *padapter = (struct _adapter *)pintfhdl->adapter;
+	struct dvobj_priv *pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
+		return _FAIL;
+	for (i = 0; i < 8; i++) {
+		if (pxmitframe->bpending[i] == false) {
+			spin_lock_irqsave(&pxmitpriv->lock, irqL);
+			pxmitpriv->txirp_cnt++;
+			pxmitframe->bpending[i]  = true;
+			switch (pattrib->priority) {
+			case 1:
+			case 2:
+				pxmitpriv->bkq_cnt++;
+				break;
+			case 4:
+			case 5:
+				pxmitpriv->viq_cnt++;
+				break;
+			case 6:
+			case 7:
+				pxmitpriv->voq_cnt++;
+				break;
+			case 0:
+			case 3:
+			default:
+				pxmitpriv->beq_cnt++;
+				break;
+			}
+			spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+			pxmitframe->sz[i] = (u16)cnt;
+			purb = pxmitframe->pxmit_urb[i];
+			break;
+		}
+	}
+	bwritezero = false;
+	if (pdvobj->ishighspeed) {
+		if (cnt > 0 && cnt % 512 == 0)
+			bwritezero = true;
+	} else {
+		if (cnt > 0 && cnt % 64 == 0)
+			bwritezero = true;
+	}
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+	if (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	else
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+	if (bwritezero)
+		cnt += 8;
+	usb_fill_bulk_urb(purb, pusbd, pipe,
+			  pxmitframe->mem_addr,
+			  cnt, usb_write_port_complete,
+			  pxmitframe); /* context is xmit_frame */
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+	if (!status)
+		ret = _SUCCESS;
+	else
+		ret = _FAIL;
+	return ret;
+}
+
+void r8712_usb_write_port_cancel(struct _adapter *padapter)
+{
+	int i, j;
+	struct xmit_buf	*pxmitbuf = (struct xmit_buf *)
+				     padapter->xmitpriv.pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		for (j = 0; j < 8; j++) {
+			if (pxmitbuf->pxmit_urb[j])
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+		}
+		pxmitbuf++;
+	}
+}
+
+int r8712_usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value,
+		      u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	unsigned int pipe;
+	int status;
+	u8 reqtype;
+	struct dvobj_priv *pdvobjpriv = (struct dvobj_priv *)
+					 pintfpriv->intf_dev;
+	struct usb_device *udev = pdvobjpriv->pusbdev;
+	/* For mstar platform, mstar suggests the address for USB IO
+	 * should be 16 bytes alignment. Trying to fix it here.
+	 */
+	u8 *palloc_buf, *pIo_buf;
+
+	palloc_buf = _malloc((u32) len + 16);
+	if (palloc_buf == NULL) {
+		printk(KERN_ERR "r8712u: [%s] Can't alloc memory for vendor"
+		       " request\n", __func__);
+		return -1;
+	}
+	pIo_buf = palloc_buf + 16 - ((addr_t)(palloc_buf) & 0x0f);
+	if (requesttype == 0x01) {
+		pipe = usb_rcvctrlpipe(udev, 0); /* read_in */
+		reqtype =  RTL871X_VENQT_READ;
+	} else {
+		pipe = usb_sndctrlpipe(udev, 0); /* write_out */
+		reqtype =  RTL871X_VENQT_WRITE;
+		memcpy(pIo_buf, pdata, len);
+	}
+	status = usb_control_msg(udev, pipe, request, reqtype, value, index,
+				 pIo_buf, len, HZ / 2);
+	if (status > 0) {  /* Success this control transfer. */
+		if (requesttype == 0x01) {
+			/* For Control read transfer, we have to copy the read
+			 * data from pIo_buf to pdata.
+			 */
+			memcpy(pdata, pIo_buf,  status);
+		}
+	}
+	kfree(palloc_buf);
+	return status;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_osintf.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_osintf.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_osintf.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_osintf.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include "osdep_service.h"
+#include "drv_types.h"
+#include "usb_vendor_req.h"
+
+#define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)
+
+extern char *r8712_initmac;
+
+unsigned int r8712_usb_inirp_init(struct _adapter *padapter);
+unsigned int r8712_usb_inirp_deinit(struct _adapter *padapter);
+uint rtl871x_hal_init(struct _adapter *padapter);
+uint rtl8712_hal_deinit(struct _adapter *padapter);
+
+void rtl871x_intf_stop(struct _adapter *padapter);
+void r871x_dev_unload(struct _adapter *padapter);
+void r8712_stop_drv_threads(struct _adapter *padapter);
+void r8712_stop_drv_timers(struct _adapter *padapter);
+u8 r8712_init_drv_sw(struct _adapter *padapter);
+u8 r8712_free_drv_sw(struct _adapter *padapter);
+struct net_device *r8712_init_netdev(void);
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_vendor_req.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_vendor_req.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/usb_vendor_req.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/usb_vendor_req.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+/*4	Set/Get Register related wIndex/Data */
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON			1
+#define	RT_USB_LDO_OFF			0
+
+/*4	Set/Get SYSCLK related	wValue or Data */
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+enum RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+};
+
+enum RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO		=	4,
+	RT_USB_BOOT_TYPE	=	5
+};
+
+#endif
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/wifi.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/wifi.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/wifi.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/wifi.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,643 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+#include "rtl871x_byteorder.h"
+#include <linux/compiler.h>
+
+#ifdef BIT
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	/*!< QoS Data */
+};
+
+enum WIFI_FRAME_SUBTYPE {
+	/* below is for mgt frame */
+	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	/* below is for control frame */
+	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_CFEND_CFACK = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	/* below is for data frame */
+	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_			= 0,
+	_RSON_UNSPECIFIED_		= 1,
+	_RSON_AUTH_NO_LONGER_VALID_	= 2,
+	_RSON_DEAUTH_STA_LEAVING_	= 3,
+	_RSON_INACTIVITY_		= 4,
+	_RSON_UNABLE_HANDLE_		= 5,
+	_RSON_CLS2_			= 6,
+	_RSON_CLS3_			= 7,
+	_RSON_DISAOC_STA_LEAVING_	= 8,
+	_RSON_ASOC_NOT_AUTH_		= 9,
+	/* WPA reason */
+	_RSON_INVALID_IE_		= 13,
+	_RSON_MIC_FAILURE_		= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_	= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_			= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_		= 20,
+	_RSON_UNSUPPORT_RSNE_VER_	= 21,
+	_RSON_INVALID_RSNE_CAP_		= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+	/* below are Realtek definitions */
+	_RSON_PMK_NOT_AVAILABLE_	= 24,
+};
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_		= 0,
+	_STATS_FAILURE_			= 1,
+	_STATS_CAP_FAIL_		= 10,
+	_STATS_NO_ASOC_			= 11,
+	_STATS_OTHER_			= 12,
+	_STATS_NO_SUPP_ALG_		= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_		= 18,
+};
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC	= 1,
+	DOMAIN_IC	= 2,
+	DOMAIN_ETSI	= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK	= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1	= 8,
+	DOMAIN_MKK2	= 9,
+	DOMAIN_MKK3	= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_		BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while (0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while (0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while (0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while (0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while (0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while (0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while (0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while (0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while (0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while (0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while (0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while (0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while (0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & \
+				le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while (0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & \
+			le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & \
+				(BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf, type)	\
+	do {	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | \
+		BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while (0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & \
+				(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | \
+				BIT(2)))
+
+#define SetFrameSubType(pbuf, type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | \
+		BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while (0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)\
+				((addr_t)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)\
+				(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)\
+				((addr_t)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 22) = \
+			((*(unsigned short *)((addr_t)(pbuf) + 22)) & \
+			le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while (0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 22) = \
+			((*(unsigned short *)((addr_t)(pbuf) + 22)) & \
+			le16_to_cpu((unsigned short)0x000f)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while (0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((addr_t)(pbuf) + 2) |= \
+			cpu_to_le16(0xffff & (dur)); \
+	} while (0)
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while (0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
+	} while (0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
+	} while (0)
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)(pbuf) + 2)) \
+			& 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((addr_t)(pbuf) + \
+			(((GetToDs(pbuf) << 1)|GetFrDs(pbuf)) == 3 ? \
+			30 : 24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((addr_t)(pbuf) + 24))
+
+
+
+static inline int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return true;
+	else
+		return false;
+}
+
+
+static inline unsigned char *get_da(unsigned char *pframe)
+{
+	unsigned char	*da;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	}
+	return da;
+}
+
+
+static inline unsigned char *get_sa(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		sa = GetAddr4Ptr(pframe);
+		break;
+	}
+
+	return sa;
+}
+
+static inline unsigned char *get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds = (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = GetAddr1Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		sa = NULL;
+		break;
+	}
+	return sa;
+}
+
+
+
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_	2
+#define _PRE_ALLOCMEM_		1
+#define _PRE_ALLOCHDR_		3
+#define _PRE_ALLOCLLCHDR_	4
+#define _PRE_ALLOCICVHDR_	5
+#define _PRE_ALLOCMICHDR_	6
+
+#define _SIFSTIME_		((priv->pmib->BssType.net_work_type & \
+				WIRELESS_11A) ? 16 : 10)
+#define _ACKCTSLNG_		14	/*14 bytes long, including crclng */
+#define _CRCLNG_		4
+
+#define _ASOCREQ_IE_OFFSET_	4	/* excluding wlan_hdr */
+#define	_ASOCRSP_IE_OFFSET_	6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_	6
+#define _DEAUTH_IE_OFFSET_	0
+#define _BEACON_IE_OFFSET_	12
+
+#define _FIXED_IE_LENGTH_	_BEACON_IE_OFFSET_
+
+#define _SSID_IE_		0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_		3
+#define _TIM_IE_		5
+#define _IBSS_PARA_IE_		6
+#define _CHLGETXT_IE_		16
+#define _RSN_IE_2_		48`
+#define _SSN_IE_1_		221
+#define _ERPINFO_IE_		42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_	45
+#define _HT_EXTRA_INFO_IE_	61
+#define _HT_ADD_INFO_IE_	61 /* _HT_EXTRA_INFO_IE_ */
+
+#define _VENDOR_SPECIFIC_IE_	221
+
+#define	_RESERVED47_		47
+
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1	/*WPA */
+#define _IEEE8021X_PSK_			2	/* WPA with pre-shared key */
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  /* for WMM STA */
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while (0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & \
+				le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __packed;
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+
+ /**
+ * struct ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+
+struct ieee80211_ht_cap {
+	unsigned short	cap_info;
+	unsigned char	ampdu_params_info;
+	unsigned char	supp_mcs_set[16];
+	unsigned short	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __packed;
+
+/**
+ * struct ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __packed;
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE		0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+#endif /* _WIFI_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/wlan_bssdef.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/wlan_bssdef.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/wlan_bssdef.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/wlan_bssdef.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,267 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+#define MAX_IE_SZ	768
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+/* Set of 8 data rates*/
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];
+/* Set of 16 data rates */
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];
+
+struct ndis_802_11_ssid {
+	u32 SsidLength;
+	u8  Ssid[32];
+};
+
+enum NDIS_802_11_NETWORK_TYPE {
+	Ndis802_11FH,
+	Ndis802_11DS,
+	Ndis802_11OFDM5,
+	Ndis802_11OFDM24,
+	Ndis802_11NetworkTypeMax /* not a real type, defined as an upper bound*/
+};
+
+struct NDIS_802_11_CONFIGURATION_FH {
+	u32 Length;             /* Length of structure */
+	u32 HopPattern;         /* As defined by 802.11, MSB set */
+	u32 HopSet;             /* to one if non-802.11 */
+	u32 DwellTime;          /* units are Kusec */
+};
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+struct NDIS_802_11_CONFIGURATION {
+	u32 Length;             /* Length of structure */
+	u32 BeaconPeriod;       /* units are Kusec */
+	u32 ATIMWindow;         /* units are Kusec */
+	u32 DSConfig;           /* Frequency, units are kHz */
+	struct NDIS_802_11_CONFIGURATION_FH FHConfig;
+};
+
+enum NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	Ndis802_11IBSS,
+	Ndis802_11Infrastructure,
+	Ndis802_11AutoUnknown,
+	Ndis802_11InfrastructureMax, /*Not a real value,defined as upper bound*/
+	Ndis802_11APMode
+};
+
+struct NDIS_802_11_FIXED_IEs {
+	u8  Timestamp[8];
+	u16 BeaconInterval;
+	u16 Capabilities;
+};
+
+/*
+ * Length is the 4 bytes multiples of the sume of
+ * 6 * sizeof (unsigned char) + 2 + sizeof (ndis_802_11_ssid) + sizeof (u32)
+ * + sizeof (s32) + sizeof (NDIS_802_11_NETWORK_TYPE)
+ * + sizeof (struct NDIS_802_11_CONFIGURATION)
+ * + sizeof (NDIS_802_11_RATES_EX) + IELength
+
+ * Except the IELength, all other fields are fixed length. Therefore, we can
+ * define a macro to present the partial sum.
+ */
+
+struct ndis_wlan_bssid_ex {
+	u32 Length;
+	unsigned char  MacAddress[6];
+	u8  Reserved[2];
+	struct ndis_802_11_ssid  Ssid;
+	u32 Privacy;
+	s32 Rssi;
+	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	struct NDIS_802_11_CONFIGURATION  Configuration;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	NDIS_802_11_RATES_EX  SupportedRates;
+	u32 IELength;
+	/*(timestamp, beacon interval, and capability information) */
+	u8 IEs[MAX_IE_SZ];
+};
+
+enum NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeMax      /* Not a real mode, defined as upper bound */
+};
+
+enum {
+	Ndis802_11WEPEnabled,
+	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+	Ndis802_11WEPDisabled,
+	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+	Ndis802_11WEPKeyAbsent,
+	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+	Ndis802_11WEPNotSupported,
+	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+	Ndis802_11Encryption2Enabled,
+	Ndis802_11Encryption2KeyAbsent,
+	Ndis802_11Encryption3Enabled,
+	Ndis802_11Encryption3KeyAbsent
+};
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+struct NDIS_802_11_AI_REQFI {
+	u16 Capabilities;
+	u16 ListenInterval;
+	unsigned char CurrentAPAddress[6];
+};
+
+struct NDIS_802_11_AI_RESFI {
+	u16 Capabilities;
+	u16 StatusCode;
+	u16 AssociationId;
+};
+
+struct NDIS_802_11_ASSOCIATION_INFORMATION {
+	u32 Length;
+	u16 AvailableRequestFixedIEs;
+	struct NDIS_802_11_AI_REQFI RequestFixedIEs;
+	u32 RequestIELength;
+	u32 OffsetRequestIEs;
+	u16 AvailableResponseFixedIEs;
+	struct NDIS_802_11_AI_RESFI ResponseFixedIEs;
+	u32 ResponseIELength;
+	u32 OffsetResponseIEs;
+};
+
+/* Key mapping keys require a BSSID*/
+struct NDIS_802_11_KEY {
+	u32 Length;			/* Length of this structure */
+	u32 KeyIndex;
+	u32 KeyLength;			/* length of key in bytes */
+	unsigned char BSSID[6];
+	unsigned long long KeyRSC;
+	u8  KeyMaterial[32];		/* variable length */
+};
+
+struct NDIS_802_11_REMOVE_KEY {
+	u32 Length;			/* Length of this structure */
+	u32 KeyIndex;
+	unsigned char BSSID[6];
+};
+
+struct NDIS_802_11_WEP {
+	u32 Length;		  /* Length of this structure */
+	u32 KeyIndex;		  /* 0 is the per-client key,
+				   * 1-N are the global keys */
+	u32 KeyLength;		  /* length of key in bytes */
+	u8  KeyMaterial[16];      /* variable length depending on above field */
+};
+
+/* mask for authentication/integrity fields */
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+/* MIC check time, 60 seconds. */
+#define MIC_CHECK_TIME	60000000
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+struct	wlan_network {
+	struct list_head list;
+	int	network_type;	/*refer to ieee80211.h for WIRELESS_11A/B/G */
+	int	fixed;		/* set to fixed when not to be removed asi
+				 * site-surveying */
+	unsigned int	last_scanned; /*timestamp for the network */
+	int	aid;		/*will only be valid when a BSS is joined. */
+	int	join_res;
+	struct ndis_wlan_bssid_ex network; /*must be the last item */
+};
+
+enum VRTL_CARRIER_SENSE {
+	DISABLE_VCS,
+	ENABLE_VCS,
+	AUTO_VCS
+};
+
+enum VCS_TYPE {
+	NONE_VCS,
+	RTS_CTS,
+	CTS_TO_SELF
+};
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+enum UAPSD_MAX_SP {
+	NO_LIMIT,
+	TWO_MSDU,
+	FOUR_MSDU,
+	SIX_MSDU
+};
+
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+ *	WPA2
+ */
+struct wlan_bssid_ex {
+	u32 Length;
+	unsigned char  MacAddress[6];
+	u8  Reserved[2];
+	struct ndis_802_11_ssid  Ssid;
+	u32 Privacy;
+	s32 Rssi;
+	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	struct NDIS_802_11_CONFIGURATION  Configuration;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	NDIS_802_11_RATES_EX  SupportedRates;
+	u32 IELength;
+	u8  IEs[MAX_IE_SZ];	/* (timestamp, beacon interval, and capability
+				 * information) */
+};
+
+#endif /* #ifndef WLAN_BSSDEF_H_ */
+
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/xmit_linux.c ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/xmit_linux.c
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/xmit_linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/xmit_linux.c	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,203 @@
+/******************************************************************************
+ * xmit_linux.c
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192SU
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+
+#define _XMIT_OSDEP_C_
+
+#include <linux/usb.h>
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+
+#include "if_ether.h"
+#include "ip.h"
+#include "rtl871x_byteorder.h"
+#include "wifi.h"
+#include "mlme_osdep.h"
+#include "xmit_osdep.h"
+#include "osdep_intf.h"
+
+static uint remainder_len(struct pkt_file *pfile)
+{
+	return (uint)(pfile->buf_len - ((addr_t)(pfile->cur_addr) -
+	       (addr_t)(pfile->buf_start)));
+}
+
+void _r8712_open_pktfile(_pkt *pktptr, struct pkt_file *pfile)
+{
+	pfile->pkt = pktptr;
+	pfile->cur_addr = pfile->buf_start = pktptr->data;
+	pfile->pkt_len = pfile->buf_len = pktptr->len;
+	pfile->cur_buffer = pfile->buf_start ;
+}
+
+uint _r8712_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen)
+{
+	uint len;
+
+	len = remainder_len(pfile);
+	len = (rlen > len) ? len : rlen;
+	if (rmem)
+		skb_copy_bits(pfile->pkt, pfile->buf_len - pfile->pkt_len,
+			      rmem, len);
+	pfile->cur_addr += len;
+	pfile->pkt_len -= len;
+	return len;
+}
+
+sint r8712_endofpktfile(struct pkt_file *pfile)
+{
+	if (pfile->pkt_len == 0)
+		return true;
+	else
+		return false;
+}
+
+
+void r8712_set_qos(struct pkt_file *ppktfile, struct pkt_attrib *pattrib)
+{
+	int i;
+	struct ethhdr etherhdr;
+	struct iphdr ip_hdr;
+	u16 UserPriority = 0;
+
+	_r8712_open_pktfile(ppktfile->pkt, ppktfile);
+	_r8712_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);
+
+	/* get UserPriority from IP hdr*/
+	if (pattrib->ether_type == 0x0800) {
+		i = _r8712_pktfile_read(ppktfile, (u8 *)&ip_hdr,
+					sizeof(ip_hdr));
+		/*UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3 ;*/
+		UserPriority = ip_hdr.tos >> 5;
+	} else {
+		/* "When priority processing of data frames is supported,
+		 * a STA's SME should send EAPOL-Key frames at the highest
+		 * priority." */
+
+		if (pattrib->ether_type == 0x888e)
+			UserPriority = 7;
+	}
+	pattrib->priority = UserPriority;
+	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+void r8712_SetFilter(struct work_struct *work)
+{
+	struct _adapter *padapter = container_of(work, struct _adapter,
+						wkFilterRxFF0);
+	u8  oldvalue = 0x00, newvalue = 0x00;
+	unsigned long irqL;
+
+	oldvalue = r8712_read8(padapter, 0x117);
+	newvalue = oldvalue & 0xfe;
+	r8712_write8(padapter, 0x117, newvalue);
+
+	spin_lock_irqsave(&padapter->lockRxFF0Filter, irqL);
+	padapter->blnEnableRxFF0Filter = 1;
+	spin_unlock_irqrestore(&padapter->lockRxFF0Filter, irqL);
+	do {
+		msleep(100);
+	} while (padapter->blnEnableRxFF0Filter == 1);
+	r8712_write8(padapter, 0x117, oldvalue);
+}
+
+int r8712_xmit_resource_alloc(struct _adapter *padapter,
+			      struct xmit_buf *pxmitbuf)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (pxmitbuf->pxmit_urb[i] == NULL) {
+			printk(KERN_ERR "r8712u: pxmitbuf->pxmit_urb[i]"
+			    " == NULL");
+			return _FAIL;
+		}
+	}
+	return _SUCCESS;
+}
+
+void r8712_xmit_resource_free(struct _adapter *padapter,
+			      struct xmit_buf *pxmitbuf)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		if (pxmitbuf->pxmit_urb[i]) {
+			usb_kill_urb(pxmitbuf->pxmit_urb[i]);
+			usb_free_urb(pxmitbuf->pxmit_urb[i]);
+		}
+	}
+}
+
+void r8712_xmit_complete(struct _adapter *padapter, struct xmit_frame *pxframe)
+{
+	if (pxframe->pkt)
+		dev_kfree_skb_any(pxframe->pkt);
+	pxframe->pkt = NULL;
+}
+
+int r8712_xmit_entry(_pkt *pkt, struct  net_device *pnetdev)
+{
+	struct xmit_frame *pxmitframe = NULL;
+	struct _adapter *padapter = (struct _adapter *)netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	int ret = 0;
+
+	if (r8712_if_up(padapter) == false) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	pxmitframe = r8712_alloc_xmitframe(pxmitpriv);
+	if (pxmitframe == NULL) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	if ((!r8712_update_attrib(padapter, pkt, &pxmitframe->attrib))) {
+		ret = 0;
+		goto _xmit_entry_drop;
+	}
+	padapter->ledpriv.LedControlHandler(padapter, LED_CTL_TX);
+	pxmitframe->pkt = pkt;
+	if (r8712_pre_xmit(padapter, pxmitframe) == true) {
+		/*dump xmitframe directly or drop xframe*/
+		dev_kfree_skb_any(pkt);
+		pxmitframe->pkt = NULL;
+	}
+	pxmitpriv->tx_pkts++;
+	pxmitpriv->tx_bytes += pxmitframe->attrib.last_txcmdsz;
+	return ret;
+_xmit_entry_drop:
+	if (pxmitframe)
+		r8712_free_xmitframe(pxmitpriv, pxmitframe);
+	pxmitpriv->tx_drop++;
+	dev_kfree_skb_any(pkt);
+	return ret;
+}
diff -Nur ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/xmit_osdep.h ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/xmit_osdep.h
--- ../linux-2.6.33-lpc313x/drivers/staging/rtl8712/xmit_osdep.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/drivers/staging/rtl8712/xmit_osdep.h	2012-10-06 18:29:29.000000000 +0200
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Modifications for inclusion into the Linux staging tree are
+ * Copyright(c) 2010 Larry Finger. All rights reserved.
+ *
+ * Contact information:
+ * WLAN FAE <wlanfae@realtek.com>
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+#include "osdep_service.h"
+#include "drv_types.h"
+
+struct pkt_file {
+	_pkt	*pkt;
+	u32	pkt_len;	 /*the remainder length of the open_file*/
+	_buffer	*cur_buffer;
+	u8	*buf_start;
+	u8	*cur_addr;
+	u32	buf_len;
+};
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+int r8712_xmit_entry(_pkt *pkt, struct  net_device *pnetdev);
+void r8712_SetFilter(struct work_struct *work);
+int r8712_xmit_resource_alloc(struct _adapter *padapter,
+			   struct xmit_buf *pxmitbuf);
+void r8712_xmit_resource_free(struct _adapter *padapter,
+			   struct xmit_buf *pxmitbuf);
+
+void r8712_set_qos(struct pkt_file *ppktfile,
+		    struct pkt_attrib *pattrib);
+void _r8712_open_pktfile(_pkt *pktptr, struct pkt_file *pfile);
+uint _r8712_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen);
+sint r8712_endofpktfile(struct pkt_file *pfile);
+void r8712_xmit_complete(struct _adapter *padapter,
+			     struct xmit_frame *pxframe);
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/include/asm-generic/atomic-long.h ../linux-2.6.33-lpc313x_original/include/asm-generic/atomic-long.h
--- ../linux-2.6.33-lpc313x/include/asm-generic/atomic-long.h	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/include/asm-generic/atomic-long.h	2012-10-06 18:29:30.000000000 +0200
@@ -243,7 +243,7 @@
 {
 	atomic_t *v = (atomic_t *)l;
 
-	return (long)atomic_add_unless(v, a, u);
+	return (long)__atomic_add_unless(v, a, u);
 }
 
 #define atomic_long_inc_not_zero(l) atomic_inc_not_zero((atomic_t *)(l))
diff -Nur ../linux-2.6.33-lpc313x/include/config/auto.conf ../linux-2.6.33-lpc313x_original/include/config/auto.conf
--- ../linux-2.6.33-lpc313x/include/config/auto.conf	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/config/auto.conf	2012-10-07 01:51:07.000000000 +0200
@@ -0,0 +1,473 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.33
+# Sun Oct  7 01:51:07 2012
+#
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_CAN_MCP251X=m
+CONFIG_FRAME_WARN=1024
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_COMPAT_BRK=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_CAN_BCM=m
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_BT_HCIUART=m
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_GPIOLIB=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_FLATMEM=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_LEDS_TIMER=y
+CONFIG_VMSPLIT_3G=y
+CONFIG_USB_SERIAL=m
+CONFIG_DEVKMEM=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_TIMERFD=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_EVENTFD=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_STAGING=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_HAS_DMA=y
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_SERIO_SERPORT=y
+CONFIG_CAN_DEV=m
+CONFIG_HW_CONSOLE=y
+CONFIG_PM_VERBOSE=y
+CONFIG_USB_G_PRINTER=m
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_I2C_PNX=y
+CONFIG_FREEZER=y
+CONFIG_ARM_UNWIND=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_LPC313x_ADC=m
+CONFIG_SPI_SPIDEV=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_RCU_FANOUT=32
+CONFIG_BLK_DEV=y
+CONFIG_SPI_MASTER=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_SPI_LPC313X=y
+CONFIG_CRYPTO_AES=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_MODULES=y
+CONFIG_USB_ACM=m
+CONFIG_I2C_CHARDEV=y
+CONFIG_USB_USBNET=m
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_EXT2_FS=y
+CONFIG_CAN_RAW=m
+CONFIG_VT_CONSOLE=y
+CONFIG_CPU_ARM926T=y
+CONFIG_DNOTIFY=y
+CONFIG_USB_HID=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RTC_LIB=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_RADIO_ADAPTERS=y
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_SUSPEND=y
+CONFIG_SLAB=y
+CONFIG_INOTIFY=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_IR_CORE=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_HOTPLUG=y
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_IPV6=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_ARPD=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_LEDS=y
+CONFIG_VFAT_FS=y
+CONFIG_RD_LZMA=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_MMC_LPC313x=y
+CONFIG_USB_ETH=m
+CONFIG_EMBEDDED=y
+CONFIG_PROC_FS=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_NEW_LPC313x_IO=y
+CONFIG_NET_KEY=y
+CONFIG_RD_GZIP=y
+CONFIG_INET=y
+CONFIG_RT_MUTEXES=y
+CONFIG_SYSVIPC=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_WLAN=y
+CONFIG_SCSI=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_USB_MON=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_VIDEO_MEDIA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_SWAP=y
+CONFIG_XFRM=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CRC32=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_OABI_COMPAT=y
+CONFIG_USB_NET_NET1080=m
+CONFIG_CRC16=m
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_EXTRA_FIRMWARE="rtlwifi/rtl8712u.bin"
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_CPU_CP15=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_LPC313x_PWM=m
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_PACKET_MMAP=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_UNIX=y
+CONFIG_BT_L2CAP=m
+CONFIG_SERIAL_CORE=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_SIGNALFD=y
+CONFIG_BT_HCIBTUSB=m
+CONFIG_UID16=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_ARCH_LPC313X=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_MEDIA_TUNER=y
+CONFIG_RT2X00_LIB_LEDS=y
+CONFIG_ANON_INODES=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_SLABINFO=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_WATCHDOG=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_AEABI=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_HAVE_IDE=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_RT2500USB=m
+CONFIG_CPU_32v5=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_USB_NET_AX8817X=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_CAN_VCAN=m
+CONFIG_LBDAF=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_KERNEL_GZIP=y
+CONFIG_GPIO_PCA953X=m
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_RD_BZIP2=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_STORAGE=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ELF_CORE=y
+CONFIG_DEBUG_FS=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_USB_PEGASUS=m
+CONFIG_SCSI_DMA=y
+CONFIG_PM_DEBUG=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_CRYPTO_HASH=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_INET_TUNNEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_BLK_DEV_XIP=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_IP_VS_TAB_BITS=12
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_USB_SUSPEND=y
+CONFIG_BLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_WIRELESS=y
+CONFIG_LEDS_CPU=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_KALLSYMS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_VIDEO_IR=y
+CONFIG_NEW_LEDS=y
+CONFIG_FSNOTIFY=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_IPV6_SIT=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_PM_SLEEP=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NET_IPIP=y
+CONFIG_R8712U=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_TREE_RCU=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_SHMEM=y
+CONFIG_INET_LRO=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_EPOLL=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_LPC313X_WATCHDOG=y
+CONFIG_EXTRA_FIRMWARE_DIR="/home/brenson/gnublin-buildroot-git/buildroot-2011.11/target/device/Gnublin/"
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_SERIO=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_INLINE_SPIN_UNLOCK=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_USB_SUPPORT=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_USB_ZERO=m
+CONFIG_HWMON=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_TMPFS=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_FUTEX=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_USB_GADGETFS=m
+CONFIG_VIDEO_IR_I2C=y
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_CPU_CP15_MMU=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_RT2X00=m
+CONFIG_INPUT=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_SENSORS_LM75=m
+CONFIG_LOCALVERSION=""
+CONFIG_USB_DEVICEFS=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_DEBUG_DRIVER=y
+CONFIG_HZ_100=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_BT=m
+CONFIG_SYSFS=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_IOSCHED_NOOP=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_CAN_PM_TRACE=y
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_PM=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_USB_EHCI_LPC=y
+CONFIG_DEFAULT_NOOP=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_IP_VS=y
+CONFIG_HZ=100
+CONFIG_TRACING_SUPPORT=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NET_ETHERNET=y
+CONFIG_MMC_BLOCK=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_USB_FSL_USB2=y
+CONFIG_VT=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_PREEMPT_NONE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_NETFILTER=y
+CONFIG_BASE_FULL=y
+CONFIG_IP_MULTICAST=y
+CONFIG_USB_G_SERIAL=m
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_USB_DEBUG=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_HAS_IOMEM=y
+CONFIG_FW_LOADER=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_USB_GADGET_FSL_USB2=y
+CONFIG_FTRACE=y
+CONFIG_VIDEO_DEV=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA=m
+CONFIG_PACKET=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_BT_RFCOMM=m
+CONFIG_CONSTRUCTORS=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_FPE_NWFPE=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_FIB_RULES=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_BOUNCE=y
+CONFIG_HAVE_AOUT=y
+CONFIG_NET_IPGRE=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_I2C=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_ARM_THUMB=y
+CONFIG_INOTIFY_USER=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RT2X00_LIB=m
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_DEFAULT_CUBIC=y
+CONFIG_CFG80211=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_MAC80211=y
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_WEXT_CORE=y
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_NETFILTER_XT_TARGET_HL=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_HWMON_DEBUG_CHIP=y
+CONFIG_CAN=m
+CONFIG_FAT_FS=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_IP_MROUTE=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_HID=m
+CONFIG_IP_NF_RAW=y
+CONFIG_NLATTR=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_PRINTK=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_AIO=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_WEXT_PROC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_VIDEO_V4L1=y
+CONFIG_MMC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_BUG=y
+CONFIG_CRYPTO_HW=y
+CONFIG_MII=m
+CONFIG_NAMESPACES=y
+CONFIG_ARM=y
+CONFIG_SENSORS_SHT15=m
+CONFIG_I2C_COMPAT=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_CRYPTO=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_SYSCTL=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_IP_PNP=y
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_NET=y
+CONFIG_WEXT_PRIV=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_STANDALONE=y
+CONFIG_NETDEVICES=y
+CONFIG_USB=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_SPI=y
+CONFIG_NLS=y
+CONFIG_MACH_EA313X=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_SERIAL_8250=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_MMU=y
+CONFIG_ENC28J60=m
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_BASE_SMALL=0
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_USB_GADGET=y
+CONFIG_BINFMT_ELF=y
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_BITREVERSE=y
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_CMDLINE="console=ttyS0,115200n8 root=/dev/ram0 rw"
+CONFIG_LEDS_CLASS=m
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_USB_BELKIN=y
+CONFIG_HIGHMEM=y
diff -Nur ../linux-2.6.33-lpc313x/include/config/auto.conf.cmd ../linux-2.6.33-lpc313x_original/include/config/auto.conf.cmd
--- ../linux-2.6.33-lpc313x/include/config/auto.conf.cmd	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/config/auto.conf.cmd	2012-10-07 01:51:07.000000000 +0200
@@ -0,0 +1,586 @@
+deps_config := \
+	lib/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/smbfs/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/autofs/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/netwave/Kconfig \
+	drivers/staging/wavelan/Kconfig \
+	drivers/staging/arlan/Kconfig \
+	drivers/staging/strip/Kconfig \
+	drivers/staging/samsung-laptop/Kconfig \
+	drivers/staging/batman-adv/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/ramzswap/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/rar/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/udlfb/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/p9auth/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/b3dfg/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/dream/camera/Kconfig \
+	drivers/staging/dream/smd/Kconfig \
+	drivers/staging/dream/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/mimio/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8192su/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/altpciechdma/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/rt2870/Kconfig \
+	drivers/staging/rt2860/Kconfig \
+	drivers/staging/otus/Kconfig \
+	drivers/staging/poch/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/lpc313x/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/s3c24xx/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/zc0301/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvideo/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/IR/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/chips/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/ar9170/Kconfig \
+	drivers/net/wireless/ath/ath9k/Kconfig \
+	drivers/net/wireless/ath/ath5k/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/octeon/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/ieee1394/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgb3i/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig.debug \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/lpc313x_io/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	kernel/time/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	kernel/Kconfig.hz \
+	arch/arm/mach-lpc313x/Kconfig \
+	arch/arm/mach-w90x900/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-ux500/Kconfig \
+	arch/arm/mach-u300/Kconfig \
+	arch/arm/mach-s5pc100/Kconfig \
+	arch/arm/plat-stmp3xxx/Kconfig \
+	arch/arm/mach-s3c6410/Kconfig \
+	arch/arm/mach-s3c6400/Kconfig \
+	arch/arm/mach-s3c2443/Kconfig \
+	arch/arm/mach-s3c2442/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c2410/Kconfig \
+	arch/arm/mach-s3c2400/Kconfig \
+	arch/arm/plat-s5pc1xx/Kconfig \
+	arch/arm/plat-s3c/Kconfig \
+	arch/arm/plat-s3c64xx/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/plat-samsung/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-mmp/Kconfig \
+	arch/arm/plat-pxa/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/mach-ns9xxx/Kconfig \
+	arch/arm/plat-nomadik/Kconfig \
+	arch/arm/mach-nomadik/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-mxc91231/Kconfig \
+	arch/arm/mach-mx25/Kconfig \
+	arch/arm/mach-mx3/Kconfig \
+	arch/arm/mach-mx2/Kconfig \
+	arch/arm/mach-mx1/Kconfig \
+	arch/arm/plat-mxc/Kconfig \
+	arch/arm/mach-mv78xx0/Kconfig \
+	arch/arm/mach-msm/Kconfig \
+	arch/arm/mach-loki/Kconfig \
+	arch/arm/mach-lh7a40x/Kconfig \
+	arch/arm/mach-ks8695/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-gemini/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-dove/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	arch/arm/mach-bcmring/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	arch/arm/mach-aaec2000/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "2.6.33"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -Nur ../linux-2.6.33-lpc313x/include/config/kernel.release ../linux-2.6.33-lpc313x_original/include/config/kernel.release
--- ../linux-2.6.33-lpc313x/include/config/kernel.release	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/config/kernel.release	2012-10-07 01:51:11.000000000 +0200
@@ -0,0 +1 @@
+2.6.33-gcf33f41-dirty
diff -Nur ../linux-2.6.33-lpc313x/include/config/tristate.conf ../linux-2.6.33-lpc313x_original/include/config/tristate.conf
--- ../linux-2.6.33-lpc313x/include/config/tristate.conf	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/config/tristate.conf	2012-10-07 01:51:07.000000000 +0200
@@ -0,0 +1,180 @@
+#
+# Automatically generated - do not edit
+
+CONFIG_CAN_MCP251X=M
+CONFIG_CAN_BCM=M
+CONFIG_INPUT_POLLDEV=Y
+CONFIG_BT_HCIUART=M
+CONFIG_IP_NF_TARGET_TTL=Y
+CONFIG_INET6_XFRM_MODE_BEET=Y
+CONFIG_CRYPTO_BLKCIPHER2=Y
+CONFIG_VIDEO_V4L2_COMMON=Y
+CONFIG_CRYPTO_MD5=Y
+CONFIG_CRYPTO_WORKQUEUE=Y
+CONFIG_USB_SERIAL=M
+CONFIG_CRYPTO_ECB=Y
+CONFIG_MEDIA_TUNER_XC5000=Y
+CONFIG_BLK_DEV_SD=Y
+CONFIG_RT2X00_LIB_USB=M
+CONFIG_SERIO_SERPORT=Y
+CONFIG_CAN_DEV=M
+CONFIG_USB_G_PRINTER=M
+CONFIG_MEDIA_TUNER_XC2028=Y
+CONFIG_I2C_PNX=Y
+CONFIG_CHR_DEV_SG=Y
+CONFIG_IP_NF_MATCH_ADDRTYPE=Y
+CONFIG_LPC313x_ADC=M
+CONFIG_SPI_SPIDEV=Y
+CONFIG_KEYBOARD_ATKBD=Y
+CONFIG_SPI_LPC313X=Y
+CONFIG_CRYPTO_AES=Y
+CONFIG_USB_ACM=M
+CONFIG_I2C_CHARDEV=Y
+CONFIG_USB_USBNET=M
+CONFIG_EXT2_FS=Y
+CONFIG_CAN_RAW=M
+CONFIG_USB_HID=M
+CONFIG_NETFILTER_XTABLES=Y
+CONFIG_RTC_LIB=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_IR_CORE=Y
+CONFIG_USB_CDC_COMPOSITE=M
+CONFIG_IPV6=Y
+CONFIG_CRYPTO_RNG=M
+CONFIG_VFAT_FS=Y
+CONFIG_MMC_LPC313x=Y
+CONFIG_USB_ETH=M
+CONFIG_NET_KEY=Y
+CONFIG_SCSI=Y
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_USB_MON=Y
+CONFIG_VIDEO_MEDIA=Y
+CONFIG_CRYPTO_MANAGER=Y
+CONFIG_CRC32=Y
+CONFIG_USB_NET_NET1080=M
+CONFIG_CRC16=M
+CONFIG_IP_NF_IPTABLES=Y
+CONFIG_IP_NF_MATCH_AH=Y
+CONFIG_LPC313x_PWM=M
+CONFIG_CRYPTO_ANSI_CPRNG=M
+CONFIG_UNIX=Y
+CONFIG_BT_L2CAP=M
+CONFIG_SERIAL_CORE=Y
+CONFIG_IP_NF_TARGET_ULOG=Y
+CONFIG_TCP_CONG_WESTWOOD=M
+CONFIG_BT_HCIBTUSB=M
+CONFIG_SCSI_WAIT_SCAN=M
+CONFIG_CRYPTO_ARC4=Y
+CONFIG_MEDIA_TUNER=Y
+CONFIG_BLK_DEV_RAM=Y
+CONFIG_INPUT_MOUSEDEV=Y
+CONFIG_RT2500USB=M
+CONFIG_MEDIA_TUNER_TDA8290=Y
+CONFIG_USB_NET_AX8817X=M
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_MEDIA_TUNER_TEA5761=Y
+CONFIG_CAN_VCAN=M
+CONFIG_IPV6_TUNNEL=Y
+CONFIG_GPIO_PCA953X=M
+CONFIG_USB_STORAGE=Y
+CONFIG_MEDIA_TUNER_TEA5767=Y
+CONFIG_MEDIA_TUNER_MT20XX=Y
+CONFIG_USB_PEGASUS=M
+CONFIG_CRYPTO_HASH=Y
+CONFIG_MEDIA_TUNER_TDA9887=Y
+CONFIG_INET_TUNNEL=Y
+CONFIG_CRYPTO_MANAGER2=Y
+CONFIG_IP_NF_QUEUE=Y
+CONFIG_VIDEO_IR=Y
+CONFIG_IPV6_SIT=Y
+CONFIG_MEDIA_TUNER_SIMPLE=Y
+CONFIG_NETFILTER_XT_MATCH_HL=Y
+CONFIG_NET_IPIP=Y
+CONFIG_R8712U=Y
+CONFIG_USB_NET_ZAURUS=M
+CONFIG_INET_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_AEAD2=Y
+CONFIG_LPC313X_WATCHDOG=Y
+CONFIG_NLS_CODEPAGE_850=Y
+CONFIG_NLS_CODEPAGE_437=Y
+CONFIG_SERIO=Y
+CONFIG_INET_XFRM_MODE_TUNNEL=Y
+CONFIG_DECOMPRESS_LZMA=Y
+CONFIG_USB_ZERO=M
+CONFIG_HWMON=Y
+CONFIG_IP_NF_ARPTABLES=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_IP_NF_MATCH_ECN=Y
+CONFIG_USB_GADGETFS=M
+CONFIG_VIDEO_IR_I2C=Y
+CONFIG_USB_NET_CDC_SUBSET=M
+CONFIG_BT_HCIBTSDIO=M
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_USB_EHCI_HCD=Y
+CONFIG_RT2X00=M
+CONFIG_INPUT=Y
+CONFIG_SENSORS_LM75=M
+CONFIG_MEDIA_TUNER_MC44S803=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_IP_NF_ARPFILTER=Y
+CONFIG_CRYPTO_HASH2=Y
+CONFIG_BT=M
+CONFIG_TCP_CONG_BIC=M
+CONFIG_INET6_TUNNEL=Y
+CONFIG_IP_NF_MANGLE=Y
+CONFIG_IP_VS=Y
+CONFIG_NLS_ISO8859_1=Y
+CONFIG_MMC_BLOCK=Y
+CONFIG_USB_FSL_USB2=Y
+CONFIG_IP_NF_MATCH_TTL=Y
+CONFIG_USB_G_SERIAL=M
+CONFIG_BLK_DEV_LOOP=Y
+CONFIG_IP_NF_FILTER=Y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
+CONFIG_FW_LOADER=Y
+CONFIG_VIDEO_DEV=Y
+CONFIG_USB_GSPCA_PAC7311=M
+CONFIG_USB_GSPCA_PAC7302=M
+CONFIG_USB_GSPCA=M
+CONFIG_PACKET=Y
+CONFIG_BT_RFCOMM=M
+CONFIG_INET6_XFRM_MODE_TUNNEL=Y
+CONFIG_DECOMPRESS_BZIP2=Y
+CONFIG_NET_IPGRE=Y
+CONFIG_I2C=Y
+CONFIG_CRYPTO_PCOMP=Y
+CONFIG_RT2X00_LIB=M
+CONFIG_CFG80211=Y
+CONFIG_MAC80211=Y
+CONFIG_IP_NF_TARGET_REJECT=Y
+CONFIG_INET_XFRM_MODE_BEET=Y
+CONFIG_USB_NET_CDCETHER=M
+CONFIG_NETFILTER_XT_TARGET_HL=Y
+CONFIG_CAN=M
+CONFIG_FAT_FS=Y
+CONFIG_CRYPTO_BLKCIPHER=Y
+CONFIG_HID=M
+CONFIG_IP_NF_RAW=Y
+CONFIG_USB_SERIAL_FTDI_SIO=M
+CONFIG_USB_FILE_STORAGE=M
+CONFIG_VIDEO_V4L1=Y
+CONFIG_MMC=Y
+CONFIG_VIDEO_V4L2=Y
+CONFIG_MII=M
+CONFIG_SENSORS_SHT15=M
+CONFIG_IP_NF_ARP_MANGLE=Y
+CONFIG_CRYPTO=Y
+CONFIG_USB_SERIAL_CP210X=M
+CONFIG_IP_NF_TARGET_ECN=Y
+CONFIG_USB=Y
+CONFIG_NLS=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_SERIAL_8250=Y
+CONFIG_ENC28J60=M
+CONFIG_USB_MASS_STORAGE=M
+CONFIG_IP_NF_TARGET_LOG=Y
+CONFIG_USB_GADGET=Y
+CONFIG_BITREVERSE=Y
+CONFIG_TCP_CONG_HTCP=M
+CONFIG_MEDIA_SUPPORT=Y
+CONFIG_LEDS_CLASS=M
diff -Nur ../linux-2.6.33-lpc313x/include/generated/autoconf.h ../linux-2.6.33-lpc313x_original/include/generated/autoconf.h
--- ../linux-2.6.33-lpc313x/include/generated/autoconf.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/generated/autoconf.h	2012-10-07 01:51:07.000000000 +0200
@@ -0,0 +1,474 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.33
+ * Sun Oct  7 01:51:07 2012
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_VIDEO_V4L1_COMPAT 1
+#define CONFIG_CAN_MCP251X_MODULE 1
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_DEFAULT_SECURITY_DAC 1
+#define CONFIG_CAN_BCM_MODULE 1
+#define CONFIG_VIDEO_HELPER_CHIPS_AUTO 1
+#define CONFIG_CPU_COPY_V4WB 1
+#define CONFIG_INPUT_POLLDEV 1
+#define CONFIG_BT_HCIUART_MODULE 1
+#define CONFIG_IP_NF_TARGET_TTL 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_RT2X00_LIB_CRYPTO 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_LEDS_TIMER 1
+#define CONFIG_VMSPLIT_3G 1
+#define CONFIG_USB_SERIAL_MODULE 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_MEDIA_TUNER_XC5000 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_BROKEN_ON_SMP 1
+#define CONFIG_STAGING 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_RT2X00_LIB_USB_MODULE 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_CAN_DEV_MODULE 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_PM_VERBOSE 1
+#define CONFIG_USB_G_PRINTER_MODULE 1
+#define CONFIG_MEDIA_TUNER_XC2028 1
+#define CONFIG_I2C_PNX 1
+#define CONFIG_FREEZER 1
+#define CONFIG_ARM_UNWIND 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_IP_NF_MATCH_ADDRTYPE 1
+#define CONFIG_LPC313x_ADC_MODULE 1
+#define CONFIG_SPI_SPIDEV 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_BLK_DEV 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_SPI_LPC313X 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_MODULES 1
+#define CONFIG_USB_ACM_MODULE 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_USB_USBNET_MODULE 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_EXT2_FS 1
+#define CONFIG_CAN_RAW_MODULE 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_CPU_ARM926T 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_USB_HID_MODULE 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_INLINE_WRITE_UNLOCK_IRQ 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+#define CONFIG_DETECT_SOFTLOCKUP 1
+#define CONFIG_RADIO_ADAPTERS 1
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_SUSPEND 1
+#define CONFIG_SLAB 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_IR_CORE 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_USB_STORAGE_DEBUG 1
+#define CONFIG_USB_CDC_COMPOSITE_MODULE 1
+#define CONFIG_MAC80211_RC_DEFAULT "minstrel"
+#define CONFIG_IPV6 1
+#define CONFIG_GPIO_SYSFS 1
+#define CONFIG_CRYPTO_RNG_MODULE 1
+#define CONFIG_ARPD 1
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_LEDS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_RD_LZMA 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_MMC_LPC313x 1
+#define CONFIG_USB_ETH_MODULE 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_NEW_LPC313x_IO 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_INET 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_DEBUG_MEMORY_INIT 1
+#define CONFIG_WLAN 1
+#define CONFIG_SCSI 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_USB_MON 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_SWAP 1
+#define CONFIG_XFRM 1
+#define CONFIG_CPU_ABRT_EV5TJ 1
+#define CONFIG_CRC32 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_OABI_COMPAT 1
+#define CONFIG_USB_NET_NET1080_MODULE 1
+#define CONFIG_CRC16_MODULE 1
+#define CONFIG_IP_NF_IPTABLES 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_EXTRA_FIRMWARE "rtlwifi/rtl8712u.bin"
+#define CONFIG_IP_NF_MATCH_AH 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_LPC313x_PWM_MODULE 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_PACKET_MMAP 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_CPU_CACHE_VIVT 1
+#define CONFIG_CRYPTO_ANSI_CPRNG_MODULE 1
+#define CONFIG_UNIX 1
+#define CONFIG_BT_L2CAP_MODULE 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_IP_NF_TARGET_ULOG 1
+#define CONFIG_TCP_CONG_WESTWOOD_MODULE 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_BT_HCIBTUSB_MODULE 1
+#define CONFIG_UID16 1
+#define CONFIG_USB_EHCI_ROOT_HUB_TT 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_CAN_CALC_BITTIMING 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_ARCH_LPC313X 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_ARM_L1_CACHE_SHIFT 5
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_RT2X00_LIB_LEDS 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_GENERIC_FIND_LAST_BIT 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_WATCHDOG 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 999999
+#define CONFIG_AEABI 1
+#define CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_RT2500USB_MODULE 1
+#define CONFIG_CPU_32v5 1
+#define CONFIG_MEDIA_TUNER_TDA8290 1
+#define CONFIG_USB_NET_AX8817X_MODULE 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_MEDIA_TUNER_TEA5761 1
+#define CONFIG_CAN_VCAN_MODULE 1
+#define CONFIG_LBDAF 1
+#define CONFIG_IPV6_TUNNEL 1
+#define CONFIG_KERNEL_GZIP 1
+#define CONFIG_GPIO_PCA953X_MODULE 1
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_RD_BZIP2 1
+#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_MEDIA_TUNER_TEA5767 1
+#define CONFIG_MEDIA_TUNER_MT20XX 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 1
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_IPV6_MROUTE 1
+#define CONFIG_USB_PEGASUS_MODULE 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_PM_DEBUG 1
+#define CONFIG_DEFAULT_IOSCHED "noop"
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_IP_PIMSM_V1 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_MEDIA_TUNER_TDA9887 1
+#define CONFIG_IP_PIMSM_V2 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_INLINE_READ_UNLOCK 1
+#define CONFIG_BLK_DEV_XIP 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_IP_VS_TAB_BITS 12
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_BLOCK 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE 0
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_LEDS_CPU 1
+#define CONFIG_IP_NF_QUEUE 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_VIDEO_IR 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_FIRMWARE_IN_KERNEL 1
+#define CONFIG_CFG80211_WEXT 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_MEDIA_TUNER_SIMPLE 1
+#define CONFIG_NETFILTER_XT_MATCH_HL 1
+#define CONFIG_NET_IPIP 1
+#define CONFIG_R8712U 1
+#define CONFIG_USB_NET_ZAURUS_MODULE 1
+#define CONFIG_TREE_RCU 1
+#define CONFIG_IP_PNP_RARP 1
+#define CONFIG_SHMEM 1
+#define CONFIG_INET_LRO 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_EPOLL 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_LPC313X_WATCHDOG 1
+#define CONFIG_EXTRA_FIRMWARE_DIR "/home/brenson/gnublin-buildroot-git/buildroot-2011.11/target/device/Gnublin/"
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_NLS_CODEPAGE_850 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_SERIO 1
+#define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
+#define CONFIG_INLINE_SPIN_UNLOCK 1
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_DECOMPRESS_LZMA 1
+#define CONFIG_USB_ZERO_MODULE 1
+#define CONFIG_HWMON 1
+#define CONFIG_IP_NF_ARPTABLES 1
+#define CONFIG_TMPFS 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_FUTEX 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_IP_NF_MATCH_ECN 1
+#define CONFIG_USB_GADGETFS_MODULE 1
+#define CONFIG_VIDEO_IR_I2C 1
+#define CONFIG_USB_NET_CDC_SUBSET_MODULE 1
+#define CONFIG_MAC80211_RC_MINSTREL 1
+#define CONFIG_BT_HCIBTSDIO_MODULE 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_RT2X00_MODULE 1
+#define CONFIG_INPUT 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_SENSORS_LM75_MODULE 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_MEDIA_TUNER_MC44S803 1
+#define CONFIG_DEBUG_DRIVER 1
+#define CONFIG_HZ_100 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_IP_NF_ARPFILTER 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_BT_MODULE 1
+#define CONFIG_SYSFS 1
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_TCP_CONG_BIC_MODULE 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_INET6_TUNNEL 1
+#define CONFIG_CAN_PM_TRACE 1
+#define CONFIG_USB_GADGET_SELECTED 1
+#define CONFIG_V4L_USB_DRIVERS 1
+#define CONFIG_PM 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_IP_NF_MANGLE 1
+#define CONFIG_USB_EHCI_LPC 1
+#define CONFIG_DEFAULT_NOOP 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_IP_VS 1
+#define CONFIG_HZ 100
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_USB_FSL_USB2 1
+#define CONFIG_VT 1
+#define CONFIG_IP_NF_MATCH_TTL 1
+#define CONFIG_PREEMPT_NONE 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_USB_G_SERIAL_MODULE 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_NET_IPGRE_BROADCAST 1
+#define CONFIG_USB_DEBUG 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_INLINE_READ_UNLOCK_IRQ 1
+#define CONFIG_IP_NF_FILTER 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_USB_GADGET_FSL_USB2 1
+#define CONFIG_FTRACE 1
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_WIRELESS_EXT_SYSFS 1
+#define CONFIG_USB_GSPCA_PAC7311_MODULE 1
+#define CONFIG_USB_GSPCA_PAC7302_MODULE 1
+#define CONFIG_USB_GSPCA_MODULE 1
+#define CONFIG_PACKET 1
+#define CONFIG_USB_ARMLINUX 1
+#define CONFIG_BT_RFCOMM_MODULE 1
+#define CONFIG_CONSTRUCTORS 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_FPE_NWFPE 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_VIDEO_ALLOW_V4L1 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_DECOMPRESS_BZIP2 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_NET_IPGRE 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_I2C 1
+#define CONFIG_CRYPTO_PCOMP 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_RT2X00_LIB_MODULE 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_IP_PNP_BOOTP 1
+#define CONFIG_DEFAULT_CUBIC 1
+#define CONFIG_CFG80211 1
+#define CONFIG_UACCESS_WITH_MEMCPY 1
+#define CONFIG_MAC80211 1
+#define CONFIG_USB_DEVICE_CLASS 1
+#define CONFIG_IP_NF_TARGET_REJECT 1
+#define CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_WEXT_CORE 1
+#define CONFIG_USB_NET_CDCETHER_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_HL 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_HWMON_DEBUG_CHIP 1
+#define CONFIG_CAN_MODULE 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_IP_MROUTE 1
+#define CONFIG_CPU_PABRT_LEGACY 1
+#define CONFIG_INLINE_WRITE_UNLOCK 1
+#define CONFIG_HID_MODULE 1
+#define CONFIG_IP_NF_RAW 1
+#define CONFIG_NLATTR 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_PRINTK 1
+#define CONFIG_USB_SERIAL_FTDI_SIO_MODULE 1
+#define CONFIG_AIO 1
+#define CONFIG_SERIAL_8250_NR_UARTS 1
+#define CONFIG_WEXT_PROC 1
+#define CONFIG_DEFAULT_SECURITY ""
+#define CONFIG_DETECT_HUNG_TASK 1
+#define CONFIG_USB_FILE_STORAGE_MODULE 1
+#define CONFIG_VIDEO_V4L1 1
+#define CONFIG_MMC 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_BUG 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_MII_MODULE 1
+#define CONFIG_NAMESPACES 1
+#define CONFIG_ARM 1
+#define CONFIG_SENSORS_SHT15_MODULE 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_IP_NF_ARP_MANGLE 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_USB_SERIAL_CP210X_MODULE 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_ZONE_DMA_FLAG 0
+#define CONFIG_IP_NF_TARGET_ECN 1
+#define CONFIG_NET 1
+#define CONFIG_WEXT_PRIV 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_USB 1
+#define CONFIG_USB_GADGET_DUALSPEED 1
+#define CONFIG_SPI 1
+#define CONFIG_NLS 1
+#define CONFIG_MACH_EA313X 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_TCP_MD5SIG 1
+#define CONFIG_MMU 1
+#define CONFIG_ENC28J60_MODULE 1
+#define CONFIG_BLK_DEV_RAM_SIZE 8192
+#define CONFIG_USB_MASS_STORAGE_MODULE 1
+#define CONFIG_IPV6_PIMSM_V2 1
+#define CONFIG_IPV6_SUBTREES 1
+#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
+#define CONFIG_IP_NF_TARGET_LOG 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CPU_TLB_V4WBI 1
+#define CONFIG_USB_GADGET 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_USB_PWC_INPUT_EVDEV 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_TCP_CONG_HTCP_MODULE 1
+#define CONFIG_LOG_BUF_SHIFT 14
+#define CONFIG_MEDIA_SUPPORT 1
+#define CONFIG_CMDLINE "console=ttyS0,115200n8 root=/dev/ram0 rw"
+#define CONFIG_LEDS_CLASS_MODULE 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_USB_BELKIN 1
+#define CONFIG_HIGHMEM 1
diff -Nur ../linux-2.6.33-lpc313x/include/generated/compile.h ../linux-2.6.33-lpc313x_original/include/generated/compile.h
--- ../linux-2.6.33-lpc313x/include/generated/compile.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/generated/compile.h	2012-10-07 01:54:33.000000000 +0200
@@ -0,0 +1,8 @@
+/* This file is auto generated, version 2 */
+#define UTS_MACHINE "arm"
+#define UTS_VERSION "#2 Sun Oct 7 01:54:33 CEST 2012"
+#define LINUX_COMPILE_TIME "01:54:33"
+#define LINUX_COMPILE_BY "brenson"
+#define LINUX_COMPILE_HOST "brenson-N53SN"
+#define LINUX_COMPILE_DOMAIN
+#define LINUX_COMPILER "gcc version 4.3.6 (Buildroot 2011.11-ge7a4474-dirty) "
diff -Nur ../linux-2.6.33-lpc313x/include/generated/mach-types.h ../linux-2.6.33-lpc313x_original/include/generated/mach-types.h
--- ../linux-2.6.33-lpc313x/include/generated/mach-types.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/generated/mach-types.h	2012-10-06 18:29:30.000000000 +0200
@@ -0,0 +1,34669 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_NEXUSPCI             3
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_TBOX                 7
+#define MACH_TYPE_CO285                8
+#define MACH_TYPE_CLPS7110             9
+#define MACH_TYPE_ARCHIMEDES           10
+#define MACH_TYPE_A5K                  11
+#define MACH_TYPE_ETOILE               12
+#define MACH_TYPE_LACIE_NAS            13
+#define MACH_TYPE_CLPS7500             14
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_ITSY                 18
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_IXP1200              23
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_VICTOR               26
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_RANGER               28
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_FPIC                 33
+#define MACH_TYPE_EXTENEX1             34
+#define MACH_TYPE_SHERMAN              35
+#define MACH_TYPE_ACCELENT_SA          36
+#define MACH_TYPE_ACCELENT_L7200       37
+#define MACH_TYPE_NETPORT              38
+#define MACH_TYPE_PANGOLIN             39
+#define MACH_TYPE_YOPY                 40
+#define MACH_TYPE_COOLIDGE             41
+#define MACH_TYPE_HUW_WEBPANEL         42
+#define MACH_TYPE_SPOTME               43
+#define MACH_TYPE_FREEBIRD             44
+#define MACH_TYPE_TI925                45
+#define MACH_TYPE_RISCSTATION          46
+#define MACH_TYPE_CAVY                 47
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_OMNIMETER            49
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_CITYGO               51
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_SPOT                 53
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_WEBPAL               55
+#define MACH_TYPE_LINPDA               56
+#define MACH_TYPE_ANAKIN               57
+#define MACH_TYPE_MVI                  58
+#define MACH_TYPE_JUPITER              59
+#define MACH_TYPE_PSIONW               60
+#define MACH_TYPE_ALN                  61
+#define MACH_TYPE_CAMELOT              62
+#define MACH_TYPE_GDS2200              63
+#define MACH_TYPE_PSION_SERIES7        64
+#define MACH_TYPE_XFILE                65
+#define MACH_TYPE_ACCELENT_EP9312      66
+#define MACH_TYPE_IC200                67
+#define MACH_TYPE_CREDITLART           68
+#define MACH_TYPE_HTM                  69
+#define MACH_TYPE_IQ80310              70
+#define MACH_TYPE_FREEBOT              71
+#define MACH_TYPE_ENTEL                72
+#define MACH_TYPE_ENP3510              73
+#define MACH_TYPE_TRIZEPS              74
+#define MACH_TYPE_NESA                 75
+#define MACH_TYPE_VENUS                76
+#define MACH_TYPE_TARDIS               77
+#define MACH_TYPE_MERCURY              78
+#define MACH_TYPE_EMPEG                79
+#define MACH_TYPE_I80200FCC            80
+#define MACH_TYPE_ITT_CPB              81
+#define MACH_TYPE_SVC                  82
+#define MACH_TYPE_ALPHA2               84
+#define MACH_TYPE_ALPHA1               85
+#define MACH_TYPE_NETARM               86
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_PDA1                 88
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_ANIKO                90
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_CS89712              92
+#define MACH_TYPE_WEARARM              93
+#define MACH_TYPE_POSSIO_PX            94
+#define MACH_TYPE_SIDEARM              95
+#define MACH_TYPE_STORK                96
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_ACE                  98
+#define MACH_TYPE_BALLYARM             99
+#define MACH_TYPE_SIMPUTER             100
+#define MACH_TYPE_NEXTERM              101
+#define MACH_TYPE_SA1100_ELF           102
+#define MACH_TYPE_GATOR                103
+#define MACH_TYPE_GRANITE              104
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PLCE                 111
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_MEDALB               113
+#define MACH_TYPE_EAGLE                114
+#define MACH_TYPE_DSC21                115
+#define MACH_TYPE_DSC24                116
+#define MACH_TYPE_TI5472               117
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_UENGINE              119
+#define MACH_TYPE_BLUESTEM             120
+#define MACH_TYPE_XINGU8               121
+#define MACH_TYPE_BUSHSTB              122
+#define MACH_TYPE_EPSILON1             123
+#define MACH_TYPE_BALLOON              124
+#define MACH_TYPE_PUPPY                125
+#define MACH_TYPE_ELROY                126
+#define MACH_TYPE_GMS720               127
+#define MACH_TYPE_S24X                 128
+#define MACH_TYPE_JTEL_CLEP7312        129
+#define MACH_TYPE_CX821XX              130
+#define MACH_TYPE_EDB7312              131
+#define MACH_TYPE_BSA1110              132
+#define MACH_TYPE_POWERPIN             133
+#define MACH_TYPE_OPENARM              134
+#define MACH_TYPE_WHITECHAPEL          135
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_H3800                137
+#define MACH_TYPE_BLUE_V1              138
+#define MACH_TYPE_PXA_CERF             139
+#define MACH_TYPE_ARM7TEVB             140
+#define MACH_TYPE_D7400                141
+#define MACH_TYPE_PIRANHA              142
+#define MACH_TYPE_SBCAMELOT            143
+#define MACH_TYPE_KINGS                144
+#define MACH_TYPE_SMDK2400             145
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_IDR                  147
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_WEBNET               149
+#define MACH_TYPE_D7300                150
+#define MACH_TYPE_CEP                  151
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_VC547X               153
+#define MACH_TYPE_FILEWALKER           154
+#define MACH_TYPE_NETGATEWAY           155
+#define MACH_TYPE_SYMBOL2800           156
+#define MACH_TYPE_SUNS                 157
+#define MACH_TYPE_FRODO                158
+#define MACH_TYPE_MACH_TYTE_MS301      159
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_AMICO                163
+#define MACH_TYPE_IAM                  164
+#define MACH_TYPE_TT530                165
+#define MACH_TYPE_SAM2400              166
+#define MACH_TYPE_JORNADA56X           167
+#define MACH_TYPE_ACTIVE               168
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_WID                  170
+#define MACH_TYPE_SABINAL              171
+#define MACH_TYPE_IXP425_MATACUMBE     172
+#define MACH_TYPE_MINIPRINT            173
+#define MACH_TYPE_ADM510X              174
+#define MACH_TYPE_SVS200               175
+#define MACH_TYPE_ATG_TCU              176
+#define MACH_TYPE_JORNADA820           177
+#define MACH_TYPE_S3C44B0              178
+#define MACH_TYPE_MARGIS2              179
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_BRH                  181
+#define MACH_TYPE_S3C2410              182
+#define MACH_TYPE_POSSIO_PX30          183
+#define MACH_TYPE_S3C2800              184
+#define MACH_TYPE_FLEETWOOD            185
+#define MACH_TYPE_OMAHA                186
+#define MACH_TYPE_TA7                  187
+#define MACH_TYPE_NOVA                 188
+#define MACH_TYPE_HMK                  189
+#define MACH_TYPE_KARO                 190
+#define MACH_TYPE_FESTER               191
+#define MACH_TYPE_GPI                  192
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_I519                 194
+#define MACH_TYPE_NEXIO                195
+#define MACH_TYPE_BITBOX               196
+#define MACH_TYPE_G200                 197
+#define MACH_TYPE_GILL                 198
+#define MACH_TYPE_PXA_MERCURY          199
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_FRET                 201
+#define MACH_TYPE_EMAILPHONE           202
+#define MACH_TYPE_H3900                203
+#define MACH_TYPE_PXA1                 204
+#define MACH_TYPE_KOAN369              205
+#define MACH_TYPE_COGENT               206
+#define MACH_TYPE_ESL_SIMPUTER         207
+#define MACH_TYPE_ESL_SIMPUTER_CLR     208
+#define MACH_TYPE_ESL_SIMPUTER_BW      209
+#define MACH_TYPE_HHP_CRADLE           210
+#define MACH_TYPE_HE500                211
+#define MACH_TYPE_INHANDELF2           212
+#define MACH_TYPE_INHANDFTIP           213
+#define MACH_TYPE_DNP1110              214
+#define MACH_TYPE_PNP1110              215
+#define MACH_TYPE_CSB226               216
+#define MACH_TYPE_ARNOLD               217
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_JZ8028               219
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_FORTE                221
+#define MACH_TYPE_ACAM                 222
+#define MACH_TYPE_ABOX                 223
+#define MACH_TYPE_ATMEL                224
+#define MACH_TYPE_SITSANG              225
+#define MACH_TYPE_CPU1110LCDNET        226
+#define MACH_TYPE_MPL_VCMA9            227
+#define MACH_TYPE_OPUS_A1              228
+#define MACH_TYPE_DAYTONA              229
+#define MACH_TYPE_KILLBEAR             230
+#define MACH_TYPE_YOHO                 231
+#define MACH_TYPE_JASPER               232
+#define MACH_TYPE_DSC25                233
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_RAMSES               235
+#define MACH_TYPE_S28X                 236
+#define MACH_TYPE_MPORT3               237
+#define MACH_TYPE_PXA_EAGLE250         238
+#define MACH_TYPE_PDB                  239
+#define MACH_TYPE_BLUE_2G              240
+#define MACH_TYPE_BLUEARCH             241
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_EXPLORER             244
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_CHIMP                246
+#define MACH_TYPE_STORK_NEST           247
+#define MACH_TYPE_STORK_EGG            248
+#define MACH_TYPE_WISMO                249
+#define MACH_TYPE_EZLINX               250
+#define MACH_TYPE_AT91RM9200           251
+#define MACH_TYPE_ADTECH_ORION         252
+#define MACH_TYPE_NEPTUNE              253
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_PXA_WINS30           255
+#define MACH_TYPE_LAVINNA              256
+#define MACH_TYPE_PXA_UENGINE          257
+#define MACH_TYPE_INNOKOM              258
+#define MACH_TYPE_BMS                  259
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_PRPMC1100            261
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_ARMSTICK             263
+#define MACH_TYPE_ARMONIE              264
+#define MACH_TYPE_MPORT1               265
+#define MACH_TYPE_S3C5410              266
+#define MACH_TYPE_ZCP320A              267
+#define MACH_TYPE_I_BOX                268
+#define MACH_TYPE_STLC1502             269
+#define MACH_TYPE_SIREN                270
+#define MACH_TYPE_GREENLAKE            271
+#define MACH_TYPE_ARGUS                272
+#define MACH_TYPE_COMBADGE             273
+#define MACH_TYPE_ROKEPXA              274
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_GUIDEA07             276
+#define MACH_TYPE_TAT257               277
+#define MACH_TYPE_IGP2425              278
+#define MACH_TYPE_BLUEGRAMMA           279
+#define MACH_TYPE_IPOD                 280
+#define MACH_TYPE_ADSBITSYX            281
+#define MACH_TYPE_TRIZEPS2             282
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADSBITSYPLUS         284
+#define MACH_TYPE_ADSAGC               285
+#define MACH_TYPE_STP7312              286
+#define MACH_TYPE_NX_PHNX              287
+#define MACH_TYPE_WEP_EP250            288
+#define MACH_TYPE_INHANDELF3           289
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IYONIX               291
+#define MACH_TYPE_DAMICAM_SA1110       292
+#define MACH_TYPE_MEG03                293
+#define MACH_TYPE_PXA_WHITECHAPEL      294
+#define MACH_TYPE_NWSC                 295
+#define MACH_TYPE_NWLARM               296
+#define MACH_TYPE_IXP425_MGUARD        297
+#define MACH_TYPE_PXA_NETDCU4          298
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_ZODIAC               301
+#define MACH_TYPE_ARMMODUL             302
+#define MACH_TYPE_KETOP                303
+#define MACH_TYPE_AV7200               304
+#define MACH_TYPE_ARCH_TI925           305
+#define MACH_TYPE_ACQ200               306
+#define MACH_TYPE_PT_DAFIT             307
+#define MACH_TYPE_IHBA                 308
+#define MACH_TYPE_QUINQUE              309
+#define MACH_TYPE_NIMBRAONE            310
+#define MACH_TYPE_NIMBRA29X            311
+#define MACH_TYPE_NIMBRA210            312
+#define MACH_TYPE_HHP_D95XX            313
+#define MACH_TYPE_LABARM               314
+#define MACH_TYPE_M825XX               315
+#define MACH_TYPE_M7100                316
+#define MACH_TYPE_NIPC2                317
+#define MACH_TYPE_FU7202               318
+#define MACH_TYPE_ADSAGX               319
+#define MACH_TYPE_PXA_POOH             320
+#define MACH_TYPE_BANDON               321
+#define MACH_TYPE_PCM7210              322
+#define MACH_TYPE_NMS9200              323
+#define MACH_TYPE_LOGODL               324
+#define MACH_TYPE_M7140                325
+#define MACH_TYPE_KOREBOT              326
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_KOAN393              328
+#define MACH_TYPE_INHANDFTIP3          329
+#define MACH_TYPE_GONZO                330
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_SCANPASS             332
+#define MACH_TYPE_EP7312_POOH          333
+#define MACH_TYPE_TA7S                 334
+#define MACH_TYPE_TA7V                 335
+#define MACH_TYPE_ICARUS               336
+#define MACH_TYPE_H1900                337
+#define MACH_TYPE_GEMINI               338
+#define MACH_TYPE_AXIM                 339
+#define MACH_TYPE_AUDIOTRON            340
+#define MACH_TYPE_H2200                341
+#define MACH_TYPE_LOOX600              342
+#define MACH_TYPE_NIOP                 343
+#define MACH_TYPE_DM310                344
+#define MACH_TYPE_SEEDPXA_C2           345
+#define MACH_TYPE_IXP4XX_MGUARD_PCI    346
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_SCORPIO              348
+#define MACH_TYPE_VIVA                 349
+#define MACH_TYPE_PXA_XCARD            350
+#define MACH_TYPE_CSB335               351
+#define MACH_TYPE_IXRD425              352
+#define MACH_TYPE_IQ80315              353
+#define MACH_TYPE_NMP7312              354
+#define MACH_TYPE_CX861XX              355
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_XDA                  357
+#define MACH_TYPE_CSIR_IMS             358
+#define MACH_TYPE_IXP421_DNAEETH       359
+#define MACH_TYPE_POCKETSERV9200       360
+#define MACH_TYPE_TOTO                 361
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_KS8695P              363
+#define MACH_TYPE_SE4000               364
+#define MACH_TYPE_QUADRICEPS           365
+#define MACH_TYPE_BRONCO               366
+#define MACH_TYPE_ESL_WIRELESS_TAB     367
+#define MACH_TYPE_ESL_SOFCOMP          368
+#define MACH_TYPE_S5C7375              369
+#define MACH_TYPE_SPEARHEAD            370
+#define MACH_TYPE_PANTERA              371
+#define MACH_TYPE_PRAYOGLITE           372
+#define MACH_TYPE_GUMSTIX              373
+#define MACH_TYPE_RCUBE                374
+#define MACH_TYPE_REA_OLV              375
+#define MACH_TYPE_PXA_IPHONE           376
+#define MACH_TYPE_S3C3410              377
+#define MACH_TYPE_ESPD_4510B           378
+#define MACH_TYPE_MP1X                 379
+#define MACH_TYPE_AT91RM9200TB         380
+#define MACH_TYPE_ADSVGX               381
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_PELEE                383
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_FUJITSU_CAMELOT      391
+#define MACH_TYPE_JANUS2M              392
+#define MACH_TYPE_EMBTF                393
+#define MACH_TYPE_HPM                  394
+#define MACH_TYPE_SMDK2410TK           395
+#define MACH_TYPE_SMDK2410AJ           396
+#define MACH_TYPE_STREETRACER          397
+#define MACH_TYPE_EFRAME               398
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_PXA_LARK             400
+#define MACH_TYPE_PNP2110              401
+#define MACH_TYPE_TCC72X               402
+#define MACH_TYPE_ALTAIR               403
+#define MACH_TYPE_KC3                  404
+#define MACH_TYPE_SINTEFTD             405
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_ADAY4X               407
+#define MACH_TYPE_LITE300              408
+#define MACH_TYPE_S5C7376              409
+#define MACH_TYPE_MT02                 410
+#define MACH_TYPE_MPORT3S              411
+#define MACH_TYPE_RA_ALPHA             412
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_STARGATE             415
+#define MACH_TYPE_ARMADILLOJ           416
+#define MACH_TYPE_ELROY_JACK           417
+#define MACH_TYPE_BACKEND              418
+#define MACH_TYPE_S5LINBOX             419
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_IA_CPU_9200          421
+#define MACH_TYPE_AT91_BJA1            422
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_TEN                  425
+#define MACH_TYPE_ROVERP5P             426
+#define MACH_TYPE_SC2700               427
+#define MACH_TYPE_EX_EAGLE             428
+#define MACH_TYPE_NX_PXA12             429
+#define MACH_TYPE_NX_PXA5              430
+#define MACH_TYPE_BLACKBOARD2          431
+#define MACH_TYPE_I819                 432
+#define MACH_TYPE_IXMB995E             433
+#define MACH_TYPE_SKYRIDER             434
+#define MACH_TYPE_SKYHAWK              435
+#define MACH_TYPE_ENTERPRISE           436
+#define MACH_TYPE_DEP2410              437
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_HOBBIT               439
+#define MACH_TYPE_H7210                440
+#define MACH_TYPE_PXA_NETDCU5          441
+#define MACH_TYPE_ACC                  442
+#define MACH_TYPE_ESL_SARVA            443
+#define MACH_TYPE_XM250                444
+#define MACH_TYPE_T6TC1XB              445
+#define MACH_TYPE_ESS710               446
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_BOLFENK              449
+#define MACH_TYPE_AT91RM9200KR         450
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_AXIMX3               453
+#define MACH_TYPE_EB67XDIP             454
+#define MACH_TYPE_WEBTXS               455
+#define MACH_TYPE_HAWK                 456
+#define MACH_TYPE_CCAT91SBC001         457
+#define MACH_TYPE_EXPRESSO             458
+#define MACH_TYPE_H4000                459
+#define MACH_TYPE_DINO                 460
+#define MACH_TYPE_ML675K               461
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_RECIVA_TT            464
+#define MACH_TYPE_CSTCB01              465
+#define MACH_TYPE_CSTCB1               466
+#define MACH_TYPE_SHADWELL             467
+#define MACH_TYPE_GOEPEL263            468
+#define MACH_TYPE_ACQ100               469
+#define MACH_TYPE_MX1FS2               470
+#define MACH_TYPE_HIPTOP_G1            471
+#define MACH_TYPE_SPARKY               472
+#define MACH_TYPE_NS9750               473
+#define MACH_TYPE_PHOENIX              474
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_DEISTERPXA           476
+#define MACH_TYPE_BCM1160              477
+#define MACH_TYPE_PCM022               478
+#define MACH_TYPE_ADSGCX               479
+#define MACH_TYPE_DREADNAUGHT          480
+#define MACH_TYPE_DM320                481
+#define MACH_TYPE_MARKOV               482
+#define MACH_TYPE_COS7A400             483
+#define MACH_TYPE_MILANO               484
+#define MACH_TYPE_UE9328               485
+#define MACH_TYPE_UEX255               486
+#define MACH_TYPE_UE2410               487
+#define MACH_TYPE_A620                 488
+#define MACH_TYPE_OCELOT               489
+#define MACH_TYPE_CHEETAH              490
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_ZVUE                 492
+#define MACH_TYPE_ROVERP1              493
+#define MACH_TYPE_ASIDIAL2             494
+#define MACH_TYPE_S3C24A0              495
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_S3C5500              498
+#define MACH_TYPE_SMDK5500             499
+#define MACH_TYPE_SIGNALSYNC           500
+#define MACH_TYPE_NBC                  501
+#define MACH_TYPE_KODIAK               502
+#define MACH_TYPE_NETBOOKPRO           503
+#define MACH_TYPE_HW90200              504
+#define MACH_TYPE_CONDOR               505
+#define MACH_TYPE_CUP                  506
+#define MACH_TYPE_KITE                 507
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_N10                  511
+#define MACH_TYPE_MONTAJADE            512
+#define MACH_TYPE_SG560                513
+#define MACH_TYPE_DP1000               514
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_RG100V3              516
+#define MACH_TYPE_MX2ADS               517
+#define MACH_TYPE_PXA_KILO             518
+#define MACH_TYPE_IXP4XX_EAGLE         519
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_MB2520F              521
+#define MACH_TYPE_EMC1000              522
+#define MACH_TYPE_TIDSC25              523
+#define MACH_TYPE_AKCPMXL              524
+#define MACH_TYPE_AV3XX                525
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_PXA_MPM10            527
+#define MACH_TYPE_PXA_KYANITE          528
+#define MACH_TYPE_SGOLD                529
+#define MACH_TYPE_OSCAR                530
+#define MACH_TYPE_EPXA4USB2            531
+#define MACH_TYPE_XSENGINE             532
+#define MACH_TYPE_IP600                533
+#define MACH_TYPE_MCAN2                534
+#define MACH_TYPE_DDI_BLUERIDGE        535
+#define MACH_TYPE_SKYMINDER            536
+#define MACH_TYPE_LPD79520             537
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HW90340              539
+#define MACH_TYPE_CIP_BOX              540
+#define MACH_TYPE_IVPN                 541
+#define MACH_TYPE_RSOC2                542
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_BOXER                544
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_AML42800AA           546
+#define MACH_TYPE_LPC2294              548
+#define MACH_TYPE_SWITCHGRASS          549
+#define MACH_TYPE_ENS_CMU              550
+#define MACH_TYPE_MM6_SDB              551
+#define MACH_TYPE_SATURN               552
+#define MACH_TYPE_I30030EVB            553
+#define MACH_TYPE_MXC27530EVB          554
+#define MACH_TYPE_SMDK2800             555
+#define MACH_TYPE_MTWILSON             556
+#define MACH_TYPE_ZITI                 557
+#define MACH_TYPE_GRANDFATHER          558
+#define MACH_TYPE_TENGINE              559
+#define MACH_TYPE_S3C2460              560
+#define MACH_TYPE_PDM                  561
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_H6300                563
+#define MACH_TYPE_RZ1700               564
+#define MACH_TYPE_A716                 565
+#define MACH_TYPE_ESTK2440A            566
+#define MACH_TYPE_ATWIXP425            567
+#define MACH_TYPE_CSB336               568
+#define MACH_TYPE_RIRM2                569
+#define MACH_TYPE_CX23518              570
+#define MACH_TYPE_CX2351X              571
+#define MACH_TYPE_COMPUTIME            572
+#define MACH_TYPE_IZARUS               573
+#define MACH_TYPE_RTS                  574
+#define MACH_TYPE_SE5100               575
+#define MACH_TYPE_S3C2510              576
+#define MACH_TYPE_CSB437TL             577
+#define MACH_TYPE_SLAUSON              578
+#define MACH_TYPE_PEARLRIVER           579
+#define MACH_TYPE_TDC_P210             580
+#define MACH_TYPE_SG580                581
+#define MACH_TYPE_WRSBCARM7            582
+#define MACH_TYPE_IPD                  583
+#define MACH_TYPE_PXA_DNP2110          584
+#define MACH_TYPE_XAENIAX              585
+#define MACH_TYPE_SOMN4250             586
+#define MACH_TYPE_PLEB2                587
+#define MACH_TYPE_CORNWALLIS           588
+#define MACH_TYPE_GURNEY_DRV           589
+#define MACH_TYPE_CHAFFEE              590
+#define MACH_TYPE_RMS101               591
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_SWIFT                593
+#define MACH_TYPE_ROVERP7              594
+#define MACH_TYPE_PR818S               595
+#define MACH_TYPE_TRXPRO               596
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_TRAB                 599
+#define MACH_TYPE_CMC_PU2              600
+#define MACH_TYPE_FULCRUM              601
+#define MACH_TYPE_NETGATE42X           602
+#define MACH_TYPE_STR710               603
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_TOMTOMGO             605
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_SG565                608
+#define MACH_TYPE_LPD79524             609
+#define MACH_TYPE_LPD79525             610
+#define MACH_TYPE_RMS100               611
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_HMS39C7092           614
+#define MACH_TYPE_ARMADILLO            615
+#define MACH_TYPE_IPCU                 616
+#define MACH_TYPE_LOOX720              617
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_ADSVIX               620
+#define MACH_TYPE_DM270                621
+#define MACH_TYPE_SOCLTPLUS            622
+#define MACH_TYPE_ECIA                 623
+#define MACH_TYPE_CM4008               624
+#define MACH_TYPE_P2001                625
+#define MACH_TYPE_TWISTER              626
+#define MACH_TYPE_MUDSHARK             627
+#define MACH_TYPE_HB2                  628
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_SENDT                630
+#define MACH_TYPE_MX2JAZZ              631
+#define MACH_TYPE_MULTIIO              632
+#define MACH_TYPE_HRDISPLAY            633
+#define MACH_TYPE_MXC27530ADS          634
+#define MACH_TYPE_TRIZEPS3             635
+#define MACH_TYPE_ZEFEERDZA            636
+#define MACH_TYPE_ZEFEERDZB            637
+#define MACH_TYPE_ZEFEERDZG            638
+#define MACH_TYPE_ZEFEERDZN            639
+#define MACH_TYPE_ZEFEERDZQ            640
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_ASTRO_JACK           643
+#define MACH_TYPE_TIP03                644
+#define MACH_TYPE_A9200EC              645
+#define MACH_TYPE_PNX0105              646
+#define MACH_TYPE_ADCPOECPU            647
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_MB9200               650
+#define MACH_TYPE_KULUN                651
+#define MACH_TYPE_SNAPPER              652
+#define MACH_TYPE_OPTIMA               653
+#define MACH_TYPE_DLHSBC               654
+#define MACH_TYPE_X30                  655
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_MANGA_KS8695         657
+#define MACH_TYPE_AJAX                 658
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_VVTK1000             661
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_VVTK3000             663
+#define MACH_TYPE_PIMX1                664
+#define MACH_TYPE_OLLIE                665
+#define MACH_TYPE_SKYMAX               666
+#define MACH_TYPE_JAZZ                 667
+#define MACH_TYPE_TEL_T3               668
+#define MACH_TYPE_AISINO_FCR255        669
+#define MACH_TYPE_BTWEB                670
+#define MACH_TYPE_DBG_LH79520          671
+#define MACH_TYPE_CM41XX               672
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_NGGPXA               674
+#define MACH_TYPE_CSB535               675
+#define MACH_TYPE_CSB536               676
+#define MACH_TYPE_PXA_TRAKPOD          677
+#define MACH_TYPE_PRAXIS               678
+#define MACH_TYPE_LH75411              679
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_LOOX410              682
+#define MACH_TYPE_WESTLAKE             683
+#define MACH_TYPE_NSB                  684
+#define MACH_TYPE_ESL_SARVA_STN        685
+#define MACH_TYPE_ESL_SARVA_TFT        686
+#define MACH_TYPE_ESL_SARVA_IAD        687
+#define MACH_TYPE_ESL_SARVA_ACC        688
+#define MACH_TYPE_TYPHOON              689
+#define MACH_TYPE_CNAV                 690
+#define MACH_TYPE_A730                 691
+#define MACH_TYPE_NETSTAR              692
+#define MACH_TYPE_PHASEFALE_SUPERCON   693
+#define MACH_TYPE_SHIVA1100            694
+#define MACH_TYPE_ETEXSC               695
+#define MACH_TYPE_IXDPG465             696
+#define MACH_TYPE_A9M2410              697
+#define MACH_TYPE_A9M2440              698
+#define MACH_TYPE_A9M9750              699
+#define MACH_TYPE_A9M9360              700
+#define MACH_TYPE_UNC90                701
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_SATVIEW              703
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_GP32                 706
+#define MACH_TYPE_GEM                  707
+#define MACH_TYPE_I858                 708
+#define MACH_TYPE_HX2750               709
+#define MACH_TYPE_MXC91131EVB          710
+#define MACH_TYPE_P700                 711
+#define MACH_TYPE_CPE                  712
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_NIMBRA340            714
+#define MACH_TYPE_LPC22XX              715
+#define MACH_TYPE_COMET3               716
+#define MACH_TYPE_COMET4               717
+#define MACH_TYPE_CSB625               718
+#define MACH_TYPE_FORTUNET2            719
+#define MACH_TYPE_S5H2200              720
+#define MACH_TYPE_OPTORM920            721
+#define MACH_TYPE_ADSBITSYXB           722
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_ADSPORTAL            724
+#define MACH_TYPE_LN2410SBC            725
+#define MACH_TYPE_CB3RUFC              726
+#define MACH_TYPE_MP2USB               727
+#define MACH_TYPE_NTNP425C             728
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_PCM7220              730
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_CMPXA                733
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_ITE8152              735
+#define MACH_TYPE_LPC3XXX              736
+#define MACH_TYPE_PUPPETEER            737
+#define MACH_TYPE_E570                 739
+#define MACH_TYPE_X50                  740
+#define MACH_TYPE_RECON                741
+#define MACH_TYPE_XBOARDGP8            742
+#define MACH_TYPE_FPIC2                743
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_A81                  745
+#define MACH_TYPE_SVM_SC25X            746
+#define MACH_TYPE_VADATECH020          747
+#define MACH_TYPE_TLI                  748
+#define MACH_TYPE_EDB9315LC            749
+#define MACH_TYPE_PASSEC               750
+#define MACH_TYPE_DS_TIGER             751
+#define MACH_TYPE_E310                 752
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_RT3000               754
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_PNX0106              756
+#define MACH_TYPE_HX21XX               757
+#define MACH_TYPE_FARADAY              758
+#define MACH_TYPE_SBC9312              759
+#define MACH_TYPE_BATMAN               760
+#define MACH_TYPE_JPD201               761
+#define MACH_TYPE_MIPSA                762
+#define MACH_TYPE_KACOM                763
+#define MACH_TYPE_SWARCOCPU            764
+#define MACH_TYPE_SWARCODSL            765
+#define MACH_TYPE_BLUEANGEL            766
+#define MACH_TYPE_HAIRYGRAMA           767
+#define MACH_TYPE_BANFF                768
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_SAM255               770
+#define MACH_TYPE_PPM10                771
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_SUNSET               773
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_MAINSTONE2           777
+#define MACH_TYPE_EZ_IXP42X            778
+#define MACH_TYPE_TAPWAVE_ZODIAC       779
+#define MACH_TYPE_UNIVERSALMETER       780
+#define MACH_TYPE_HICOARM9             781
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_KWS6000              783
+#define MACH_TYPE_PORTUX920T           784
+#define MACH_TYPE_EZ_X5                785
+#define MACH_TYPE_OMAP_RUDOLPH         786
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_REA9200              788
+#define MACH_TYPE_ACTS_PUNE_SA1110     789
+#define MACH_TYPE_IXP425               790
+#define MACH_TYPE_I30030ADS            791
+#define MACH_TYPE_PERCH                792
+#define MACH_TYPE_EIS05R1              793
+#define MACH_TYPE_PEPPERPAD            794
+#define MACH_TYPE_SB3010               795
+#define MACH_TYPE_RM9200               796
+#define MACH_TYPE_DMA03                797
+#define MACH_TYPE_ROAD_S101            798
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ_NEXTGEN_B         800
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_IQ_NEXTGEN_D         802
+#define MACH_TYPE_IQ_NEXTGEN_E         803
+#define MACH_TYPE_MALLOW_AT91          804
+#define MACH_TYPE_CYBERTRACKER_I       805
+#define MACH_TYPE_GESBC931X            806
+#define MACH_TYPE_CENTIPAD             807
+#define MACH_TYPE_ARMSOC               808
+#define MACH_TYPE_SE4200               809
+#define MACH_TYPE_EMS197A              810
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_UC5471DSP            813
+#define MACH_TYPE_SJ5471ENG            814
+#define MACH_TYPE_CMPXA26X             815
+#define MACH_TYPE_NC                   816
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_AJAX52X              818
+#define MACH_TYPE_SIRIUSTAR            819
+#define MACH_TYPE_IODATA_HDLG          820
+#define MACH_TYPE_AT91RM9200UTL        821
+#define MACH_TYPE_BIOSAFE              822
+#define MACH_TYPE_MP1000               823
+#define MACH_TYPE_PARSY                824
+#define MACH_TYPE_CCXP                 825
+#define MACH_TYPE_OMAP_GSAMPLE         826
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_SAMOA                828
+#define MACH_TYPE_PALMT3               829
+#define MACH_TYPE_I878                 830
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_GECKO                832
+#define MACH_TYPE_DS101                833
+#define MACH_TYPE_OMAP_PALMTT2         834
+#define MACH_TYPE_PALMLD               835
+#define MACH_TYPE_CC9C                 836
+#define MACH_TYPE_SBC1670              837
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ML696K               840
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_MAESTRO              843
+#define MACH_TYPE_PALMTE2              844
+#define MACH_TYPE_IXBBM                845
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AX8004               847
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MAGPIE               850
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_MB87M3400            852
+#define MACH_TYPE_MGUARD_DELTA         853
+#define MACH_TYPE_DAVINCI_DVDP         854
+#define MACH_TYPE_HTCUNIVERSAL         855
+#define MACH_TYPE_TPAD                 856
+#define MACH_TYPE_ROVERP3              857
+#define MACH_TYPE_JORNADA928           858
+#define MACH_TYPE_MV88FXX81            859
+#define MACH_TYPE_STMP36XX             860
+#define MACH_TYPE_SXNI79524            861
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_URANIUM              863
+#define MACH_TYPE_UCON                 864
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_L083_1000            866
+#define MACH_TYPE_EZX                  867
+#define MACH_TYPE_PNX5220              868
+#define MACH_TYPE_BUTTE                869
+#define MACH_TYPE_SRM2                 870
+#define MACH_TYPE_DSBR                 871
+#define MACH_TYPE_CRYSTALBALL          872
+#define MACH_TYPE_TINYPXA27X           873
+#define MACH_TYPE_HERBIE               874
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_CM4002               876
+#define MACH_TYPE_B4                   877
+#define MACH_TYPE_MAUI                 878
+#define MACH_TYPE_CYBERTRACKER_G       879
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_MIO8390              881
+#define MACH_TYPE_OMI_BOARD            882
+#define MACH_TYPE_MX21CIV              883
+#define MACH_TYPE_MAHI_CDAC            884
+#define MACH_TYPE_PALMTX               885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_SAMSYS_EP0           888
+#define MACH_TYPE_WG302V1              889
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_EB42X                891
+#define MACH_TYPE_IQ331ES              892
+#define MACH_TYPE_COSYDSP              893
+#define MACH_TYPE_UPLAT7D              894
+#define MACH_TYPE_PTDAVINCI            895
+#define MACH_TYPE_MBUS                 896
+#define MACH_TYPE_NADIA2VB             897
+#define MACH_TYPE_R1000                898
+#define MACH_TYPE_HW90250              899
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_OMAP_TORNADO         902
+#define MACH_TYPE_OLOCREEK             903
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_APF9328              906
+#define MACH_TYPE_OMAP_WIPOQ           907
+#define MACH_TYPE_OMAP_TWIP            908
+#define MACH_TYPE_TREO650              909
+#define MACH_TYPE_ACUMEN               910
+#define MACH_TYPE_XP100                911
+#define MACH_TYPE_FS2410               912
+#define MACH_TYPE_PXA270_CERF          913
+#define MACH_TYPE_SQ2FTLPALM           914
+#define MACH_TYPE_BSEMSERVER           915
+#define MACH_TYPE_NETCLIENT            916
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_MXC30030EVB          920
+#define MACH_TYPE_REA_2D               921
+#define MACH_TYPE_TI3E524              922
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_AUCKLAND             924
+#define MACH_TYPE_AK3320M              925
+#define MACH_TYPE_DURAMAX              926
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_PRONGHORN            928
+#define MACH_TYPE_FUNDY                929
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_CPU777               931
+#define MACH_TYPE_SIMICON9201          932
+#define MACH_TYPE_LEAP2_HPM            933
+#define MACH_TYPE_CM922TXA10           934
+#define MACH_TYPE_PXA                  935
+#define MACH_TYPE_SANDGATE2            936
+#define MACH_TYPE_SANDGATE2G           937
+#define MACH_TYPE_SANDGATE2P           938
+#define MACH_TYPE_FRED_JACK            939
+#define MACH_TYPE_TTG_COLOR1           940
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_NETDCU8              942
+#define MACH_TYPE_NG_FVX538            944
+#define MACH_TYPE_NG_FVS338            945
+#define MACH_TYPE_PNX4103              946
+#define MACH_TYPE_HESDB                947
+#define MACH_TYPE_XSILO                948
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_EMLC                 950
+#define MACH_TYPE_SISTERON             951
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_TSC_VENUS            953
+#define MACH_TYPE_DS101J               954
+#define MACH_TYPE_MXC30030ADS          955
+#define MACH_TYPE_FUJITSU_WIMAXSOC     956
+#define MACH_TYPE_DUALPCMODEM          957
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_HTCAPACHE            959
+#define MACH_TYPE_IXDP435              960
+#define MACH_TYPE_CATPROVT100          961
+#define MACH_TYPE_PICOTUX1XX           962
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_EMPC2                965
+#define MACH_TYPE_VENTURA              966
+#define MACH_TYPE_PHIDGET_SBC          967
+#define MACH_TYPE_IJ3K                 968
+#define MACH_TYPE_PISGAH               969
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SG720                971
+#define MACH_TYPE_REDFOX               972
+#define MACH_TYPE_MYSH_EP9315_1        973
+#define MACH_TYPE_TPF106               974
+#define MACH_TYPE_AT91RM9200KG         975
+#define MACH_TYPE_SLEDB                976
+#define MACH_TYPE_ONTRACK              977
+#define MACH_TYPE_PM1200               978
+#define MACH_TYPE_ESS24XXX             979
+#define MACH_TYPE_COREMP7              980
+#define MACH_TYPE_NEXCODER_6446        981
+#define MACH_TYPE_STVC8380             982
+#define MACH_TYPE_TEKLYNX              983
+#define MACH_TYPE_CARBONADO            984
+#define MACH_TYPE_SYSMOS_MP730         985
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_PGIGIM               987
+#define MACH_TYPE_PTX9160P2            988
+#define MACH_TYPE_DCORE1               989
+#define MACH_TYPE_VICTORPXA            990
+#define MACH_TYPE_MX2DTB               991
+#define MACH_TYPE_PXA_IREX_ER0100      992
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_BARTEC_DEG           994
+#define MACH_TYPE_HW50251              995
+#define MACH_TYPE_IBOX                 996
+#define MACH_TYPE_ATLASLH7A404         997
+#define MACH_TYPE_PT2026               998
+#define MACH_TYPE_HTCALPINE            999
+#define MACH_TYPE_BARTEC_VTU           1000
+#define MACH_TYPE_VCOREII              1001
+#define MACH_TYPE_PDNB3                1002
+#define MACH_TYPE_HTCBEETLES           1003
+#define MACH_TYPE_S3C6400              1004
+#define MACH_TYPE_S3C2443              1005
+#define MACH_TYPE_OMAP_LDK             1006
+#define MACH_TYPE_SMDK2460             1007
+#define MACH_TYPE_SMDK2440             1008
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_WEBBOX               1010
+#define MACH_TYPE_CWWNDP               1011
+#define MACH_TYPE_DRAGON               1012
+#define MACH_TYPE_OPENDO_CPU_BOARD     1013
+#define MACH_TYPE_CCM2200              1014
+#define MACH_TYPE_ETWARM               1015
+#define MACH_TYPE_M93030               1016
+#define MACH_TYPE_CC7U                 1017
+#define MACH_TYPE_MTT_RANGER           1018
+#define MACH_TYPE_NEXUS                1019
+#define MACH_TYPE_DESMAN               1020
+#define MACH_TYPE_BKDE303              1021
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M7200            1023
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_SG640                1025
+#define MACH_TYPE_EDG79524             1026
+#define MACH_TYPE_AI2410               1027
+#define MACH_TYPE_IXP465               1028
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_HEINS                1030
+#define MACH_TYPE_MPLUSEVA             1031
+#define MACH_TYPE_RT042                1032
+#define MACH_TYPE_CWIEM                1033
+#define MACH_TYPE_CM_X270              1034
+#define MACH_TYPE_CM_X255              1035
+#define MACH_TYPE_ESH_AT91             1036
+#define MACH_TYPE_SANDGATE3            1037
+#define MACH_TYPE_PRIMO                1038
+#define MACH_TYPE_GEMSTONE             1039
+#define MACH_TYPE_PRONGHORNMETRO       1040
+#define MACH_TYPE_SIDEWINDER           1041
+#define MACH_TYPE_PICOMOD1             1042
+#define MACH_TYPE_SG590                1043
+#define MACH_TYPE_AKAI9307             1044
+#define MACH_TYPE_FONTAINE             1045
+#define MACH_TYPE_WOMBAT               1046
+#define MACH_TYPE_ACQ300               1047
+#define MACH_TYPE_MOD_270              1048
+#define MACH_TYPE_VC0820               1049
+#define MACH_TYPE_ANI_AIM              1050
+#define MACH_TYPE_JELLYFISH            1051
+#define MACH_TYPE_AMANITA              1052
+#define MACH_TYPE_VLINK                1053
+#define MACH_TYPE_DEXFLEX              1054
+#define MACH_TYPE_EIGEN_TTQ            1055
+#define MACH_TYPE_ARCOM_TITAN          1056
+#define MACH_TYPE_TABLA                1057
+#define MACH_TYPE_MDIRAC3              1058
+#define MACH_TYPE_MRHFBP2              1059
+#define MACH_TYPE_AT91RM9200RB         1060
+#define MACH_TYPE_ANI_APM              1061
+#define MACH_TYPE_ELLA1                1062
+#define MACH_TYPE_INHAND_PXA27X        1063
+#define MACH_TYPE_INHAND_PXA25X        1064
+#define MACH_TYPE_EMPOS_XM             1065
+#define MACH_TYPE_EMPOS                1066
+#define MACH_TYPE_EMPOS_TINY           1067
+#define MACH_TYPE_EMPOS_SM             1068
+#define MACH_TYPE_EGRET                1069
+#define MACH_TYPE_OSTRICH              1070
+#define MACH_TYPE_N50                  1071
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_STAREAST             1073
+#define MACH_TYPE_DSPG_DW              1074
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_MRG110_6             1076
+#define MACH_TYPE_WRT300NV2            1077
+#define MACH_TYPE_XM_BULVERDE          1078
+#define MACH_TYPE_MSM6100              1079
+#define MACH_TYPE_ETI_B1               1080
+#define MACH_TYPE_ZILOG_ZA9L           1081
+#define MACH_TYPE_BIT2440              1082
+#define MACH_TYPE_NBI                  1083
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_VDAVINCI             1085
+#define MACH_TYPE_ATC6                 1086
+#define MACH_TYPE_MULTMDW              1087
+#define MACH_TYPE_MBA2440              1088
+#define MACH_TYPE_ECSD                 1089
+#define MACH_TYPE_PALMZ31              1090
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_RAZOR101             1092
+#define MACH_TYPE_OPERA_TDM            1093
+#define MACH_TYPE_COMCERTO             1094
+#define MACH_TYPE_TB0319               1095
+#define MACH_TYPE_KWS8000              1096
+#define MACH_TYPE_B2                   1097
+#define MACH_TYPE_LCL54                1098
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_N4100                1102
+#define MACH_TYPE_VERTICAL_RSC4        1103
+#define MACH_TYPE_SG8100               1104
+#define MACH_TYPE_IM42XX               1105
+#define MACH_TYPE_FTXX                 1106
+#define MACH_TYPE_LWFUSION             1107
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CCW9C                1110
+#define MACH_TYPE_DABHS                1111
+#define MACH_TYPE_GZMX                 1112
+#define MACH_TYPE_IPNW100AP            1113
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_CC9P9750DEV          1115
+#define MACH_TYPE_CC9P9360VAL          1116
+#define MACH_TYPE_CC9P9750VAL          1117
+#define MACH_TYPE_NX70V                1118
+#define MACH_TYPE_AT91RM9200DF         1119
+#define MACH_TYPE_SE_PILOT2            1120
+#define MACH_TYPE_MTCN_T800            1121
+#define MACH_TYPE_VCMX212              1122
+#define MACH_TYPE_LYNX                 1123
+#define MACH_TYPE_AT91SAM9260ID        1124
+#define MACH_TYPE_HW86052              1125
+#define MACH_TYPE_PILZ_PMI3            1126
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_CT_DFS               1129
+#define MACH_TYPE_PILZ_PMI4            1130
+#define MACH_TYPE_XCEEDNP_IXP          1131
+#define MACH_TYPE_SMDK2442B            1132
+#define MACH_TYPE_XNODE                1133
+#define MACH_TYPE_AIDX270              1134
+#define MACH_TYPE_REMA                 1135
+#define MACH_TYPE_BPS1000              1136
+#define MACH_TYPE_HW90350              1137
+#define MACH_TYPE_OMAP_3430SDP         1138
+#define MACH_TYPE_BLUETOUCH            1139
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_XSBASE270            1141
+#define MACH_TYPE_AT91SAM9260EK_CN     1142
+#define MACH_TYPE_ADSTURBOXB           1143
+#define MACH_TYPE_OTI4110              1144
+#define MACH_TYPE_HME_PXA              1145
+#define MACH_TYPE_DEISTERDCA           1146
+#define MACH_TYPE_CES_SSEM2            1147
+#define MACH_TYPE_CES_MTR              1148
+#define MACH_TYPE_TDS_AVNG_SBC         1149
+#define MACH_TYPE_EVEREST              1150
+#define MACH_TYPE_PNX4010              1151
+#define MACH_TYPE_OXNAS                1152
+#define MACH_TYPE_FIORI                1153
+#define MACH_TYPE_ML1200               1154
+#define MACH_TYPE_PECOS                1155
+#define MACH_TYPE_NB2XXX               1156
+#define MACH_TYPE_HW6900               1157
+#define MACH_TYPE_CDCS_QUOLL           1158
+#define MACH_TYPE_QUICKSILVER          1159
+#define MACH_TYPE_UPLAT926             1160
+#define MACH_TYPE_DEP2410_THOMAS       1161
+#define MACH_TYPE_DTK2410              1162
+#define MACH_TYPE_CHILI                1163
+#define MACH_TYPE_DEMETER              1164
+#define MACH_TYPE_DIONYSUS             1165
+#define MACH_TYPE_AS352X               1166
+#define MACH_TYPE_SERVICE              1167
+#define MACH_TYPE_CS_E9301             1168
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_IA_MOSPCK            1170
+#define MACH_TYPE_QL201B               1171
+#define MACH_TYPE_BBM                  1174
+#define MACH_TYPE_EXXX                 1175
+#define MACH_TYPE_WMA11B               1176
+#define MACH_TYPE_PELCO_ATLAS          1177
+#define MACH_TYPE_G500                 1178
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_MX33ADS              1180
+#define MACH_TYPE_CHUB                 1181
+#define MACH_TYPE_NEO1973_GTA01        1182
+#define MACH_TYPE_W90N740              1183
+#define MACH_TYPE_MEDALLION_SA2410     1184
+#define MACH_TYPE_IA_CPU_9200_2        1185
+#define MACH_TYPE_DIMMRM9200           1186
+#define MACH_TYPE_PM9261               1187
+#define MACH_TYPE_ML7304               1189
+#define MACH_TYPE_UCP250               1190
+#define MACH_TYPE_INTBOARD             1191
+#define MACH_TYPE_GULFSTREAM           1192
+#define MACH_TYPE_LABQUEST             1193
+#define MACH_TYPE_VCMX313              1194
+#define MACH_TYPE_URG200               1195
+#define MACH_TYPE_CPUX255LCDNET        1196
+#define MACH_TYPE_NETDCU9              1197
+#define MACH_TYPE_NETDCU10             1198
+#define MACH_TYPE_DSPG_DGA             1199
+#define MACH_TYPE_DSPG_DVW             1200
+#define MACH_TYPE_SOLOS                1201
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_OSSTBOX              1203
+#define MACH_TYPE_KBAT9261             1204
+#define MACH_TYPE_CT1100               1205
+#define MACH_TYPE_AKCPPXA              1206
+#define MACH_TYPE_OCHAYA1020           1207
+#define MACH_TYPE_HITRACK              1208
+#define MACH_TYPE_SYME1                1209
+#define MACH_TYPE_SYHL1                1210
+#define MACH_TYPE_EMPCA400             1211
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_HTCHERMES            1213
+#define MACH_TYPE_ETI_C1               1214
+#define MACH_TYPE_AC100                1216
+#define MACH_TYPE_SNEETCH              1217
+#define MACH_TYPE_STUDENTMATE          1218
+#define MACH_TYPE_ZIR2410              1219
+#define MACH_TYPE_ZIR2413              1220
+#define MACH_TYPE_DLONIP3              1221
+#define MACH_TYPE_INSTREAM             1222
+#define MACH_TYPE_AMBARELLA            1223
+#define MACH_TYPE_NEVIS                1224
+#define MACH_TYPE_HTC_TRINITY          1225
+#define MACH_TYPE_QL202B               1226
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_RD129                1228
+#define MACH_TYPE_HTCWIZARD            1229
+#define MACH_TYPE_TREO680              1230
+#define MACH_TYPE_TECON_TMEZON         1231
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_GENE1270             1234
+#define MACH_TYPE_ZIR2412              1235
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_T700WX               1237
+#define MACH_TYPE_VF100                1238
+#define MACH_TYPE_NSB2                 1239
+#define MACH_TYPE_NXHMI_BB             1240
+#define MACH_TYPE_NXHMI_RE             1241
+#define MACH_TYPE_N4100PRO             1242
+#define MACH_TYPE_SAM9260              1243
+#define MACH_TYPE_OMAP_TREO600         1244
+#define MACH_TYPE_INDY2410             1245
+#define MACH_TYPE_NELT_A               1246
+#define MACH_TYPE_N311                 1248
+#define MACH_TYPE_AT91SAM9260VGK       1249
+#define MACH_TYPE_AT91LEPPE            1250
+#define MACH_TYPE_AT91LEPCCN           1251
+#define MACH_TYPE_APC7100              1252
+#define MACH_TYPE_STARGAZER            1253
+#define MACH_TYPE_SONATA               1254
+#define MACH_TYPE_SCHMOOGIE            1255
+#define MACH_TYPE_AZTOOL               1256
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_SXNI9260             1258
+#define MACH_TYPE_MXC27520EVB          1259
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_MB9260               1261
+#define MACH_TYPE_MB9263               1262
+#define MACH_TYPE_IPAC9302             1263
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_GALLIUM              1265
+#define MACH_TYPE_MSC2410              1266
+#define MACH_TYPE_GHI270               1267
+#define MACH_TYPE_DAVINCI_LEONARDO     1268
+#define MACH_TYPE_OIAB                 1269
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_GREENPHONE           1272
+#define MACH_TYPE_COMPEXWP18           1273
+#define MACH_TYPE_XMATE                1274
+#define MACH_TYPE_ENERGIZER            1275
+#define MACH_TYPE_IME1                 1276
+#define MACH_TYPE_SWEDATMS             1277
+#define MACH_TYPE_NTNP435C             1278
+#define MACH_TYPE_SPECTRO2             1279
+#define MACH_TYPE_H6039                1280
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_SAMOA_II             1282
+#define MACH_TYPE_CWMXL                1283
+#define MACH_TYPE_AS9200               1284
+#define MACH_TYPE_SFX1149              1285
+#define MACH_TYPE_NAVI010              1286
+#define MACH_TYPE_MULTMDP              1287
+#define MACH_TYPE_SCB9520              1288
+#define MACH_TYPE_HTCATHENA            1289
+#define MACH_TYPE_XP179                1290
+#define MACH_TYPE_H4300                1291
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_MXC30020EVB          1293
+#define MACH_TYPE_ADSBITSYG5           1294
+#define MACH_TYPE_ADSPORTALPLUS        1295
+#define MACH_TYPE_MMSP2PLUS            1296
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_TPP302               1298
+#define MACH_TYPE_TPM104               1299
+#define MACH_TYPE_TPM102               1300
+#define MACH_TYPE_TPM109               1301
+#define MACH_TYPE_FBXO1                1302
+#define MACH_TYPE_HXD8                 1303
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_EMTEST               1305
+#define MACH_TYPE_AD6900               1306
+#define MACH_TYPE_EUROPA               1307
+#define MACH_TYPE_METROCONNECT         1308
+#define MACH_TYPE_EZ_S2410             1309
+#define MACH_TYPE_EZ_S2440             1310
+#define MACH_TYPE_EZ_EP9312            1311
+#define MACH_TYPE_EZ_EP9315            1312
+#define MACH_TYPE_EZ_X7                1313
+#define MACH_TYPE_GODOTDB              1314
+#define MACH_TYPE_MISTRAL              1315
+#define MACH_TYPE_MSM                  1316
+#define MACH_TYPE_CT5910               1317
+#define MACH_TYPE_CT5912               1318
+#define MACH_TYPE_HYNET_INE            1319
+#define MACH_TYPE_HYNET_APP            1320
+#define MACH_TYPE_MSM7200              1321
+#define MACH_TYPE_MSM7600              1322
+#define MACH_TYPE_CEB255               1323
+#define MACH_TYPE_CIEL                 1324
+#define MACH_TYPE_SLM5650              1325
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COMTECH_ROUTER       1327
+#define MACH_TYPE_SBC2410X             1328
+#define MACH_TYPE_AT4X0BD              1329
+#define MACH_TYPE_CBIFR                1330
+#define MACH_TYPE_ARCOM_QUANTUM        1331
+#define MACH_TYPE_MATRIX520            1332
+#define MACH_TYPE_MATRIX510            1333
+#define MACH_TYPE_MATRIX500            1334
+#define MACH_TYPE_M501                 1335
+#define MACH_TYPE_AAEON1270            1336
+#define MACH_TYPE_MATRIX500EV          1337
+#define MACH_TYPE_PAC500               1338
+#define MACH_TYPE_PNX8181              1339
+#define MACH_TYPE_COLIBRI320           1340
+#define MACH_TYPE_AZTOOLBB             1341
+#define MACH_TYPE_AZTOOLG2             1342
+#define MACH_TYPE_DVLHOST              1343
+#define MACH_TYPE_ZIR9200              1344
+#define MACH_TYPE_ZIR9260              1345
+#define MACH_TYPE_COCOPAH              1346
+#define MACH_TYPE_NDS                  1347
+#define MACH_TYPE_ROSENCRANTZ          1348
+#define MACH_TYPE_FTTX_ODSC            1349
+#define MACH_TYPE_CLASSE_R6904         1350
+#define MACH_TYPE_CAM60                1351
+#define MACH_TYPE_MXC30031ADS          1352
+#define MACH_TYPE_DATACALL             1353
+#define MACH_TYPE_AT91EB01             1354
+#define MACH_TYPE_RTY                  1355
+#define MACH_TYPE_DWL2100              1356
+#define MACH_TYPE_VINSI                1357
+#define MACH_TYPE_DB88F5281            1358
+#define MACH_TYPE_CSB726               1359
+#define MACH_TYPE_TIK27                1360
+#define MACH_TYPE_MX_UC7420            1361
+#define MACH_TYPE_RIRM3                1362
+#define MACH_TYPE_PELCO_ODYSSEY        1363
+#define MACH_TYPE_ADX_ABOX             1365
+#define MACH_TYPE_ADX_TPID             1366
+#define MACH_TYPE_MINICHECK            1367
+#define MACH_TYPE_IDAM                 1368
+#define MACH_TYPE_MARIO_MX             1369
+#define MACH_TYPE_VI1888               1370
+#define MACH_TYPE_ZR4230               1371
+#define MACH_TYPE_T1_IX_BLUE           1372
+#define MACH_TYPE_SYHQ2                1373
+#define MACH_TYPE_COMPUTIME_R3         1374
+#define MACH_TYPE_ORATIS               1375
+#define MACH_TYPE_MIKKO                1376
+#define MACH_TYPE_HOLON                1377
+#define MACH_TYPE_OLIP8                1378
+#define MACH_TYPE_GHI270HG             1379
+#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
+#define MACH_TYPE_BLACKRIVER           1383
+#define MACH_TYPE_SANDGATEWP           1384
+#define MACH_TYPE_CDOTBWSG             1385
+#define MACH_TYPE_QUARK963             1386
+#define MACH_TYPE_CSB735               1387
+#define MACH_TYPE_LITTLETON            1388
+#define MACH_TYPE_MIO_P550             1389
+#define MACH_TYPE_MOTION2440           1390
+#define MACH_TYPE_IMM500               1391
+#define MACH_TYPE_HOMEMATIC            1392
+#define MACH_TYPE_ERMINE               1393
+#define MACH_TYPE_KB9202B              1394
+#define MACH_TYPE_HS1XX                1395
+#define MACH_TYPE_STUDENTMATE2440      1396
+#define MACH_TYPE_ARVOO_L1_Z1          1397
+#define MACH_TYPE_DEP2410K             1398
+#define MACH_TYPE_XXSVIDEO             1399
+#define MACH_TYPE_IM4004               1400
+#define MACH_TYPE_OCHAYA1050           1401
+#define MACH_TYPE_LEP9261              1402
+#define MACH_TYPE_SVENMEB              1403
+#define MACH_TYPE_FORTUNET2NE          1404
+#define MACH_TYPE_NXHX                 1406
+#define MACH_TYPE_REALVIEW_PB11MP      1407
+#define MACH_TYPE_IDS500               1408
+#define MACH_TYPE_ORS_N725             1409
+#define MACH_TYPE_HSDARM               1410
+#define MACH_TYPE_SHA_PON003           1411
+#define MACH_TYPE_SHA_PON004           1412
+#define MACH_TYPE_SHA_PON007           1413
+#define MACH_TYPE_SHA_PON011           1414
+#define MACH_TYPE_H6042                1415
+#define MACH_TYPE_H6043                1416
+#define MACH_TYPE_LOOXC550             1417
+#define MACH_TYPE_CNTY_TITAN           1418
+#define MACH_TYPE_APP3XX               1419
+#define MACH_TYPE_SIDEOATSGRAMA        1420
+#define MACH_TYPE_TREO700P             1421
+#define MACH_TYPE_TREO700W             1422
+#define MACH_TYPE_TREO750              1423
+#define MACH_TYPE_TREO755P             1424
+#define MACH_TYPE_EZREGANUT9200        1425
+#define MACH_TYPE_SARGE                1426
+#define MACH_TYPE_A696                 1427
+#define MACH_TYPE_TURTLE               1428
+#define MACH_TYPE_MX27_3DS             1430
+#define MACH_TYPE_BISHOP               1431
+#define MACH_TYPE_PXX                  1432
+#define MACH_TYPE_REDWOOD              1433
+#define MACH_TYPE_OMAP_2430DLP         1436
+#define MACH_TYPE_OMAP_2430OSK         1437
+#define MACH_TYPE_SARDINE              1438
+#define MACH_TYPE_HALIBUT              1439
+#define MACH_TYPE_TROUT                1440
+#define MACH_TYPE_GOLDFISH             1441
+#define MACH_TYPE_GESBC2440            1442
+#define MACH_TYPE_NOMAD                1443
+#define MACH_TYPE_ROSALIND             1444
+#define MACH_TYPE_CC9P9215             1445
+#define MACH_TYPE_CC9P9210             1446
+#define MACH_TYPE_CC9P9215JS           1447
+#define MACH_TYPE_CC9P9210JS           1448
+#define MACH_TYPE_NASFFE               1449
+#define MACH_TYPE_TN2X0BD              1450
+#define MACH_TYPE_GWMPXA               1451
+#define MACH_TYPE_EXYPLUS              1452
+#define MACH_TYPE_JADOO21              1453
+#define MACH_TYPE_LOOXN560             1454
+#define MACH_TYPE_BONSAI               1455
+#define MACH_TYPE_ADSMILGATO           1456
+#define MACH_TYPE_GBA                  1457
+#define MACH_TYPE_H6044                1458
+#define MACH_TYPE_APP                  1459
+#define MACH_TYPE_TCT_HAMMER           1460
+#define MACH_TYPE_HERALD               1461
+#define MACH_TYPE_ARTEMIS              1462
+#define MACH_TYPE_HTCTITAN             1463
+#define MACH_TYPE_QRANIUM              1464
+#define MACH_TYPE_ADX_WSC2             1465
+#define MACH_TYPE_ADX_MEDCOM           1466
+#define MACH_TYPE_BBOARD               1467
+#define MACH_TYPE_CAMBRIA              1468
+#define MACH_TYPE_MT7XXX               1469
+#define MACH_TYPE_MATRIX512            1470
+#define MACH_TYPE_MATRIX522            1471
+#define MACH_TYPE_IPAC5010             1472
+#define MACH_TYPE_SAKURA               1473
+#define MACH_TYPE_GROCX                1474
+#define MACH_TYPE_PM9263               1475
+#define MACH_TYPE_SIM_ONE              1476
+#define MACH_TYPE_ACQ132               1477
+#define MACH_TYPE_DATR                 1478
+#define MACH_TYPE_ACTUX1               1479
+#define MACH_TYPE_ACTUX2               1480
+#define MACH_TYPE_ACTUX3               1481
+#define MACH_TYPE_FLEXIT               1482
+#define MACH_TYPE_BH2X0BD              1483
+#define MACH_TYPE_ATB2002              1484
+#define MACH_TYPE_XENON                1485
+#define MACH_TYPE_FM607                1486
+#define MACH_TYPE_MATRIX514            1487
+#define MACH_TYPE_MATRIX524            1488
+#define MACH_TYPE_INPOD                1489
+#define MACH_TYPE_JIVE                 1490
+#define MACH_TYPE_TLL_MX21             1491
+#define MACH_TYPE_SBC2800              1492
+#define MACH_TYPE_CC7UCAMRY            1493
+#define MACH_TYPE_UBISYS_P9_SC15       1494
+#define MACH_TYPE_UBISYS_P9_SSC2D10    1495
+#define MACH_TYPE_UBISYS_P9_RCU3       1496
+#define MACH_TYPE_AML_M8000            1497
+#define MACH_TYPE_SNAPPER_270          1498
+#define MACH_TYPE_OMAP_BBX             1499
+#define MACH_TYPE_UCN2410              1500
+#define MACH_TYPE_SAM9_L9260           1501
+#define MACH_TYPE_ETI_C2               1502
+#define MACH_TYPE_AVALANCHE            1503
+#define MACH_TYPE_REALVIEW_PB1176      1504
+#define MACH_TYPE_DP1500               1505
+#define MACH_TYPE_APPLE_IPHONE         1506
+#define MACH_TYPE_YL9200               1507
+#define MACH_TYPE_RD88F5182            1508
+#define MACH_TYPE_KUROBOX_PRO          1509
+#define MACH_TYPE_SE_POET              1510
+#define MACH_TYPE_MX31_3DS             1511
+#define MACH_TYPE_R270                 1512
+#define MACH_TYPE_ARMOUR21             1513
+#define MACH_TYPE_DT2                  1514
+#define MACH_TYPE_VT4                  1515
+#define MACH_TYPE_TYCO320              1516
+#define MACH_TYPE_ADMA                 1517
+#define MACH_TYPE_WP188                1518
+#define MACH_TYPE_CORSICA              1519
+#define MACH_TYPE_BIGEYE               1520
+#define MACH_TYPE_TLL5000              1522
+#define MACH_TYPE_BEBOT                1523
+#define MACH_TYPE_QONG                 1524
+#define MACH_TYPE_TCOMPACT             1525
+#define MACH_TYPE_PUMA5                1526
+#define MACH_TYPE_ELARA                1527
+#define MACH_TYPE_ELLINGTON            1528
+#define MACH_TYPE_XDA_ATOM             1529
+#define MACH_TYPE_ENERGIZER2           1530
+#define MACH_TYPE_ODIN                 1531
+#define MACH_TYPE_ACTUX4               1532
+#define MACH_TYPE_ESL_OMAP             1533
+#define MACH_TYPE_OMAP2EVM             1534
+#define MACH_TYPE_OMAP3EVM             1535
+#define MACH_TYPE_ADX_PCU57            1536
+#define MACH_TYPE_MONACO               1537
+#define MACH_TYPE_LEVANTE              1538
+#define MACH_TYPE_TMXIPX425            1539
+#define MACH_TYPE_LEEP                 1540
+#define MACH_TYPE_RAAD                 1541
+#define MACH_TYPE_DNS323               1542
+#define MACH_TYPE_AP1000               1543
+#define MACH_TYPE_A9SAM6432            1544
+#define MACH_TYPE_SHINY                1545
+#define MACH_TYPE_OMAP3_BEAGLE         1546
+#define MACH_TYPE_CSR_BDB2             1547
+#define MACH_TYPE_NOKIA_N810           1548
+#define MACH_TYPE_C270                 1549
+#define MACH_TYPE_SENTRY               1550
+#define MACH_TYPE_PCM038               1551
+#define MACH_TYPE_ANC300               1552
+#define MACH_TYPE_HTCKAISER            1553
+#define MACH_TYPE_SBAT100              1554
+#define MACH_TYPE_MODUNORM             1555
+#define MACH_TYPE_PELOS_TWARM          1556
+#define MACH_TYPE_FLANK                1557
+#define MACH_TYPE_SIRLOIN              1558
+#define MACH_TYPE_BRISKET              1559
+#define MACH_TYPE_CHUCK                1560
+#define MACH_TYPE_OTTER                1561
+#define MACH_TYPE_DAVINCI_LDK          1562
+#define MACH_TYPE_PHREEDOM             1563
+#define MACH_TYPE_SG310                1564
+#define MACH_TYPE_TS209                1565
+#define MACH_TYPE_AT91CAP9ADK          1566
+#define MACH_TYPE_TION9315             1567
+#define MACH_TYPE_MAST                 1568
+#define MACH_TYPE_PFW                  1569
+#define MACH_TYPE_YL_P2440             1570
+#define MACH_TYPE_ZSBC32               1571
+#define MACH_TYPE_OMAP_PACE2           1572
+#define MACH_TYPE_IMX_PACE2            1573
+#define MACH_TYPE_MX31MOBOARD          1574
+#define MACH_TYPE_MX37_3DS             1575
+#define MACH_TYPE_RCC                  1576
+#define MACH_TYPE_ARM9                 1577
+#define MACH_TYPE_VISION_EP9307        1578
+#define MACH_TYPE_SCLY1000             1579
+#define MACH_TYPE_FONTEL_EP            1580
+#define MACH_TYPE_VOICEBLUE3G          1581
+#define MACH_TYPE_TT9200               1582
+#define MACH_TYPE_DIGI2410             1583
+#define MACH_TYPE_TERASTATION_PRO2     1584
+#define MACH_TYPE_LINKSTATION_PRO      1585
+#define MACH_TYPE_MOTOROLA_A780        1587
+#define MACH_TYPE_MOTOROLA_E6          1588
+#define MACH_TYPE_MOTOROLA_E2          1589
+#define MACH_TYPE_MOTOROLA_E680        1590
+#define MACH_TYPE_UR2410               1591
+#define MACH_TYPE_TAS9261              1592
+#define MACH_TYPE_HERMES_HD            1593
+#define MACH_TYPE_PERSEO_HD            1594
+#define MACH_TYPE_STARGAZER2           1595
+#define MACH_TYPE_E350                 1596
+#define MACH_TYPE_WPCM450              1597
+#define MACH_TYPE_CARTESIO             1598
+#define MACH_TYPE_TOYBOX               1599
+#define MACH_TYPE_TX27                 1600
+#define MACH_TYPE_TS409                1601
+#define MACH_TYPE_P300                 1602
+#define MACH_TYPE_XDACOMET             1603
+#define MACH_TYPE_DEXFLEX2             1604
+#define MACH_TYPE_OW                   1605
+#define MACH_TYPE_ARMEBS3              1606
+#define MACH_TYPE_U3                   1607
+#define MACH_TYPE_SMDK2450             1608
+#define MACH_TYPE_RSI_EWS              1609
+#define MACH_TYPE_TNB                  1610
+#define MACH_TYPE_TOEPATH              1611
+#define MACH_TYPE_KB9263               1612
+#define MACH_TYPE_MT7108               1613
+#define MACH_TYPE_SMTR2440             1614
+#define MACH_TYPE_MANAO                1615
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_GULFSTREAM_KP        1617
+#define MACH_TYPE_LANREADYFN522        1618
+#define MACH_TYPE_ARMA37               1619
+#define MACH_TYPE_MENDEL               1620
+#define MACH_TYPE_PELCO_ILIAD          1621
+#define MACH_TYPE_UNIT2P               1622
+#define MACH_TYPE_INC20OTTER           1623
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_STORCENTER           1625
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_U500                 1628
+#define MACH_TYPE_DS9260               1629
+#define MACH_TYPE_RIVERROCK            1630
+#define MACH_TYPE_SCIBATH              1631
+#define MACH_TYPE_AT91SAM7SE512EK      1632
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_MULTIMEDIA           1634
+#define MACH_TYPE_MARVIN               1635
+#define MACH_TYPE_X500                 1636
+#define MACH_TYPE_AWLUG4LCU            1637
+#define MACH_TYPE_PALERMOC             1638
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_IP500                1640
+#define MACH_TYPE_ASE2                 1642
+#define MACH_TYPE_MX35EVB              1643
+#define MACH_TYPE_AML_M8050            1644
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_MARS                 1646
+#define MACH_TYPE_NEUROS_OSD2          1647
+#define MACH_TYPE_BADGER               1648
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TRIZEPS5             1650
+#define MACH_TYPE_MARLIN               1651
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_HPIPAQ214            1653
+#define MACH_TYPE_AT572D940DCM         1654
+#define MACH_TYPE_NE1BOARD             1655
+#define MACH_TYPE_ZANTE                1656
+#define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_TW2662               1658
+#define MACH_TYPE_VF10XX               1659
+#define MACH_TYPE_ZORAN43XX            1660
+#define MACH_TYPE_SONIX926             1661
+#define MACH_TYPE_CELESTIALSEMI        1662
+#define MACH_TYPE_CC9M2443JS           1663
+#define MACH_TYPE_TW5334               1664
+#define MACH_TYPE_HTCARTEMIS           1665
+#define MACH_TYPE_NAL_HLITE            1666
+#define MACH_TYPE_HTCVOGUE             1667
+#define MACH_TYPE_SMARTWEB             1668
+#define MACH_TYPE_MV86XX               1669
+#define MACH_TYPE_MV87XX               1670
+#define MACH_TYPE_SONGYOUNGHO          1671
+#define MACH_TYPE_YOUNGHOTEMA          1672
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_MMVP                 1674
+#define MACH_TYPE_MMAP                 1675
+#define MACH_TYPE_PTID2410             1676
+#define MACH_TYPE_JAMES_926            1677
+#define MACH_TYPE_FM6000               1678
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_OCE_SPIDER_SI        1686
+#define MACH_TYPE_OCE_SPIDER_SK        1687
+#define MACH_TYPE_ROVERN6              1688
+#define MACH_TYPE_PELCO_EVOLUTION      1689
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_ELARACPE             1691
+#define MACH_TYPE_MABV3                1692
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_CSB737               1695
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_G900                 1697
+#define MACH_TYPE_APF27                1698
+#define MACH_TYPE_GGUS2000             1699
+#define MACH_TYPE_OMAP_2430_MIMIC      1700
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_ALMEX                1702
+#define MACH_TYPE_CONTROL              1703
+#define MACH_TYPE_MBA2410              1704
+#define MACH_TYPE_VOLCANO              1705
+#define MACH_TYPE_ZENITH               1706
+#define MACH_TYPE_MUCHIP               1707
+#define MACH_TYPE_MAGELLAN             1708
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_CME9210              1712
+#define MACH_TYPE_HCZH4                1713
+#define MACH_TYPE_SPEARBASIC           1714
+#define MACH_TYPE_DEP2440              1715
+#define MACH_TYPE_HDL_GXR              1716
+#define MACH_TYPE_HDL_GT               1717
+#define MACH_TYPE_HDL_4G               1718
+#define MACH_TYPE_S3C6000              1719
+#define MACH_TYPE_MMSP2_MDK            1720
+#define MACH_TYPE_MPX220               1721
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_HTC_POLARIS          1723
+#define MACH_TYPE_HTC_KAISER           1724
+#define MACH_TYPE_LG_KS20              1725
+#define MACH_TYPE_HHGPS                1726
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_INSIGHT              1728
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_CSB637XO             1730
+#define MACH_TYPE_EVISIONG             1731
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_TNT                  1734
+#define MACH_TYPE_TBXT                 1735
+#define MACH_TYPE_PLAYMATE             1736
+#define MACH_TYPE_PNS10                1737
+#define MACH_TYPE_EZNAVI               1738
+#define MACH_TYPE_PS4000               1739
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_CWMX31               1746
+#define MACH_TYPE_SL2312               1747
+#define MACH_TYPE_BLENNY               1748
+#define MACH_TYPE_DS107                1749
+#define MACH_TYPE_DSX07                1750
+#define MACH_TYPE_PICOCOM1             1751
+#define MACH_TYPE_LYNX_WOLVERINE       1752
+#define MACH_TYPE_UBISYS_P9_SC19       1753
+#define MACH_TYPE_KRATOS_LOW           1754
+#define MACH_TYPE_M700                 1755
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_HSLFEMTOCELL         1758
+#define MACH_TYPE_DAINTREE_AT91        1759
+#define MACH_TYPE_SG560USB             1760
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_USR8200              1762
+#define MACH_TYPE_S1S65K               1763
+#define MACH_TYPE_S2S65A               1764
+#define MACH_TYPE_ICORE                1765
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_BELMONT              1767
+#define MACH_TYPE_ASUSP525             1768
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_HIPXA                1770
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_M800                 1772
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_PRIMA_EVB            1774
+#define MACH_TYPE_MX31BT1              1775
+#define MACH_TYPE_ATLAS4_EVB           1776
+#define MACH_TYPE_MX31CICADA           1777
+#define MACH_TYPE_MI424WR              1778
+#define MACH_TYPE_AXS_ULTRAX           1779
+#define MACH_TYPE_AT572D940DEB         1780
+#define MACH_TYPE_DAVINCI_DA830_EVM    1781
+#define MACH_TYPE_EP9302               1782
+#define MACH_TYPE_AT572D940HFEB        1783
+#define MACH_TYPE_CYBOOK3              1784
+#define MACH_TYPE_WDG002               1785
+#define MACH_TYPE_SG560ADSL            1786
+#define MACH_TYPE_NEXTIO_N2800_ICA     1787
+#define MACH_TYPE_DOVE_DB              1788
+#define MACH_TYPE_MARVELL_NEWDB        1789
+#define MACH_TYPE_VANDIHUD             1790
+#define MACH_TYPE_MAGX_E8              1791
+#define MACH_TYPE_MAGX_Z6              1792
+#define MACH_TYPE_MAGX_V8              1793
+#define MACH_TYPE_MAGX_U9              1794
+#define MACH_TYPE_TOUGHCF08            1795
+#define MACH_TYPE_ZW4400               1796
+#define MACH_TYPE_MARAT91              1797
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_IMX27                1802
+#define MACH_TYPE_MOOSE_DB             1803
+#define MACH_TYPE_FAB4                 1804
+#define MACH_TYPE_HTCDIAMOND           1805
+#define MACH_TYPE_FIONA                1806
+#define MACH_TYPE_MXC30030_X           1807
+#define MACH_TYPE_BMP1000              1808
+#define MACH_TYPE_LOGI9200             1809
+#define MACH_TYPE_TQMA31               1810
+#define MACH_TYPE_CCW9P9215JS          1811
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_SIFMAIN              1813
+#define MACH_TYPE_SAM9_L9261           1814
+#define MACH_TYPE_CC9M2443             1815
+#define MACH_TYPE_XARIA300             1816
+#define MACH_TYPE_IT9200               1817
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_KRISS_SENSOR         1819
+#define MACH_TYPE_PILZ_PMI5            1820
+#define MACH_TYPE_JADE                 1821
+#define MACH_TYPE_KS8695_SOFTPLC       1822
+#define MACH_TYPE_GPRISC3              1823
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDK6430             1825
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_DEISTER_EYECAM       1829
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_LINKSTATION_PRODUO   1831
+#define MACH_TYPE_HIT_B0               1832
+#define MACH_TYPE_ADX_RMU              1833
+#define MACH_TYPE_XG_CPE_MAIN          1834
+#define MACH_TYPE_EDB9407A             1835
+#define MACH_TYPE_DTB9608              1836
+#define MACH_TYPE_EM104V1              1837
+#define MACH_TYPE_DEMO                 1838
+#define MACH_TYPE_LOGI9260             1839
+#define MACH_TYPE_MX31_EXM32           1840
+#define MACH_TYPE_USB_A9G20            1841
+#define MACH_TYPE_PICPROJE2008         1842
+#define MACH_TYPE_CS_E9315             1843
+#define MACH_TYPE_QIL_A9G20            1844
+#define MACH_TYPE_SHA_PON020           1845
+#define MACH_TYPE_NAD                  1846
+#define MACH_TYPE_SBC35_A9260          1847
+#define MACH_TYPE_SBC35_A9G20          1848
+#define MACH_TYPE_DAVINCI_BEGINNING    1849
+#define MACH_TYPE_UWC                  1850
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_HTCNIKE              1852
+#define MACH_TYPE_DEISTER_PXA270       1853
+#define MACH_TYPE_CME9210JS            1854
+#define MACH_TYPE_CC9P9360             1855
+#define MACH_TYPE_MOCHA                1856
+#define MACH_TYPE_WAPD170AG            1857
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_W90X900              1860
+#define MACH_TYPE_W90X700              1861
+#define MACH_TYPE_KT300IP              1862
+#define MACH_TYPE_KT300IP_G20          1863
+#define MACH_TYPE_SRCM                 1864
+#define MACH_TYPE_WLNX_9260            1865
+#define MACH_TYPE_OPENMOKO_GTA03       1866
+#define MACH_TYPE_OSPREY2              1867
+#define MACH_TYPE_KBIO9260             1868
+#define MACH_TYPE_GINZA                1869
+#define MACH_TYPE_A636N                1870
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_NEMOC                1872
+#define MACH_TYPE_GENEVA               1873
+#define MACH_TYPE_HTCPHAROS            1874
+#define MACH_TYPE_NEONC                1875
+#define MACH_TYPE_NAS7100              1876
+#define MACH_TYPE_TEUPHONE             1877
+#define MACH_TYPE_ANNAX_ETH2           1878
+#define MACH_TYPE_CSB733               1879
+#define MACH_TYPE_BK3                  1880
+#define MACH_TYPE_OMAP_EM32            1881
+#define MACH_TYPE_ET9261CP             1882
+#define MACH_TYPE_JASPERC              1883
+#define MACH_TYPE_ISSI_ARM9            1884
+#define MACH_TYPE_UED                  1885
+#define MACH_TYPE_ESIBLADE             1886
+#define MACH_TYPE_EYE02                1887
+#define MACH_TYPE_IMX27KBD             1888
+#define MACH_TYPE_SST61VC010_FPGA      1889
+#define MACH_TYPE_KIXVP435             1890
+#define MACH_TYPE_KIXNP435             1891
+#define MACH_TYPE_AFRICA               1892
+#define MACH_TYPE_NH233                1893
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_BCM4760              1895
+#define MACH_TYPE_EDDY_V2              1896
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_HID_A7               1898
+#define MACH_TYPE_HERO                 1899
+#define MACH_TYPE_OMAP_POSEIDON        1900
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_MAKO                 1903
+#define MACH_TYPE_XDAFLAME             1904
+#define MACH_TYPE_PHIDGET_SBC2         1905
+#define MACH_TYPE_LIMESTONE            1906
+#define MACH_TYPE_IPROBE_C32           1907
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_ASUSP535             1909
+#define MACH_TYPE_HTCRAPHAEL           1910
+#define MACH_TYPE_SYGDG1               1911
+#define MACH_TYPE_SYGDG2               1912
+#define MACH_TYPE_SEOUL                1913
+#define MACH_TYPE_SALERNO              1914
+#define MACH_TYPE_UCN_S3C64XX          1915
+#define MACH_TYPE_MSM7201A             1916
+#define MACH_TYPE_LPR1                 1917
+#define MACH_TYPE_ARMADILLO500FX       1918
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_Z3_DM355             1920
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P920EVB           1922
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_CAMHD                1925
+#define MACH_TYPE_MVC100               1926
+#define MACH_TYPE_ELECTRUM_200         1927
+#define MACH_TYPE_HTCJADE              1928
+#define MACH_TYPE_MEMPHIS              1929
+#define MACH_TYPE_IMX27SBC             1930
+#define MACH_TYPE_LEXTAR               1931
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_Z32AN                1934
+#define MACH_TYPE_TMQ_CAPD             1935
+#define MACH_TYPE_OMAP3_WL             1936
+#define MACH_TYPE_CHUMBY               1937
+#define MACH_TYPE_ATSARM9              1938
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_BAHAMAS              1940
+#define MACH_TYPE_DAS                  1941
+#define MACH_TYPE_MINIDAS              1942
+#define MACH_TYPE_VK1000               1943
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_CTERA_2BAY           1945
+#define MACH_TYPE_EDGECONNECT          1946
+#define MACH_TYPE_ND27000              1947
+#define MACH_TYPE_GEMALTO_COBRA        1948
+#define MACH_TYPE_INGELABS_COMET       1949
+#define MACH_TYPE_POLLUX_WIZ           1950
+#define MACH_TYPE_BLACKSTONE           1951
+#define MACH_TYPE_TOPAZ                1952
+#define MACH_TYPE_AIXLE                1953
+#define MACH_TYPE_MW998                1954
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_VSC5605EV            1956
+#define MACH_TYPE_NT98700DK            1957
+#define MACH_TYPE_ICONTACT             1958
+#define MACH_TYPE_SWARCO_FRCPU         1959
+#define MACH_TYPE_SWARCO_SCPU          1960
+#define MACH_TYPE_BBOX_P16             1961
+#define MACH_TYPE_BSTD                 1962
+#define MACH_TYPE_SBC2440II            1963
+#define MACH_TYPE_PCM034               1964
+#define MACH_TYPE_NESO                 1965
+#define MACH_TYPE_WLNX_9G20            1966
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_TOTEMNOVA            1968
+#define MACH_TYPE_C5000                1969
+#define MACH_TYPE_UNIPO_AT91SAM9263    1970
+#define MACH_TYPE_ETHERNUT5            1971
+#define MACH_TYPE_ARM11                1972
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_CPUPXA255            1974
+#define MACH_TYPE_CPUIMX27             1975
+#define MACH_TYPE_CHEFLUX              1976
+#define MACH_TYPE_EB_CPUX9K2           1977
+#define MACH_TYPE_OPCOTEC              1978
+#define MACH_TYPE_YT                   1979
+#define MACH_TYPE_MOTOQ                1980
+#define MACH_TYPE_BSB1                 1981
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_MILAN                1983
+#define MACH_TYPE_QUARTZV2             1984
+#define MACH_TYPE_RSVP                 1985
+#define MACH_TYPE_RMP200               1986
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_ADSGCM               1989
+#define MACH_TYPE_ASE2_400             1990
+#define MACH_TYPE_PIZZA                1991
+#define MACH_TYPE_SPOT_NGPL            1992
+#define MACH_TYPE_ARMATA               1993
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MX31SF005            1995
+#define MACH_TYPE_F5D8231_4_V2         1996
+#define MACH_TYPE_Q2440                1997
+#define MACH_TYPE_QQ2440               1998
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_JADES                2001
+#define MACH_TYPE_SPARK                2002
+#define MACH_TYPE_BENZINA              2003
+#define MACH_TYPE_BLAZE                2004
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_HTCVENUS             2006
+#define MACH_TYPE_SONY_PRS505          2007
+#define MACH_TYPE_HANLIN_V3            2008
+#define MACH_TYPE_SAPPHIRA             2009
+#define MACH_TYPE_DACK_SDA_01          2010
+#define MACH_TYPE_ARMBOX               2011
+#define MACH_TYPE_HARRIS_RVP           2012
+#define MACH_TYPE_RIBALDO              2013
+#define MACH_TYPE_AGORA                2014
+#define MACH_TYPE_OMAP3_MINI           2015
+#define MACH_TYPE_A9SAM6432_B          2016
+#define MACH_TYPE_USG2410              2017
+#define MACH_TYPE_PC72052_I10_REVB     2018
+#define MACH_TYPE_MX35_EXM32           2019
+#define MACH_TYPE_TOPAS910             2020
+#define MACH_TYPE_HYENA                2021
+#define MACH_TYPE_POSPAX               2022
+#define MACH_TYPE_HDL_GX               2023
+#define MACH_TYPE_CTERA_4BAY           2024
+#define MACH_TYPE_CTERA_PLUG_C         2025
+#define MACH_TYPE_CRWEA_PLUG_I         2026
+#define MACH_TYPE_EGAUGE2              2027
+#define MACH_TYPE_DIDJ                 2028
+#define MACH_TYPE_MEISTER              2029
+#define MACH_TYPE_HTCBLACKSTONE        2030
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_OMAP_35XX_MVP        2033
+#define MACH_TYPE_CTERA_PLUG_I         2034
+#define MACH_TYPE_PVG610               2035
+#define MACH_TYPE_HPRW6815             2036
+#define MACH_TYPE_OMAP3_OSWALD         2037
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_HTCRAPHAEL_CDMA      2039
+#define MACH_TYPE_HTCDIAMOND_CDMA      2040
+#define MACH_TYPE_SCALER               2041
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TETON                2044
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_BISHOP2              2046
+#define MACH_TYPE_IPPV5                2047
+#define MACH_TYPE_FARM926              2048
+#define MACH_TYPE_MMCCPU               2049
+#define MACH_TYPE_SGMSFL               2050
+#define MACH_TYPE_TT8000               2051
+#define MACH_TYPE_ZRN4300LP            2052
+#define MACH_TYPE_MPTC                 2053
+#define MACH_TYPE_H6051                2054
+#define MACH_TYPE_PVG610_101           2055
+#define MACH_TYPE_STAMP9261_PC_EVB     2056
+#define MACH_TYPE_PELCO_ODYSSEUS       2057
+#define MACH_TYPE_TNY_A9260            2058
+#define MACH_TYPE_TNY_A9G20            2059
+#define MACH_TYPE_AESOP_MP2530F        2060
+#define MACH_TYPE_DX900                2061
+#define MACH_TYPE_CPODC2               2062
+#define MACH_TYPE_TILT_8925            2063
+#define MACH_TYPE_DAVINCI_DM357_EVM    2064
+#define MACH_TYPE_SWORDFISH            2065
+#define MACH_TYPE_CORVUS               2066
+#define MACH_TYPE_TAURUS               2067
+#define MACH_TYPE_AXM                  2068
+#define MACH_TYPE_AXC                  2069
+#define MACH_TYPE_BABY                 2070
+#define MACH_TYPE_MP200                2071
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_HANLIN_V3C           2073
+#define MACH_TYPE_KBK9G20              2074
+#define MACH_TYPE_ADSTURBOG5           2075
+#define MACH_TYPE_AVENGER_LITE1        2076
+#define MACH_TYPE_SUC                  2077
+#define MACH_TYPE_AT91SAM7S256         2078
+#define MACH_TYPE_MENDOZA              2079
+#define MACH_TYPE_KIRA                 2080
+#define MACH_TYPE_MX1HBM               2081
+#define MACH_TYPE_QUATRO43XX           2082
+#define MACH_TYPE_QUATRO4230           2083
+#define MACH_TYPE_NSB400               2084
+#define MACH_TYPE_DRP255               2085
+#define MACH_TYPE_THOTH                2086
+#define MACH_TYPE_FIRESTONE            2087
+#define MACH_TYPE_ASUSP750             2088
+#define MACH_TYPE_CTERA_DL             2089
+#define MACH_TYPE_SOCR                 2090
+#define MACH_TYPE_HTCOXYGEN            2091
+#define MACH_TYPE_HEROC                2092
+#define MACH_TYPE_ZENO6800             2093
+#define MACH_TYPE_SC2MCS               2094
+#define MACH_TYPE_GENE100              2095
+#define MACH_TYPE_AS353X               2096
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AT91SAM9G20          2098
+#define MACH_TYPE_MV88F6192GTW_FE      2099
+#define MACH_TYPE_CC9200               2100
+#define MACH_TYPE_SM9200               2101
+#define MACH_TYPE_TP9200               2102
+#define MACH_TYPE_SNAPPERDV            2103
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_AVENGERS_LITE1       2105
+#define MACH_TYPE_OMAP3AXON            2106
+#define MACH_TYPE_MA8XX                2107
+#define MACH_TYPE_MP201EK              2108
+#define MACH_TYPE_DAVINCI_TUX          2109
+#define MACH_TYPE_MPA1600              2110
+#define MACH_TYPE_PELCO_TROY           2111
+#define MACH_TYPE_NSB667               2112
+#define MACH_TYPE_ROVERS5_4MPIX        2113
+#define MACH_TYPE_TWOCOM               2114
+#define MACH_TYPE_UBISYS_P9_RCU3R2     2115
+#define MACH_TYPE_HERO_ESPRESSO        2116
+#define MACH_TYPE_AFEUSB               2117
+#define MACH_TYPE_T830                 2118
+#define MACH_TYPE_SPD8020_CC           2119
+#define MACH_TYPE_OM_3D7K              2120
+#define MACH_TYPE_PICOCOM2             2121
+#define MACH_TYPE_UWG4MX27             2122
+#define MACH_TYPE_UWG4MX31             2123
+#define MACH_TYPE_CHERRY               2124
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_S3C2440TURKIYE       2126
+#define MACH_TYPE_TX37                 2127
+#define MACH_TYPE_SBC2800_9G20         2128
+#define MACH_TYPE_BENZGLB              2129
+#define MACH_TYPE_BENZTD               2130
+#define MACH_TYPE_CARTESIO_PLUS        2131
+#define MACH_TYPE_SOLRAD_G20           2132
+#define MACH_TYPE_MX27WALLACE          2133
+#define MACH_TYPE_FMZWEBMODUL          2134
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_SMALLOGGER           2136
+#define MACH_TYPE_CCW9P9215            2137
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_TNY_A9263            2140
+#define MACH_TYPE_APOLLO               2141
+#define MACH_TYPE_AT91CAP9STK          2142
+#define MACH_TYPE_SPC300               2143
+#define MACH_TYPE_EKO                  2144
+#define MACH_TYPE_CCW9M2443            2145
+#define MACH_TYPE_CCW9M2443JS          2146
+#define MACH_TYPE_M2M_ROUTER_DEVICE    2147
+#define MACH_TYPE_STAR9104NAS          2148
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_Z3_DM365_MOD_01      2150
+#define MACH_TYPE_HIPOX                2151
+#define MACH_TYPE_OMAP3_PITEDS         2152
+#define MACH_TYPE_BM150R               2153
+#define MACH_TYPE_TBONE                2154
+#define MACH_TYPE_MERLIN               2155
+#define MACH_TYPE_FALCON               2156
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_S5P6440              2158
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_LPC313X              2161
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_MAGX_EM30            2163
+#define MACH_TYPE_MAGX_VE66            2164
+#define MACH_TYPE_MEESC                2165
+#define MACH_TYPE_OTC570               2166
+#define MACH_TYPE_BCU2412              2167
+#define MACH_TYPE_BEACON               2168
+#define MACH_TYPE_ACTIA_TGW            2169
+#define MACH_TYPE_E4430                2170
+#define MACH_TYPE_QL300                2171
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_SQ201                2174
+#define MACH_TYPE_QUATRO45XX           2175
+#define MACH_TYPE_OPENPAD              2176
+#define MACH_TYPE_TX25                 2177
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_HTCRAPHAEL_K         2179
+#define MACH_TYPE_LAL43                2181
+#define MACH_TYPE_HTCRAPHAEL_CDMA500   2182
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_HTCPROPHET           2185
+#define MACH_TYPE_CFA_10022            2186
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PX2IMX27             2188
+#define MACH_TYPE_STM3210E_EVAL        2189
+#define MACH_TYPE_DVS10                2190
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_ARM_SPV              2192
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_CABESPRESSO          2194
+#define MACH_TYPE_HMC800               2195
+#define MACH_TYPE_SHOLES               2196
+#define MACH_TYPE_BTMXC31              2197
+#define MACH_TYPE_DT501                2198
+#define MACH_TYPE_KTX                  2199
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET4BIG_V2           2205
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_ENDB2443             2207
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_TROS                 2209
+#define MACH_TYPE_PELCO_HOMER          2210
+#define MACH_TYPE_OFSP8                2211
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_GUF_CUPID            2213
+#define MACH_TYPE_EAB1R                2214
+#define MACH_TYPE_DESIREC              2215
+#define MACH_TYPE_CORDOBA              2216
+#define MACH_TYPE_IRVINE               2217
+#define MACH_TYPE_SFF772               2218
+#define MACH_TYPE_PELCO_MILANO         2219
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_BIP6000              2221
+#define MACH_TYPE_SILVERMOON           2222
+#define MACH_TYPE_VC0830               2223
+#define MACH_TYPE_DT430                2224
+#define MACH_TYPE_JI42PF               2225
+#define MACH_TYPE_GNET_KSM             2226
+#define MACH_TYPE_GNET_SGM             2227
+#define MACH_TYPE_GNET_SGR             2228
+#define MACH_TYPE_OMAP3_ICETEKEVM      2229
+#define MACH_TYPE_PNP                  2230
+#define MACH_TYPE_CTERA_2BAY_K         2231
+#define MACH_TYPE_CTERA_2BAY_U         2232
+#define MACH_TYPE_SAS_C                2233
+#define MACH_TYPE_VMA2315              2234
+#define MACH_TYPE_VCS                  2235
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_SPEAR1300            2238
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_ARVOO_AX301          2240
+#define MACH_TYPE_MAPPHONE             2241
+#define MACH_TYPE_LEGEND               2242
+#define MACH_TYPE_SALSA                2243
+#define MACH_TYPE_LOUNGE               2244
+#define MACH_TYPE_VISION               2245
+#define MACH_TYPE_VMB20                2246
+#define MACH_TYPE_HY2410               2247
+#define MACH_TYPE_HY9315               2248
+#define MACH_TYPE_BULLWINKLE           2249
+#define MACH_TYPE_ARM_ULTIMATOR2       2250
+#define MACH_TYPE_VS_V210              2252
+#define MACH_TYPE_VS_V212              2253
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_SUEN3                2255
+#define MACH_TYPE_VESPER               2256
+#define MACH_TYPE_STR9                 2257
+#define MACH_TYPE_OMAP3_WL_FF          2258
+#define MACH_TYPE_SIMCOM               2259
+#define MACH_TYPE_MCWEBIO              2260
+#define MACH_TYPE_OMAP3_PHRAZER        2261
+#define MACH_TYPE_DARWIN               2262
+#define MACH_TYPE_ORATISCOMU           2263
+#define MACH_TYPE_RTSBC20              2264
+#define MACH_TYPE_I780                 2265
+#define MACH_TYPE_GEMINI324            2266
+#define MACH_TYPE_ORATISLAN            2267
+#define MACH_TYPE_ORATISALOG           2268
+#define MACH_TYPE_ORATISMADI           2269
+#define MACH_TYPE_ORATISOT16           2270
+#define MACH_TYPE_ORATISDESK           2271
+#define MACH_TYPE_VEXPRESS             2272
+#define MACH_TYPE_SINTEXO              2273
+#define MACH_TYPE_CM3389               2274
+#define MACH_TYPE_OMAP3_CIO            2275
+#define MACH_TYPE_SGH_I900             2276
+#define MACH_TYPE_BST100               2277
+#define MACH_TYPE_PASSION              2278
+#define MACH_TYPE_INDESIGN_AT91SAM     2279
+#define MACH_TYPE_C4_BADGER            2280
+#define MACH_TYPE_C4_VIPER             2281
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_NOTALVISION          2284
+#define MACH_TYPE_OMAP3_KBOC           2285
+#define MACH_TYPE_CYCLONE              2286
+#define MACH_TYPE_NINJA                2287
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_RESOL_DL2            2290
+#define MACH_TYPE_IFOSW                2291
+#define MACH_TYPE_HTCRHODIUM           2292
+#define MACH_TYPE_HTCTOPAZ             2293
+#define MACH_TYPE_MATRIX504            2294
+#define MACH_TYPE_MRFSA                2295
+#define MACH_TYPE_SC_P270              2296
+#define MACH_TYPE_ATLAS5_EVB           2297
+#define MACH_TYPE_PELCO_LOBOX          2298
+#define MACH_TYPE_DILAX_PCU200         2299
+#define MACH_TYPE_LEONARDO             2300
+#define MACH_TYPE_ZORAN_APPROACH7      2301
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_BCM2153_VESPER       2303
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_CLICKC               2305
+#define MACH_TYPE_ZB_GATEWAY           2306
+#define MACH_TYPE_TAZCARD              2307
+#define MACH_TYPE_TAZDEV               2308
+#define MACH_TYPE_ANNAX_CB_ARM         2309
+#define MACH_TYPE_ANNAX_DM3            2310
+#define MACH_TYPE_CEREBRIC             2311
+#define MACH_TYPE_ORCA                 2312
+#define MACH_TYPE_PC9260               2313
+#define MACH_TYPE_EMS285A              2314
+#define MACH_TYPE_GEC2410              2315
+#define MACH_TYPE_GEC2440              2316
+#define MACH_TYPE_ARCH_MW903           2317
+#define MACH_TYPE_MW2440               2318
+#define MACH_TYPE_ECAC2378             2319
+#define MACH_TYPE_TAZKIOSK             2320
+#define MACH_TYPE_WHITERABBIT_MCH      2321
+#define MACH_TYPE_SBOX9263             2322
+#define MACH_TYPE_OREO                 2323
+#define MACH_TYPE_SMDK6442             2324
+#define MACH_TYPE_OPENRD_BASE          2325
+#define MACH_TYPE_INCREDIBLE           2326
+#define MACH_TYPE_INCREDIBLEC          2327
+#define MACH_TYPE_HEROCT               2328
+#define MACH_TYPE_MMNET1000            2329
+#define MACH_TYPE_DEVKIT8000           2330
+#define MACH_TYPE_DEVKIT9000           2331
+#define MACH_TYPE_MX31TXTR             2332
+#define MACH_TYPE_U380                 2333
+#define MACH_TYPE_HUALU_BOARD          2334
+#define MACH_TYPE_NPCMX50              2335
+#define MACH_TYPE_MX51_LANGE51         2336
+#define MACH_TYPE_MX51_LANGE52         2337
+#define MACH_TYPE_RIOM                 2338
+#define MACH_TYPE_COMCAS               2339
+#define MACH_TYPE_WSI_MX27             2340
+#define MACH_TYPE_CM_T35               2341
+#define MACH_TYPE_NET2BIG              2342
+#define MACH_TYPE_MOTOROLA_A1600       2343
+#define MACH_TYPE_IGEP0020             2344
+#define MACH_TYPE_IGEP0010             2345
+#define MACH_TYPE_MV6281GTWGE2         2346
+#define MACH_TYPE_SCAT100              2347
+#define MACH_TYPE_SANMINA              2348
+#define MACH_TYPE_MOMENTO              2349
+#define MACH_TYPE_NUC9XX               2350
+#define MACH_TYPE_NUC910EVB            2351
+#define MACH_TYPE_NUC920EVB            2352
+#define MACH_TYPE_NUC950EVB            2353
+#define MACH_TYPE_NUC945EVB            2354
+#define MACH_TYPE_NUC960EVB            2355
+#define MACH_TYPE_NUC932EVB            2356
+#define MACH_TYPE_NUC900               2357
+#define MACH_TYPE_SD1SOC               2358
+#define MACH_TYPE_LN2440BC             2359
+#define MACH_TYPE_RSBC                 2360
+#define MACH_TYPE_OPENRD_CLIENT        2361
+#define MACH_TYPE_HPIPAQ11X            2362
+#define MACH_TYPE_WAYLAND              2363
+#define MACH_TYPE_ACNBSX102            2364
+#define MACH_TYPE_HWAT91               2365
+#define MACH_TYPE_AT91SAM9263CS        2366
+#define MACH_TYPE_CSB732               2367
+#define MACH_TYPE_U8500                2368
+#define MACH_TYPE_HUQIU                2369
+#define MACH_TYPE_MX51_KUNLUN          2370
+#define MACH_TYPE_PMT1G                2371
+#define MACH_TYPE_HTCELF               2372
+#define MACH_TYPE_ARMADILLO420         2373
+#define MACH_TYPE_ARMADILLO440         2374
+#define MACH_TYPE_U_CHIP_DUAL_ARM      2375
+#define MACH_TYPE_CSR_BDB3             2376
+#define MACH_TYPE_DOLBY_CAT1018        2377
+#define MACH_TYPE_HY9307               2378
+#define MACH_TYPE_A_ES                 2379
+#define MACH_TYPE_DAVINCI_IRIF         2380
+#define MACH_TYPE_AGAMA9263            2381
+#define MACH_TYPE_MARVELL_JASPER       2382
+#define MACH_TYPE_FLINT                2383
+#define MACH_TYPE_TAVOREVB3            2384
+#define MACH_TYPE_SCH_M490             2386
+#define MACH_TYPE_RBL01                2387
+#define MACH_TYPE_OMNIFI               2388
+#define MACH_TYPE_OTAVALO              2389
+#define MACH_TYPE_SIENNA               2390
+#define MACH_TYPE_HTC_EXCALIBUR_S620   2391
+#define MACH_TYPE_HTC_OPAL             2392
+#define MACH_TYPE_TOUCHBOOK            2393
+#define MACH_TYPE_LATTE                2394
+#define MACH_TYPE_XA200                2395
+#define MACH_TYPE_NIMROD               2396
+#define MACH_TYPE_CC9P9215_3G          2397
+#define MACH_TYPE_CC9P9215_3GJS        2398
+#define MACH_TYPE_TK71                 2399
+#define MACH_TYPE_COMHAM3525           2400
+#define MACH_TYPE_MX31EREBUS           2401
+#define MACH_TYPE_MCARDMX27            2402
+#define MACH_TYPE_PARADISE             2403
+#define MACH_TYPE_TIDE                 2404
+#define MACH_TYPE_WZL2440              2405
+#define MACH_TYPE_SDRDEMO              2406
+#define MACH_TYPE_ETHERCAN2            2407
+#define MACH_TYPE_ECMIMG20             2408
+#define MACH_TYPE_OMAP_DRAGON          2409
+#define MACH_TYPE_HALO                 2410
+#define MACH_TYPE_HUANGSHAN            2411
+#define MACH_TYPE_VL_MA2SC             2412
+#define MACH_TYPE_RAUMFELD_RC          2413
+#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
+#define MACH_TYPE_RAUMFELD_SPEAKER     2415
+#define MACH_TYPE_MULTIBUS_MASTER      2416
+#define MACH_TYPE_MULTIBUS_PBK         2417
+#define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_SNAKE                2419
+#define MACH_TYPE_CWMX27               2420
+#define MACH_TYPE_SCH_M480             2421
+#define MACH_TYPE_PLATYPUS             2422
+#define MACH_TYPE_PSS2                 2423
+#define MACH_TYPE_DAVINCI_APM150       2424
+#define MACH_TYPE_STR9100              2425
+#define MACH_TYPE_NET5BIG              2426
+#define MACH_TYPE_SEABED9263           2427
+#define MACH_TYPE_MX51_M2ID            2428
+#define MACH_TYPE_OCTVOCPLUS_EB        2429
+#define MACH_TYPE_KLK_FIREFOX          2430
+#define MACH_TYPE_KLK_WIRMA_MODULE     2431
+#define MACH_TYPE_KLK_WIRMA_MMI        2432
+#define MACH_TYPE_SUPERSONIC           2433
+#define MACH_TYPE_LIBERTY              2434
+#define MACH_TYPE_MH355                2435
+#define MACH_TYPE_PC7802               2436
+#define MACH_TYPE_GNET_SGC             2437
+#define MACH_TYPE_EINSTEIN15           2438
+#define MACH_TYPE_CMPD                 2439
+#define MACH_TYPE_DAVINCI_HASE1        2440
+#define MACH_TYPE_LGEINCITEPHONE       2441
+#define MACH_TYPE_EA313X               9998
+#define MACH_TYPE_FWBD_39064           2443
+#define MACH_TYPE_FWBD_390128          2444
+#define MACH_TYPE_PELCO_MOE            2445
+#define MACH_TYPE_MINIMIX27            2446
+#define MACH_TYPE_OMAP3_THUNDER        2447
+#define MACH_TYPE_PASSIONC             2448
+#define MACH_TYPE_MX27AMATA            2449
+#define MACH_TYPE_BGAT1                2450
+#define MACH_TYPE_BUZZ                 2451
+#define MACH_TYPE_MB9G20               2452
+#define MACH_TYPE_YUSHAN               2453
+#define MACH_TYPE_LIZARD               2454
+#define MACH_TYPE_OMAP3POLYCOM         2455
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_BRAVO                2457
+#define MACH_TYPE_SIOGENTOO1           2458
+#define MACH_TYPE_SIOGENTOO2           2459
+#define MACH_TYPE_SM3K                 2460
+#define MACH_TYPE_ACER_TEMPO_F900      2461
+#define MACH_TYPE_SST61VC010_DEV       2462
+#define MACH_TYPE_GLITTERTIND          2463
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_CYBOOK2440           2466
+#define MACH_TYPE_TORINO_S             2467
+#define MACH_TYPE_HAVANA               2468
+#define MACH_TYPE_BEAUMONT_11          2469
+#define MACH_TYPE_VANGUARD             2470
+#define MACH_TYPE_S5PC110_DRACO        2471
+#define MACH_TYPE_CARTESIO_TWO         2472
+#define MACH_TYPE_ASTER                2473
+#define MACH_TYPE_VOGUESV210           2474
+#define MACH_TYPE_ACM500X              2475
+#define MACH_TYPE_KM9260               2476
+#define MACH_TYPE_NIDEFLEXG1           2477
+#define MACH_TYPE_CTERA_PLUG_IO        2478
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_AT91SAM9G10EK2       2480
+#define MACH_TYPE_ASUSP527             2481
+#define MACH_TYPE_AT91SAM9G20MPM2      2482
+#define MACH_TYPE_TOPASA900            2483
+#define MACH_TYPE_ELECTRUM_100         2484
+#define MACH_TYPE_MX51GRB              2485
+#define MACH_TYPE_XEA300               2486
+#define MACH_TYPE_HTCSTARTREK          2487
+#define MACH_TYPE_LIMA                 2488
+#define MACH_TYPE_CSB740               2489
+#define MACH_TYPE_USB_S8815            2490
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_MILKYWAY             2492
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_PICOMOD6             2494
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_IP6000               2496
+#define MACH_TYPE_IP6010               2497
+#define MACH_TYPE_UTM400               2498
+#define MACH_TYPE_OMAP3_ZYBEX          2499
+#define MACH_TYPE_WIRELESS_SPACE       2500
+#define MACH_TYPE_SX560                2501
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_ELPHEL10373          2503
+#define MACH_TYPE_RHOBOT               2504
+#define MACH_TYPE_MX51_REFRESH         2505
+#define MACH_TYPE_LS9260               2506
+#define MACH_TYPE_SHANK                2507
+#define MACH_TYPE_QSD8X50_ST1          2508
+#define MACH_TYPE_AT91SAM9M10EKES      2509
+#define MACH_TYPE_HIRAM                2510
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_EA3250               2512
+#define MACH_TYPE_FDI3250              2513
+#define MACH_TYPE_WHITESTONE           2514
+#define MACH_TYPE_AT91SAM9263NIT       2515
+#define MACH_TYPE_CCMX51               2516
+#define MACH_TYPE_CCMX51JS             2517
+#define MACH_TYPE_CCWMX51              2518
+#define MACH_TYPE_CCWMX51JS            2519
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_TINY6410             2521
+#define MACH_TYPE_NANO6410             2522
+#define MACH_TYPE_AT572D940HFNLDB      2523
+#define MACH_TYPE_HTCLEO               2524
+#define MACH_TYPE_AVP13                2525
+#define MACH_TYPE_XXSVIDEOD            2526
+#define MACH_TYPE_VPNEXT               2527
+#define MACH_TYPE_SWARCO_ITC3          2528
+#define MACH_TYPE_TX51                 2529
+#define MACH_TYPE_DOLBY_CAT1021        2530
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_PHOENIX260           2532
+#define MACH_TYPE_UVACA_STORK          2533
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_ALL3078              2535
+#define MACH_TYPE_CTERA_2BAY_DS        2536
+#define MACH_TYPE_SIOGENTOO3           2537
+#define MACH_TYPE_EPB5000              2538
+#define MACH_TYPE_HY9263               2539
+#define MACH_TYPE_ACER_TEMPO_M900      2540
+#define MACH_TYPE_ACER_TEMPO_DX900     2541
+#define MACH_TYPE_ACER_TEMPO_X960      2542
+#define MACH_TYPE_ACER_ETEN_V900       2543
+#define MACH_TYPE_ACER_ETEN_X900       2544
+#define MACH_TYPE_BONNELL              2545
+#define MACH_TYPE_OHT_MX27             2546
+#define MACH_TYPE_HTCQUARTZ            2547
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_C3AX03               2549
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_ESYX                 2551
+#define MACH_TYPE_DOVE_DB2             2552
+#define MACH_TYPE_BULLDOG              2553
+#define MACH_TYPE_DERELL_ME2000        2554
+#define MACH_TYPE_BCMRING_BASE         2555
+#define MACH_TYPE_BCMRING_EVM          2556
+#define MACH_TYPE_BCMRING_EVM_JAZZ     2557
+#define MACH_TYPE_BCMRING_SP           2558
+#define MACH_TYPE_BCMRING_SV           2559
+#define MACH_TYPE_BCMRING_SV_JAZZ      2560
+#define MACH_TYPE_BCMRING_TABLET       2561
+#define MACH_TYPE_BCMRING_VP           2562
+#define MACH_TYPE_BCMRING_EVM_SEIKOR   2563
+#define MACH_TYPE_BCMRING_SP_WQVGA     2564
+#define MACH_TYPE_BCMRING_CUSTOM       2565
+#define MACH_TYPE_ACER_S200            2566
+#define MACH_TYPE_BT270                2567
+#define MACH_TYPE_ISEO                 2568
+#define MACH_TYPE_CEZANNE              2569
+#define MACH_TYPE_LUCCA                2570
+#define MACH_TYPE_SUPERSMART           2571
+#define MACH_TYPE_CS_MISANO            2572
+#define MACH_TYPE_MAGNOLIA2            2573
+#define MACH_TYPE_EMXX                 2574
+#define MACH_TYPE_OUTLAW               2575
+#define MACH_TYPE_RIOT_BEI2            2576
+#define MACH_TYPE_RIOT_VOX             2577
+#define MACH_TYPE_RIOT_X37             2578
+#define MACH_TYPE_MEGA25MX             2579
+#define MACH_TYPE_BENZINA2             2580
+#define MACH_TYPE_IGNITE               2581
+#define MACH_TYPE_FOGGIA               2582
+#define MACH_TYPE_AREZZO               2583
+#define MACH_TYPE_LEICA_SKYWALKER      2584
+#define MACH_TYPE_JACINTO2_JAMR        2585
+#define MACH_TYPE_GTS_NOVA             2586
+#define MACH_TYPE_P3600                2587
+#define MACH_TYPE_DLT2                 2588
+#define MACH_TYPE_DF3120               2589
+#define MACH_TYPE_ECUCORE_9G20         2590
+#define MACH_TYPE_NAUTEL_LPC3240       2591
+#define MACH_TYPE_GLACIER              2592
+#define MACH_TYPE_PHRAZER_BULLDOG      2593
+#define MACH_TYPE_OMAP3_BULLDOG        2594
+#define MACH_TYPE_PCA101               2595
+#define MACH_TYPE_BUZZC                2596
+#define MACH_TYPE_SASIE2               2597
+#define MACH_TYPE_DAVINCI_CIO          2598
+#define MACH_TYPE_SMARTMETER_DL        2599
+#define MACH_TYPE_WZL6410              2600
+#define MACH_TYPE_WZL6410M             2601
+#define MACH_TYPE_WZL6410F             2602
+#define MACH_TYPE_WZL6410I             2603
+#define MACH_TYPE_SPACECOM1            2604
+#define MACH_TYPE_PINGU920             2605
+#define MACH_TYPE_BRAVOC               2606
+#define MACH_TYPE_CYBO2440             2607
+#define MACH_TYPE_VDSSW                2608
+#define MACH_TYPE_ROMULUS              2609
+#define MACH_TYPE_OMAP_MAGIC           2610
+#define MACH_TYPE_ELTD100              2611
+#define MACH_TYPE_CAPC7117             2612
+#define MACH_TYPE_SWAN                 2613
+#define MACH_TYPE_VEU                  2614
+#define MACH_TYPE_RM2                  2615
+#define MACH_TYPE_TT2100               2616
+#define MACH_TYPE_VENICE               2617
+#define MACH_TYPE_PC7323               2618
+#define MACH_TYPE_MASP                 2619
+#define MACH_TYPE_FUJITSU_TVSTBSOC     2620
+#define MACH_TYPE_FUJITSU_TVSTBSOC1    2621
+#define MACH_TYPE_LEXIKON              2622
+#define MACH_TYPE_MINI2440V2           2623
+#define MACH_TYPE_ICONTROL             2624
+#define MACH_TYPE_SHEEVAD              2625
+#define MACH_TYPE_QSD8X50A_ST1_1       2626
+#define MACH_TYPE_QSD8X50A_ST1_5       2627
+#define MACH_TYPE_BEE                  2628
+#define MACH_TYPE_MX23EVK              2629
+#define MACH_TYPE_AP4EVB               2630
+#define MACH_TYPE_STOCKHOLM            2631
+#define MACH_TYPE_LPC_H3131            2632
+#define MACH_TYPE_STINGRAY             2633
+#define MACH_TYPE_KRAKEN               2634
+#define MACH_TYPE_GW2388               2635
+#define MACH_TYPE_JADECPU              2636
+#define MACH_TYPE_CARLISLE             2637
+#define MACH_TYPE_LUX_SFT9             2638
+#define MACH_TYPE_NEMID_TB             2639
+#define MACH_TYPE_TERRIER              2640
+#define MACH_TYPE_TURBOT               2641
+#define MACH_TYPE_SANDDAB              2642
+#define MACH_TYPE_MX35_CICADA          2643
+#define MACH_TYPE_GHI2703D             2644
+#define MACH_TYPE_LUX_SFX9             2645
+#define MACH_TYPE_LUX_SF9G             2646
+#define MACH_TYPE_LUX_EDK9             2647
+#define MACH_TYPE_HW90240              2648
+#define MACH_TYPE_DM365_LEOPARD        2649
+#define MACH_TYPE_MITYOMAPL138         2650
+#define MACH_TYPE_SCAT110              2651
+#define MACH_TYPE_ACER_A1              2652
+#define MACH_TYPE_CMCONTROL            2653
+#define MACH_TYPE_PELCO_LAMAR          2654
+#define MACH_TYPE_RFP43                2655
+#define MACH_TYPE_SK86R0301            2656
+#define MACH_TYPE_CTPXA                2657
+#define MACH_TYPE_EPB_ARM9_A           2658
+#define MACH_TYPE_GURUPLUG             2659
+#define MACH_TYPE_SPEAR310             2660
+#define MACH_TYPE_SPEAR320             2661
+#define MACH_TYPE_ROBOTX               2662
+#define MACH_TYPE_LSXHL                2663
+#define MACH_TYPE_SMARTLITE            2664
+#define MACH_TYPE_CWS2                 2665
+#define MACH_TYPE_M619                 2666
+#define MACH_TYPE_SMARTVIEW            2667
+#define MACH_TYPE_LSA_SALSA            2668
+#define MACH_TYPE_KIZBOX               2669
+#define MACH_TYPE_HTCCHARMER           2670
+#define MACH_TYPE_GUF_NESO_LT          2671
+#define MACH_TYPE_PM9G45               2672
+#define MACH_TYPE_HTCPANTHER           2673
+#define MACH_TYPE_HTCPANTHER_CDMA      2674
+#define MACH_TYPE_REB01                2675
+#define MACH_TYPE_AQUILA               2676
+#define MACH_TYPE_SPARK_SLS_HW2        2677
+#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
+#define MACH_TYPE_SURF7X30             2679
+#define MACH_TYPE_MICRO2440            2680
+#define MACH_TYPE_AM2440               2681
+#define MACH_TYPE_TQ2440               2682
+#define MACH_TYPE_LPC2478OEM           2683
+#define MACH_TYPE_AK880X               2684
+#define MACH_TYPE_COBRA3530            2685
+#define MACH_TYPE_PMPPB                2686
+#define MACH_TYPE_U6715                2687
+#define MACH_TYPE_AXAR1500_SENDER      2688
+#define MACH_TYPE_G30_DVB              2689
+#define MACH_TYPE_VC088X               2690
+#define MACH_TYPE_MIOA702              2691
+#define MACH_TYPE_HPMIN                2692
+#define MACH_TYPE_AK880XAK             2693
+#define MACH_TYPE_VAL3153              9999
+#define MACH_TYPE_VAL3154              9997
+#define MACH_TYPE_EA3152               9996
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEXUSPCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUSPCI
+# endif
+# define machine_is_nexuspci()	(machine_arch_type == MACH_TYPE_NEXUSPCI)
+#else
+# define machine_is_nexuspci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBOX
+# endif
+# define machine_is_tbox()	(machine_arch_type == MACH_TYPE_TBOX)
+#else
+# define machine_is_tbox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CO285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CO285
+# endif
+# define machine_is_co285()	(machine_arch_type == MACH_TYPE_CO285)
+#else
+# define machine_is_co285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7110
+# endif
+# define machine_is_clps7110()	(machine_arch_type == MACH_TYPE_CLPS7110)
+#else
+# define machine_is_clps7110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCHIMEDES
+# endif
+# define machine_is_archimedes()	(machine_arch_type == MACH_TYPE_ARCHIMEDES)
+#else
+# define machine_is_archimedes()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_A5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A5K
+# endif
+# define machine_is_a5k()	(machine_arch_type == MACH_TYPE_A5K)
+#else
+# define machine_is_a5k()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ETOILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETOILE
+# endif
+# define machine_is_etoile()	(machine_arch_type == MACH_TYPE_ETOILE)
+#else
+# define machine_is_etoile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LACIE_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LACIE_NAS
+# endif
+# define machine_is_lacie_nas()	(machine_arch_type == MACH_TYPE_LACIE_NAS)
+#else
+# define machine_is_lacie_nas()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLPS7500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLPS7500
+# endif
+# define machine_is_clps7500()	(machine_arch_type == MACH_TYPE_CLPS7500)
+#else
+# define machine_is_clps7500()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITSY
+# endif
+# define machine_is_itsy()	(machine_arch_type == MACH_TYPE_ITSY)
+#else
+# define machine_is_itsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP1200
+# endif
+# define machine_is_ixp1200()	(machine_arch_type == MACH_TYPE_IXP1200)
+#else
+# define machine_is_ixp1200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_VICTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTOR
+# endif
+# define machine_is_victor()	(machine_arch_type == MACH_TYPE_VICTOR)
+#else
+# define machine_is_victor()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RANGER
+# endif
+# define machine_is_ranger()	(machine_arch_type == MACH_TYPE_RANGER)
+#else
+# define machine_is_ranger()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FPIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC
+# endif
+# define machine_is_fpic()	(machine_arch_type == MACH_TYPE_FPIC)
+#else
+# define machine_is_fpic()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXTENEX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXTENEX1
+# endif
+# define machine_is_extenex1()	(machine_arch_type == MACH_TYPE_EXTENEX1)
+#else
+# define machine_is_extenex1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHERMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHERMAN
+# endif
+# define machine_is_sherman()	(machine_arch_type == MACH_TYPE_SHERMAN)
+#else
+# define machine_is_sherman()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_SA
+# endif
+# define machine_is_accelent_sa()	(machine_arch_type == MACH_TYPE_ACCELENT_SA)
+#else
+# define machine_is_accelent_sa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200_ACCELENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_L7200
+# endif
+# define machine_is_accelent_l7200()	(machine_arch_type == MACH_TYPE_ACCELENT_L7200)
+#else
+# define machine_is_accelent_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETPORT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETPORT
+# endif
+# define machine_is_netport()	(machine_arch_type == MACH_TYPE_NETPORT)
+#else
+# define machine_is_netport()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PANGOLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANGOLIN
+# endif
+# define machine_is_pangolin()	(machine_arch_type == MACH_TYPE_PANGOLIN)
+#else
+# define machine_is_pangolin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_YOPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOPY
+# endif
+# define machine_is_yopy()	(machine_arch_type == MACH_TYPE_YOPY)
+#else
+# define machine_is_yopy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COOLIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COOLIDGE
+# endif
+# define machine_is_coolidge()	(machine_arch_type == MACH_TYPE_COOLIDGE)
+#else
+# define machine_is_coolidge()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HUW_WEBPANEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUW_WEBPANEL
+# endif
+# define machine_is_huw_webpanel()	(machine_arch_type == MACH_TYPE_HUW_WEBPANEL)
+#else
+# define machine_is_huw_webpanel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPOTME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOTME
+# endif
+# define machine_is_spotme()	(machine_arch_type == MACH_TYPE_SPOTME)
+#else
+# define machine_is_spotme()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FREEBIRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBIRD
+# endif
+# define machine_is_freebird()	(machine_arch_type == MACH_TYPE_FREEBIRD)
+#else
+# define machine_is_freebird()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI925
+# endif
+# define machine_is_ti925()	(machine_arch_type == MACH_TYPE_TI925)
+#else
+# define machine_is_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RISCSTATION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCSTATION
+# endif
+# define machine_is_riscstation()	(machine_arch_type == MACH_TYPE_RISCSTATION)
+#else
+# define machine_is_riscstation()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CAVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAVY
+# endif
+# define machine_is_cavy()	(machine_arch_type == MACH_TYPE_CAVY)
+#else
+# define machine_is_cavy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_OMNIMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMNIMETER
+# endif
+# define machine_is_omnimeter()	(machine_arch_type == MACH_TYPE_OMNIMETER)
+#else
+# define machine_is_omnimeter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CITYGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CITYGO
+# endif
+# define machine_is_citygo()	(machine_arch_type == MACH_TYPE_CITYGO)
+#else
+# define machine_is_citygo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SPOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT
+# endif
+# define machine_is_spot()	(machine_arch_type == MACH_TYPE_SPOT)
+#else
+# define machine_is_spot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBPAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBPAL
+# endif
+# define machine_is_webpal()	(machine_arch_type == MACH_TYPE_WEBPAL)
+#else
+# define machine_is_webpal()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LINPDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINPDA
+# endif
+# define machine_is_linpda()	(machine_arch_type == MACH_TYPE_LINPDA)
+#else
+# define machine_is_linpda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANAKIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANAKIN
+# endif
+# define machine_is_anakin()	(machine_arch_type == MACH_TYPE_ANAKIN)
+#else
+# define machine_is_anakin()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVI
+# endif
+# define machine_is_mvi()	(machine_arch_type == MACH_TYPE_MVI)
+#else
+# define machine_is_mvi()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JUPITER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JUPITER
+# endif
+# define machine_is_jupiter()	(machine_arch_type == MACH_TYPE_JUPITER)
+#else
+# define machine_is_jupiter()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PSIONW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSIONW
+# endif
+# define machine_is_psionw()	(machine_arch_type == MACH_TYPE_PSIONW)
+#else
+# define machine_is_psionw()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALN
+# endif
+# define machine_is_aln()	(machine_arch_type == MACH_TYPE_ALN)
+#else
+# define machine_is_aln()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMELOT
+# endif
+# define machine_is_epxa()	(machine_arch_type == MACH_TYPE_CAMELOT)
+#else
+# define machine_is_epxa()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GDS2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GDS2200
+# endif
+# define machine_is_gds2200()	(machine_arch_type == MACH_TYPE_GDS2200)
+#else
+# define machine_is_gds2200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PSION_SERIES7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSION_SERIES7
+# endif
+# define machine_is_netbook()	(machine_arch_type == MACH_TYPE_PSION_SERIES7)
+#else
+# define machine_is_netbook()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XFILE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XFILE
+# endif
+# define machine_is_xfile()	(machine_arch_type == MACH_TYPE_XFILE)
+#else
+# define machine_is_xfile()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACCELENT_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACCELENT_EP9312
+# endif
+# define machine_is_accelent_ep9312()	(machine_arch_type == MACH_TYPE_ACCELENT_EP9312)
+#else
+# define machine_is_accelent_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IC200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IC200
+# endif
+# define machine_is_ic200()	(machine_arch_type == MACH_TYPE_IC200)
+#else
+# define machine_is_ic200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CREDITLART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CREDITLART
+# endif
+# define machine_is_creditlart()	(machine_arch_type == MACH_TYPE_CREDITLART)
+#else
+# define machine_is_creditlart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HTM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTM
+# endif
+# define machine_is_htm()	(machine_arch_type == MACH_TYPE_HTM)
+#else
+# define machine_is_htm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80310
+# endif
+# define machine_is_iq80310()	(machine_arch_type == MACH_TYPE_IQ80310)
+#else
+# define machine_is_iq80310()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FREEBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FREEBOT
+# endif
+# define machine_is_freebot()	(machine_arch_type == MACH_TYPE_FREEBOT)
+#else
+# define machine_is_freebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENTEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTEL
+# endif
+# define machine_is_entel()	(machine_arch_type == MACH_TYPE_ENTEL)
+#else
+# define machine_is_entel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP3510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP3510
+# endif
+# define machine_is_enp3510()	(machine_arch_type == MACH_TYPE_ENP3510)
+#else
+# define machine_is_enp3510()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TRIZEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS
+# endif
+# define machine_is_trizeps()	(machine_arch_type == MACH_TYPE_TRIZEPS)
+#else
+# define machine_is_trizeps()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NESA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESA
+# endif
+# define machine_is_nesa()	(machine_arch_type == MACH_TYPE_NESA)
+#else
+# define machine_is_nesa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENUS
+# endif
+# define machine_is_venus()	(machine_arch_type == MACH_TYPE_VENUS)
+#else
+# define machine_is_venus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TARDIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TARDIS
+# endif
+# define machine_is_tardis()	(machine_arch_type == MACH_TYPE_TARDIS)
+#else
+# define machine_is_tardis()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERCURY
+# endif
+# define machine_is_mercury()	(machine_arch_type == MACH_TYPE_MERCURY)
+#else
+# define machine_is_mercury()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMPEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPEG
+# endif
+# define machine_is_empeg()	(machine_arch_type == MACH_TYPE_EMPEG)
+#else
+# define machine_is_empeg()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I80200FCC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I80200FCC
+# endif
+# define machine_is_adi_evb()	(machine_arch_type == MACH_TYPE_I80200FCC)
+#else
+# define machine_is_adi_evb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ITT_CPB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITT_CPB
+# endif
+# define machine_is_itt_cpb()	(machine_arch_type == MACH_TYPE_ITT_CPB)
+#else
+# define machine_is_itt_cpb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVC
+# endif
+# define machine_is_svc()	(machine_arch_type == MACH_TYPE_SVC)
+#else
+# define machine_is_svc()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA2
+# endif
+# define machine_is_alpha2()	(machine_arch_type == MACH_TYPE_ALPHA2)
+#else
+# define machine_is_alpha2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ALPHA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALPHA1
+# endif
+# define machine_is_alpha1()	(machine_arch_type == MACH_TYPE_ALPHA1)
+#else
+# define machine_is_alpha1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETARM
+# endif
+# define machine_is_netarm()	(machine_arch_type == MACH_TYPE_NETARM)
+#else
+# define machine_is_netarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDA1
+# endif
+# define machine_is_pda1()	(machine_arch_type == MACH_TYPE_PDA1)
+#else
+# define machine_is_pda1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ANIKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANIKO
+# endif
+# define machine_is_aniko()	(machine_arch_type == MACH_TYPE_ANIKO)
+#else
+# define machine_is_aniko()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CS89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS89712
+# endif
+# define machine_is_cs89712()	(machine_arch_type == MACH_TYPE_CS89712)
+#else
+# define machine_is_cs89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WEARARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEARARM
+# endif
+# define machine_is_weararm()	(machine_arch_type == MACH_TYPE_WEARARM)
+#else
+# define machine_is_weararm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_POSSIO_PX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX
+# endif
+# define machine_is_possio_px()	(machine_arch_type == MACH_TYPE_POSSIO_PX)
+#else
+# define machine_is_possio_px()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIDEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEARM
+# endif
+# define machine_is_sidearm()	(machine_arch_type == MACH_TYPE_SIDEARM)
+#else
+# define machine_is_sidearm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK
+# endif
+# define machine_is_stork()	(machine_arch_type == MACH_TYPE_STORK)
+#else
+# define machine_is_stork()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACE
+# endif
+# define machine_is_ace()	(machine_arch_type == MACH_TYPE_ACE)
+#else
+# define machine_is_ace()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLYARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLYARM
+# endif
+# define machine_is_ballyarm()	(machine_arch_type == MACH_TYPE_BALLYARM)
+#else
+# define machine_is_ballyarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPUTER
+# endif
+# define machine_is_simputer()	(machine_arch_type == MACH_TYPE_SIMPUTER)
+#else
+# define machine_is_simputer()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXTERM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTERM
+# endif
+# define machine_is_nexterm()	(machine_arch_type == MACH_TYPE_NEXTERM)
+#else
+# define machine_is_nexterm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SA1100_ELF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SA1100_ELF
+# endif
+# define machine_is_sa1100_elf()	(machine_arch_type == MACH_TYPE_SA1100_ELF)
+#else
+# define machine_is_sa1100_elf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATOR
+# endif
+# define machine_is_gator()	(machine_arch_type == MACH_TYPE_GATOR)
+#else
+# define machine_is_gator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GRANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANITE
+# endif
+# define machine_is_granite()	(machine_arch_type == MACH_TYPE_GRANITE)
+#else
+# define machine_is_granite()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PLCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLCE
+# endif
+# define machine_is_plce()	(machine_arch_type == MACH_TYPE_PLCE)
+#else
+# define machine_is_plce()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEDALB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALB
+# endif
+# define machine_is_murphy()	(machine_arch_type == MACH_TYPE_MEDALB)
+#else
+# define machine_is_murphy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAGLE
+# endif
+# define machine_is_eagle()	(machine_arch_type == MACH_TYPE_EAGLE)
+#else
+# define machine_is_eagle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC21
+# endif
+# define machine_is_dsc21()	(machine_arch_type == MACH_TYPE_DSC21)
+#else
+# define machine_is_dsc21()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC24
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC24
+# endif
+# define machine_is_dsc24()	(machine_arch_type == MACH_TYPE_DSC24)
+#else
+# define machine_is_dsc24()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TI5472
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI5472
+# endif
+# define machine_is_ti5472()	(machine_arch_type == MACH_TYPE_TI5472)
+#else
+# define machine_is_ti5472()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UENGINE
+# endif
+# define machine_is_uengine()	(machine_arch_type == MACH_TYPE_UENGINE)
+#else
+# define machine_is_uengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUESTEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESTEM
+# endif
+# define machine_is_bluestem()	(machine_arch_type == MACH_TYPE_BLUESTEM)
+#else
+# define machine_is_bluestem()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_XINGU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XINGU8
+# endif
+# define machine_is_xingu8()	(machine_arch_type == MACH_TYPE_XINGU8)
+#else
+# define machine_is_xingu8()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BUSHSTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUSHSTB
+# endif
+# define machine_is_bushstb()	(machine_arch_type == MACH_TYPE_BUSHSTB)
+#else
+# define machine_is_bushstb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EPSILON1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPSILON1
+# endif
+# define machine_is_epsilon1()	(machine_arch_type == MACH_TYPE_EPSILON1)
+#else
+# define machine_is_epsilon1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BALLOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON
+# endif
+# define machine_is_balloon()	(machine_arch_type == MACH_TYPE_BALLOON)
+#else
+# define machine_is_balloon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPY
+# endif
+# define machine_is_puppy()	(machine_arch_type == MACH_TYPE_PUPPY)
+#else
+# define machine_is_puppy()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ELROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY
+# endif
+# define machine_is_elroy()	(machine_arch_type == MACH_TYPE_ELROY)
+#else
+# define machine_is_elroy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GMS720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GMS720
+# endif
+# define machine_is_gms720()	(machine_arch_type == MACH_TYPE_GMS720)
+#else
+# define machine_is_gms720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S24X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S24X
+# endif
+# define machine_is_s24x()	(machine_arch_type == MACH_TYPE_S24X)
+#else
+# define machine_is_s24x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JTEL_CLEP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JTEL_CLEP7312
+# endif
+# define machine_is_jtel_clep7312()	(machine_arch_type == MACH_TYPE_JTEL_CLEP7312)
+#else
+# define machine_is_jtel_clep7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX821XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX821XX
+# endif
+# define machine_is_cx821xx()	(machine_arch_type == MACH_TYPE_CX821XX)
+#else
+# define machine_is_cx821xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7312
+# endif
+# define machine_is_edb7312()	(machine_arch_type == MACH_TYPE_EDB7312)
+#else
+# define machine_is_edb7312()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BSA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSA1110
+# endif
+# define machine_is_bsa1110()	(machine_arch_type == MACH_TYPE_BSA1110)
+#else
+# define machine_is_bsa1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POWERPIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POWERPIN
+# endif
+# define machine_is_powerpin()	(machine_arch_type == MACH_TYPE_POWERPIN)
+#else
+# define machine_is_powerpin()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPENARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENARM
+# endif
+# define machine_is_openarm()	(machine_arch_type == MACH_TYPE_OPENARM)
+#else
+# define machine_is_openarm()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITECHAPEL
+# endif
+# define machine_is_whitechapel()	(machine_arch_type == MACH_TYPE_WHITECHAPEL)
+#else
+# define machine_is_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3800
+# endif
+# define machine_is_h3800()	(machine_arch_type == MACH_TYPE_H3800)
+#else
+# define machine_is_h3800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUE_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_V1
+# endif
+# define machine_is_blue_v1()	(machine_arch_type == MACH_TYPE_BLUE_V1)
+#else
+# define machine_is_blue_v1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_CERF
+# endif
+# define machine_is_pxa_cerf()	(machine_arch_type == MACH_TYPE_PXA_CERF)
+#else
+# define machine_is_pxa_cerf()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARM7TEVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM7TEVB
+# endif
+# define machine_is_arm7tevb()	(machine_arch_type == MACH_TYPE_ARM7TEVB)
+#else
+# define machine_is_arm7tevb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7400
+# endif
+# define machine_is_d7400()	(machine_arch_type == MACH_TYPE_D7400)
+#else
+# define machine_is_d7400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PIRANHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIRANHA
+# endif
+# define machine_is_piranha()	(machine_arch_type == MACH_TYPE_PIRANHA)
+#else
+# define machine_is_piranha()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SBCAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCAMELOT
+# endif
+# define machine_is_sbcamelot()	(machine_arch_type == MACH_TYPE_SBCAMELOT)
+#else
+# define machine_is_sbcamelot()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KINGS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGS
+# endif
+# define machine_is_kings()	(machine_arch_type == MACH_TYPE_KINGS)
+#else
+# define machine_is_kings()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2400
+# endif
+# define machine_is_smdk2400()	(machine_arch_type == MACH_TYPE_SMDK2400)
+#else
+# define machine_is_smdk2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDR
+# endif
+# define machine_is_idr()	(machine_arch_type == MACH_TYPE_IDR)
+#else
+# define machine_is_idr()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEBNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBNET
+# endif
+# define machine_is_webnet()	(machine_arch_type == MACH_TYPE_WEBNET)
+#else
+# define machine_is_webnet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_D7300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D7300
+# endif
+# define machine_is_d7300()	(machine_arch_type == MACH_TYPE_D7300)
+#else
+# define machine_is_d7300()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEP
+# endif
+# define machine_is_cep()	(machine_arch_type == MACH_TYPE_CEP)
+#else
+# define machine_is_cep()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VC547X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC547X
+# endif
+# define machine_is_vc547x()	(machine_arch_type == MACH_TYPE_VC547X)
+#else
+# define machine_is_vc547x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FILEWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FILEWALKER
+# endif
+# define machine_is_filewalker()	(machine_arch_type == MACH_TYPE_FILEWALKER)
+#else
+# define machine_is_filewalker()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NETGATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATEWAY
+# endif
+# define machine_is_netgateway()	(machine_arch_type == MACH_TYPE_NETGATEWAY)
+#else
+# define machine_is_netgateway()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SYMBOL2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYMBOL2800
+# endif
+# define machine_is_symbol2800()	(machine_arch_type == MACH_TYPE_SYMBOL2800)
+#else
+# define machine_is_symbol2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SUNS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNS
+# endif
+# define machine_is_suns()	(machine_arch_type == MACH_TYPE_SUNS)
+#else
+# define machine_is_suns()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRODO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRODO
+# endif
+# define machine_is_frodo()	(machine_arch_type == MACH_TYPE_FRODO)
+#else
+# define machine_is_frodo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MACH_TYTE_MS301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_TYTE_MS301
+# endif
+# define machine_is_ms301()	(machine_arch_type == MACH_TYPE_MACH_TYTE_MS301)
+#else
+# define machine_is_ms301()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AMICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMICO
+# endif
+# define machine_is_amico()	(machine_arch_type == MACH_TYPE_AMICO)
+#else
+# define machine_is_amico()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_IAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM
+# endif
+# define machine_is_iam()	(machine_arch_type == MACH_TYPE_IAM)
+#else
+# define machine_is_iam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_TT530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT530
+# endif
+# define machine_is_tt530()	(machine_arch_type == MACH_TYPE_TT530)
+#else
+# define machine_is_tt530()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SAM2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM2400
+# endif
+# define machine_is_sam2400()	(machine_arch_type == MACH_TYPE_SAM2400)
+#else
+# define machine_is_sam2400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA56X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA56X
+# endif
+# define machine_is_jornada56x()	(machine_arch_type == MACH_TYPE_JORNADA56X)
+#else
+# define machine_is_jornada56x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACTIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIVE
+# endif
+# define machine_is_active()	(machine_arch_type == MACH_TYPE_ACTIVE)
+#else
+# define machine_is_active()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WID
+# endif
+# define machine_is_wid()	(machine_arch_type == MACH_TYPE_WID)
+#else
+# define machine_is_wid()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SABINAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SABINAL
+# endif
+# define machine_is_sabinal()	(machine_arch_type == MACH_TYPE_SABINAL)
+#else
+# define machine_is_sabinal()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MATACUMBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MATACUMBE
+# endif
+# define machine_is_ixp425_matacumbe()	(machine_arch_type == MACH_TYPE_IXP425_MATACUMBE)
+#else
+# define machine_is_ixp425_matacumbe()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_MINIPRINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIPRINT
+# endif
+# define machine_is_miniprint()	(machine_arch_type == MACH_TYPE_MINIPRINT)
+#else
+# define machine_is_miniprint()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADM510X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADM510X
+# endif
+# define machine_is_adm510x()	(machine_arch_type == MACH_TYPE_ADM510X)
+#else
+# define machine_is_adm510x()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SVS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVS200
+# endif
+# define machine_is_svs200()	(machine_arch_type == MACH_TYPE_SVS200)
+#else
+# define machine_is_svs200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATG_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATG_TCU
+# endif
+# define machine_is_atg_tcu()	(machine_arch_type == MACH_TYPE_ATG_TCU)
+#else
+# define machine_is_atg_tcu()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA820
+# endif
+# define machine_is_jornada820()	(machine_arch_type == MACH_TYPE_JORNADA820)
+#else
+# define machine_is_jornada820()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C44B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C44B0
+# endif
+# define machine_is_s3c44b0()	(machine_arch_type == MACH_TYPE_S3C44B0)
+#else
+# define machine_is_s3c44b0()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MARGIS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARGIS2
+# endif
+# define machine_is_margis2()	(machine_arch_type == MACH_TYPE_MARGIS2)
+#else
+# define machine_is_margis2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRH
+# endif
+# define machine_is_brh()	(machine_arch_type == MACH_TYPE_BRH)
+#else
+# define machine_is_brh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2410
+# endif
+# define machine_is_s3c2410()	(machine_arch_type == MACH_TYPE_S3C2410)
+#else
+# define machine_is_s3c2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POSSIO_PX30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSSIO_PX30
+# endif
+# define machine_is_possio_px30()	(machine_arch_type == MACH_TYPE_POSSIO_PX30)
+#else
+# define machine_is_possio_px30()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2800
+# endif
+# define machine_is_s3c2800()	(machine_arch_type == MACH_TYPE_S3C2800)
+#else
+# define machine_is_s3c2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEETWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEETWOOD
+# endif
+# define machine_is_fleetwood()	(machine_arch_type == MACH_TYPE_FLEETWOOD)
+#else
+# define machine_is_fleetwood()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OMAHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAHA
+# endif
+# define machine_is_omaha()	(machine_arch_type == MACH_TYPE_OMAHA)
+#else
+# define machine_is_omaha()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7
+# endif
+# define machine_is_ta7()	(machine_arch_type == MACH_TYPE_TA7)
+#else
+# define machine_is_ta7()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOVA
+# endif
+# define machine_is_nova()	(machine_arch_type == MACH_TYPE_NOVA)
+#else
+# define machine_is_nova()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HMK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMK
+# endif
+# define machine_is_hmk()	(machine_arch_type == MACH_TYPE_HMK)
+#else
+# define machine_is_hmk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KARO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KARO
+# endif
+# define machine_is_karo()	(machine_arch_type == MACH_TYPE_KARO)
+#else
+# define machine_is_karo()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FESTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FESTER
+# endif
+# define machine_is_fester()	(machine_arch_type == MACH_TYPE_FESTER)
+#else
+# define machine_is_fester()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GPI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPI
+# endif
+# define machine_is_gpi()	(machine_arch_type == MACH_TYPE_GPI)
+#else
+# define machine_is_gpi()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I519
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I519
+# endif
+# define machine_is_i519()	(machine_arch_type == MACH_TYPE_I519)
+#else
+# define machine_is_i519()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NEXIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXIO
+# endif
+# define machine_is_nexio()	(machine_arch_type == MACH_TYPE_NEXIO)
+#else
+# define machine_is_nexio()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BITBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BITBOX
+# endif
+# define machine_is_bitbox()	(machine_arch_type == MACH_TYPE_BITBOX)
+#else
+# define machine_is_bitbox()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_G200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G200
+# endif
+# define machine_is_g200()	(machine_arch_type == MACH_TYPE_G200)
+#else
+# define machine_is_g200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GILL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GILL
+# endif
+# define machine_is_gill()	(machine_arch_type == MACH_TYPE_GILL)
+#else
+# define machine_is_gill()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_MERCURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MERCURY
+# endif
+# define machine_is_pxa_mercury()	(machine_arch_type == MACH_TYPE_PXA_MERCURY)
+#else
+# define machine_is_pxa_mercury()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRET
+# endif
+# define machine_is_fret()	(machine_arch_type == MACH_TYPE_FRET)
+#else
+# define machine_is_fret()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EMAILPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMAILPHONE
+# endif
+# define machine_is_emailphone()	(machine_arch_type == MACH_TYPE_EMAILPHONE)
+#else
+# define machine_is_emailphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H3900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3900
+# endif
+# define machine_is_h3900()	(machine_arch_type == MACH_TYPE_H3900)
+#else
+# define machine_is_h3900()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA1
+# endif
+# define machine_is_pxa1()	(machine_arch_type == MACH_TYPE_PXA1)
+#else
+# define machine_is_pxa1()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN369
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN369
+# endif
+# define machine_is_koan369()	(machine_arch_type == MACH_TYPE_KOAN369)
+#else
+# define machine_is_koan369()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_COGENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COGENT
+# endif
+# define machine_is_cogent()	(machine_arch_type == MACH_TYPE_COGENT)
+#else
+# define machine_is_cogent()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER
+# endif
+# define machine_is_esl_simputer()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER)
+#else
+# define machine_is_esl_simputer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_CLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_CLR
+# endif
+# define machine_is_esl_simputer_clr()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_CLR)
+#else
+# define machine_is_esl_simputer_clr()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SIMPUTER_BW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SIMPUTER_BW
+# endif
+# define machine_is_esl_simputer_bw()	(machine_arch_type == MACH_TYPE_ESL_SIMPUTER_BW)
+#else
+# define machine_is_esl_simputer_bw()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_CRADLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_CRADLE
+# endif
+# define machine_is_hhp_cradle()	(machine_arch_type == MACH_TYPE_HHP_CRADLE)
+#else
+# define machine_is_hhp_cradle()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HE500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HE500
+# endif
+# define machine_is_he500()	(machine_arch_type == MACH_TYPE_HE500)
+#else
+# define machine_is_he500()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDELF2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF2
+# endif
+# define machine_is_inhandelf2()	(machine_arch_type == MACH_TYPE_INHANDELF2)
+#else
+# define machine_is_inhandelf2()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_INHANDFTIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP
+# endif
+# define machine_is_inhandftip()	(machine_arch_type == MACH_TYPE_INHANDFTIP)
+#else
+# define machine_is_inhandftip()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_DNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNP1110
+# endif
+# define machine_is_dnp1110()	(machine_arch_type == MACH_TYPE_DNP1110)
+#else
+# define machine_is_dnp1110()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PNP1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP1110
+# endif
+# define machine_is_pnp1110()	(machine_arch_type == MACH_TYPE_PNP1110)
+#else
+# define machine_is_pnp1110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB226
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB226
+# endif
+# define machine_is_csb226()	(machine_arch_type == MACH_TYPE_CSB226)
+#else
+# define machine_is_csb226()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ARNOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARNOLD
+# endif
+# define machine_is_arnold()	(machine_arch_type == MACH_TYPE_ARNOLD)
+#else
+# define machine_is_arnold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JZ8028
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JZ8028
+# endif
+# define machine_is_jz8028()	(machine_arch_type == MACH_TYPE_JZ8028)
+#else
+# define machine_is_jz8028()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FORTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTE
+# endif
+# define machine_is_forte()	(machine_arch_type == MACH_TYPE_FORTE)
+#else
+# define machine_is_forte()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ACAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACAM
+# endif
+# define machine_is_acam()	(machine_arch_type == MACH_TYPE_ACAM)
+#else
+# define machine_is_acam()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ABOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABOX
+# endif
+# define machine_is_abox()	(machine_arch_type == MACH_TYPE_ABOX)
+#else
+# define machine_is_abox()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ATMEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATMEL
+# endif
+# define machine_is_atmel()	(machine_arch_type == MACH_TYPE_ATMEL)
+#else
+# define machine_is_atmel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SITSANG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SITSANG
+# endif
+# define machine_is_sitsang()	(machine_arch_type == MACH_TYPE_SITSANG)
+#else
+# define machine_is_sitsang()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CPU1110LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU1110LCDNET
+# endif
+# define machine_is_cpu1110lcdnet()	(machine_arch_type == MACH_TYPE_CPU1110LCDNET)
+#else
+# define machine_is_cpu1110lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPL_VCMA9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPL_VCMA9
+# endif
+# define machine_is_mpl_vcma9()	(machine_arch_type == MACH_TYPE_MPL_VCMA9)
+#else
+# define machine_is_mpl_vcma9()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_OPUS_A1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPUS_A1
+# endif
+# define machine_is_opus_a1()	(machine_arch_type == MACH_TYPE_OPUS_A1)
+#else
+# define machine_is_opus_a1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAYTONA
+# endif
+# define machine_is_daytona()	(machine_arch_type == MACH_TYPE_DAYTONA)
+#else
+# define machine_is_daytona()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KILLBEAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KILLBEAR
+# endif
+# define machine_is_killbear()	(machine_arch_type == MACH_TYPE_KILLBEAR)
+#else
+# define machine_is_killbear()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_YOHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOHO
+# endif
+# define machine_is_yoho()	(machine_arch_type == MACH_TYPE_YOHO)
+#else
+# define machine_is_yoho()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPER
+# endif
+# define machine_is_jasper()	(machine_arch_type == MACH_TYPE_JASPER)
+#else
+# define machine_is_jasper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSC25
+# endif
+# define machine_is_dsc25()	(machine_arch_type == MACH_TYPE_DSC25)
+#else
+# define machine_is_dsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RAMSES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAMSES
+# endif
+# define machine_is_mnci()	(machine_arch_type == MACH_TYPE_RAMSES)
+#else
+# define machine_is_mnci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S28X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S28X
+# endif
+# define machine_is_s28x()	(machine_arch_type == MACH_TYPE_S28X)
+#else
+# define machine_is_s28x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3
+# endif
+# define machine_is_mport3()	(machine_arch_type == MACH_TYPE_MPORT3)
+#else
+# define machine_is_mport3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_EAGLE250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_EAGLE250
+# endif
+# define machine_is_pxa_eagle250()	(machine_arch_type == MACH_TYPE_PXA_EAGLE250)
+#else
+# define machine_is_pxa_eagle250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDB
+# endif
+# define machine_is_pdb()	(machine_arch_type == MACH_TYPE_PDB)
+#else
+# define machine_is_pdb()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUE_2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUE_2G
+# endif
+# define machine_is_blue_2g()	(machine_arch_type == MACH_TYPE_BLUE_2G)
+#else
+# define machine_is_blue_2g()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BLUEARCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEARCH
+# endif
+# define machine_is_bluearch()	(machine_arch_type == MACH_TYPE_BLUEARCH)
+#else
+# define machine_is_bluearch()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPLORER
+# endif
+# define machine_is_explorer()	(machine_arch_type == MACH_TYPE_EXPLORER)
+#else
+# define machine_is_explorer()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CHIMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHIMP
+# endif
+# define machine_is_chimp()	(machine_arch_type == MACH_TYPE_CHIMP)
+#else
+# define machine_is_chimp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_NEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_NEST
+# endif
+# define machine_is_stork_nest()	(machine_arch_type == MACH_TYPE_STORK_NEST)
+#else
+# define machine_is_stork_nest()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STORK_EGG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORK_EGG
+# endif
+# define machine_is_stork_egg()	(machine_arch_type == MACH_TYPE_STORK_EGG)
+#else
+# define machine_is_stork_egg()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_WISMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WISMO
+# endif
+# define machine_is_wismo()	(machine_arch_type == MACH_TYPE_WISMO)
+#else
+# define machine_is_wismo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EZLINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZLINX
+# endif
+# define machine_is_ezlinx()	(machine_arch_type == MACH_TYPE_EZLINX)
+#else
+# define machine_is_ezlinx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200
+# endif
+# define machine_is_at91rm9200()	(machine_arch_type == MACH_TYPE_AT91RM9200)
+#else
+# define machine_is_at91rm9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADTECH_ORION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADTECH_ORION
+# endif
+# define machine_is_adtech_orion()	(machine_arch_type == MACH_TYPE_ADTECH_ORION)
+#else
+# define machine_is_adtech_orion()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NEPTUNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEPTUNE
+# endif
+# define machine_is_neptune()	(machine_arch_type == MACH_TYPE_NEPTUNE)
+#else
+# define machine_is_neptune()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WINS30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WINS30
+# endif
+# define machine_is_pxa_wins30()	(machine_arch_type == MACH_TYPE_PXA_WINS30)
+#else
+# define machine_is_pxa_wins30()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LAVINNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAVINNA
+# endif
+# define machine_is_lavinna()	(machine_arch_type == MACH_TYPE_LAVINNA)
+#else
+# define machine_is_lavinna()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_UENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_UENGINE
+# endif
+# define machine_is_pxa_uengine()	(machine_arch_type == MACH_TYPE_PXA_UENGINE)
+#else
+# define machine_is_pxa_uengine()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INNOKOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INNOKOM
+# endif
+# define machine_is_innokom()	(machine_arch_type == MACH_TYPE_INNOKOM)
+#else
+# define machine_is_innokom()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMS
+# endif
+# define machine_is_bms()	(machine_arch_type == MACH_TYPE_BMS)
+#else
+# define machine_is_bms()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRPMC1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRPMC1100
+# endif
+# define machine_is_prpmc1100()	(machine_arch_type == MACH_TYPE_PRPMC1100)
+#else
+# define machine_is_prpmc1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMSTICK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSTICK
+# endif
+# define machine_is_armstick()	(machine_arch_type == MACH_TYPE_ARMSTICK)
+#else
+# define machine_is_armstick()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMONIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMONIE
+# endif
+# define machine_is_armonie()	(machine_arch_type == MACH_TYPE_ARMONIE)
+#else
+# define machine_is_armonie()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MPORT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT1
+# endif
+# define machine_is_mport1()	(machine_arch_type == MACH_TYPE_MPORT1)
+#else
+# define machine_is_mport1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C5410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5410
+# endif
+# define machine_is_s3c5410()	(machine_arch_type == MACH_TYPE_S3C5410)
+#else
+# define machine_is_s3c5410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZCP320A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZCP320A
+# endif
+# define machine_is_zcp320a()	(machine_arch_type == MACH_TYPE_ZCP320A)
+#else
+# define machine_is_zcp320a()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_I_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I_BOX
+# endif
+# define machine_is_i_box()	(machine_arch_type == MACH_TYPE_I_BOX)
+#else
+# define machine_is_i_box()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STLC1502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STLC1502
+# endif
+# define machine_is_stlc1502()	(machine_arch_type == MACH_TYPE_STLC1502)
+#else
+# define machine_is_stlc1502()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIREN
+# endif
+# define machine_is_siren()	(machine_arch_type == MACH_TYPE_SIREN)
+#else
+# define machine_is_siren()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GREENLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENLAKE
+# endif
+# define machine_is_greenlake()	(machine_arch_type == MACH_TYPE_GREENLAKE)
+#else
+# define machine_is_greenlake()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARGUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARGUS
+# endif
+# define machine_is_argus()	(machine_arch_type == MACH_TYPE_ARGUS)
+#else
+# define machine_is_argus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COMBADGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMBADGE
+# endif
+# define machine_is_combadge()	(machine_arch_type == MACH_TYPE_COMBADGE)
+#else
+# define machine_is_combadge()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ROKEPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROKEPXA
+# endif
+# define machine_is_rokepxa()	(machine_arch_type == MACH_TYPE_ROKEPXA)
+#else
+# define machine_is_rokepxa()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUIDEA07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUIDEA07
+# endif
+# define machine_is_guidea07()	(machine_arch_type == MACH_TYPE_GUIDEA07)
+#else
+# define machine_is_guidea07()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TAT257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAT257
+# endif
+# define machine_is_tat257()	(machine_arch_type == MACH_TYPE_TAT257)
+#else
+# define machine_is_tat257()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IGP2425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGP2425
+# endif
+# define machine_is_igp2425()	(machine_arch_type == MACH_TYPE_IGP2425)
+#else
+# define machine_is_igp2425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BLUEGRAMMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEGRAMMA
+# endif
+# define machine_is_bluegrama()	(machine_arch_type == MACH_TYPE_BLUEGRAMMA)
+#else
+# define machine_is_bluegrama()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPOD
+# endif
+# define machine_is_ipod()	(machine_arch_type == MACH_TYPE_IPOD)
+#else
+# define machine_is_ipod()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSBITSYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYX
+# endif
+# define machine_is_adsbitsyx()	(machine_arch_type == MACH_TYPE_ADSBITSYX)
+#else
+# define machine_is_adsbitsyx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TRIZEPS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS2
+# endif
+# define machine_is_trizeps2()	(machine_arch_type == MACH_TYPE_TRIZEPS2)
+#else
+# define machine_is_trizeps2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSYPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYPLUS
+# endif
+# define machine_is_adsbitsyplus()	(machine_arch_type == MACH_TYPE_ADSBITSYPLUS)
+#else
+# define machine_is_adsbitsyplus()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSAGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGC
+# endif
+# define machine_is_adsagc()	(machine_arch_type == MACH_TYPE_ADSAGC)
+#else
+# define machine_is_adsagc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_STP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STP7312
+# endif
+# define machine_is_stp7312()	(machine_arch_type == MACH_TYPE_STP7312)
+#else
+# define machine_is_stp7312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PHNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PHNX
+# endif
+# define machine_is_nx_phnx()	(machine_arch_type == MACH_TYPE_NX_PHNX)
+#else
+# define machine_is_nx_phnx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_WEP_EP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEP_EP250
+# endif
+# define machine_is_wep_ep250()	(machine_arch_type == MACH_TYPE_WEP_EP250)
+#else
+# define machine_is_wep_ep250()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDELF3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDELF3
+# endif
+# define machine_is_inhandelf3()	(machine_arch_type == MACH_TYPE_INHANDELF3)
+#else
+# define machine_is_inhandelf3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IYONIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IYONIX
+# endif
+# define machine_is_iyonix()	(machine_arch_type == MACH_TYPE_IYONIX)
+#else
+# define machine_is_iyonix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DAMICAM_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAMICAM_SA1110
+# endif
+# define machine_is_damicam1()	(machine_arch_type == MACH_TYPE_DAMICAM_SA1110)
+#else
+# define machine_is_damicam1()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MEG03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEG03
+# endif
+# define machine_is_meg03()	(machine_arch_type == MACH_TYPE_MEG03)
+#else
+# define machine_is_meg03()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_WHITECHAPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_WHITECHAPEL
+# endif
+# define machine_is_pxa_whitechapel()	(machine_arch_type == MACH_TYPE_PXA_WHITECHAPEL)
+#else
+# define machine_is_pxa_whitechapel()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWSC
+# endif
+# define machine_is_nwsc()	(machine_arch_type == MACH_TYPE_NWSC)
+#else
+# define machine_is_nwsc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NWLARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NWLARM
+# endif
+# define machine_is_nwlarm()	(machine_arch_type == MACH_TYPE_NWLARM)
+#else
+# define machine_is_nwlarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP425_MGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425_MGUARD
+# endif
+# define machine_is_ixp425_mguard()	(machine_arch_type == MACH_TYPE_IXP425_MGUARD)
+#else
+# define machine_is_ixp425_mguard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_NETDCU4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU4
+# endif
+# define machine_is_pxa_netdcu4()	(machine_arch_type == MACH_TYPE_PXA_NETDCU4)
+#else
+# define machine_is_pxa_netdcu4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZODIAC
+# endif
+# define machine_is_zodiac()	(machine_arch_type == MACH_TYPE_ZODIAC)
+#else
+# define machine_is_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARMMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMMODUL
+# endif
+# define machine_is_armmodul()	(machine_arch_type == MACH_TYPE_ARMMODUL)
+#else
+# define machine_is_armmodul()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KETOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KETOP
+# endif
+# define machine_is_ketop()	(machine_arch_type == MACH_TYPE_KETOP)
+#else
+# define machine_is_ketop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AV7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV7200
+# endif
+# define machine_is_av7200()	(machine_arch_type == MACH_TYPE_AV7200)
+#else
+# define machine_is_av7200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ARCH_TI925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_TI925
+# endif
+# define machine_is_arch_ti925()	(machine_arch_type == MACH_TYPE_ARCH_TI925)
+#else
+# define machine_is_arch_ti925()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ACQ200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ200
+# endif
+# define machine_is_acq200()	(machine_arch_type == MACH_TYPE_ACQ200)
+#else
+# define machine_is_acq200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_DAFIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_DAFIT
+# endif
+# define machine_is_pt_dafit()	(machine_arch_type == MACH_TYPE_PT_DAFIT)
+#else
+# define machine_is_pt_dafit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IHBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IHBA
+# endif
+# define machine_is_ihba()	(machine_arch_type == MACH_TYPE_IHBA)
+#else
+# define machine_is_ihba()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUINQUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUINQUE
+# endif
+# define machine_is_quinque()	(machine_arch_type == MACH_TYPE_QUINQUE)
+#else
+# define machine_is_quinque()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRAONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRAONE
+# endif
+# define machine_is_nimbraone()	(machine_arch_type == MACH_TYPE_NIMBRAONE)
+#else
+# define machine_is_nimbraone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA29X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA29X
+# endif
+# define machine_is_nimbra29x()	(machine_arch_type == MACH_TYPE_NIMBRA29X)
+#else
+# define machine_is_nimbra29x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIMBRA210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA210
+# endif
+# define machine_is_nimbra210()	(machine_arch_type == MACH_TYPE_NIMBRA210)
+#else
+# define machine_is_nimbra210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_HHP_D95XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHP_D95XX
+# endif
+# define machine_is_hhp_d95xx()	(machine_arch_type == MACH_TYPE_HHP_D95XX)
+#else
+# define machine_is_hhp_d95xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LABARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABARM
+# endif
+# define machine_is_labarm()	(machine_arch_type == MACH_TYPE_LABARM)
+#else
+# define machine_is_labarm()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_M825XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M825XX
+# endif
+# define machine_is_m825xx()	(machine_arch_type == MACH_TYPE_M825XX)
+#else
+# define machine_is_m825xx()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7100
+# endif
+# define machine_is_m7100()	(machine_arch_type == MACH_TYPE_M7100)
+#else
+# define machine_is_m7100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIPC2
+# endif
+# define machine_is_nipc2()	(machine_arch_type == MACH_TYPE_NIPC2)
+#else
+# define machine_is_nipc2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FU7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FU7202
+# endif
+# define machine_is_fu7202()	(machine_arch_type == MACH_TYPE_FU7202)
+#else
+# define machine_is_fu7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSAGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSAGX
+# endif
+# define machine_is_adsagx()	(machine_arch_type == MACH_TYPE_ADSAGX)
+#else
+# define machine_is_adsagx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_POOH
+# endif
+# define machine_is_pxa_pooh()	(machine_arch_type == MACH_TYPE_PXA_POOH)
+#else
+# define machine_is_pxa_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BANDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANDON
+# endif
+# define machine_is_bandon()	(machine_arch_type == MACH_TYPE_BANDON)
+#else
+# define machine_is_bandon()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PCM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7210
+# endif
+# define machine_is_pcm7210()	(machine_arch_type == MACH_TYPE_PCM7210)
+#else
+# define machine_is_pcm7210()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMS9200
+# endif
+# define machine_is_nms9200()	(machine_arch_type == MACH_TYPE_NMS9200)
+#else
+# define machine_is_nms9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOGODL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGODL
+# endif
+# define machine_is_logodl()	(machine_arch_type == MACH_TYPE_LOGODL)
+#else
+# define machine_is_logodl()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_M7140
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M7140
+# endif
+# define machine_is_m7140()	(machine_arch_type == MACH_TYPE_M7140)
+#else
+# define machine_is_m7140()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KOREBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOREBOT
+# endif
+# define machine_is_korebot()	(machine_arch_type == MACH_TYPE_KOREBOT)
+#else
+# define machine_is_korebot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_KOAN393
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOAN393
+# endif
+# define machine_is_koan393()	(machine_arch_type == MACH_TYPE_KOAN393)
+#else
+# define machine_is_koan393()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INHANDFTIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHANDFTIP3
+# endif
+# define machine_is_inhandftip3()	(machine_arch_type == MACH_TYPE_INHANDFTIP3)
+#else
+# define machine_is_inhandftip3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GONZO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONZO
+# endif
+# define machine_is_gonzo()	(machine_arch_type == MACH_TYPE_GONZO)
+#else
+# define machine_is_gonzo()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCANPASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCANPASS
+# endif
+# define machine_is_scanpass()	(machine_arch_type == MACH_TYPE_SCANPASS)
+#else
+# define machine_is_scanpass()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EP7312_POOH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP7312_POOH
+# endif
+# define machine_is_ep7312_pooh()	(machine_arch_type == MACH_TYPE_EP7312_POOH)
+#else
+# define machine_is_ep7312_pooh()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7S
+# endif
+# define machine_is_ta7s()	(machine_arch_type == MACH_TYPE_TA7S)
+#else
+# define machine_is_ta7s()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TA7V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TA7V
+# endif
+# define machine_is_ta7v()	(machine_arch_type == MACH_TYPE_TA7V)
+#else
+# define machine_is_ta7v()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ICARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICARUS
+# endif
+# define machine_is_icarus()	(machine_arch_type == MACH_TYPE_ICARUS)
+#else
+# define machine_is_icarus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1900
+# endif
+# define machine_is_h1900()	(machine_arch_type == MACH_TYPE_H1900)
+#else
+# define machine_is_h1900()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GEMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI
+# endif
+# define machine_is_gemini()	(machine_arch_type == MACH_TYPE_GEMINI)
+#else
+# define machine_is_gemini()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AXIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIM
+# endif
+# define machine_is_axim()	(machine_arch_type == MACH_TYPE_AXIM)
+#else
+# define machine_is_axim()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUDIOTRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUDIOTRON
+# endif
+# define machine_is_audiotron()	(machine_arch_type == MACH_TYPE_AUDIOTRON)
+#else
+# define machine_is_audiotron()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H2200
+# endif
+# define machine_is_h2200()	(machine_arch_type == MACH_TYPE_H2200)
+#else
+# define machine_is_h2200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LOOX600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX600
+# endif
+# define machine_is_loox600()	(machine_arch_type == MACH_TYPE_LOOX600)
+#else
+# define machine_is_loox600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NIOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIOP
+# endif
+# define machine_is_niop()	(machine_arch_type == MACH_TYPE_NIOP)
+#else
+# define machine_is_niop()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_DM310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM310
+# endif
+# define machine_is_dm310()	(machine_arch_type == MACH_TYPE_DM310)
+#else
+# define machine_is_dm310()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SEEDPXA_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEEDPXA_C2
+# endif
+# define machine_is_seedpxa_c2()	(machine_arch_type == MACH_TYPE_SEEDPXA_C2)
+#else
+# define machine_is_seedpxa_c2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP4XX_MGUARD_PCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_MGUARD_PCI
+# endif
+# define machine_is_ixp4xx_mguardpci()	(machine_arch_type == MACH_TYPE_IXP4XX_MGUARD_PCI)
+#else
+# define machine_is_ixp4xx_mguardpci()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SCORPIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCORPIO
+# endif
+# define machine_is_scorpio()	(machine_arch_type == MACH_TYPE_SCORPIO)
+#else
+# define machine_is_scorpio()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVA
+# endif
+# define machine_is_viva()	(machine_arch_type == MACH_TYPE_VIVA)
+#else
+# define machine_is_viva()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_XCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_XCARD
+# endif
+# define machine_is_pxa_xcard()	(machine_arch_type == MACH_TYPE_PXA_XCARD)
+#else
+# define machine_is_pxa_xcard()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSB335
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB335
+# endif
+# define machine_is_csb335()	(machine_arch_type == MACH_TYPE_CSB335)
+#else
+# define machine_is_csb335()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXRD425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXRD425
+# endif
+# define machine_is_ixrd425()	(machine_arch_type == MACH_TYPE_IXRD425)
+#else
+# define machine_is_ixrd425()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80315
+# endif
+# define machine_is_iq80315()	(machine_arch_type == MACH_TYPE_IQ80315)
+#else
+# define machine_is_iq80315()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NMP7312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMP7312
+# endif
+# define machine_is_nmp7312()	(machine_arch_type == MACH_TYPE_NMP7312)
+#else
+# define machine_is_nmp7312()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CX861XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX861XX
+# endif
+# define machine_is_cx861xx()	(machine_arch_type == MACH_TYPE_CX861XX)
+#else
+# define machine_is_cx861xx()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDA
+# endif
+# define machine_is_xda()	(machine_arch_type == MACH_TYPE_XDA)
+#else
+# define machine_is_xda()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CSIR_IMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSIR_IMS
+# endif
+# define machine_is_csir_ims()	(machine_arch_type == MACH_TYPE_CSIR_IMS)
+#else
+# define machine_is_csir_ims()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXP421_DNAEETH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP421_DNAEETH
+# endif
+# define machine_is_ixp421_dnaeeth()	(machine_arch_type == MACH_TYPE_IXP421_DNAEETH)
+#else
+# define machine_is_ixp421_dnaeeth()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_POCKETSERV9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POCKETSERV9200
+# endif
+# define machine_is_pocketserv9200()	(machine_arch_type == MACH_TYPE_POCKETSERV9200)
+#else
+# define machine_is_pocketserv9200()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_TOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTO
+# endif
+# define machine_is_toto()	(machine_arch_type == MACH_TYPE_TOTO)
+#else
+# define machine_is_toto()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695P
+# endif
+# define machine_is_ks8695p()	(machine_arch_type == MACH_TYPE_KS8695P)
+#else
+# define machine_is_ks8695p()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SE4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4000
+# endif
+# define machine_is_se4000()	(machine_arch_type == MACH_TYPE_SE4000)
+#else
+# define machine_is_se4000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_QUADRICEPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUADRICEPS
+# endif
+# define machine_is_quadriceps()	(machine_arch_type == MACH_TYPE_QUADRICEPS)
+#else
+# define machine_is_quadriceps()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BRONCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRONCO
+# endif
+# define machine_is_bronco()	(machine_arch_type == MACH_TYPE_BRONCO)
+#else
+# define machine_is_bronco()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_WIRELESS_TAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WIRELESS_TAB
+# endif
+# define machine_is_esl_wireless_tab()	(machine_arch_type == MACH_TYPE_ESL_WIRELESS_TAB)
+#else
+# define machine_is_esl_wireless_tab()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESL_SOFCOMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SOFCOMP
+# endif
+# define machine_is_esl_sofcomp()	(machine_arch_type == MACH_TYPE_ESL_SOFCOMP)
+#else
+# define machine_is_esl_sofcomp()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S5C7375
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7375
+# endif
+# define machine_is_s5c7375()	(machine_arch_type == MACH_TYPE_S5C7375)
+#else
+# define machine_is_s5c7375()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SPEARHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARHEAD
+# endif
+# define machine_is_spearhead()	(machine_arch_type == MACH_TYPE_SPEARHEAD)
+#else
+# define machine_is_spearhead()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PANTERA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PANTERA
+# endif
+# define machine_is_pantera()	(machine_arch_type == MACH_TYPE_PANTERA)
+#else
+# define machine_is_pantera()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PRAYOGLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAYOGLITE
+# endif
+# define machine_is_prayoglite()	(machine_arch_type == MACH_TYPE_PRAYOGLITE)
+#else
+# define machine_is_prayoglite()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RCUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RCUBE
+# endif
+# define machine_is_rcube()	(machine_arch_type == MACH_TYPE_RCUBE)
+#else
+# define machine_is_rcube()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_REA_OLV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_OLV
+# endif
+# define machine_is_rea_olv()	(machine_arch_type == MACH_TYPE_REA_OLV)
+#else
+# define machine_is_rea_olv()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IPHONE
+# endif
+# define machine_is_pxa_iphone()	(machine_arch_type == MACH_TYPE_PXA_IPHONE)
+#else
+# define machine_is_pxa_iphone()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C3410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C3410
+# endif
+# define machine_is_s3c3410()	(machine_arch_type == MACH_TYPE_S3C3410)
+#else
+# define machine_is_s3c3410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ESPD_4510B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPD_4510B
+# endif
+# define machine_is_espd_4510b()	(machine_arch_type == MACH_TYPE_ESPD_4510B)
+#else
+# define machine_is_espd_4510b()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MP1X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1X
+# endif
+# define machine_is_mp1x()	(machine_arch_type == MACH_TYPE_MP1X)
+#else
+# define machine_is_mp1x()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200TB
+# endif
+# define machine_is_at91rm9200tb()	(machine_arch_type == MACH_TYPE_AT91RM9200TB)
+#else
+# define machine_is_at91rm9200tb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADSVGX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVGX
+# endif
+# define machine_is_adsvgx()	(machine_arch_type == MACH_TYPE_ADSVGX)
+#else
+# define machine_is_adsvgx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PELEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELEE
+# endif
+# define machine_is_pelee()	(machine_arch_type == MACH_TYPE_PELEE)
+#else
+# define machine_is_pelee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FUJITSU_CAMELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_CAMELOT
+# endif
+# define machine_is_fujitsu_camelot()	(machine_arch_type == MACH_TYPE_FUJITSU_CAMELOT)
+#else
+# define machine_is_fujitsu_camelot()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_JANUS2M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS2M
+# endif
+# define machine_is_janus2m()	(machine_arch_type == MACH_TYPE_JANUS2M)
+#else
+# define machine_is_janus2m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMBTF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMBTF
+# endif
+# define machine_is_embtf()	(machine_arch_type == MACH_TYPE_EMBTF)
+#else
+# define machine_is_embtf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPM
+# endif
+# define machine_is_hpm()	(machine_arch_type == MACH_TYPE_HPM)
+#else
+# define machine_is_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410TK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410TK
+# endif
+# define machine_is_smdk2410tk()	(machine_arch_type == MACH_TYPE_SMDK2410TK)
+#else
+# define machine_is_smdk2410tk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2410AJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410AJ
+# endif
+# define machine_is_smdk2410aj()	(machine_arch_type == MACH_TYPE_SMDK2410AJ)
+#else
+# define machine_is_smdk2410aj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STREETRACER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STREETRACER
+# endif
+# define machine_is_streetracer()	(machine_arch_type == MACH_TYPE_STREETRACER)
+#else
+# define machine_is_streetracer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EFRAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EFRAME
+# endif
+# define machine_is_eframe()	(machine_arch_type == MACH_TYPE_EFRAME)
+#else
+# define machine_is_eframe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_LARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_LARK
+# endif
+# define machine_is_pxa_lark()	(machine_arch_type == MACH_TYPE_PXA_LARK)
+#else
+# define machine_is_pxa_lark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP2110
+# endif
+# define machine_is_pxa_pnp2110()	(machine_arch_type == MACH_TYPE_PNP2110)
+#else
+# define machine_is_pxa_pnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC72X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC72X
+# endif
+# define machine_is_tcc72x()	(machine_arch_type == MACH_TYPE_TCC72X)
+#else
+# define machine_is_tcc72x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALTAIR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALTAIR
+# endif
+# define machine_is_altair()	(machine_arch_type == MACH_TYPE_ALTAIR)
+#else
+# define machine_is_altair()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KC3
+# endif
+# define machine_is_kc3()	(machine_arch_type == MACH_TYPE_KC3)
+#else
+# define machine_is_kc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEFTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEFTD
+# endif
+# define machine_is_sinteftd()	(machine_arch_type == MACH_TYPE_SINTEFTD)
+#else
+# define machine_is_sinteftd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADAY4X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADAY4X
+# endif
+# define machine_is_aday4x()	(machine_arch_type == MACH_TYPE_ADAY4X)
+#else
+# define machine_is_aday4x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITE300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITE300
+# endif
+# define machine_is_lite300()	(machine_arch_type == MACH_TYPE_LITE300)
+#else
+# define machine_is_lite300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5C7376
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5C7376
+# endif
+# define machine_is_s5c7376()	(machine_arch_type == MACH_TYPE_S5C7376)
+#else
+# define machine_is_s5c7376()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT02
+# endif
+# define machine_is_mt02()	(machine_arch_type == MACH_TYPE_MT02)
+#else
+# define machine_is_mt02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPORT3S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPORT3S
+# endif
+# define machine_is_mport3s()	(machine_arch_type == MACH_TYPE_MPORT3S)
+#else
+# define machine_is_mport3s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RA_ALPHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RA_ALPHA
+# endif
+# define machine_is_ra_alpha()	(machine_arch_type == MACH_TYPE_RA_ALPHA)
+#else
+# define machine_is_ra_alpha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE
+# endif
+# define machine_is_stargate()	(machine_arch_type == MACH_TYPE_STARGATE)
+#else
+# define machine_is_stargate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLOJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLOJ
+# endif
+# define machine_is_armadilloj()	(machine_arch_type == MACH_TYPE_ARMADILLOJ)
+#else
+# define machine_is_armadilloj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELROY_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELROY_JACK
+# endif
+# define machine_is_elroy_jack()	(machine_arch_type == MACH_TYPE_ELROY_JACK)
+#else
+# define machine_is_elroy_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BACKEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BACKEND
+# endif
+# define machine_is_backend()	(machine_arch_type == MACH_TYPE_BACKEND)
+#else
+# define machine_is_backend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5LINBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5LINBOX
+# endif
+# define machine_is_s5linbox()	(machine_arch_type == MACH_TYPE_S5LINBOX)
+#else
+# define machine_is_s5linbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200
+# endif
+# define machine_is_ia_cpu_9200()	(machine_arch_type == MACH_TYPE_IA_CPU_9200)
+#else
+# define machine_is_ia_cpu_9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91_BJA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91_BJA1
+# endif
+# define machine_is_at91_bja1()	(machine_arch_type == MACH_TYPE_AT91_BJA1)
+#else
+# define machine_is_at91_bja1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEN
+# endif
+# define machine_is_ten()	(machine_arch_type == MACH_TYPE_TEN)
+#else
+# define machine_is_ten()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP5P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP5P
+# endif
+# define machine_is_roverp5p()	(machine_arch_type == MACH_TYPE_ROVERP5P)
+#else
+# define machine_is_roverp5p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2700
+# endif
+# define machine_is_sc2700()	(machine_arch_type == MACH_TYPE_SC2700)
+#else
+# define machine_is_sc2700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EX_EAGLE
+# endif
+# define machine_is_ex_eagle()	(machine_arch_type == MACH_TYPE_EX_EAGLE)
+#else
+# define machine_is_ex_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA12
+# endif
+# define machine_is_nx_pxa12()	(machine_arch_type == MACH_TYPE_NX_PXA12)
+#else
+# define machine_is_nx_pxa12()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX_PXA5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX_PXA5
+# endif
+# define machine_is_nx_pxa5()	(machine_arch_type == MACH_TYPE_NX_PXA5)
+#else
+# define machine_is_nx_pxa5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKBOARD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKBOARD2
+# endif
+# define machine_is_blackboard2()	(machine_arch_type == MACH_TYPE_BLACKBOARD2)
+#else
+# define machine_is_blackboard2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I819
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I819
+# endif
+# define machine_is_i819()	(machine_arch_type == MACH_TYPE_I819)
+#else
+# define machine_is_i819()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXMB995E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXMB995E
+# endif
+# define machine_is_ixmb995e()	(machine_arch_type == MACH_TYPE_IXMB995E)
+#else
+# define machine_is_ixmb995e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYRIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYRIDER
+# endif
+# define machine_is_skyrider()	(machine_arch_type == MACH_TYPE_SKYRIDER)
+#else
+# define machine_is_skyrider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYHAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYHAWK
+# endif
+# define machine_is_skyhawk()	(machine_arch_type == MACH_TYPE_SKYHAWK)
+#else
+# define machine_is_skyhawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENTERPRISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENTERPRISE
+# endif
+# define machine_is_enterprise()	(machine_arch_type == MACH_TYPE_ENTERPRISE)
+#else
+# define machine_is_enterprise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410
+# endif
+# define machine_is_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410)
+#else
+# define machine_is_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOBBIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOBBIT
+# endif
+# define machine_is_hobbit()	(machine_arch_type == MACH_TYPE_HOBBIT)
+#else
+# define machine_is_hobbit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7210
+# endif
+# define machine_is_h7210()	(machine_arch_type == MACH_TYPE_H7210)
+#else
+# define machine_is_h7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_NETDCU5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_NETDCU5
+# endif
+# define machine_is_pxa_netdcu5()	(machine_arch_type == MACH_TYPE_PXA_NETDCU5)
+#else
+# define machine_is_pxa_netdcu5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACC
+# endif
+# define machine_is_acc()	(machine_arch_type == MACH_TYPE_ACC)
+#else
+# define machine_is_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA
+# endif
+# define machine_is_esl_sarva()	(machine_arch_type == MACH_TYPE_ESL_SARVA)
+#else
+# define machine_is_esl_sarva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM250
+# endif
+# define machine_is_xm250()	(machine_arch_type == MACH_TYPE_XM250)
+#else
+# define machine_is_xm250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T6TC1XB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T6TC1XB
+# endif
+# define machine_is_t6tc1xb()	(machine_arch_type == MACH_TYPE_T6TC1XB)
+#else
+# define machine_is_t6tc1xb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS710
+# endif
+# define machine_is_ess710()	(machine_arch_type == MACH_TYPE_ESS710)
+#else
+# define machine_is_ess710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOLFENK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOLFENK
+# endif
+# define machine_is_bolfenk()	(machine_arch_type == MACH_TYPE_BOLFENK)
+#else
+# define machine_is_bolfenk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KR
+# endif
+# define machine_is_at91rm9200kr()	(machine_arch_type == MACH_TYPE_AT91RM9200KR)
+#else
+# define machine_is_at91rm9200kr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXIMX3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXIMX3
+# endif
+# define machine_is_aximx3()	(machine_arch_type == MACH_TYPE_AXIMX3)
+#else
+# define machine_is_aximx3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB67XDIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB67XDIP
+# endif
+# define machine_is_eb67xdip()	(machine_arch_type == MACH_TYPE_EB67XDIP)
+#else
+# define machine_is_eb67xdip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBTXS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBTXS
+# endif
+# define machine_is_webtxs()	(machine_arch_type == MACH_TYPE_WEBTXS)
+#else
+# define machine_is_webtxs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWK
+# endif
+# define machine_is_hawk()	(machine_arch_type == MACH_TYPE_HAWK)
+#else
+# define machine_is_hawk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCAT91SBC001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCAT91SBC001
+# endif
+# define machine_is_ccat91sbc001()	(machine_arch_type == MACH_TYPE_CCAT91SBC001)
+#else
+# define machine_is_ccat91sbc001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSO
+# endif
+# define machine_is_expresso()	(machine_arch_type == MACH_TYPE_EXPRESSO)
+#else
+# define machine_is_expresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4000
+# endif
+# define machine_is_h4000()	(machine_arch_type == MACH_TYPE_H4000)
+#else
+# define machine_is_h4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINO
+# endif
+# define machine_is_dino()	(machine_arch_type == MACH_TYPE_DINO)
+#else
+# define machine_is_dino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML675K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML675K
+# endif
+# define machine_is_ml675k()	(machine_arch_type == MACH_TYPE_ML675K)
+#else
+# define machine_is_ml675k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECIVA_TT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECIVA_TT
+# endif
+# define machine_is_reciva_tt()	(machine_arch_type == MACH_TYPE_RECIVA_TT)
+#else
+# define machine_is_reciva_tt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB01
+# endif
+# define machine_is_cstcb01()	(machine_arch_type == MACH_TYPE_CSTCB01)
+#else
+# define machine_is_cstcb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSTCB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSTCB1
+# endif
+# define machine_is_cstcb1()	(machine_arch_type == MACH_TYPE_CSTCB1)
+#else
+# define machine_is_cstcb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHADWELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHADWELL
+# endif
+# define machine_is_shadwell()	(machine_arch_type == MACH_TYPE_SHADWELL)
+#else
+# define machine_is_shadwell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOEPEL263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOEPEL263
+# endif
+# define machine_is_goepel263()	(machine_arch_type == MACH_TYPE_GOEPEL263)
+#else
+# define machine_is_goepel263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ100
+# endif
+# define machine_is_acq100()	(machine_arch_type == MACH_TYPE_ACQ100)
+#else
+# define machine_is_acq100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1FS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1FS2
+# endif
+# define machine_is_mx1fs2()	(machine_arch_type == MACH_TYPE_MX1FS2)
+#else
+# define machine_is_mx1fs2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPTOP_G1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPTOP_G1
+# endif
+# define machine_is_hiptop_g1()	(machine_arch_type == MACH_TYPE_HIPTOP_G1)
+#else
+# define machine_is_hiptop_g1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARKY
+# endif
+# define machine_is_sparky()	(machine_arch_type == MACH_TYPE_SPARKY)
+#else
+# define machine_is_sparky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS9750
+# endif
+# define machine_is_ns9750()	(machine_arch_type == MACH_TYPE_NS9750)
+#else
+# define machine_is_ns9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX
+# endif
+# define machine_is_phoenix()	(machine_arch_type == MACH_TYPE_PHOENIX)
+#else
+# define machine_is_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERPXA
+# endif
+# define machine_is_deisterpxa()	(machine_arch_type == MACH_TYPE_DEISTERPXA)
+#else
+# define machine_is_deisterpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM1160
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM1160
+# endif
+# define machine_is_bcm1160()	(machine_arch_type == MACH_TYPE_BCM1160)
+#else
+# define machine_is_bcm1160()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM022
+# endif
+# define machine_is_pcm022()	(machine_arch_type == MACH_TYPE_PCM022)
+#else
+# define machine_is_pcm022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCX
+# endif
+# define machine_is_adsgcx()	(machine_arch_type == MACH_TYPE_ADSGCX)
+#else
+# define machine_is_adsgcx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DREADNAUGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DREADNAUGHT
+# endif
+# define machine_is_dreadnaught()	(machine_arch_type == MACH_TYPE_DREADNAUGHT)
+#else
+# define machine_is_dreadnaught()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM320
+# endif
+# define machine_is_dm320()	(machine_arch_type == MACH_TYPE_DM320)
+#else
+# define machine_is_dm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARKOV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARKOV
+# endif
+# define machine_is_markov()	(machine_arch_type == MACH_TYPE_MARKOV)
+#else
+# define machine_is_markov()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COS7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COS7A400
+# endif
+# define machine_is_cos7a400()	(machine_arch_type == MACH_TYPE_COS7A400)
+#else
+# define machine_is_cos7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILANO
+# endif
+# define machine_is_milano()	(machine_arch_type == MACH_TYPE_MILANO)
+#else
+# define machine_is_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE9328
+# endif
+# define machine_is_ue9328()	(machine_arch_type == MACH_TYPE_UE9328)
+#else
+# define machine_is_ue9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEX255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEX255
+# endif
+# define machine_is_uex255()	(machine_arch_type == MACH_TYPE_UEX255)
+#else
+# define machine_is_uex255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UE2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UE2410
+# endif
+# define machine_is_ue2410()	(machine_arch_type == MACH_TYPE_UE2410)
+#else
+# define machine_is_ue2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A620
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A620
+# endif
+# define machine_is_a620()	(machine_arch_type == MACH_TYPE_A620)
+#else
+# define machine_is_a620()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCELOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCELOT
+# endif
+# define machine_is_ocelot()	(machine_arch_type == MACH_TYPE_OCELOT)
+#else
+# define machine_is_ocelot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEETAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEETAH
+# endif
+# define machine_is_cheetah()	(machine_arch_type == MACH_TYPE_CHEETAH)
+#else
+# define machine_is_cheetah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZVUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZVUE
+# endif
+# define machine_is_zvue()	(machine_arch_type == MACH_TYPE_ZVUE)
+#else
+# define machine_is_zvue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP1
+# endif
+# define machine_is_roverp1()	(machine_arch_type == MACH_TYPE_ROVERP1)
+#else
+# define machine_is_roverp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASIDIAL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASIDIAL2
+# endif
+# define machine_is_asidial2()	(machine_arch_type == MACH_TYPE_ASIDIAL2)
+#else
+# define machine_is_asidial2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C24A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C24A0
+# endif
+# define machine_is_s3c24a0()	(machine_arch_type == MACH_TYPE_S3C24A0)
+#else
+# define machine_is_s3c24a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C5500
+# endif
+# define machine_is_s3c5500()	(machine_arch_type == MACH_TYPE_S3C5500)
+#else
+# define machine_is_s3c5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5500
+# endif
+# define machine_is_smdk5500()	(machine_arch_type == MACH_TYPE_SMDK5500)
+#else
+# define machine_is_smdk5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIGNALSYNC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIGNALSYNC
+# endif
+# define machine_is_signalsync()	(machine_arch_type == MACH_TYPE_SIGNALSYNC)
+#else
+# define machine_is_signalsync()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBC
+# endif
+# define machine_is_nbc()	(machine_arch_type == MACH_TYPE_NBC)
+#else
+# define machine_is_nbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KODIAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KODIAK
+# endif
+# define machine_is_kodiak()	(machine_arch_type == MACH_TYPE_KODIAK)
+#else
+# define machine_is_kodiak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETBOOKPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETBOOKPRO
+# endif
+# define machine_is_netbookpro()	(machine_arch_type == MACH_TYPE_NETBOOKPRO)
+#else
+# define machine_is_netbookpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90200
+# endif
+# define machine_is_hw90200()	(machine_arch_type == MACH_TYPE_HW90200)
+#else
+# define machine_is_hw90200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONDOR
+# endif
+# define machine_is_condor()	(machine_arch_type == MACH_TYPE_CONDOR)
+#else
+# define machine_is_condor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CUP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CUP
+# endif
+# define machine_is_cup()	(machine_arch_type == MACH_TYPE_CUP)
+#else
+# define machine_is_cup()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KITE
+# endif
+# define machine_is_kite()	(machine_arch_type == MACH_TYPE_KITE)
+#else
+# define machine_is_kite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N10
+# endif
+# define machine_is_n10()	(machine_arch_type == MACH_TYPE_N10)
+#else
+# define machine_is_n10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONTAJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONTAJADE
+# endif
+# define machine_is_montejade()	(machine_arch_type == MACH_TYPE_MONTAJADE)
+#else
+# define machine_is_montejade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560
+# endif
+# define machine_is_sg560()	(machine_arch_type == MACH_TYPE_SG560)
+#else
+# define machine_is_sg560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1000
+# endif
+# define machine_is_dp1000()	(machine_arch_type == MACH_TYPE_DP1000)
+#else
+# define machine_is_dp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RG100V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RG100V3
+# endif
+# define machine_is_rg100v3()	(machine_arch_type == MACH_TYPE_RG100V3)
+#else
+# define machine_is_rg100v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2ADS
+# endif
+# define machine_is_mx2ads()	(machine_arch_type == MACH_TYPE_MX2ADS)
+#else
+# define machine_is_mx2ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KILO
+# endif
+# define machine_is_pxa_kilo()	(machine_arch_type == MACH_TYPE_PXA_KILO)
+#else
+# define machine_is_pxa_kilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP4XX_EAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP4XX_EAGLE
+# endif
+# define machine_is_ixp4xx_eagle()	(machine_arch_type == MACH_TYPE_IXP4XX_EAGLE)
+#else
+# define machine_is_ixp4xx_eagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB2520F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB2520F
+# endif
+# define machine_is_mb2520f()	(machine_arch_type == MACH_TYPE_MB2520F)
+#else
+# define machine_is_mb2520f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMC1000
+# endif
+# define machine_is_emc1000()	(machine_arch_type == MACH_TYPE_EMC1000)
+#else
+# define machine_is_emc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIDSC25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIDSC25
+# endif
+# define machine_is_tidsc25()	(machine_arch_type == MACH_TYPE_TIDSC25)
+#else
+# define machine_is_tidsc25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPMXL
+# endif
+# define machine_is_akcpmxl()	(machine_arch_type == MACH_TYPE_AKCPMXL)
+#else
+# define machine_is_akcpmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AV3XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AV3XX
+# endif
+# define machine_is_av3xx()	(machine_arch_type == MACH_TYPE_AV3XX)
+#else
+# define machine_is_av3xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_MPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_MPM10
+# endif
+# define machine_is_pxa_mpm10()	(machine_arch_type == MACH_TYPE_PXA_MPM10)
+#else
+# define machine_is_pxa_mpm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_KYANITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_KYANITE
+# endif
+# define machine_is_pxa_kyanite()	(machine_arch_type == MACH_TYPE_PXA_KYANITE)
+#else
+# define machine_is_pxa_kyanite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGOLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGOLD
+# endif
+# define machine_is_sgold()	(machine_arch_type == MACH_TYPE_SGOLD)
+#else
+# define machine_is_sgold()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSCAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSCAR
+# endif
+# define machine_is_oscar()	(machine_arch_type == MACH_TYPE_OSCAR)
+#else
+# define machine_is_oscar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPXA4USB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPXA4USB2
+# endif
+# define machine_is_epxa4usb2()	(machine_arch_type == MACH_TYPE_EPXA4USB2)
+#else
+# define machine_is_epxa4usb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSENGINE
+# endif
+# define machine_is_xsengine()	(machine_arch_type == MACH_TYPE_XSENGINE)
+#else
+# define machine_is_xsengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP600
+# endif
+# define machine_is_ip600()	(machine_arch_type == MACH_TYPE_IP600)
+#else
+# define machine_is_ip600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCAN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCAN2
+# endif
+# define machine_is_mcan2()	(machine_arch_type == MACH_TYPE_MCAN2)
+#else
+# define machine_is_mcan2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDI_BLUERIDGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDI_BLUERIDGE
+# endif
+# define machine_is_ddi_blueridge()	(machine_arch_type == MACH_TYPE_DDI_BLUERIDGE)
+#else
+# define machine_is_ddi_blueridge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMINDER
+# endif
+# define machine_is_skyminder()	(machine_arch_type == MACH_TYPE_SKYMINDER)
+#else
+# define machine_is_skyminder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79520
+# endif
+# define machine_is_lpd79520()	(machine_arch_type == MACH_TYPE_LPD79520)
+#else
+# define machine_is_lpd79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90340
+# endif
+# define machine_is_hw90340()	(machine_arch_type == MACH_TYPE_HW90340)
+#else
+# define machine_is_hw90340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIP_BOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIP_BOX
+# endif
+# define machine_is_cip_box()	(machine_arch_type == MACH_TYPE_CIP_BOX)
+#else
+# define machine_is_cip_box()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IVPN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IVPN
+# endif
+# define machine_is_ivpn()	(machine_arch_type == MACH_TYPE_IVPN)
+#else
+# define machine_is_ivpn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSOC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSOC2
+# endif
+# define machine_is_rsoc2()	(machine_arch_type == MACH_TYPE_RSOC2)
+#else
+# define machine_is_rsoc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOXER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOXER
+# endif
+# define machine_is_boxer()	(machine_arch_type == MACH_TYPE_BOXER)
+#else
+# define machine_is_boxer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML42800AA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML42800AA
+# endif
+# define machine_is_aml42800aa()	(machine_arch_type == MACH_TYPE_AML42800AA)
+#else
+# define machine_is_aml42800aa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC2294
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC2294
+# endif
+# define machine_is_lpc2294()	(machine_arch_type == MACH_TYPE_LPC2294)
+#else
+# define machine_is_lpc2294()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWITCHGRASS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWITCHGRASS
+# endif
+# define machine_is_switchgrass()	(machine_arch_type == MACH_TYPE_SWITCHGRASS)
+#else
+# define machine_is_switchgrass()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENS_CMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENS_CMU
+# endif
+# define machine_is_ens_cmu()	(machine_arch_type == MACH_TYPE_ENS_CMU)
+#else
+# define machine_is_ens_cmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MM6_SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MM6_SDB
+# endif
+# define machine_is_mm6_sdb()	(machine_arch_type == MACH_TYPE_MM6_SDB)
+#else
+# define machine_is_mm6_sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATURN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATURN
+# endif
+# define machine_is_saturn()	(machine_arch_type == MACH_TYPE_SATURN)
+#else
+# define machine_is_saturn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030EVB
+# endif
+# define machine_is_i30030evb()	(machine_arch_type == MACH_TYPE_I30030EVB)
+#else
+# define machine_is_i30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530EVB
+# endif
+# define machine_is_mxc27530evb()	(machine_arch_type == MACH_TYPE_MXC27530EVB)
+#else
+# define machine_is_mxc27530evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2800
+# endif
+# define machine_is_smdk2800()	(machine_arch_type == MACH_TYPE_SMDK2800)
+#else
+# define machine_is_smdk2800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTWILSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTWILSON
+# endif
+# define machine_is_mtwilson()	(machine_arch_type == MACH_TYPE_MTWILSON)
+#else
+# define machine_is_mtwilson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZITI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZITI
+# endif
+# define machine_is_ziti()	(machine_arch_type == MACH_TYPE_ZITI)
+#else
+# define machine_is_ziti()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GRANDFATHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRANDFATHER
+# endif
+# define machine_is_grandfather()	(machine_arch_type == MACH_TYPE_GRANDFATHER)
+#else
+# define machine_is_grandfather()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENGINE
+# endif
+# define machine_is_tengine()	(machine_arch_type == MACH_TYPE_TENGINE)
+#else
+# define machine_is_tengine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2460
+# endif
+# define machine_is_s3c2460()	(machine_arch_type == MACH_TYPE_S3C2460)
+#else
+# define machine_is_s3c2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDM
+# endif
+# define machine_is_pdm()	(machine_arch_type == MACH_TYPE_PDM)
+#else
+# define machine_is_pdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6300
+# endif
+# define machine_is_h6300()	(machine_arch_type == MACH_TYPE_H6300)
+#else
+# define machine_is_h6300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RZ1700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RZ1700
+# endif
+# define machine_is_rz1700()	(machine_arch_type == MACH_TYPE_RZ1700)
+#else
+# define machine_is_rz1700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A716
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A716
+# endif
+# define machine_is_a716()	(machine_arch_type == MACH_TYPE_A716)
+#else
+# define machine_is_a716()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESTK2440A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESTK2440A
+# endif
+# define machine_is_estk2440a()	(machine_arch_type == MACH_TYPE_ESTK2440A)
+#else
+# define machine_is_estk2440a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATWIXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATWIXP425
+# endif
+# define machine_is_atwixp425()	(machine_arch_type == MACH_TYPE_ATWIXP425)
+#else
+# define machine_is_atwixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB336
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB336
+# endif
+# define machine_is_csb336()	(machine_arch_type == MACH_TYPE_CSB336)
+#else
+# define machine_is_csb336()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIRM2
+# endif
+# define machine_is_rirm2()	(machine_arch_type == MACH_TYPE_RIRM2)
+#else
+# define machine_is_rirm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX23518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX23518
+# endif
+# define machine_is_cx23518()	(machine_arch_type == MACH_TYPE_CX23518)
+#else
+# define machine_is_cx23518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CX2351X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CX2351X
+# endif
+# define machine_is_cx2351x()	(machine_arch_type == MACH_TYPE_CX2351X)
+#else
+# define machine_is_cx2351x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPUTIME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPUTIME
+# endif
+# define machine_is_computime()	(machine_arch_type == MACH_TYPE_COMPUTIME)
+#else
+# define machine_is_computime()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IZARUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IZARUS
+# endif
+# define machine_is_izarus()	(machine_arch_type == MACH_TYPE_IZARUS)
+#else
+# define machine_is_izarus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTS
+# endif
+# define machine_is_pxa_rts()	(machine_arch_type == MACH_TYPE_RTS)
+#else
+# define machine_is_pxa_rts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE5100
+# endif
+# define machine_is_se5100()	(machine_arch_type == MACH_TYPE_SE5100)
+#else
+# define machine_is_se5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2510
+# endif
+# define machine_is_s3c2510()	(machine_arch_type == MACH_TYPE_S3C2510)
+#else
+# define machine_is_s3c2510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB437TL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB437TL
+# endif
+# define machine_is_csb437tl()	(machine_arch_type == MACH_TYPE_CSB437TL)
+#else
+# define machine_is_csb437tl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLAUSON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLAUSON
+# endif
+# define machine_is_slauson()	(machine_arch_type == MACH_TYPE_SLAUSON)
+#else
+# define machine_is_slauson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEARLRIVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEARLRIVER
+# endif
+# define machine_is_pearlriver()	(machine_arch_type == MACH_TYPE_PEARLRIVER)
+#else
+# define machine_is_pearlriver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDC_P210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDC_P210
+# endif
+# define machine_is_tdc_p210()	(machine_arch_type == MACH_TYPE_TDC_P210)
+#else
+# define machine_is_tdc_p210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG580
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG580
+# endif
+# define machine_is_sg580()	(machine_arch_type == MACH_TYPE_SG580)
+#else
+# define machine_is_sg580()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRSBCARM7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRSBCARM7
+# endif
+# define machine_is_wrsbcarm7()	(machine_arch_type == MACH_TYPE_WRSBCARM7)
+#else
+# define machine_is_wrsbcarm7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPD
+# endif
+# define machine_is_ipd()	(machine_arch_type == MACH_TYPE_IPD)
+#else
+# define machine_is_ipd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_DNP2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_DNP2110
+# endif
+# define machine_is_pxa_dnp2110()	(machine_arch_type == MACH_TYPE_PXA_DNP2110)
+#else
+# define machine_is_pxa_dnp2110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XAENIAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XAENIAX
+# endif
+# define machine_is_xaeniax()	(machine_arch_type == MACH_TYPE_XAENIAX)
+#else
+# define machine_is_xaeniax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOMN4250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOMN4250
+# endif
+# define machine_is_somn4250()	(machine_arch_type == MACH_TYPE_SOMN4250)
+#else
+# define machine_is_somn4250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLEB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB2
+# endif
+# define machine_is_pleb2()	(machine_arch_type == MACH_TYPE_PLEB2)
+#else
+# define machine_is_pleb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORNWALLIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORNWALLIS
+# endif
+# define machine_is_cornwallis()	(machine_arch_type == MACH_TYPE_CORNWALLIS)
+#else
+# define machine_is_cornwallis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNEY_DRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNEY_DRV
+# endif
+# define machine_is_gurney_drv()	(machine_arch_type == MACH_TYPE_GURNEY_DRV)
+#else
+# define machine_is_gurney_drv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHAFFEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHAFFEE
+# endif
+# define machine_is_chaffee()	(machine_arch_type == MACH_TYPE_CHAFFEE)
+#else
+# define machine_is_chaffee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS101
+# endif
+# define machine_is_rms101()	(machine_arch_type == MACH_TYPE_RMS101)
+#else
+# define machine_is_rms101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWIFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWIFT
+# endif
+# define machine_is_swift()	(machine_arch_type == MACH_TYPE_SWIFT)
+#else
+# define machine_is_swift()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP7
+# endif
+# define machine_is_roverp7()	(machine_arch_type == MACH_TYPE_ROVERP7)
+#else
+# define machine_is_roverp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PR818S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PR818S
+# endif
+# define machine_is_pr818s()	(machine_arch_type == MACH_TYPE_PR818S)
+#else
+# define machine_is_pr818s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRXPRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRXPRO
+# endif
+# define machine_is_trxpro()	(machine_arch_type == MACH_TYPE_TRXPRO)
+#else
+# define machine_is_trxpro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRAB
+# endif
+# define machine_is_trab()	(machine_arch_type == MACH_TYPE_TRAB)
+#else
+# define machine_is_trab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMC_PU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMC_PU2
+# endif
+# define machine_is_cmc_pu2()	(machine_arch_type == MACH_TYPE_CMC_PU2)
+#else
+# define machine_is_cmc_pu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FULCRUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FULCRUM
+# endif
+# define machine_is_fulcrum()	(machine_arch_type == MACH_TYPE_FULCRUM)
+#else
+# define machine_is_fulcrum()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETGATE42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGATE42X
+# endif
+# define machine_is_netgate42x()	(machine_arch_type == MACH_TYPE_NETGATE42X)
+#else
+# define machine_is_netgate42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR710
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR710
+# endif
+# define machine_is_str710()	(machine_arch_type == MACH_TYPE_STR710)
+#else
+# define machine_is_str710()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOMTOMGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOMTOMGO
+# endif
+# define machine_is_tomtomgo()	(machine_arch_type == MACH_TYPE_TOMTOMGO)
+#else
+# define machine_is_tomtomgo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG565
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG565
+# endif
+# define machine_is_sg565()	(machine_arch_type == MACH_TYPE_SG565)
+#else
+# define machine_is_sg565()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79524
+# endif
+# define machine_is_lpd79524()	(machine_arch_type == MACH_TYPE_LPD79524)
+#else
+# define machine_is_lpd79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD79525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD79525
+# endif
+# define machine_is_lpd79525()	(machine_arch_type == MACH_TYPE_LPD79525)
+#else
+# define machine_is_lpd79525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMS100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMS100
+# endif
+# define machine_is_rms100()	(machine_arch_type == MACH_TYPE_RMS100)
+#else
+# define machine_is_rms100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMS39C7092
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMS39C7092
+# endif
+# define machine_is_hms39c7092()	(machine_arch_type == MACH_TYPE_HMS39C7092)
+#else
+# define machine_is_hms39c7092()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO
+# endif
+# define machine_is_armadillo()	(machine_arch_type == MACH_TYPE_ARMADILLO)
+#else
+# define machine_is_armadillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPCU
+# endif
+# define machine_is_ipcu()	(machine_arch_type == MACH_TYPE_IPCU)
+#else
+# define machine_is_ipcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX720
+# endif
+# define machine_is_loox720()	(machine_arch_type == MACH_TYPE_LOOX720)
+#else
+# define machine_is_loox720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSVIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSVIX
+# endif
+# define machine_is_adsvix()	(machine_arch_type == MACH_TYPE_ADSVIX)
+#else
+# define machine_is_adsvix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM270
+# endif
+# define machine_is_dm270()	(machine_arch_type == MACH_TYPE_DM270)
+#else
+# define machine_is_dm270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCLTPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCLTPLUS
+# endif
+# define machine_is_socltplus()	(machine_arch_type == MACH_TYPE_SOCLTPLUS)
+#else
+# define machine_is_socltplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECIA
+# endif
+# define machine_is_ecia()	(machine_arch_type == MACH_TYPE_ECIA)
+#else
+# define machine_is_ecia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4008
+# endif
+# define machine_is_cm4008()	(machine_arch_type == MACH_TYPE_CM4008)
+#else
+# define machine_is_cm4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P2001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P2001
+# endif
+# define machine_is_p2001()	(machine_arch_type == MACH_TYPE_P2001)
+#else
+# define machine_is_p2001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWISTER
+# endif
+# define machine_is_twister()	(machine_arch_type == MACH_TYPE_TWISTER)
+#else
+# define machine_is_twister()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUDSHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUDSHARK
+# endif
+# define machine_is_mudshark()	(machine_arch_type == MACH_TYPE_MUDSHARK)
+#else
+# define machine_is_mudshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HB2
+# endif
+# define machine_is_hb2()	(machine_arch_type == MACH_TYPE_HB2)
+#else
+# define machine_is_hb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SENDT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SENDT
+# endif
+# define machine_is_sendt()	(machine_arch_type == MACH_TYPE_SENDT)
+#else
+# define machine_is_sendt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2JAZZ
+# endif
+# define machine_is_mx2jazz()	(machine_arch_type == MACH_TYPE_MX2JAZZ)
+#else
+# define machine_is_mx2jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIIO
+# endif
+# define machine_is_multiio()	(machine_arch_type == MACH_TYPE_MULTIIO)
+#else
+# define machine_is_multiio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HRDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HRDISPLAY
+# endif
+# define machine_is_hrdisplay()	(machine_arch_type == MACH_TYPE_HRDISPLAY)
+#else
+# define machine_is_hrdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27530ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27530ADS
+# endif
+# define machine_is_mxc27530ads()	(machine_arch_type == MACH_TYPE_MXC27530ADS)
+#else
+# define machine_is_mxc27530ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS3
+# endif
+# define machine_is_trizeps3()	(machine_arch_type == MACH_TYPE_TRIZEPS3)
+#else
+# define machine_is_trizeps3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZA
+# endif
+# define machine_is_zefeerdza()	(machine_arch_type == MACH_TYPE_ZEFEERDZA)
+#else
+# define machine_is_zefeerdza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZB
+# endif
+# define machine_is_zefeerdzb()	(machine_arch_type == MACH_TYPE_ZEFEERDZB)
+#else
+# define machine_is_zefeerdzb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZG
+# endif
+# define machine_is_zefeerdzg()	(machine_arch_type == MACH_TYPE_ZEFEERDZG)
+#else
+# define machine_is_zefeerdzg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZN
+# endif
+# define machine_is_zefeerdzn()	(machine_arch_type == MACH_TYPE_ZEFEERDZN)
+#else
+# define machine_is_zefeerdzn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZEFEERDZQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZEFEERDZQ
+# endif
+# define machine_is_zefeerdzq()	(machine_arch_type == MACH_TYPE_ZEFEERDZQ)
+#else
+# define machine_is_zefeerdzq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTRO_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTRO_JACK
+# endif
+# define machine_is_astro_jack()	(machine_arch_type == MACH_TYPE_ASTRO_JACK)
+#else
+# define machine_is_astro_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIP03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIP03
+# endif
+# define machine_is_tip03()	(machine_arch_type == MACH_TYPE_TIP03)
+#else
+# define machine_is_tip03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9200EC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9200EC
+# endif
+# define machine_is_a9200ec()	(machine_arch_type == MACH_TYPE_A9200EC)
+#else
+# define machine_is_a9200ec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0105
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0105
+# endif
+# define machine_is_pnx0105()	(machine_arch_type == MACH_TYPE_PNX0105)
+#else
+# define machine_is_pnx0105()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADCPOECPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADCPOECPU
+# endif
+# define machine_is_adcpoecpu()	(machine_arch_type == MACH_TYPE_ADCPOECPU)
+#else
+# define machine_is_adcpoecpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9200
+# endif
+# define machine_is_mb9200()	(machine_arch_type == MACH_TYPE_MB9200)
+#else
+# define machine_is_mb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KULUN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KULUN
+# endif
+# define machine_is_kulun()	(machine_arch_type == MACH_TYPE_KULUN)
+#else
+# define machine_is_kulun()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER
+# endif
+# define machine_is_snapper()	(machine_arch_type == MACH_TYPE_SNAPPER)
+#else
+# define machine_is_snapper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTIMA
+# endif
+# define machine_is_optima()	(machine_arch_type == MACH_TYPE_OPTIMA)
+#else
+# define machine_is_optima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLHSBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLHSBC
+# endif
+# define machine_is_dlhsbc()	(machine_arch_type == MACH_TYPE_DLHSBC)
+#else
+# define machine_is_dlhsbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X30
+# endif
+# define machine_is_x30()	(machine_arch_type == MACH_TYPE_X30)
+#else
+# define machine_is_x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANGA_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANGA_KS8695
+# endif
+# define machine_is_manga_ks8695()	(machine_arch_type == MACH_TYPE_MANGA_KS8695)
+#else
+# define machine_is_manga_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX
+# endif
+# define machine_is_ajax()	(machine_arch_type == MACH_TYPE_AJAX)
+#else
+# define machine_is_ajax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK1000
+# endif
+# define machine_is_vvtk1000()	(machine_arch_type == MACH_TYPE_VVTK1000)
+#else
+# define machine_is_vvtk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVTK3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVTK3000
+# endif
+# define machine_is_vvtk3000()	(machine_arch_type == MACH_TYPE_VVTK3000)
+#else
+# define machine_is_vvtk3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIMX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIMX1
+# endif
+# define machine_is_pimx1()	(machine_arch_type == MACH_TYPE_PIMX1)
+#else
+# define machine_is_pimx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLLIE
+# endif
+# define machine_is_ollie()	(machine_arch_type == MACH_TYPE_OLLIE)
+#else
+# define machine_is_ollie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKYMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKYMAX
+# endif
+# define machine_is_skymax()	(machine_arch_type == MACH_TYPE_SKYMAX)
+#else
+# define machine_is_skymax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAZZ
+# endif
+# define machine_is_jazz()	(machine_arch_type == MACH_TYPE_JAZZ)
+#else
+# define machine_is_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEL_T3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEL_T3
+# endif
+# define machine_is_tel_t3()	(machine_arch_type == MACH_TYPE_TEL_T3)
+#else
+# define machine_is_tel_t3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AISINO_FCR255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AISINO_FCR255
+# endif
+# define machine_is_aisino_fcr255()	(machine_arch_type == MACH_TYPE_AISINO_FCR255)
+#else
+# define machine_is_aisino_fcr255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTWEB
+# endif
+# define machine_is_btweb()	(machine_arch_type == MACH_TYPE_BTWEB)
+#else
+# define machine_is_btweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DBG_LH79520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DBG_LH79520
+# endif
+# define machine_is_dbg_lh79520()	(machine_arch_type == MACH_TYPE_DBG_LH79520)
+#else
+# define machine_is_dbg_lh79520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM41XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM41XX
+# endif
+# define machine_is_cm41xx()	(machine_arch_type == MACH_TYPE_CM41XX)
+#else
+# define machine_is_cm41xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NGGPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NGGPXA
+# endif
+# define machine_is_nggpxa()	(machine_arch_type == MACH_TYPE_NGGPXA)
+#else
+# define machine_is_nggpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB535
+# endif
+# define machine_is_csb535()	(machine_arch_type == MACH_TYPE_CSB535)
+#else
+# define machine_is_csb535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB536
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB536
+# endif
+# define machine_is_csb536()	(machine_arch_type == MACH_TYPE_CSB536)
+#else
+# define machine_is_csb536()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_TRAKPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_TRAKPOD
+# endif
+# define machine_is_pxa_trakpod()	(machine_arch_type == MACH_TYPE_PXA_TRAKPOD)
+#else
+# define machine_is_pxa_trakpod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRAXIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRAXIS
+# endif
+# define machine_is_praxis()	(machine_arch_type == MACH_TYPE_PRAXIS)
+#else
+# define machine_is_praxis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LH75411
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LH75411
+# endif
+# define machine_is_lh75411()	(machine_arch_type == MACH_TYPE_LH75411)
+#else
+# define machine_is_lh75411()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOX410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOX410
+# endif
+# define machine_is_loox410()	(machine_arch_type == MACH_TYPE_LOOX410)
+#else
+# define machine_is_loox410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WESTLAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WESTLAKE
+# endif
+# define machine_is_westlake()	(machine_arch_type == MACH_TYPE_WESTLAKE)
+#else
+# define machine_is_westlake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB
+# endif
+# define machine_is_nsb()	(machine_arch_type == MACH_TYPE_NSB)
+#else
+# define machine_is_nsb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_STN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_STN
+# endif
+# define machine_is_esl_sarva_stn()	(machine_arch_type == MACH_TYPE_ESL_SARVA_STN)
+#else
+# define machine_is_esl_sarva_stn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_TFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_TFT
+# endif
+# define machine_is_esl_sarva_tft()	(machine_arch_type == MACH_TYPE_ESL_SARVA_TFT)
+#else
+# define machine_is_esl_sarva_tft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_IAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_IAD
+# endif
+# define machine_is_esl_sarva_iad()	(machine_arch_type == MACH_TYPE_ESL_SARVA_IAD)
+#else
+# define machine_is_esl_sarva_iad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_SARVA_ACC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_SARVA_ACC
+# endif
+# define machine_is_esl_sarva_acc()	(machine_arch_type == MACH_TYPE_ESL_SARVA_ACC)
+#else
+# define machine_is_esl_sarva_acc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TYPHOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TYPHOON
+# endif
+# define machine_is_typhoon()	(machine_arch_type == MACH_TYPE_TYPHOON)
+#else
+# define machine_is_typhoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNAV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNAV
+# endif
+# define machine_is_cnav()	(machine_arch_type == MACH_TYPE_CNAV)
+#else
+# define machine_is_cnav()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A730
+# endif
+# define machine_is_a730()	(machine_arch_type == MACH_TYPE_A730)
+#else
+# define machine_is_a730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSTAR
+# endif
+# define machine_is_netstar()	(machine_arch_type == MACH_TYPE_NETSTAR)
+#else
+# define machine_is_netstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHASEFALE_SUPERCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHASEFALE_SUPERCON
+# endif
+# define machine_is_supercon()	(machine_arch_type == MACH_TYPE_PHASEFALE_SUPERCON)
+#else
+# define machine_is_supercon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHIVA1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHIVA1100
+# endif
+# define machine_is_shiva1100()	(machine_arch_type == MACH_TYPE_SHIVA1100)
+#else
+# define machine_is_shiva1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETEXSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETEXSC
+# endif
+# define machine_is_etexsc()	(machine_arch_type == MACH_TYPE_ETEXSC)
+#else
+# define machine_is_etexsc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG465
+# endif
+# define machine_is_ixdpg465()	(machine_arch_type == MACH_TYPE_IXDPG465)
+#else
+# define machine_is_ixdpg465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2410
+# endif
+# define machine_is_a9m2410()	(machine_arch_type == MACH_TYPE_A9M2410)
+#else
+# define machine_is_a9m2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M2440
+# endif
+# define machine_is_a9m2440()	(machine_arch_type == MACH_TYPE_A9M2440)
+#else
+# define machine_is_a9m2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9750
+# endif
+# define machine_is_a9m9750()	(machine_arch_type == MACH_TYPE_A9M9750)
+#else
+# define machine_is_a9m9750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9M9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9M9360
+# endif
+# define machine_is_a9m9360()	(machine_arch_type == MACH_TYPE_A9M9360)
+#else
+# define machine_is_a9m9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNC90
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNC90
+# endif
+# define machine_is_unc90()	(machine_arch_type == MACH_TYPE_UNC90)
+#else
+# define machine_is_unc90()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SATVIEW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SATVIEW
+# endif
+# define machine_is_satview()	(machine_arch_type == MACH_TYPE_SATVIEW)
+#else
+# define machine_is_satview()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GP32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GP32
+# endif
+# define machine_is_gp32()	(machine_arch_type == MACH_TYPE_GP32)
+#else
+# define machine_is_gp32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEM
+# endif
+# define machine_is_gem()	(machine_arch_type == MACH_TYPE_GEM)
+#else
+# define machine_is_gem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I858
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I858
+# endif
+# define machine_is_i858()	(machine_arch_type == MACH_TYPE_I858)
+#else
+# define machine_is_i858()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX2750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX2750
+# endif
+# define machine_is_hx2750()	(machine_arch_type == MACH_TYPE_HX2750)
+#else
+# define machine_is_hx2750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC91131EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC91131EVB
+# endif
+# define machine_is_mxc91131evb()	(machine_arch_type == MACH_TYPE_MXC91131EVB)
+#else
+# define machine_is_mxc91131evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P700
+# endif
+# define machine_is_p700()	(machine_arch_type == MACH_TYPE_P700)
+#else
+# define machine_is_p700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPE
+# endif
+# define machine_is_cpe()	(machine_arch_type == MACH_TYPE_CPE)
+#else
+# define machine_is_cpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIMBRA340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMBRA340
+# endif
+# define machine_is_nimbra340()	(machine_arch_type == MACH_TYPE_NIMBRA340)
+#else
+# define machine_is_nimbra340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC22XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC22XX
+# endif
+# define machine_is_lpc22xx()	(machine_arch_type == MACH_TYPE_LPC22XX)
+#else
+# define machine_is_lpc22xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET3
+# endif
+# define machine_is_omap_comet3()	(machine_arch_type == MACH_TYPE_COMET3)
+#else
+# define machine_is_omap_comet3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMET4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMET4
+# endif
+# define machine_is_omap_comet4()	(machine_arch_type == MACH_TYPE_COMET4)
+#else
+# define machine_is_omap_comet4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB625
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB625
+# endif
+# define machine_is_csb625()	(machine_arch_type == MACH_TYPE_CSB625)
+#else
+# define machine_is_csb625()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FORTUNET2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET2
+# endif
+# define machine_is_fortunet2()	(machine_arch_type == MACH_TYPE_FORTUNET2)
+#else
+# define machine_is_fortunet2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5H2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5H2200
+# endif
+# define machine_is_s5h2200()	(machine_arch_type == MACH_TYPE_S5H2200)
+#else
+# define machine_is_s5h2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPTORM920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPTORM920
+# endif
+# define machine_is_optorm920()	(machine_arch_type == MACH_TYPE_OPTORM920)
+#else
+# define machine_is_optorm920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSYXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYXB
+# endif
+# define machine_is_adsbitsyxb()	(machine_arch_type == MACH_TYPE_ADSBITSYXB)
+#else
+# define machine_is_adsbitsyxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTAL
+# endif
+# define machine_is_adsportal()	(machine_arch_type == MACH_TYPE_ADSPORTAL)
+#else
+# define machine_is_adsportal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LN2410SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LN2410SBC
+# endif
+# define machine_is_ln2410sbc()	(machine_arch_type == MACH_TYPE_LN2410SBC)
+#else
+# define machine_is_ln2410sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CB3RUFC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CB3RUFC
+# endif
+# define machine_is_cb3rufc()	(machine_arch_type == MACH_TYPE_CB3RUFC)
+#else
+# define machine_is_cb3rufc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP2USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP2USB
+# endif
+# define machine_is_mp2usb()	(machine_arch_type == MACH_TYPE_MP2USB)
+#else
+# define machine_is_mp2usb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP425C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP425C
+# endif
+# define machine_is_ntnp425c()	(machine_arch_type == MACH_TYPE_NTNP425C)
+#else
+# define machine_is_ntnp425c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM7220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM7220
+# endif
+# define machine_is_pcm7220()	(machine_arch_type == MACH_TYPE_PCM7220)
+#else
+# define machine_is_pcm7220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA
+# endif
+# define machine_is_cmpxa()	(machine_arch_type == MACH_TYPE_CMPXA)
+#else
+# define machine_is_cmpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ITE8152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ITE8152
+# endif
+# define machine_is_ite8152()	(machine_arch_type == MACH_TYPE_ITE8152)
+#else
+# define machine_is_ite8152()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC3XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC3XXX
+# endif
+# define machine_is_lpc3xxx()	(machine_arch_type == MACH_TYPE_LPC3XXX)
+#else
+# define machine_is_lpc3xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPPETEER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPPETEER
+# endif
+# define machine_is_puppeteer()	(machine_arch_type == MACH_TYPE_PUPPETEER)
+#else
+# define machine_is_puppeteer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E570
+# endif
+# define machine_is_e570()	(machine_arch_type == MACH_TYPE_E570)
+#else
+# define machine_is_e570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X50
+# endif
+# define machine_is_x50()	(machine_arch_type == MACH_TYPE_X50)
+#else
+# define machine_is_x50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RECON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RECON
+# endif
+# define machine_is_recon()	(machine_arch_type == MACH_TYPE_RECON)
+#else
+# define machine_is_recon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XBOARDGP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XBOARDGP8
+# endif
+# define machine_is_xboardgp8()	(machine_arch_type == MACH_TYPE_XBOARDGP8)
+#else
+# define machine_is_xboardgp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FPIC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FPIC2
+# endif
+# define machine_is_fpic2()	(machine_arch_type == MACH_TYPE_FPIC2)
+#else
+# define machine_is_fpic2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A81
+# endif
+# define machine_is_a81()	(machine_arch_type == MACH_TYPE_A81)
+#else
+# define machine_is_a81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVM_SC25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVM_SC25X
+# endif
+# define machine_is_svm_sc25x()	(machine_arch_type == MACH_TYPE_SVM_SC25X)
+#else
+# define machine_is_svm_sc25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VADATECH020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VADATECH020
+# endif
+# define machine_is_vt020()	(machine_arch_type == MACH_TYPE_VADATECH020)
+#else
+# define machine_is_vt020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLI
+# endif
+# define machine_is_tli()	(machine_arch_type == MACH_TYPE_TLI)
+#else
+# define machine_is_tli()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315LC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315LC
+# endif
+# define machine_is_edb9315lc()	(machine_arch_type == MACH_TYPE_EDB9315LC)
+#else
+# define machine_is_edb9315lc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSEC
+# endif
+# define machine_is_passec()	(machine_arch_type == MACH_TYPE_PASSEC)
+#else
+# define machine_is_passec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS_TIGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS_TIGER
+# endif
+# define machine_is_ds_tiger()	(machine_arch_type == MACH_TYPE_DS_TIGER)
+#else
+# define machine_is_ds_tiger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E310
+# endif
+# define machine_is_e310()	(machine_arch_type == MACH_TYPE_E310)
+#else
+# define machine_is_e310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT3000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT3000
+# endif
+# define machine_is_rt3000()	(machine_arch_type == MACH_TYPE_RT3000)
+#else
+# define machine_is_rt3000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX0106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX0106
+# endif
+# define machine_is_pnx0106()	(machine_arch_type == MACH_TYPE_PNX0106)
+#else
+# define machine_is_pnx0106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HX21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HX21XX
+# endif
+# define machine_is_hx21xx()	(machine_arch_type == MACH_TYPE_HX21XX)
+#else
+# define machine_is_hx21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARADAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARADAY
+# endif
+# define machine_is_faraday()	(machine_arch_type == MACH_TYPE_FARADAY)
+#else
+# define machine_is_faraday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC9312
+# endif
+# define machine_is_sbc9312()	(machine_arch_type == MACH_TYPE_SBC9312)
+#else
+# define machine_is_sbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BATMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BATMAN
+# endif
+# define machine_is_batman()	(machine_arch_type == MACH_TYPE_BATMAN)
+#else
+# define machine_is_batman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JPD201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JPD201
+# endif
+# define machine_is_jpd201()	(machine_arch_type == MACH_TYPE_JPD201)
+#else
+# define machine_is_jpd201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIPSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIPSA
+# endif
+# define machine_is_mipsa()	(machine_arch_type == MACH_TYPE_MIPSA)
+#else
+# define machine_is_mipsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KACOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KACOM
+# endif
+# define machine_is_kacom()	(machine_arch_type == MACH_TYPE_KACOM)
+#else
+# define machine_is_kacom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOCPU
+# endif
+# define machine_is_swarcocpu()	(machine_arch_type == MACH_TYPE_SWARCOCPU)
+#else
+# define machine_is_swarcocpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCODSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCODSL
+# endif
+# define machine_is_swarcodsl()	(machine_arch_type == MACH_TYPE_SWARCODSL)
+#else
+# define machine_is_swarcodsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEANGEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEANGEL
+# endif
+# define machine_is_blueangel()	(machine_arch_type == MACH_TYPE_BLUEANGEL)
+#else
+# define machine_is_blueangel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAIRYGRAMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAIRYGRAMA
+# endif
+# define machine_is_hairygrama()	(machine_arch_type == MACH_TYPE_HAIRYGRAMA)
+#else
+# define machine_is_hairygrama()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BANFF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BANFF
+# endif
+# define machine_is_banff()	(machine_arch_type == MACH_TYPE_BANFF)
+#else
+# define machine_is_banff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM255
+# endif
+# define machine_is_sam255()	(machine_arch_type == MACH_TYPE_SAM255)
+#else
+# define machine_is_sam255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PPM10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PPM10
+# endif
+# define machine_is_ppm10()	(machine_arch_type == MACH_TYPE_PPM10)
+#else
+# define machine_is_ppm10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNSET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNSET
+# endif
+# define machine_is_sunset()	(machine_arch_type == MACH_TYPE_SUNSET)
+#else
+# define machine_is_sunset()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE2
+# endif
+# define machine_is_mainstone2()	(machine_arch_type == MACH_TYPE_MAINSTONE2)
+#else
+# define machine_is_mainstone2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_IXP42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_IXP42X
+# endif
+# define machine_is_ez_ixp42x()	(machine_arch_type == MACH_TYPE_EZ_IXP42X)
+#else
+# define machine_is_ez_ixp42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAPWAVE_ZODIAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAPWAVE_ZODIAC
+# endif
+# define machine_is_tapwave_zodiac()	(machine_arch_type == MACH_TYPE_TAPWAVE_ZODIAC)
+#else
+# define machine_is_tapwave_zodiac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSALMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSALMETER
+# endif
+# define machine_is_universalmeter()	(machine_arch_type == MACH_TYPE_UNIVERSALMETER)
+#else
+# define machine_is_universalmeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HICOARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HICOARM9
+# endif
+# define machine_is_hicoarm9()	(machine_arch_type == MACH_TYPE_HICOARM9)
+#else
+# define machine_is_hicoarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS6000
+# endif
+# define machine_is_kws6000()	(machine_arch_type == MACH_TYPE_KWS6000)
+#else
+# define machine_is_kws6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUX920T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUX920T
+# endif
+# define machine_is_portux920t()	(machine_arch_type == MACH_TYPE_PORTUX920T)
+#else
+# define machine_is_portux920t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X5
+# endif
+# define machine_is_ez_x5()	(machine_arch_type == MACH_TYPE_EZ_X5)
+#else
+# define machine_is_ez_x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_RUDOLPH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_RUDOLPH
+# endif
+# define machine_is_omap_rudolph()	(machine_arch_type == MACH_TYPE_OMAP_RUDOLPH)
+#else
+# define machine_is_omap_rudolph()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA9200
+# endif
+# define machine_is_rea9200()	(machine_arch_type == MACH_TYPE_REA9200)
+#else
+# define machine_is_rea9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTS_PUNE_SA1110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTS_PUNE_SA1110
+# endif
+# define machine_is_acts_pune_sa1110()	(machine_arch_type == MACH_TYPE_ACTS_PUNE_SA1110)
+#else
+# define machine_is_acts_pune_sa1110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP425
+# endif
+# define machine_is_ixp425()	(machine_arch_type == MACH_TYPE_IXP425)
+#else
+# define machine_is_ixp425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I30030ADS
+# endif
+# define machine_is_i30030ads()	(machine_arch_type == MACH_TYPE_I30030ADS)
+#else
+# define machine_is_i30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PERCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERCH
+# endif
+# define machine_is_perch()	(machine_arch_type == MACH_TYPE_PERCH)
+#else
+# define machine_is_perch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIS05R1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIS05R1
+# endif
+# define machine_is_eis05r1()	(machine_arch_type == MACH_TYPE_EIS05R1)
+#else
+# define machine_is_eis05r1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEPPERPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEPPERPAD
+# endif
+# define machine_is_pepperpad()	(machine_arch_type == MACH_TYPE_PEPPERPAD)
+#else
+# define machine_is_pepperpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SB3010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SB3010
+# endif
+# define machine_is_sb3010()	(machine_arch_type == MACH_TYPE_SB3010)
+#else
+# define machine_is_sb3010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RM9200
+# endif
+# define machine_is_rm9200()	(machine_arch_type == MACH_TYPE_RM9200)
+#else
+# define machine_is_rm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA03
+# endif
+# define machine_is_dma03()	(machine_arch_type == MACH_TYPE_DMA03)
+#else
+# define machine_is_dma03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROAD_S101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROAD_S101
+# endif
+# define machine_is_road_s101()	(machine_arch_type == MACH_TYPE_ROAD_S101)
+#else
+# define machine_is_road_s101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_B
+# endif
+# define machine_is_iq_nextgen_b()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_B)
+#else
+# define machine_is_iq_nextgen_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_D
+# endif
+# define machine_is_iq_nextgen_d()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_D)
+#else
+# define machine_is_iq_nextgen_d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ_NEXTGEN_E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ_NEXTGEN_E
+# endif
+# define machine_is_iq_nextgen_e()	(machine_arch_type == MACH_TYPE_IQ_NEXTGEN_E)
+#else
+# define machine_is_iq_nextgen_e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MALLOW_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MALLOW_AT91
+# endif
+# define machine_is_mallow_at91()	(machine_arch_type == MACH_TYPE_MALLOW_AT91)
+#else
+# define machine_is_mallow_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_I
+# endif
+# define machine_is_cybertracker_i()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_I)
+#else
+# define machine_is_cybertracker_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC931X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC931X
+# endif
+# define machine_is_gesbc931x()	(machine_arch_type == MACH_TYPE_GESBC931X)
+#else
+# define machine_is_gesbc931x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTIPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTIPAD
+# endif
+# define machine_is_centipad()	(machine_arch_type == MACH_TYPE_CENTIPAD)
+#else
+# define machine_is_centipad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMSOC
+# endif
+# define machine_is_armsoc()	(machine_arch_type == MACH_TYPE_ARMSOC)
+#else
+# define machine_is_armsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE4200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE4200
+# endif
+# define machine_is_se4200()	(machine_arch_type == MACH_TYPE_SE4200)
+#else
+# define machine_is_se4200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS197A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS197A
+# endif
+# define machine_is_ems197a()	(machine_arch_type == MACH_TYPE_EMS197A)
+#else
+# define machine_is_ems197a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UC5471DSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UC5471DSP
+# endif
+# define machine_is_uc5471dsp()	(machine_arch_type == MACH_TYPE_UC5471DSP)
+#else
+# define machine_is_uc5471dsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SJ5471ENG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SJ5471ENG
+# endif
+# define machine_is_sj5471eng()	(machine_arch_type == MACH_TYPE_SJ5471ENG)
+#else
+# define machine_is_sj5471eng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPXA26X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPXA26X
+# endif
+# define machine_is_none()	(machine_arch_type == MACH_TYPE_CMPXA26X)
+#else
+# define machine_is_none()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NC
+# endif
+# define machine_is_nc1()	(machine_arch_type == MACH_TYPE_NC)
+#else
+# define machine_is_nc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AJAX52X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AJAX52X
+# endif
+# define machine_is_ajax52x()	(machine_arch_type == MACH_TYPE_AJAX52X)
+#else
+# define machine_is_ajax52x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIRIUSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIRIUSTAR
+# endif
+# define machine_is_siriustar()	(machine_arch_type == MACH_TYPE_SIRIUSTAR)
+#else
+# define machine_is_siriustar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IODATA_HDLG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IODATA_HDLG
+# endif
+# define machine_is_iodata_hdlg()	(machine_arch_type == MACH_TYPE_IODATA_HDLG)
+#else
+# define machine_is_iodata_hdlg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200UTL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200UTL
+# endif
+# define machine_is_at91rm9200utl()	(machine_arch_type == MACH_TYPE_AT91RM9200UTL)
+#else
+# define machine_is_at91rm9200utl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIOSAFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIOSAFE
+# endif
+# define machine_is_biosafe()	(machine_arch_type == MACH_TYPE_BIOSAFE)
+#else
+# define machine_is_biosafe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP1000
+# endif
+# define machine_is_mp1000()	(machine_arch_type == MACH_TYPE_MP1000)
+#else
+# define machine_is_mp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PARSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PARSY
+# endif
+# define machine_is_parsy()	(machine_arch_type == MACH_TYPE_PARSY)
+#else
+# define machine_is_parsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCXP
+# endif
+# define machine_is_ccxp270()	(machine_arch_type == MACH_TYPE_CCXP)
+#else
+# define machine_is_ccxp270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GSAMPLE
+# endif
+# define machine_is_omap_gsample()	(machine_arch_type == MACH_TYPE_OMAP_GSAMPLE)
+#else
+# define machine_is_omap_gsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA
+# endif
+# define machine_is_samoa()	(machine_arch_type == MACH_TYPE_SAMOA)
+#else
+# define machine_is_samoa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT3
+# endif
+# define machine_is_palmt3()	(machine_arch_type == MACH_TYPE_PALMT3)
+#else
+# define machine_is_palmt3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I878
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I878
+# endif
+# define machine_is_i878()	(machine_arch_type == MACH_TYPE_I878)
+#else
+# define machine_is_i878()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GECKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GECKO
+# endif
+# define machine_is_gecko()	(machine_arch_type == MACH_TYPE_GECKO)
+#else
+# define machine_is_gecko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101
+# endif
+# define machine_is_ds101()	(machine_arch_type == MACH_TYPE_DS101)
+#else
+# define machine_is_ds101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT2
+# endif
+# define machine_is_omap_palmtt2()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT2)
+#else
+# define machine_is_omap_palmtt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMLD
+# endif
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
+#else
+# define machine_is_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9C
+# endif
+# define machine_is_cc9c()	(machine_arch_type == MACH_TYPE_CC9C)
+#else
+# define machine_is_cc9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC1670
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC1670
+# endif
+# define machine_is_sbc1670()	(machine_arch_type == MACH_TYPE_SBC1670)
+#else
+# define machine_is_sbc1670()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML696K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML696K
+# endif
+# define machine_is_ml696k()	(machine_arch_type == MACH_TYPE_ML696K)
+#else
+# define machine_is_ml696k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAESTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAESTRO
+# endif
+# define machine_is_maestro()	(machine_arch_type == MACH_TYPE_MAESTRO)
+#else
+# define machine_is_maestro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTE2
+# endif
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
+#else
+# define machine_is_palmte2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXBBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXBBM
+# endif
+# define machine_is_ixbbm()	(machine_arch_type == MACH_TYPE_IXBBM)
+#else
+# define machine_is_ixbbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8004
+# endif
+# define machine_is_ax8004()	(machine_arch_type == MACH_TYPE_AX8004)
+#else
+# define machine_is_ax8004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGPIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGPIE
+# endif
+# define machine_is_magpie()	(machine_arch_type == MACH_TYPE_MAGPIE)
+#else
+# define machine_is_magpie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB87M3400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB87M3400
+# endif
+# define machine_is_mb87m3400()	(machine_arch_type == MACH_TYPE_MB87M3400)
+#else
+# define machine_is_mb87m3400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MGUARD_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MGUARD_DELTA
+# endif
+# define machine_is_mguard_delta()	(machine_arch_type == MACH_TYPE_MGUARD_DELTA)
+#else
+# define machine_is_mguard_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DVDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DVDP
+# endif
+# define machine_is_davinci_dvdp()	(machine_arch_type == MACH_TYPE_DAVINCI_DVDP)
+#else
+# define machine_is_davinci_dvdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCUNIVERSAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCUNIVERSAL
+# endif
+# define machine_is_htcuniversal()	(machine_arch_type == MACH_TYPE_HTCUNIVERSAL)
+#else
+# define machine_is_htcuniversal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPAD
+# endif
+# define machine_is_tpad()	(machine_arch_type == MACH_TYPE_TPAD)
+#else
+# define machine_is_tpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERP3
+# endif
+# define machine_is_roverp3()	(machine_arch_type == MACH_TYPE_ROVERP3)
+#else
+# define machine_is_roverp3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JORNADA928
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA928
+# endif
+# define machine_is_jornada928()	(machine_arch_type == MACH_TYPE_JORNADA928)
+#else
+# define machine_is_jornada928()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88FXX81
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88FXX81
+# endif
+# define machine_is_mv88fxx81()	(machine_arch_type == MACH_TYPE_MV88FXX81)
+#else
+# define machine_is_mv88fxx81()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP36XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP36XX
+# endif
+# define machine_is_stmp36xx()	(machine_arch_type == MACH_TYPE_STMP36XX)
+#else
+# define machine_is_stmp36xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI79524
+# endif
+# define machine_is_sxni79524()	(machine_arch_type == MACH_TYPE_SXNI79524)
+#else
+# define machine_is_sxni79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URANIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URANIUM
+# endif
+# define machine_is_uranium()	(machine_arch_type == MACH_TYPE_URANIUM)
+#else
+# define machine_is_uranium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCON
+# endif
+# define machine_is_ucon()	(machine_arch_type == MACH_TYPE_UCON)
+#else
+# define machine_is_ucon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_L083_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L083_1000
+# endif
+# define machine_is_l083()	(machine_arch_type == MACH_TYPE_L083_1000)
+#else
+# define machine_is_l083()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX
+# endif
+# define machine_is_ezx()	(machine_arch_type == MACH_TYPE_EZX)
+#else
+# define machine_is_ezx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX5220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX5220
+# endif
+# define machine_is_pnx5220()	(machine_arch_type == MACH_TYPE_PNX5220)
+#else
+# define machine_is_pnx5220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUTTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUTTE
+# endif
+# define machine_is_butte()	(machine_arch_type == MACH_TYPE_BUTTE)
+#else
+# define machine_is_butte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRM2
+# endif
+# define machine_is_srm2()	(machine_arch_type == MACH_TYPE_SRM2)
+#else
+# define machine_is_srm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSBR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSBR
+# endif
+# define machine_is_dsbr()	(machine_arch_type == MACH_TYPE_DSBR)
+#else
+# define machine_is_dsbr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRYSTALBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRYSTALBALL
+# endif
+# define machine_is_crystalball()	(machine_arch_type == MACH_TYPE_CRYSTALBALL)
+#else
+# define machine_is_crystalball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINYPXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINYPXA27X
+# endif
+# define machine_is_tinypxa27x()	(machine_arch_type == MACH_TYPE_TINYPXA27X)
+#else
+# define machine_is_tinypxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERBIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERBIE
+# endif
+# define machine_is_herbie()	(machine_arch_type == MACH_TYPE_HERBIE)
+#else
+# define machine_is_herbie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4002
+# endif
+# define machine_is_cm4002()	(machine_arch_type == MACH_TYPE_CM4002)
+#else
+# define machine_is_cm4002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B4
+# endif
+# define machine_is_b4()	(machine_arch_type == MACH_TYPE_B4)
+#else
+# define machine_is_b4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAUI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAUI
+# endif
+# define machine_is_maui()	(machine_arch_type == MACH_TYPE_MAUI)
+#else
+# define machine_is_maui()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBERTRACKER_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBERTRACKER_G
+# endif
+# define machine_is_cybertracker_g()	(machine_arch_type == MACH_TYPE_CYBERTRACKER_G)
+#else
+# define machine_is_cybertracker_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIO8390
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIO8390
+# endif
+# define machine_is_mio8390()	(machine_arch_type == MACH_TYPE_MIO8390)
+#else
+# define machine_is_mio8390()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMI_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMI_BOARD
+# endif
+# define machine_is_omi_board()	(machine_arch_type == MACH_TYPE_OMI_BOARD)
+#else
+# define machine_is_omi_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21CIV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21CIV
+# endif
+# define machine_is_mx21civ()	(machine_arch_type == MACH_TYPE_MX21CIV)
+#else
+# define machine_is_mx21civ()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHI_CDAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHI_CDAC
+# endif
+# define machine_is_mahi_cdac()	(machine_arch_type == MACH_TYPE_MAHI_CDAC)
+#else
+# define machine_is_mahi_cdac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTX
+# endif
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
+#else
+# define machine_is_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMSYS_EP0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMSYS_EP0
+# endif
+# define machine_is_samsys_ep0()	(machine_arch_type == MACH_TYPE_SAMSYS_EP0)
+#else
+# define machine_is_samsys_ep0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V1
+# endif
+# define machine_is_wg302v1()	(machine_arch_type == MACH_TYPE_WG302V1)
+#else
+# define machine_is_wg302v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB42X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB42X
+# endif
+# define machine_is_eb42x()	(machine_arch_type == MACH_TYPE_EB42X)
+#else
+# define machine_is_eb42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ331ES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ331ES
+# endif
+# define machine_is_iq331es()	(machine_arch_type == MACH_TYPE_IQ331ES)
+#else
+# define machine_is_iq331es()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COSYDSP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COSYDSP
+# endif
+# define machine_is_cosydsp()	(machine_arch_type == MACH_TYPE_COSYDSP)
+#else
+# define machine_is_cosydsp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT7D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT7D
+# endif
+# define machine_is_uplat7d_proto()	(machine_arch_type == MACH_TYPE_UPLAT7D)
+#else
+# define machine_is_uplat7d_proto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTDAVINCI
+# endif
+# define machine_is_ptdavinci()	(machine_arch_type == MACH_TYPE_PTDAVINCI)
+#else
+# define machine_is_ptdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBUS
+# endif
+# define machine_is_mbus()	(machine_arch_type == MACH_TYPE_MBUS)
+#else
+# define machine_is_mbus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NADIA2VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NADIA2VB
+# endif
+# define machine_is_nadia2vb()	(machine_arch_type == MACH_TYPE_NADIA2VB)
+#else
+# define machine_is_nadia2vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1000
+# endif
+# define machine_is_r1000()	(machine_arch_type == MACH_TYPE_R1000)
+#else
+# define machine_is_r1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90250
+# endif
+# define machine_is_hw90250()	(machine_arch_type == MACH_TYPE_HW90250)
+#else
+# define machine_is_hw90250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TORNADO
+# endif
+# define machine_is_omap_tornado()	(machine_arch_type == MACH_TYPE_OMAP_TORNADO)
+#else
+# define machine_is_omap_tornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLOCREEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLOCREEK
+# endif
+# define machine_is_olocreek()	(machine_arch_type == MACH_TYPE_OLOCREEK)
+#else
+# define machine_is_olocreek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF9328
+# endif
+# define machine_is_apf9328()	(machine_arch_type == MACH_TYPE_APF9328)
+#else
+# define machine_is_apf9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_WIPOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_WIPOQ
+# endif
+# define machine_is_omap_wipoq()	(machine_arch_type == MACH_TYPE_OMAP_WIPOQ)
+#else
+# define machine_is_omap_wipoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TWIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TWIP
+# endif
+# define machine_is_omap_twip()	(machine_arch_type == MACH_TYPE_OMAP_TWIP)
+#else
+# define machine_is_omap_twip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO650
+# endif
+# define machine_is_treo650()	(machine_arch_type == MACH_TYPE_TREO650)
+#else
+# define machine_is_treo650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACUMEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACUMEN
+# endif
+# define machine_is_acumen()	(machine_arch_type == MACH_TYPE_ACUMEN)
+#else
+# define machine_is_acumen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP100
+# endif
+# define machine_is_xp100()	(machine_arch_type == MACH_TYPE_XP100)
+#else
+# define machine_is_xp100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS2410
+# endif
+# define machine_is_fs2410()	(machine_arch_type == MACH_TYPE_FS2410)
+#else
+# define machine_is_fs2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA270_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA270_CERF
+# endif
+# define machine_is_pxa270_cerf()	(machine_arch_type == MACH_TYPE_PXA270_CERF)
+#else
+# define machine_is_pxa270_cerf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ2FTLPALM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ2FTLPALM
+# endif
+# define machine_is_sq2ftlpalm()	(machine_arch_type == MACH_TYPE_SQ2FTLPALM)
+#else
+# define machine_is_sq2ftlpalm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSEMSERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSEMSERVER
+# endif
+# define machine_is_bsemserver()	(machine_arch_type == MACH_TYPE_BSEMSERVER)
+#else
+# define machine_is_bsemserver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETCLIENT
+# endif
+# define machine_is_netclient()	(machine_arch_type == MACH_TYPE_NETCLIENT)
+#else
+# define machine_is_netclient()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT5
+# endif
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
+#else
+# define machine_is_palmt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTC
+# endif
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
+#else
+# define machine_is_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030EVB
+# endif
+# define machine_is_mxc30030evb()	(machine_arch_type == MACH_TYPE_MXC30030EVB)
+#else
+# define machine_is_mxc30030evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REA_2D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REA_2D
+# endif
+# define machine_is_rea_cpu2()	(machine_arch_type == MACH_TYPE_REA_2D)
+#else
+# define machine_is_rea_cpu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI3E524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI3E524
+# endif
+# define machine_is_eti3e524()	(machine_arch_type == MACH_TYPE_TI3E524)
+#else
+# define machine_is_eti3e524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUCKLAND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUCKLAND
+# endif
+# define machine_is_auckland()	(machine_arch_type == MACH_TYPE_AUCKLAND)
+#else
+# define machine_is_auckland()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK3320M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK3320M
+# endif
+# define machine_is_ak3220m()	(machine_arch_type == MACH_TYPE_AK3320M)
+#else
+# define machine_is_ak3220m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURAMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURAMAX
+# endif
+# define machine_is_duramax()	(machine_arch_type == MACH_TYPE_DURAMAX)
+#else
+# define machine_is_duramax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORN
+# endif
+# define machine_is_pronghorn()	(machine_arch_type == MACH_TYPE_PRONGHORN)
+#else
+# define machine_is_pronghorn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUNDY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUNDY
+# endif
+# define machine_is_fundy()	(machine_arch_type == MACH_TYPE_FUNDY)
+#else
+# define machine_is_fundy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPU777
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPU777
+# endif
+# define machine_is_cpu777()	(machine_arch_type == MACH_TYPE_CPU777)
+#else
+# define machine_is_cpu777()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMICON9201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMICON9201
+# endif
+# define machine_is_simicon9201()	(machine_arch_type == MACH_TYPE_SIMICON9201)
+#else
+# define machine_is_simicon9201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAP2_HPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAP2_HPM
+# endif
+# define machine_is_leap2_hpm()	(machine_arch_type == MACH_TYPE_LEAP2_HPM)
+#else
+# define machine_is_leap2_hpm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM922TXA10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM922TXA10
+# endif
+# define machine_is_cm922txa10()	(machine_arch_type == MACH_TYPE_CM922TXA10)
+#else
+# define machine_is_cm922txa10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA
+# endif
+# define machine_is_sandgate()	(machine_arch_type == MACH_TYPE_PXA)
+#else
+# define machine_is_sandgate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2
+# endif
+# define machine_is_sandgate2()	(machine_arch_type == MACH_TYPE_SANDGATE2)
+#else
+# define machine_is_sandgate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2G
+# endif
+# define machine_is_sandgate2g()	(machine_arch_type == MACH_TYPE_SANDGATE2G)
+#else
+# define machine_is_sandgate2g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE2P
+# endif
+# define machine_is_sandgate2p()	(machine_arch_type == MACH_TYPE_SANDGATE2P)
+#else
+# define machine_is_sandgate2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRED_JACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRED_JACK
+# endif
+# define machine_is_fred_jack()	(machine_arch_type == MACH_TYPE_FRED_JACK)
+#else
+# define machine_is_fred_jack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTG_COLOR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTG_COLOR1
+# endif
+# define machine_is_ttg_color1()	(machine_arch_type == MACH_TYPE_TTG_COLOR1)
+#else
+# define machine_is_ttg_color1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU8
+# endif
+# define machine_is_netdcu8()	(machine_arch_type == MACH_TYPE_NETDCU8)
+#else
+# define machine_is_netdcu8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVX538
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVX538
+# endif
+# define machine_is_ng_fvx538()	(machine_arch_type == MACH_TYPE_NG_FVX538)
+#else
+# define machine_is_ng_fvx538()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NG_FVS338
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NG_FVS338
+# endif
+# define machine_is_ng_fvs338()	(machine_arch_type == MACH_TYPE_NG_FVS338)
+#else
+# define machine_is_ng_fvs338()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4103
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4103
+# endif
+# define machine_is_pnx4103()	(machine_arch_type == MACH_TYPE_PNX4103)
+#else
+# define machine_is_pnx4103()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HESDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HESDB
+# endif
+# define machine_is_hesdb()	(machine_arch_type == MACH_TYPE_HESDB)
+#else
+# define machine_is_hesdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSILO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSILO
+# endif
+# define machine_is_xsilo()	(machine_arch_type == MACH_TYPE_XSILO)
+#else
+# define machine_is_xsilo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMLC
+# endif
+# define machine_is_emlc()	(machine_arch_type == MACH_TYPE_EMLC)
+#else
+# define machine_is_emlc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SISTERON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SISTERON
+# endif
+# define machine_is_sisteron()	(machine_arch_type == MACH_TYPE_SISTERON)
+#else
+# define machine_is_sisteron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSC_VENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSC_VENUS
+# endif
+# define machine_is_tsc_venus()	(machine_arch_type == MACH_TYPE_TSC_VENUS)
+#else
+# define machine_is_tsc_venus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS101J
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS101J
+# endif
+# define machine_is_ds101j()	(machine_arch_type == MACH_TYPE_DS101J)
+#else
+# define machine_is_ds101j()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030ADS
+# endif
+# define machine_is_mxc30030ads()	(machine_arch_type == MACH_TYPE_MXC30030ADS)
+#else
+# define machine_is_mxc30030ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_WIMAXSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_WIMAXSOC
+# endif
+# define machine_is_fujitsu_wimaxsoc()	(machine_arch_type == MACH_TYPE_FUJITSU_WIMAXSOC)
+#else
+# define machine_is_fujitsu_wimaxsoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DUALPCMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DUALPCMODEM
+# endif
+# define machine_is_dualpcmodem()	(machine_arch_type == MACH_TYPE_DUALPCMODEM)
+#else
+# define machine_is_dualpcmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCAPACHE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCAPACHE
+# endif
+# define machine_is_htcapache()	(machine_arch_type == MACH_TYPE_HTCAPACHE)
+#else
+# define machine_is_htcapache()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP435
+# endif
+# define machine_is_ixdp435()	(machine_arch_type == MACH_TYPE_IXDP435)
+#else
+# define machine_is_ixdp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CATPROVT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATPROVT100
+# endif
+# define machine_is_catprovt100()	(machine_arch_type == MACH_TYPE_CATPROVT100)
+#else
+# define machine_is_catprovt100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX1XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX1XX
+# endif
+# define machine_is_picotux1xx()	(machine_arch_type == MACH_TYPE_PICOTUX1XX)
+#else
+# define machine_is_picotux1xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPC2
+# endif
+# define machine_is_empc2()	(machine_arch_type == MACH_TYPE_EMPC2)
+#else
+# define machine_is_empc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTURA
+# endif
+# define machine_is_ventura()	(machine_arch_type == MACH_TYPE_VENTURA)
+#else
+# define machine_is_ventura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC
+# endif
+# define machine_is_phidget_sbc()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC)
+#else
+# define machine_is_phidget_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K
+# endif
+# define machine_is_ij3k()	(machine_arch_type == MACH_TYPE_IJ3K)
+#else
+# define machine_is_ij3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PISGAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PISGAH
+# endif
+# define machine_is_pisgah()	(machine_arch_type == MACH_TYPE_PISGAH)
+#else
+# define machine_is_pisgah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG720
+# endif
+# define machine_is_sg720()	(machine_arch_type == MACH_TYPE_SG720)
+#else
+# define machine_is_sg720()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDFOX
+# endif
+# define machine_is_redfox()	(machine_arch_type == MACH_TYPE_REDFOX)
+#else
+# define machine_is_redfox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MYSH_EP9315_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MYSH_EP9315_1
+# endif
+# define machine_is_mysh_ep9315_1()	(machine_arch_type == MACH_TYPE_MYSH_EP9315_1)
+#else
+# define machine_is_mysh_ep9315_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPF106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPF106
+# endif
+# define machine_is_tpf106()	(machine_arch_type == MACH_TYPE_TPF106)
+#else
+# define machine_is_tpf106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200KG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200KG
+# endif
+# define machine_is_at91rm9200kg()	(machine_arch_type == MACH_TYPE_AT91RM9200KG)
+#else
+# define machine_is_at91rm9200kg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLEDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLEDB
+# endif
+# define machine_is_rcmt2()	(machine_arch_type == MACH_TYPE_SLEDB)
+#else
+# define machine_is_rcmt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONTRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONTRACK
+# endif
+# define machine_is_ontrack()	(machine_arch_type == MACH_TYPE_ONTRACK)
+#else
+# define machine_is_ontrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM1200
+# endif
+# define machine_is_pm1200()	(machine_arch_type == MACH_TYPE_PM1200)
+#else
+# define machine_is_pm1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESS24XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESS24XXX
+# endif
+# define machine_is_ess24562()	(machine_arch_type == MACH_TYPE_ESS24XXX)
+#else
+# define machine_is_ess24562()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COREMP7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COREMP7
+# endif
+# define machine_is_coremp7()	(machine_arch_type == MACH_TYPE_COREMP7)
+#else
+# define machine_is_coremp7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_6446
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_6446
+# endif
+# define machine_is_nexcoder_6446()	(machine_arch_type == MACH_TYPE_NEXCODER_6446)
+#else
+# define machine_is_nexcoder_6446()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STVC8380
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STVC8380
+# endif
+# define machine_is_stvc8380()	(machine_arch_type == MACH_TYPE_STVC8380)
+#else
+# define machine_is_stvc8380()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEKLYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEKLYNX
+# endif
+# define machine_is_teklynx()	(machine_arch_type == MACH_TYPE_TEKLYNX)
+#else
+# define machine_is_teklynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARBONADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARBONADO
+# endif
+# define machine_is_carbonado()	(machine_arch_type == MACH_TYPE_CARBONADO)
+#else
+# define machine_is_carbonado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYSMOS_MP730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYSMOS_MP730
+# endif
+# define machine_is_sysmos_mp730()	(machine_arch_type == MACH_TYPE_SYSMOS_MP730)
+#else
+# define machine_is_sysmos_mp730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGIGIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGIGIM
+# endif
+# define machine_is_pgigim()	(machine_arch_type == MACH_TYPE_PGIGIM)
+#else
+# define machine_is_pgigim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX9160P2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX9160P2
+# endif
+# define machine_is_ptx9160p2()	(machine_arch_type == MACH_TYPE_PTX9160P2)
+#else
+# define machine_is_ptx9160p2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DCORE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DCORE1
+# endif
+# define machine_is_dcore1()	(machine_arch_type == MACH_TYPE_DCORE1)
+#else
+# define machine_is_dcore1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VICTORPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VICTORPXA
+# endif
+# define machine_is_victorpxa()	(machine_arch_type == MACH_TYPE_VICTORPXA)
+#else
+# define machine_is_victorpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX2DTB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX2DTB
+# endif
+# define machine_is_mx2dtb()	(machine_arch_type == MACH_TYPE_MX2DTB)
+#else
+# define machine_is_mx2dtb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXA_IREX_ER0100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IREX_ER0100
+# endif
+# define machine_is_pxa_irex_er0100()	(machine_arch_type == MACH_TYPE_PXA_IREX_ER0100)
+#else
+# define machine_is_pxa_irex_er0100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_DEG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_DEG
+# endif
+# define machine_is_bartec_deg()	(machine_arch_type == MACH_TYPE_BARTEC_DEG)
+#else
+# define machine_is_bartec_deg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW50251
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW50251
+# endif
+# define machine_is_hw50251()	(machine_arch_type == MACH_TYPE_HW50251)
+#else
+# define machine_is_hw50251()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IBOX
+# endif
+# define machine_is_ibox()	(machine_arch_type == MACH_TYPE_IBOX)
+#else
+# define machine_is_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLASLH7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLASLH7A404
+# endif
+# define machine_is_atlaslh7a404()	(machine_arch_type == MACH_TYPE_ATLASLH7A404)
+#else
+# define machine_is_atlaslh7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PT2026
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT2026
+# endif
+# define machine_is_pt2026()	(machine_arch_type == MACH_TYPE_PT2026)
+#else
+# define machine_is_pt2026()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCALPINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCALPINE
+# endif
+# define machine_is_htcalpine()	(machine_arch_type == MACH_TYPE_HTCALPINE)
+#else
+# define machine_is_htcalpine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BARTEC_VTU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BARTEC_VTU
+# endif
+# define machine_is_bartec_vtu()	(machine_arch_type == MACH_TYPE_BARTEC_VTU)
+#else
+# define machine_is_bartec_vtu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCOREII
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCOREII
+# endif
+# define machine_is_vcoreii()	(machine_arch_type == MACH_TYPE_VCOREII)
+#else
+# define machine_is_vcoreii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PDNB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PDNB3
+# endif
+# define machine_is_pdnb3()	(machine_arch_type == MACH_TYPE_PDNB3)
+#else
+# define machine_is_pdnb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBEETLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBEETLES
+# endif
+# define machine_is_htcbeetles()	(machine_arch_type == MACH_TYPE_HTCBEETLES)
+#else
+# define machine_is_htcbeetles()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6400
+# endif
+# define machine_is_s3c6400()	(machine_arch_type == MACH_TYPE_S3C6400)
+#else
+# define machine_is_s3c6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2443
+# endif
+# define machine_is_s3c2443()	(machine_arch_type == MACH_TYPE_S3C2443)
+#else
+# define machine_is_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDK
+# endif
+# define machine_is_omap_ldk()	(machine_arch_type == MACH_TYPE_OMAP_LDK)
+#else
+# define machine_is_omap_ldk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2460
+# endif
+# define machine_is_smdk2460()	(machine_arch_type == MACH_TYPE_SMDK2460)
+#else
+# define machine_is_smdk2460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2440
+# endif
+# define machine_is_smdk2440()	(machine_arch_type == MACH_TYPE_SMDK2440)
+#else
+# define machine_is_smdk2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WEBBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WEBBOX
+# endif
+# define machine_is_webbox()	(machine_arch_type == MACH_TYPE_WEBBOX)
+#else
+# define machine_is_webbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWWNDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWWNDP
+# endif
+# define machine_is_cwwndp()	(machine_arch_type == MACH_TYPE_CWWNDP)
+#else
+# define machine_is_cwwndp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGON
+# endif
+# define machine_is_i839()	(machine_arch_type == MACH_TYPE_DRAGON)
+#else
+# define machine_is_i839()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENDO_CPU_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENDO_CPU_BOARD
+# endif
+# define machine_is_opendo_cpu_board()	(machine_arch_type == MACH_TYPE_OPENDO_CPU_BOARD)
+#else
+# define machine_is_opendo_cpu_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCM2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCM2200
+# endif
+# define machine_is_ccm2200()	(machine_arch_type == MACH_TYPE_CCM2200)
+#else
+# define machine_is_ccm2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETWARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETWARM
+# endif
+# define machine_is_etwarm()	(machine_arch_type == MACH_TYPE_ETWARM)
+#else
+# define machine_is_etwarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M93030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M93030
+# endif
+# define machine_is_m93030()	(machine_arch_type == MACH_TYPE_M93030)
+#else
+# define machine_is_m93030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC7U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC7U
+# endif
+# define machine_is_cc7u()	(machine_arch_type == MACH_TYPE_CC7U)
+#else
+# define machine_is_cc7u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTT_RANGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTT_RANGER
+# endif
+# define machine_is_mtt_ranger()	(machine_arch_type == MACH_TYPE_MTT_RANGER)
+#else
+# define machine_is_mtt_ranger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXUS
+# endif
+# define machine_is_nexus()	(machine_arch_type == MACH_TYPE_NEXUS)
+#else
+# define machine_is_nexus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESMAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESMAN
+# endif
+# define machine_is_desman()	(machine_arch_type == MACH_TYPE_DESMAN)
+#else
+# define machine_is_desman()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BKDE303
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BKDE303
+# endif
+# define machine_is_bkde303()	(machine_arch_type == MACH_TYPE_BKDE303)
+#else
+# define machine_is_bkde303()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M7200
+# endif
+# define machine_is_aml_m7200()	(machine_arch_type == MACH_TYPE_AML_M7200)
+#else
+# define machine_is_aml_m7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG640
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG640
+# endif
+# define machine_is_sg640()	(machine_arch_type == MACH_TYPE_SG640)
+#else
+# define machine_is_sg640()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDG79524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDG79524
+# endif
+# define machine_is_edg79524()	(machine_arch_type == MACH_TYPE_EDG79524)
+#else
+# define machine_is_edg79524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AI2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AI2410
+# endif
+# define machine_is_ai2410()	(machine_arch_type == MACH_TYPE_AI2410)
+#else
+# define machine_is_ai2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXP465
+# endif
+# define machine_is_ixp465()	(machine_arch_type == MACH_TYPE_IXP465)
+#else
+# define machine_is_ixp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEINS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEINS
+# endif
+# define machine_is_heins()	(machine_arch_type == MACH_TYPE_HEINS)
+#else
+# define machine_is_heins()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPLUSEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPLUSEVA
+# endif
+# define machine_is_mpluseva()	(machine_arch_type == MACH_TYPE_MPLUSEVA)
+#else
+# define machine_is_mpluseva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RT042
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RT042
+# endif
+# define machine_is_rt042()	(machine_arch_type == MACH_TYPE_RT042)
+#else
+# define machine_is_rt042()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWIEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWIEM
+# endif
+# define machine_is_cwiem()	(machine_arch_type == MACH_TYPE_CWIEM)
+#else
+# define machine_is_cwiem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X270
+# endif
+# define machine_is_cm_x270()	(machine_arch_type == MACH_TYPE_CM_X270)
+#else
+# define machine_is_cm_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X255
+# endif
+# define machine_is_cm_x255()	(machine_arch_type == MACH_TYPE_CM_X255)
+#else
+# define machine_is_cm_x255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESH_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESH_AT91
+# endif
+# define machine_is_esh_at91()	(machine_arch_type == MACH_TYPE_ESH_AT91)
+#else
+# define machine_is_esh_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATE3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATE3
+# endif
+# define machine_is_sandgate3()	(machine_arch_type == MACH_TYPE_SANDGATE3)
+#else
+# define machine_is_sandgate3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMO
+# endif
+# define machine_is_primo()	(machine_arch_type == MACH_TYPE_PRIMO)
+#else
+# define machine_is_primo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMSTONE
+# endif
+# define machine_is_gemstone()	(machine_arch_type == MACH_TYPE_GEMSTONE)
+#else
+# define machine_is_gemstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRONGHORNMETRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRONGHORNMETRO
+# endif
+# define machine_is_pronghorn_metro()	(machine_arch_type == MACH_TYPE_PRONGHORNMETRO)
+#else
+# define machine_is_pronghorn_metro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIDEWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEWINDER
+# endif
+# define machine_is_sidewinder()	(machine_arch_type == MACH_TYPE_SIDEWINDER)
+#else
+# define machine_is_sidewinder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOMOD1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOMOD1
+# endif
+# define machine_is_picomod1()	(machine_arch_type == MACH_TYPE_PICOMOD1)
+#else
+# define machine_is_picomod1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG590
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG590
+# endif
+# define machine_is_sg590()	(machine_arch_type == MACH_TYPE_SG590)
+#else
+# define machine_is_sg590()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKAI9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKAI9307
+# endif
+# define machine_is_akai9307()	(machine_arch_type == MACH_TYPE_AKAI9307)
+#else
+# define machine_is_akai9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FONTAINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FONTAINE
+# endif
+# define machine_is_fontaine()	(machine_arch_type == MACH_TYPE_FONTAINE)
+#else
+# define machine_is_fontaine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WOMBAT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WOMBAT
+# endif
+# define machine_is_wombat()	(machine_arch_type == MACH_TYPE_WOMBAT)
+#else
+# define machine_is_wombat()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ300
+# endif
+# define machine_is_acq300()	(machine_arch_type == MACH_TYPE_ACQ300)
+#else
+# define machine_is_acq300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOD_270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOD_270
+# endif
+# define machine_is_mod272()	(machine_arch_type == MACH_TYPE_MOD_270)
+#else
+# define machine_is_mod272()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0820
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0820
+# endif
+# define machine_is_vmc_vc0820()	(machine_arch_type == MACH_TYPE_VC0820)
+#else
+# define machine_is_vmc_vc0820()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_AIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_AIM
+# endif
+# define machine_is_ani_aim()	(machine_arch_type == MACH_TYPE_ANI_AIM)
+#else
+# define machine_is_ani_aim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JELLYFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JELLYFISH
+# endif
+# define machine_is_jellyfish()	(machine_arch_type == MACH_TYPE_JELLYFISH)
+#else
+# define machine_is_jellyfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMANITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMANITA
+# endif
+# define machine_is_amanita()	(machine_arch_type == MACH_TYPE_AMANITA)
+#else
+# define machine_is_amanita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VLINK
+# endif
+# define machine_is_vlink()	(machine_arch_type == MACH_TYPE_VLINK)
+#else
+# define machine_is_vlink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEXFLEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEXFLEX
+# endif
+# define machine_is_dexflex()	(machine_arch_type == MACH_TYPE_DEXFLEX)
+#else
+# define machine_is_dexflex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIGEN_TTQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIGEN_TTQ
+# endif
+# define machine_is_eigen_ttq()	(machine_arch_type == MACH_TYPE_EIGEN_TTQ)
+#else
+# define machine_is_eigen_ttq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_TITAN
+# endif
+# define machine_is_arcom_titan()	(machine_arch_type == MACH_TYPE_ARCOM_TITAN)
+#else
+# define machine_is_arcom_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TABLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TABLA
+# endif
+# define machine_is_tabla()	(machine_arch_type == MACH_TYPE_TABLA)
+#else
+# define machine_is_tabla()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MDIRAC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MDIRAC3
+# endif
+# define machine_is_mdirac3()	(machine_arch_type == MACH_TYPE_MDIRAC3)
+#else
+# define machine_is_mdirac3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRHFBP2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRHFBP2
+# endif
+# define machine_is_mrhfbp2()	(machine_arch_type == MACH_TYPE_MRHFBP2)
+#else
+# define machine_is_mrhfbp2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200RB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200RB
+# endif
+# define machine_is_at91rm9200rb()	(machine_arch_type == MACH_TYPE_AT91RM9200RB)
+#else
+# define machine_is_at91rm9200rb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANI_APM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANI_APM
+# endif
+# define machine_is_ani_apm()	(machine_arch_type == MACH_TYPE_ANI_APM)
+#else
+# define machine_is_ani_apm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELLA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELLA1
+# endif
+# define machine_is_ella1()	(machine_arch_type == MACH_TYPE_ELLA1)
+#else
+# define machine_is_ella1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA27X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA27X
+# endif
+# define machine_is_inhand_pxa27x()	(machine_arch_type == MACH_TYPE_INHAND_PXA27X)
+#else
+# define machine_is_inhand_pxa27x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_PXA25X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_PXA25X
+# endif
+# define machine_is_inhand_pxa25x()	(machine_arch_type == MACH_TYPE_INHAND_PXA25X)
+#else
+# define machine_is_inhand_pxa25x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_XM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_XM
+# endif
+# define machine_is_empos_xm()	(machine_arch_type == MACH_TYPE_EMPOS_XM)
+#else
+# define machine_is_empos_xm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS
+# endif
+# define machine_is_empos()	(machine_arch_type == MACH_TYPE_EMPOS)
+#else
+# define machine_is_empos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_TINY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_TINY
+# endif
+# define machine_is_empos_tiny()	(machine_arch_type == MACH_TYPE_EMPOS_TINY)
+#else
+# define machine_is_empos_tiny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPOS_SM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPOS_SM
+# endif
+# define machine_is_empos_sm()	(machine_arch_type == MACH_TYPE_EMPOS_SM)
+#else
+# define machine_is_empos_sm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EGRET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EGRET
+# endif
+# define machine_is_egret()	(machine_arch_type == MACH_TYPE_EGRET)
+#else
+# define machine_is_egret()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSTRICH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSTRICH
+# endif
+# define machine_is_ostrich()	(machine_arch_type == MACH_TYPE_OSTRICH)
+#else
+# define machine_is_ostrich()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N50
+# endif
+# define machine_is_n50()	(machine_arch_type == MACH_TYPE_N50)
+#else
+# define machine_is_n50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAREAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAREAST
+# endif
+# define machine_is_stareast()	(machine_arch_type == MACH_TYPE_STAREAST)
+#else
+# define machine_is_stareast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DW
+# endif
+# define machine_is_dspg_dw()	(machine_arch_type == MACH_TYPE_DSPG_DW)
+#else
+# define machine_is_dspg_dw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRG110_6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRG110_6
+# endif
+# define machine_is_mrg110_6()	(machine_arch_type == MACH_TYPE_MRG110_6)
+#else
+# define machine_is_mrg110_6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT300NV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT300NV2
+# endif
+# define machine_is_wrt300nv2()	(machine_arch_type == MACH_TYPE_WRT300NV2)
+#else
+# define machine_is_wrt300nv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XM_BULVERDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XM_BULVERDE
+# endif
+# define machine_is_xm_bulverde()	(machine_arch_type == MACH_TYPE_XM_BULVERDE)
+#else
+# define machine_is_xm_bulverde()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM6100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM6100
+# endif
+# define machine_is_msm6100()	(machine_arch_type == MACH_TYPE_MSM6100)
+#else
+# define machine_is_msm6100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_B1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_B1
+# endif
+# define machine_is_eti_b1()	(machine_arch_type == MACH_TYPE_ETI_B1)
+#else
+# define machine_is_eti_b1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZILOG_ZA9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZILOG_ZA9L
+# endif
+# define machine_is_za9l_series()	(machine_arch_type == MACH_TYPE_ZILOG_ZA9L)
+#else
+# define machine_is_za9l_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIT2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIT2440
+# endif
+# define machine_is_bit2440()	(machine_arch_type == MACH_TYPE_BIT2440)
+#else
+# define machine_is_bit2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NBI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NBI
+# endif
+# define machine_is_nbi()	(machine_arch_type == MACH_TYPE_NBI)
+#else
+# define machine_is_nbi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VDAVINCI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VDAVINCI
+# endif
+# define machine_is_vdavinci()	(machine_arch_type == MACH_TYPE_VDAVINCI)
+#else
+# define machine_is_vdavinci()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATC6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATC6
+# endif
+# define machine_is_atc6()	(machine_arch_type == MACH_TYPE_ATC6)
+#else
+# define machine_is_atc6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDW
+# endif
+# define machine_is_multmdw()	(machine_arch_type == MACH_TYPE_MULTMDW)
+#else
+# define machine_is_multmdw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBA2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBA2440
+# endif
+# define machine_is_mba2440()	(machine_arch_type == MACH_TYPE_MBA2440)
+#else
+# define machine_is_mba2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECSD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECSD
+# endif
+# define machine_is_ecsd()	(machine_arch_type == MACH_TYPE_ECSD)
+#else
+# define machine_is_ecsd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ31
+# endif
+# define machine_is_palmz31()	(machine_arch_type == MACH_TYPE_PALMZ31)
+#else
+# define machine_is_palmz31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAZOR101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAZOR101
+# endif
+# define machine_is_razor101()	(machine_arch_type == MACH_TYPE_RAZOR101)
+#else
+# define machine_is_razor101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPERA_TDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPERA_TDM
+# endif
+# define machine_is_opera_tdm()	(machine_arch_type == MACH_TYPE_OPERA_TDM)
+#else
+# define machine_is_opera_tdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMCERTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMCERTO
+# endif
+# define machine_is_comcerto()	(machine_arch_type == MACH_TYPE_COMCERTO)
+#else
+# define machine_is_comcerto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TB0319
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TB0319
+# endif
+# define machine_is_tb0319()	(machine_arch_type == MACH_TYPE_TB0319)
+#else
+# define machine_is_tb0319()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KWS8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KWS8000
+# endif
+# define machine_is_kws8000()	(machine_arch_type == MACH_TYPE_KWS8000)
+#else
+# define machine_is_kws8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B2
+# endif
+# define machine_is_b2()	(machine_arch_type == MACH_TYPE_B2)
+#else
+# define machine_is_b2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LCL54
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LCL54
+# endif
+# define machine_is_lcl54()	(machine_arch_type == MACH_TYPE_LCL54)
+#else
+# define machine_is_lcl54()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100
+# endif
+# define machine_is_n4100()	(machine_arch_type == MACH_TYPE_N4100)
+#else
+# define machine_is_n4100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERTICAL_RSC4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERTICAL_RSC4
+# endif
+# define machine_is_rsc4()	(machine_arch_type == MACH_TYPE_VERTICAL_RSC4)
+#else
+# define machine_is_rsc4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG8100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG8100
+# endif
+# define machine_is_sg8100()	(machine_arch_type == MACH_TYPE_SG8100)
+#else
+# define machine_is_sg8100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM42XX
+# endif
+# define machine_is_im42xx()	(machine_arch_type == MACH_TYPE_IM42XX)
+#else
+# define machine_is_im42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FTXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FTXX
+# endif
+# define machine_is_ftxx()	(machine_arch_type == MACH_TYPE_FTXX)
+#else
+# define machine_is_ftxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LWFUSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LWFUSION
+# endif
+# define machine_is_lwfusion()	(machine_arch_type == MACH_TYPE_LWFUSION)
+#else
+# define machine_is_lwfusion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9C
+# endif
+# define machine_is_ccw9c()	(machine_arch_type == MACH_TYPE_CCW9C)
+#else
+# define machine_is_ccw9c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DABHS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DABHS
+# endif
+# define machine_is_dabhs()	(machine_arch_type == MACH_TYPE_DABHS)
+#else
+# define machine_is_dabhs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GZMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GZMX
+# endif
+# define machine_is_gzmx()	(machine_arch_type == MACH_TYPE_GZMX)
+#else
+# define machine_is_gzmx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPNW100AP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPNW100AP
+# endif
+# define machine_is_ipnw100ap()	(machine_arch_type == MACH_TYPE_IPNW100AP)
+#else
+# define machine_is_ipnw100ap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750DEV
+# endif
+# define machine_is_cc9p9750dev()	(machine_arch_type == MACH_TYPE_CC9P9750DEV)
+#else
+# define machine_is_cc9p9750dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360VAL
+# endif
+# define machine_is_cc9p9360val()	(machine_arch_type == MACH_TYPE_CC9P9360VAL)
+#else
+# define machine_is_cc9p9360val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9750VAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9750VAL
+# endif
+# define machine_is_cc9p9750val()	(machine_arch_type == MACH_TYPE_CC9P9750VAL)
+#else
+# define machine_is_cc9p9750val()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NX70V
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NX70V
+# endif
+# define machine_is_nx70v()	(machine_arch_type == MACH_TYPE_NX70V)
+#else
+# define machine_is_nx70v()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200DF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DF
+# endif
+# define machine_is_at91rm9200df()	(machine_arch_type == MACH_TYPE_AT91RM9200DF)
+#else
+# define machine_is_at91rm9200df()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE_PILOT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE_PILOT2
+# endif
+# define machine_is_se_pilot2()	(machine_arch_type == MACH_TYPE_SE_PILOT2)
+#else
+# define machine_is_se_pilot2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MTCN_T800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MTCN_T800
+# endif
+# define machine_is_mtcn_t800()	(machine_arch_type == MACH_TYPE_MTCN_T800)
+#else
+# define machine_is_mtcn_t800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX212
+# endif
+# define machine_is_vcmx212()	(machine_arch_type == MACH_TYPE_VCMX212)
+#else
+# define machine_is_vcmx212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LYNX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LYNX
+# endif
+# define machine_is_lynx()	(machine_arch_type == MACH_TYPE_LYNX)
+#else
+# define machine_is_lynx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260ID
+# endif
+# define machine_is_at91sam9260id()	(machine_arch_type == MACH_TYPE_AT91SAM9260ID)
+#else
+# define machine_is_at91sam9260id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW86052
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW86052
+# endif
+# define machine_is_hw86052()	(machine_arch_type == MACH_TYPE_HW86052)
+#else
+# define machine_is_hw86052()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI3
+# endif
+# define machine_is_pilz_pmi3()	(machine_arch_type == MACH_TYPE_PILZ_PMI3)
+#else
+# define machine_is_pilz_pmi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT_DFS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT_DFS
+# endif
+# define machine_is_ct_dfs()	(machine_arch_type == MACH_TYPE_CT_DFS)
+#else
+# define machine_is_ct_dfs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI4
+# endif
+# define machine_is_pilz_pmi4()	(machine_arch_type == MACH_TYPE_PILZ_PMI4)
+#else
+# define machine_is_pilz_pmi4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEEDNP_IXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEEDNP_IXP
+# endif
+# define machine_is_xceednp_ixp()	(machine_arch_type == MACH_TYPE_XCEEDNP_IXP)
+#else
+# define machine_is_xceednp_ixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2442B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2442B
+# endif
+# define machine_is_smdk2442b()	(machine_arch_type == MACH_TYPE_SMDK2442B)
+#else
+# define machine_is_smdk2442b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XNODE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XNODE
+# endif
+# define machine_is_xnode()	(machine_arch_type == MACH_TYPE_XNODE)
+#else
+# define machine_is_xnode()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIDX270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIDX270
+# endif
+# define machine_is_aidx270()	(machine_arch_type == MACH_TYPE_AIDX270)
+#else
+# define machine_is_aidx270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REMA
+# endif
+# define machine_is_rema()	(machine_arch_type == MACH_TYPE_REMA)
+#else
+# define machine_is_rema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BPS1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BPS1000
+# endif
+# define machine_is_bps1000()	(machine_arch_type == MACH_TYPE_BPS1000)
+#else
+# define machine_is_bps1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90350
+# endif
+# define machine_is_hw90350()	(machine_arch_type == MACH_TYPE_HW90350)
+#else
+# define machine_is_hw90350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
+# endif
+# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
+#else
+# define machine_is_omap_3430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUETOUCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUETOUCH
+# endif
+# define machine_is_bluetouch()	(machine_arch_type == MACH_TYPE_BLUETOUCH)
+#else
+# define machine_is_bluetouch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSBASE270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSBASE270
+# endif
+# define machine_is_xsbase270()	(machine_arch_type == MACH_TYPE_XSBASE270)
+#else
+# define machine_is_xsbase270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK_CN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK_CN
+# endif
+# define machine_is_at91sam9260ek_cn()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK_CN)
+#else
+# define machine_is_at91sam9260ek_cn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSTURBOXB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSTURBOXB
+# endif
+# define machine_is_adsturboxb()	(machine_arch_type == MACH_TYPE_ADSTURBOXB)
+#else
+# define machine_is_adsturboxb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTI4110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTI4110
+# endif
+# define machine_is_oti4110()	(machine_arch_type == MACH_TYPE_OTI4110)
+#else
+# define machine_is_oti4110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HME_PXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HME_PXA
+# endif
+# define machine_is_hme_pxa()	(machine_arch_type == MACH_TYPE_HME_PXA)
+#else
+# define machine_is_hme_pxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTERDCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTERDCA
+# endif
+# define machine_is_deisterdca()	(machine_arch_type == MACH_TYPE_DEISTERDCA)
+#else
+# define machine_is_deisterdca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_SSEM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_SSEM2
+# endif
+# define machine_is_ces_ssem2()	(machine_arch_type == MACH_TYPE_CES_SSEM2)
+#else
+# define machine_is_ces_ssem2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CES_MTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CES_MTR
+# endif
+# define machine_is_ces_mtr()	(machine_arch_type == MACH_TYPE_CES_MTR)
+#else
+# define machine_is_ces_mtr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TDS_AVNG_SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TDS_AVNG_SBC
+# endif
+# define machine_is_tds_avng_sbc()	(machine_arch_type == MACH_TYPE_TDS_AVNG_SBC)
+#else
+# define machine_is_tds_avng_sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVEREST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVEREST
+# endif
+# define machine_is_everest()	(machine_arch_type == MACH_TYPE_EVEREST)
+#else
+# define machine_is_everest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4010
+# endif
+# define machine_is_pnx4010()	(machine_arch_type == MACH_TYPE_PNX4010)
+#else
+# define machine_is_pnx4010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OXNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OXNAS
+# endif
+# define machine_is_oxnas()	(machine_arch_type == MACH_TYPE_OXNAS)
+#else
+# define machine_is_oxnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIORI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIORI
+# endif
+# define machine_is_fiori()	(machine_arch_type == MACH_TYPE_FIORI)
+#else
+# define machine_is_fiori()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML1200
+# endif
+# define machine_is_ml1200()	(machine_arch_type == MACH_TYPE_ML1200)
+#else
+# define machine_is_ml1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PECOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PECOS
+# endif
+# define machine_is_pecos()	(machine_arch_type == MACH_TYPE_PECOS)
+#else
+# define machine_is_pecos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB2XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB2XXX
+# endif
+# define machine_is_nb2xxx()	(machine_arch_type == MACH_TYPE_NB2XXX)
+#else
+# define machine_is_nb2xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW6900
+# endif
+# define machine_is_hw6900()	(machine_arch_type == MACH_TYPE_HW6900)
+#else
+# define machine_is_hw6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CDCS_QUOLL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDCS_QUOLL
+# endif
+# define machine_is_cdcs_quoll()	(machine_arch_type == MACH_TYPE_CDCS_QUOLL)
+#else
+# define machine_is_cdcs_quoll()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUICKSILVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUICKSILVER
+# endif
+# define machine_is_quicksilver()	(machine_arch_type == MACH_TYPE_QUICKSILVER)
+#else
+# define machine_is_quicksilver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UPLAT926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UPLAT926
+# endif
+# define machine_is_uplat926()	(machine_arch_type == MACH_TYPE_UPLAT926)
+#else
+# define machine_is_uplat926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410_THOMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410_THOMAS
+# endif
+# define machine_is_dep2410_dep2410()	(machine_arch_type == MACH_TYPE_DEP2410_THOMAS)
+#else
+# define machine_is_dep2410_dep2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DTK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DTK2410
+# endif
+# define machine_is_dtk2410()	(machine_arch_type == MACH_TYPE_DTK2410)
+#else
+# define machine_is_dtk2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHILI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHILI
+# endif
+# define machine_is_chili()	(machine_arch_type == MACH_TYPE_CHILI)
+#else
+# define machine_is_chili()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEMETER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEMETER
+# endif
+# define machine_is_demeter()	(machine_arch_type == MACH_TYPE_DEMETER)
+#else
+# define machine_is_demeter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIONYSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIONYSUS
+# endif
+# define machine_is_dionysus()	(machine_arch_type == MACH_TYPE_DIONYSUS)
+#else
+# define machine_is_dionysus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS352X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS352X
+# endif
+# define machine_is_as352x()	(machine_arch_type == MACH_TYPE_AS352X)
+#else
+# define machine_is_as352x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SERVICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SERVICE
+# endif
+# define machine_is_service()	(machine_arch_type == MACH_TYPE_SERVICE)
+#else
+# define machine_is_service()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_E9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_E9301
+# endif
+# define machine_is_cs_e9301()	(machine_arch_type == MACH_TYPE_CS_E9301)
+#else
+# define machine_is_cs_e9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_MOSPCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_MOSPCK
+# endif
+# define machine_is_ia_mospck()	(machine_arch_type == MACH_TYPE_IA_MOSPCK)
+#else
+# define machine_is_ia_mospck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL201B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL201B
+# endif
+# define machine_is_ql201b()	(machine_arch_type == MACH_TYPE_QL201B)
+#else
+# define machine_is_ql201b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBM
+# endif
+# define machine_is_bbm()	(machine_arch_type == MACH_TYPE_BBM)
+#else
+# define machine_is_bbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXXX
+# endif
+# define machine_is_exxx()	(machine_arch_type == MACH_TYPE_EXXX)
+#else
+# define machine_is_exxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WMA11B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WMA11B
+# endif
+# define machine_is_wma11b()	(machine_arch_type == MACH_TYPE_WMA11B)
+#else
+# define machine_is_wma11b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ATLAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ATLAS
+# endif
+# define machine_is_pelco_atlas()	(machine_arch_type == MACH_TYPE_PELCO_ATLAS)
+#else
+# define machine_is_pelco_atlas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G500
+# endif
+# define machine_is_g500()	(machine_arch_type == MACH_TYPE_G500)
+#else
+# define machine_is_g500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX33ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX33ADS
+# endif
+# define machine_is_mx33ads()	(machine_arch_type == MACH_TYPE_MX33ADS)
+#else
+# define machine_is_mx33ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUB
+# endif
+# define machine_is_chub()	(machine_arch_type == MACH_TYPE_CHUB)
+#else
+# define machine_is_chub()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA01
+# endif
+# define machine_is_neo1973_gta01()	(machine_arch_type == MACH_TYPE_NEO1973_GTA01)
+#else
+# define machine_is_neo1973_gta01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N740
+# endif
+# define machine_is_w90n740()	(machine_arch_type == MACH_TYPE_W90N740)
+#else
+# define machine_is_w90n740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEDALLION_SA2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEDALLION_SA2410
+# endif
+# define machine_is_medallion_sa2410()	(machine_arch_type == MACH_TYPE_MEDALLION_SA2410)
+#else
+# define machine_is_medallion_sa2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IA_CPU_9200_2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IA_CPU_9200_2
+# endif
+# define machine_is_ia_cpu_9200_2()	(machine_arch_type == MACH_TYPE_IA_CPU_9200_2)
+#else
+# define machine_is_ia_cpu_9200_2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMRM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMRM9200
+# endif
+# define machine_is_dimmrm9200()	(machine_arch_type == MACH_TYPE_DIMMRM9200)
+#else
+# define machine_is_dimmrm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM9261
+# endif
+# define machine_is_pm9261()	(machine_arch_type == MACH_TYPE_PM9261)
+#else
+# define machine_is_pm9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ML7304
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ML7304
+# endif
+# define machine_is_ml7304()	(machine_arch_type == MACH_TYPE_ML7304)
+#else
+# define machine_is_ml7304()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCP250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCP250
+# endif
+# define machine_is_ucp250()	(machine_arch_type == MACH_TYPE_UCP250)
+#else
+# define machine_is_ucp250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTBOARD
+# endif
+# define machine_is_intboard()	(machine_arch_type == MACH_TYPE_INTBOARD)
+#else
+# define machine_is_intboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GULFSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GULFSTREAM
+# endif
+# define machine_is_gulfstream()	(machine_arch_type == MACH_TYPE_GULFSTREAM)
+#else
+# define machine_is_gulfstream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LABQUEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LABQUEST
+# endif
+# define machine_is_labquest()	(machine_arch_type == MACH_TYPE_LABQUEST)
+#else
+# define machine_is_labquest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCMX313
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCMX313
+# endif
+# define machine_is_vcmx313()	(machine_arch_type == MACH_TYPE_VCMX313)
+#else
+# define machine_is_vcmx313()	(0)
+#endif
+
+#ifdef CONFIG_MACH_URG200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_URG200
+# endif
+# define machine_is_urg200()	(machine_arch_type == MACH_TYPE_URG200)
+#else
+# define machine_is_urg200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUX255LCDNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUX255LCDNET
+# endif
+# define machine_is_cpux255lcdnet()	(machine_arch_type == MACH_TYPE_CPUX255LCDNET)
+#else
+# define machine_is_cpux255lcdnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU9
+# endif
+# define machine_is_netdcu9()	(machine_arch_type == MACH_TYPE_NETDCU9)
+#else
+# define machine_is_netdcu9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETDCU10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETDCU10
+# endif
+# define machine_is_netdcu10()	(machine_arch_type == MACH_TYPE_NETDCU10)
+#else
+# define machine_is_netdcu10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DGA
+# endif
+# define machine_is_dspg_dga()	(machine_arch_type == MACH_TYPE_DSPG_DGA)
+#else
+# define machine_is_dspg_dga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSPG_DVW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSPG_DVW
+# endif
+# define machine_is_dspg_dvw()	(machine_arch_type == MACH_TYPE_DSPG_DVW)
+#else
+# define machine_is_dspg_dvw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLOS
+# endif
+# define machine_is_solos()	(machine_arch_type == MACH_TYPE_SOLOS)
+#else
+# define machine_is_solos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSSTBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSSTBOX
+# endif
+# define machine_is_osstbox()	(machine_arch_type == MACH_TYPE_OSSTBOX)
+#else
+# define machine_is_osstbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBAT9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBAT9261
+# endif
+# define machine_is_kbat9261()	(machine_arch_type == MACH_TYPE_KBAT9261)
+#else
+# define machine_is_kbat9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT1100
+# endif
+# define machine_is_ct1100()	(machine_arch_type == MACH_TYPE_CT1100)
+#else
+# define machine_is_ct1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKCPPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKCPPXA
+# endif
+# define machine_is_akcppxa()	(machine_arch_type == MACH_TYPE_AKCPPXA)
+#else
+# define machine_is_akcppxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCHAYA1020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCHAYA1020
+# endif
+# define machine_is_ochaya1020()	(machine_arch_type == MACH_TYPE_OCHAYA1020)
+#else
+# define machine_is_ochaya1020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HITRACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HITRACK
+# endif
+# define machine_is_hitrack()	(machine_arch_type == MACH_TYPE_HITRACK)
+#else
+# define machine_is_hitrack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYME1
+# endif
+# define machine_is_syme1()	(machine_arch_type == MACH_TYPE_SYME1)
+#else
+# define machine_is_syme1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYHL1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYHL1
+# endif
+# define machine_is_syhl1()	(machine_arch_type == MACH_TYPE_SYHL1)
+#else
+# define machine_is_syhl1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMPCA400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMPCA400
+# endif
+# define machine_is_empca400()	(machine_arch_type == MACH_TYPE_EMPCA400)
+#else
+# define machine_is_empca400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCHERMES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCHERMES
+# endif
+# define machine_is_htchermes()	(machine_arch_type == MACH_TYPE_HTCHERMES)
+#else
+# define machine_is_htchermes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_C1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_C1
+# endif
+# define machine_is_eti_c1()	(machine_arch_type == MACH_TYPE_ETI_C1)
+#else
+# define machine_is_eti_c1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AC100
+# endif
+# define machine_is_ac100()	(machine_arch_type == MACH_TYPE_AC100)
+#else
+# define machine_is_ac100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNEETCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNEETCH
+# endif
+# define machine_is_sneetch()	(machine_arch_type == MACH_TYPE_SNEETCH)
+#else
+# define machine_is_sneetch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STUDENTMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STUDENTMATE
+# endif
+# define machine_is_studentmate()	(machine_arch_type == MACH_TYPE_STUDENTMATE)
+#else
+# define machine_is_studentmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2410
+# endif
+# define machine_is_zir2410()	(machine_arch_type == MACH_TYPE_ZIR2410)
+#else
+# define machine_is_zir2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2413
+# endif
+# define machine_is_zir2413()	(machine_arch_type == MACH_TYPE_ZIR2413)
+#else
+# define machine_is_zir2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLONIP3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLONIP3
+# endif
+# define machine_is_dlonip3()	(machine_arch_type == MACH_TYPE_DLONIP3)
+#else
+# define machine_is_dlonip3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INSTREAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INSTREAM
+# endif
+# define machine_is_instream()	(machine_arch_type == MACH_TYPE_INSTREAM)
+#else
+# define machine_is_instream()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMBARELLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMBARELLA
+# endif
+# define machine_is_ambarella()	(machine_arch_type == MACH_TYPE_AMBARELLA)
+#else
+# define machine_is_ambarella()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEVIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEVIS
+# endif
+# define machine_is_nevis()	(machine_arch_type == MACH_TYPE_NEVIS)
+#else
+# define machine_is_nevis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_TRINITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_TRINITY
+# endif
+# define machine_is_htc_trinity()	(machine_arch_type == MACH_TYPE_HTC_TRINITY)
+#else
+# define machine_is_htc_trinity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL202B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL202B
+# endif
+# define machine_is_ql202b()	(machine_arch_type == MACH_TYPE_QL202B)
+#else
+# define machine_is_ql202b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD129
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD129
+# endif
+# define machine_is_rd129()	(machine_arch_type == MACH_TYPE_RD129)
+#else
+# define machine_is_rd129()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCWIZARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCWIZARD
+# endif
+# define machine_is_htcwizard()	(machine_arch_type == MACH_TYPE_HTCWIZARD)
+#else
+# define machine_is_htcwizard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO680
+# endif
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
+#else
+# define machine_is_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TECON_TMEZON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TECON_TMEZON
+# endif
+# define machine_is_tecon_tmezon()	(machine_arch_type == MACH_TYPE_TECON_TMEZON)
+#else
+# define machine_is_tecon_tmezon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENE1270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENE1270
+# endif
+# define machine_is_gene1270()	(machine_arch_type == MACH_TYPE_GENE1270)
+#else
+# define machine_is_gene1270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR2412
+# endif
+# define machine_is_zir2412()	(machine_arch_type == MACH_TYPE_ZIR2412)
+#else
+# define machine_is_zir2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T700WX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T700WX
+# endif
+# define machine_is_t700wx()	(machine_arch_type == MACH_TYPE_T700WX)
+#else
+# define machine_is_t700wx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VF100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VF100
+# endif
+# define machine_is_vf100()	(machine_arch_type == MACH_TYPE_VF100)
+#else
+# define machine_is_vf100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB2
+# endif
+# define machine_is_nsb2()	(machine_arch_type == MACH_TYPE_NSB2)
+#else
+# define machine_is_nsb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_BB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_BB
+# endif
+# define machine_is_nxhmi_bb()	(machine_arch_type == MACH_TYPE_NXHMI_BB)
+#else
+# define machine_is_nxhmi_bb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHMI_RE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHMI_RE
+# endif
+# define machine_is_nxhmi_re()	(machine_arch_type == MACH_TYPE_NXHMI_RE)
+#else
+# define machine_is_nxhmi_re()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N4100PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N4100PRO
+# endif
+# define machine_is_n4100pro()	(machine_arch_type == MACH_TYPE_N4100PRO)
+#else
+# define machine_is_n4100pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9260
+# endif
+# define machine_is_sam9260()	(machine_arch_type == MACH_TYPE_SAM9260)
+#else
+# define machine_is_sam9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_TREO600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_TREO600
+# endif
+# define machine_is_omap_treo600()	(machine_arch_type == MACH_TYPE_OMAP_TREO600)
+#else
+# define machine_is_omap_treo600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INDY2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INDY2410
+# endif
+# define machine_is_indy2410()	(machine_arch_type == MACH_TYPE_INDY2410)
+#else
+# define machine_is_indy2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NELT_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NELT_A
+# endif
+# define machine_is_nelt_a()	(machine_arch_type == MACH_TYPE_NELT_A)
+#else
+# define machine_is_nelt_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N311
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N311
+# endif
+# define machine_is_n311()	(machine_arch_type == MACH_TYPE_N311)
+#else
+# define machine_is_n311()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260VGK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260VGK
+# endif
+# define machine_is_at91sam9260vgk()	(machine_arch_type == MACH_TYPE_AT91SAM9260VGK)
+#else
+# define machine_is_at91sam9260vgk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPPE
+# endif
+# define machine_is_at91leppe()	(machine_arch_type == MACH_TYPE_AT91LEPPE)
+#else
+# define machine_is_at91leppe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91LEPCCN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91LEPCCN
+# endif
+# define machine_is_at91lepccn()	(machine_arch_type == MACH_TYPE_AT91LEPCCN)
+#else
+# define machine_is_at91lepccn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APC7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APC7100
+# endif
+# define machine_is_apc7100()	(machine_arch_type == MACH_TYPE_APC7100)
+#else
+# define machine_is_apc7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGAZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGAZER
+# endif
+# define machine_is_stargazer()	(machine_arch_type == MACH_TYPE_STARGAZER)
+#else
+# define machine_is_stargazer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONATA
+# endif
+# define machine_is_sonata()	(machine_arch_type == MACH_TYPE_SONATA)
+#else
+# define machine_is_sonata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCHMOOGIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCHMOOGIE
+# endif
+# define machine_is_schmoogie()	(machine_arch_type == MACH_TYPE_SCHMOOGIE)
+#else
+# define machine_is_schmoogie()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AZTOOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AZTOOL
+# endif
+# define machine_is_aztool()	(machine_arch_type == MACH_TYPE_AZTOOL)
+#else
+# define machine_is_aztool()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SXNI9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SXNI9260
+# endif
+# define machine_is_sxni9260()	(machine_arch_type == MACH_TYPE_SXNI9260)
+#else
+# define machine_is_sxni9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC27520EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC27520EVB
+# endif
+# define machine_is_mxc27520evb()	(machine_arch_type == MACH_TYPE_MXC27520EVB)
+#else
+# define machine_is_mxc27520evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9260
+# endif
+# define machine_is_mb9260()	(machine_arch_type == MACH_TYPE_MB9260)
+#else
+# define machine_is_mb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9263
+# endif
+# define machine_is_mb9263()	(machine_arch_type == MACH_TYPE_MB9263)
+#else
+# define machine_is_mb9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAC9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAC9302
+# endif
+# define machine_is_ipac9302()	(machine_arch_type == MACH_TYPE_IPAC9302)
+#else
+# define machine_is_ipac9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GALLIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GALLIUM
+# endif
+# define machine_is_gallium()	(machine_arch_type == MACH_TYPE_GALLIUM)
+#else
+# define machine_is_gallium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSC2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSC2410
+# endif
+# define machine_is_msc2410()	(machine_arch_type == MACH_TYPE_MSC2410)
+#else
+# define machine_is_msc2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GHI270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GHI270
+# endif
+# define machine_is_ghi270()	(machine_arch_type == MACH_TYPE_GHI270)
+#else
+# define machine_is_ghi270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_LEONARDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_LEONARDO
+# endif
+# define machine_is_davinci_leonardo()	(machine_arch_type == MACH_TYPE_DAVINCI_LEONARDO)
+#else
+# define machine_is_davinci_leonardo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OIAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OIAB
+# endif
+# define machine_is_oiab()	(machine_arch_type == MACH_TYPE_OIAB)
+#else
+# define machine_is_oiab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GREENPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREENPHONE
+# endif
+# define machine_is_greenphone()	(machine_arch_type == MACH_TYPE_GREENPHONE)
+#else
+# define machine_is_greenphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPEXWP18
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPEXWP18
+# endif
+# define machine_is_compex42x()	(machine_arch_type == MACH_TYPE_COMPEXWP18)
+#else
+# define machine_is_compex42x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XMATE
+# endif
+# define machine_is_xmate()	(machine_arch_type == MACH_TYPE_XMATE)
+#else
+# define machine_is_xmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENERGIZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENERGIZER
+# endif
+# define machine_is_energizer()	(machine_arch_type == MACH_TYPE_ENERGIZER)
+#else
+# define machine_is_energizer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IME1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IME1
+# endif
+# define machine_is_ime1()	(machine_arch_type == MACH_TYPE_IME1)
+#else
+# define machine_is_ime1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDATMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDATMS
+# endif
+# define machine_is_sweda_tms()	(machine_arch_type == MACH_TYPE_SWEDATMS)
+#else
+# define machine_is_sweda_tms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTNP435C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTNP435C
+# endif
+# define machine_is_ntnp435c()	(machine_arch_type == MACH_TYPE_NTNP435C)
+#else
+# define machine_is_ntnp435c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPECTRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPECTRO2
+# endif
+# define machine_is_spectro2()	(machine_arch_type == MACH_TYPE_SPECTRO2)
+#else
+# define machine_is_spectro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6039
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6039
+# endif
+# define machine_is_h6039()	(machine_arch_type == MACH_TYPE_H6039)
+#else
+# define machine_is_h6039()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAMOA_II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAMOA_II
+# endif
+# define machine_is_samoa_ii()	(machine_arch_type == MACH_TYPE_SAMOA_II)
+#else
+# define machine_is_samoa_ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMXL
+# endif
+# define machine_is_cwmxl()	(machine_arch_type == MACH_TYPE_CWMXL)
+#else
+# define machine_is_cwmxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS9200
+# endif
+# define machine_is_as9200()	(machine_arch_type == MACH_TYPE_AS9200)
+#else
+# define machine_is_as9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFX1149
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFX1149
+# endif
+# define machine_is_sfx1149()	(machine_arch_type == MACH_TYPE_SFX1149)
+#else
+# define machine_is_sfx1149()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVI010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVI010
+# endif
+# define machine_is_navi010()	(machine_arch_type == MACH_TYPE_NAVI010)
+#else
+# define machine_is_navi010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTMDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTMDP
+# endif
+# define machine_is_multmdp()	(machine_arch_type == MACH_TYPE_MULTMDP)
+#else
+# define machine_is_multmdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9520
+# endif
+# define machine_is_scb9520()	(machine_arch_type == MACH_TYPE_SCB9520)
+#else
+# define machine_is_scb9520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCATHENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCATHENA
+# endif
+# define machine_is_htcathena()	(machine_arch_type == MACH_TYPE_HTCATHENA)
+#else
+# define machine_is_htcathena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XP179
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP179
+# endif
+# define machine_is_xp179()	(machine_arch_type == MACH_TYPE_XP179)
+#else
+# define machine_is_xp179()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4300
+# endif
+# define machine_is_h4300()	(machine_arch_type == MACH_TYPE_H4300)
+#else
+# define machine_is_h4300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30020EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30020EVB
+# endif
+# define machine_is_mxc30020evb()	(machine_arch_type == MACH_TYPE_MXC30020EVB)
+#else
+# define machine_is_mxc30020evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSBITSYG5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSYG5
+# endif
+# define machine_is_adsbitsyg5()	(machine_arch_type == MACH_TYPE_ADSBITSYG5)
+#else
+# define machine_is_adsbitsyg5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSPORTALPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSPORTALPLUS
+# endif
+# define machine_is_adsportalplus()	(machine_arch_type == MACH_TYPE_ADSPORTALPLUS)
+#else
+# define machine_is_adsportalplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMSP2PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMSP2PLUS
+# endif
+# define machine_is_mmsp2plus()	(machine_arch_type == MACH_TYPE_MMSP2PLUS)
+#else
+# define machine_is_mmsp2plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPP302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPP302
+# endif
+# define machine_is_tpp302()	(machine_arch_type == MACH_TYPE_TPP302)
+#else
+# define machine_is_tpp302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM104
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM104
+# endif
+# define machine_is_tpp104()	(machine_arch_type == MACH_TYPE_TPM104)
+#else
+# define machine_is_tpp104()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM102
+# endif
+# define machine_is_tpm102()	(machine_arch_type == MACH_TYPE_TPM102)
+#else
+# define machine_is_tpm102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPM109
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPM109
+# endif
+# define machine_is_tpm109()	(machine_arch_type == MACH_TYPE_TPM109)
+#else
+# define machine_is_tpm109()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FBXO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FBXO1
+# endif
+# define machine_is_fbxo1()	(machine_arch_type == MACH_TYPE_FBXO1)
+#else
+# define machine_is_fbxo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HXD8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HXD8
+# endif
+# define machine_is_hxd8()	(machine_arch_type == MACH_TYPE_HXD8)
+#else
+# define machine_is_hxd8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMTEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMTEST
+# endif
+# define machine_is_emtest()	(machine_arch_type == MACH_TYPE_EMTEST)
+#else
+# define machine_is_emtest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AD6900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AD6900
+# endif
+# define machine_is_ad6900()	(machine_arch_type == MACH_TYPE_AD6900)
+#else
+# define machine_is_ad6900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUROPA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUROPA
+# endif
+# define machine_is_europa()	(machine_arch_type == MACH_TYPE_EUROPA)
+#else
+# define machine_is_europa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_METROCONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_METROCONNECT
+# endif
+# define machine_is_metroconnect()	(machine_arch_type == MACH_TYPE_METROCONNECT)
+#else
+# define machine_is_metroconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2410
+# endif
+# define machine_is_ez_s2410()	(machine_arch_type == MACH_TYPE_EZ_S2410)
+#else
+# define machine_is_ez_s2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_S2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_S2440
+# endif
+# define machine_is_ez_s2440()	(machine_arch_type == MACH_TYPE_EZ_S2440)
+#else
+# define machine_is_ez_s2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9312
+# endif
+# define machine_is_ez_ep9312()	(machine_arch_type == MACH_TYPE_EZ_EP9312)
+#else
+# define machine_is_ez_ep9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_EP9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_EP9315
+# endif
+# define machine_is_ez_ep9315()	(machine_arch_type == MACH_TYPE_EZ_EP9315)
+#else
+# define machine_is_ez_ep9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZ_X7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZ_X7
+# endif
+# define machine_is_ez_x7()	(machine_arch_type == MACH_TYPE_EZ_X7)
+#else
+# define machine_is_ez_x7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GODOTDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GODOTDB
+# endif
+# define machine_is_godotdb()	(machine_arch_type == MACH_TYPE_GODOTDB)
+#else
+# define machine_is_godotdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MISTRAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MISTRAL
+# endif
+# define machine_is_mistral()	(machine_arch_type == MACH_TYPE_MISTRAL)
+#else
+# define machine_is_mistral()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM
+# endif
+# define machine_is_msm()	(machine_arch_type == MACH_TYPE_MSM)
+#else
+# define machine_is_msm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5910
+# endif
+# define machine_is_ct5910()	(machine_arch_type == MACH_TYPE_CT5910)
+#else
+# define machine_is_ct5910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CT5912
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CT5912
+# endif
+# define machine_is_ct5912()	(machine_arch_type == MACH_TYPE_CT5912)
+#else
+# define machine_is_ct5912()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_INE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_INE
+# endif
+# define machine_is_hynet_ine()	(machine_arch_type == MACH_TYPE_HYNET_INE)
+#else
+# define machine_is_hynet_ine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYNET_APP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYNET_APP
+# endif
+# define machine_is_hynet_app()	(machine_arch_type == MACH_TYPE_HYNET_APP)
+#else
+# define machine_is_hynet_app()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7200
+# endif
+# define machine_is_msm7200()	(machine_arch_type == MACH_TYPE_MSM7200)
+#else
+# define machine_is_msm7200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7600
+# endif
+# define machine_is_msm7600()	(machine_arch_type == MACH_TYPE_MSM7600)
+#else
+# define machine_is_msm7600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEB255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEB255
+# endif
+# define machine_is_ceb255()	(machine_arch_type == MACH_TYPE_CEB255)
+#else
+# define machine_is_ceb255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CIEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CIEL
+# endif
+# define machine_is_ciel()	(machine_arch_type == MACH_TYPE_CIEL)
+#else
+# define machine_is_ciel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLM5650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLM5650
+# endif
+# define machine_is_slm5650()	(machine_arch_type == MACH_TYPE_SLM5650)
+#else
+# define machine_is_slm5650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMTECH_ROUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMTECH_ROUTER
+# endif
+# define machine_is_comtech_router()	(machine_arch_type == MACH_TYPE_COMTECH_ROUTER)
+#else
+# define machine_is_comtech_router()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2410X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2410X
+# endif
+# define machine_is_sbc2410x()	(machine_arch_type == MACH_TYPE_SBC2410X)
+#else
+# define machine_is_sbc2410x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT4X0BD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT4X0BD
+# endif
+# define machine_is_at4x0bd()	(machine_arch_type == MACH_TYPE_AT4X0BD)
+#else
+# define machine_is_at4x0bd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CBIFR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CBIFR
+# endif
+# define machine_is_cbifr()	(machine_arch_type == MACH_TYPE_CBIFR)
+#else
+# define machine_is_cbifr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_QUANTUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_QUANTUM
+# endif
+# define machine_is_arcom_quantum()	(machine_arch_type == MACH_TYPE_ARCOM_QUANTUM)
+#else
+# define machine_is_arcom_quantum()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX520
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX520
+# endif
+# define machine_is_matrix520()	(machine_arch_type == MACH_TYPE_MATRIX520)
+#else
+# define machine_is_matrix520()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX510
+# endif
+# define machine_is_matrix510()	(machine_arch_type == MACH_TYPE_MATRIX510)
+#else
+# define machine_is_matrix510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX500
+# endif
+# define machine_is_matrix500()	(machine_arch_type == MACH_TYPE_MATRIX500)
+#else
+# define machine_is_matrix500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M501
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M501
+# endif
+# define machine_is_m501()	(machine_arch_type == MACH_TYPE_M501)
+#else
+# define machine_is_m501()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AAEON1270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAEON1270
+# endif
+# define machine_is_aaeon1270()	(machine_arch_type == MACH_TYPE_AAEON1270)
+#else
+# define machine_is_aaeon1270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX500EV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX500EV
+# endif
+# define machine_is_matrix500ev()	(machine_arch_type == MACH_TYPE_MATRIX500EV)
+#else
+# define machine_is_matrix500ev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PAC500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PAC500
+# endif
+# define machine_is_pac500()	(machine_arch_type == MACH_TYPE_PAC500)
+#else
+# define machine_is_pac500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX8181
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX8181
+# endif
+# define machine_is_pnx8181()	(machine_arch_type == MACH_TYPE_PNX8181)
+#else
+# define machine_is_pnx8181()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI320
+# endif
+# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
+#else
+# define machine_is_colibri320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AZTOOLBB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AZTOOLBB
+# endif
+# define machine_is_aztoolbb()	(machine_arch_type == MACH_TYPE_AZTOOLBB)
+#else
+# define machine_is_aztoolbb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AZTOOLG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AZTOOLG2
+# endif
+# define machine_is_aztoolg2()	(machine_arch_type == MACH_TYPE_AZTOOLG2)
+#else
+# define machine_is_aztoolg2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DVLHOST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DVLHOST
+# endif
+# define machine_is_dvlhost()	(machine_arch_type == MACH_TYPE_DVLHOST)
+#else
+# define machine_is_dvlhost()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR9200
+# endif
+# define machine_is_zir9200()	(machine_arch_type == MACH_TYPE_ZIR9200)
+#else
+# define machine_is_zir9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIR9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIR9260
+# endif
+# define machine_is_zir9260()	(machine_arch_type == MACH_TYPE_ZIR9260)
+#else
+# define machine_is_zir9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COCOPAH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COCOPAH
+# endif
+# define machine_is_cocopah()	(machine_arch_type == MACH_TYPE_COCOPAH)
+#else
+# define machine_is_cocopah()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NDS
+# endif
+# define machine_is_nds()	(machine_arch_type == MACH_TYPE_NDS)
+#else
+# define machine_is_nds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROSENCRANTZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROSENCRANTZ
+# endif
+# define machine_is_rosencrantz()	(machine_arch_type == MACH_TYPE_ROSENCRANTZ)
+#else
+# define machine_is_rosencrantz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FTTX_ODSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FTTX_ODSC
+# endif
+# define machine_is_fttx_odsc()	(machine_arch_type == MACH_TYPE_FTTX_ODSC)
+#else
+# define machine_is_fttx_odsc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLASSE_R6904
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLASSE_R6904
+# endif
+# define machine_is_classe_r6904()	(machine_arch_type == MACH_TYPE_CLASSE_R6904)
+#else
+# define machine_is_classe_r6904()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAM60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAM60
+# endif
+# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
+#else
+# define machine_is_cam60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30031ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30031ADS
+# endif
+# define machine_is_mxc30031ads()	(machine_arch_type == MACH_TYPE_MXC30031ADS)
+#else
+# define machine_is_mxc30031ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATACALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATACALL
+# endif
+# define machine_is_datacall()	(machine_arch_type == MACH_TYPE_DATACALL)
+#else
+# define machine_is_datacall()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91EB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91EB01
+# endif
+# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
+#else
+# define machine_is_at91eb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTY
+# endif
+# define machine_is_rty()	(machine_arch_type == MACH_TYPE_RTY)
+#else
+# define machine_is_rty()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DWL2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DWL2100
+# endif
+# define machine_is_dwl2100()	(machine_arch_type == MACH_TYPE_DWL2100)
+#else
+# define machine_is_dwl2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VINSI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VINSI
+# endif
+# define machine_is_vinsi()	(machine_arch_type == MACH_TYPE_VINSI)
+#else
+# define machine_is_vinsi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F5281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F5281
+# endif
+# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
+#else
+# define machine_is_db88f5281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB726
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB726
+# endif
+# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
+#else
+# define machine_is_csb726()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIK27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIK27
+# endif
+# define machine_is_tik27()	(machine_arch_type == MACH_TYPE_TIK27)
+#else
+# define machine_is_tik27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX_UC7420
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX_UC7420
+# endif
+# define machine_is_mx_uc7420()	(machine_arch_type == MACH_TYPE_MX_UC7420)
+#else
+# define machine_is_mx_uc7420()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIRM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIRM3
+# endif
+# define machine_is_rirm3()	(machine_arch_type == MACH_TYPE_RIRM3)
+#else
+# define machine_is_rirm3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ODYSSEY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ODYSSEY
+# endif
+# define machine_is_pelco_odyssey()	(machine_arch_type == MACH_TYPE_PELCO_ODYSSEY)
+#else
+# define machine_is_pelco_odyssey()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_ABOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_ABOX
+# endif
+# define machine_is_adx_abox()	(machine_arch_type == MACH_TYPE_ADX_ABOX)
+#else
+# define machine_is_adx_abox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_TPID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_TPID
+# endif
+# define machine_is_adx_tpid()	(machine_arch_type == MACH_TYPE_ADX_TPID)
+#else
+# define machine_is_adx_tpid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINICHECK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINICHECK
+# endif
+# define machine_is_minicheck()	(machine_arch_type == MACH_TYPE_MINICHECK)
+#else
+# define machine_is_minicheck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IDAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDAM
+# endif
+# define machine_is_idam()	(machine_arch_type == MACH_TYPE_IDAM)
+#else
+# define machine_is_idam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARIO_MX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARIO_MX
+# endif
+# define machine_is_mario_mx()	(machine_arch_type == MACH_TYPE_MARIO_MX)
+#else
+# define machine_is_mario_mx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VI1888
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VI1888
+# endif
+# define machine_is_vi1888()	(machine_arch_type == MACH_TYPE_VI1888)
+#else
+# define machine_is_vi1888()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZR4230
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZR4230
+# endif
+# define machine_is_zr4230()	(machine_arch_type == MACH_TYPE_ZR4230)
+#else
+# define machine_is_zr4230()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T1_IX_BLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T1_IX_BLUE
+# endif
+# define machine_is_t1_ix_blue()	(machine_arch_type == MACH_TYPE_T1_IX_BLUE)
+#else
+# define machine_is_t1_ix_blue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYHQ2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYHQ2
+# endif
+# define machine_is_syhq2()	(machine_arch_type == MACH_TYPE_SYHQ2)
+#else
+# define machine_is_syhq2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMPUTIME_R3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMPUTIME_R3
+# endif
+# define machine_is_computime_r3()	(machine_arch_type == MACH_TYPE_COMPUTIME_R3)
+#else
+# define machine_is_computime_r3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATIS
+# endif
+# define machine_is_oratis()	(machine_arch_type == MACH_TYPE_ORATIS)
+#else
+# define machine_is_oratis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIKKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIKKO
+# endif
+# define machine_is_mikko()	(machine_arch_type == MACH_TYPE_MIKKO)
+#else
+# define machine_is_mikko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOLON
+# endif
+# define machine_is_holon()	(machine_arch_type == MACH_TYPE_HOLON)
+#else
+# define machine_is_holon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OLIP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OLIP8
+# endif
+# define machine_is_olip8()	(machine_arch_type == MACH_TYPE_OLIP8)
+#else
+# define machine_is_olip8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GHI270HG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GHI270HG
+# endif
+# define machine_is_ghi270hg()	(machine_arch_type == MACH_TYPE_GHI270HG)
+#else
+# define machine_is_ghi270hg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
+# endif
+# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
+#else
+# define machine_is_davinci_dm6467_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
+# endif
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
+#else
+# define machine_is_davinci_dm355_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKRIVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKRIVER
+# endif
+# define machine_is_blackriver()	(machine_arch_type == MACH_TYPE_BLACKRIVER)
+#else
+# define machine_is_blackriver()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDGATEWP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDGATEWP
+# endif
+# define machine_is_sandgate_wp()	(machine_arch_type == MACH_TYPE_SANDGATEWP)
+#else
+# define machine_is_sandgate_wp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CDOTBWSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDOTBWSG
+# endif
+# define machine_is_cdotbwsg()	(machine_arch_type == MACH_TYPE_CDOTBWSG)
+#else
+# define machine_is_cdotbwsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUARK963
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUARK963
+# endif
+# define machine_is_quark963()	(machine_arch_type == MACH_TYPE_QUARK963)
+#else
+# define machine_is_quark963()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB735
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB735
+# endif
+# define machine_is_csb735()	(machine_arch_type == MACH_TYPE_CSB735)
+#else
+# define machine_is_csb735()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITTLETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITTLETON
+# endif
+# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
+#else
+# define machine_is_littleton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIO_P550
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIO_P550
+# endif
+# define machine_is_mio_p550()	(machine_arch_type == MACH_TYPE_MIO_P550)
+#else
+# define machine_is_mio_p550()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTION2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTION2440
+# endif
+# define machine_is_motion2440()	(machine_arch_type == MACH_TYPE_MOTION2440)
+#else
+# define machine_is_motion2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMM500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMM500
+# endif
+# define machine_is_imm500()	(machine_arch_type == MACH_TYPE_IMM500)
+#else
+# define machine_is_imm500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOMEMATIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOMEMATIC
+# endif
+# define machine_is_homematic()	(machine_arch_type == MACH_TYPE_HOMEMATIC)
+#else
+# define machine_is_homematic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ERMINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ERMINE
+# endif
+# define machine_is_ermine()	(machine_arch_type == MACH_TYPE_ERMINE)
+#else
+# define machine_is_ermine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9202B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9202B
+# endif
+# define machine_is_kb9202b()	(machine_arch_type == MACH_TYPE_KB9202B)
+#else
+# define machine_is_kb9202b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HS1XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HS1XX
+# endif
+# define machine_is_hs1xx()	(machine_arch_type == MACH_TYPE_HS1XX)
+#else
+# define machine_is_hs1xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STUDENTMATE2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STUDENTMATE2440
+# endif
+# define machine_is_studentmate2440()	(machine_arch_type == MACH_TYPE_STUDENTMATE2440)
+#else
+# define machine_is_studentmate2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARVOO_L1_Z1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARVOO_L1_Z1
+# endif
+# define machine_is_arvoo_l1_z1()	(machine_arch_type == MACH_TYPE_ARVOO_L1_Z1)
+#else
+# define machine_is_arvoo_l1_z1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2410K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2410K
+# endif
+# define machine_is_dep2410k()	(machine_arch_type == MACH_TYPE_DEP2410K)
+#else
+# define machine_is_dep2410k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XXSVIDEO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XXSVIDEO
+# endif
+# define machine_is_xxsvideo()	(machine_arch_type == MACH_TYPE_XXSVIDEO)
+#else
+# define machine_is_xxsvideo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IM4004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IM4004
+# endif
+# define machine_is_im4004()	(machine_arch_type == MACH_TYPE_IM4004)
+#else
+# define machine_is_im4004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCHAYA1050
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCHAYA1050
+# endif
+# define machine_is_ochaya1050()	(machine_arch_type == MACH_TYPE_OCHAYA1050)
+#else
+# define machine_is_ochaya1050()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEP9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEP9261
+# endif
+# define machine_is_lep9261()	(machine_arch_type == MACH_TYPE_LEP9261)
+#else
+# define machine_is_lep9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVENMEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVENMEB
+# endif
+# define machine_is_svenmeb()	(machine_arch_type == MACH_TYPE_SVENMEB)
+#else
+# define machine_is_svenmeb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FORTUNET2NE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET2NE
+# endif
+# define machine_is_fortunet2ne()	(machine_arch_type == MACH_TYPE_FORTUNET2NE)
+#else
+# define machine_is_fortunet2ne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXHX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXHX
+# endif
+# define machine_is_nxhx()	(machine_arch_type == MACH_TYPE_NXHX)
+#else
+# define machine_is_nxhx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB11MP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
+# endif
+# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
+#else
+# define machine_is_realview_pb11mp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IDS500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDS500
+# endif
+# define machine_is_ids500()	(machine_arch_type == MACH_TYPE_IDS500)
+#else
+# define machine_is_ids500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORS_N725
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORS_N725
+# endif
+# define machine_is_ors_n725()	(machine_arch_type == MACH_TYPE_ORS_N725)
+#else
+# define machine_is_ors_n725()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSDARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSDARM
+# endif
+# define machine_is_hsdarm()	(machine_arch_type == MACH_TYPE_HSDARM)
+#else
+# define machine_is_hsdarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON003
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON003
+# endif
+# define machine_is_sha_pon003()	(machine_arch_type == MACH_TYPE_SHA_PON003)
+#else
+# define machine_is_sha_pon003()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON004
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON004
+# endif
+# define machine_is_sha_pon004()	(machine_arch_type == MACH_TYPE_SHA_PON004)
+#else
+# define machine_is_sha_pon004()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON007
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON007
+# endif
+# define machine_is_sha_pon007()	(machine_arch_type == MACH_TYPE_SHA_PON007)
+#else
+# define machine_is_sha_pon007()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON011
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON011
+# endif
+# define machine_is_sha_pon011()	(machine_arch_type == MACH_TYPE_SHA_PON011)
+#else
+# define machine_is_sha_pon011()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6042
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6042
+# endif
+# define machine_is_h6042()	(machine_arch_type == MACH_TYPE_H6042)
+#else
+# define machine_is_h6042()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6043
+# endif
+# define machine_is_h6043()	(machine_arch_type == MACH_TYPE_H6043)
+#else
+# define machine_is_h6043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOXC550
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOXC550
+# endif
+# define machine_is_looxc550()	(machine_arch_type == MACH_TYPE_LOOXC550)
+#else
+# define machine_is_looxc550()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNTY_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNTY_TITAN
+# endif
+# define machine_is_cnty_titan()	(machine_arch_type == MACH_TYPE_CNTY_TITAN)
+#else
+# define machine_is_cnty_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APP3XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APP3XX
+# endif
+# define machine_is_app3xx()	(machine_arch_type == MACH_TYPE_APP3XX)
+#else
+# define machine_is_app3xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIDEOATSGRAMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIDEOATSGRAMA
+# endif
+# define machine_is_sideoatsgrama()	(machine_arch_type == MACH_TYPE_SIDEOATSGRAMA)
+#else
+# define machine_is_sideoatsgrama()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO700P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO700P
+# endif
+# define machine_is_treo700p()	(machine_arch_type == MACH_TYPE_TREO700P)
+#else
+# define machine_is_treo700p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO700W
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO700W
+# endif
+# define machine_is_treo700w()	(machine_arch_type == MACH_TYPE_TREO700W)
+#else
+# define machine_is_treo700w()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO750
+# endif
+# define machine_is_treo750()	(machine_arch_type == MACH_TYPE_TREO750)
+#else
+# define machine_is_treo750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO755P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO755P
+# endif
+# define machine_is_treo755p()	(machine_arch_type == MACH_TYPE_TREO755P)
+#else
+# define machine_is_treo755p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZREGANUT9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZREGANUT9200
+# endif
+# define machine_is_ezreganut9200()	(machine_arch_type == MACH_TYPE_EZREGANUT9200)
+#else
+# define machine_is_ezreganut9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SARGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SARGE
+# endif
+# define machine_is_sarge()	(machine_arch_type == MACH_TYPE_SARGE)
+#else
+# define machine_is_sarge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A696
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A696
+# endif
+# define machine_is_a696()	(machine_arch_type == MACH_TYPE_A696)
+#else
+# define machine_is_a696()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TURTLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TURTLE
+# endif
+# define machine_is_turtle1916()	(machine_arch_type == MACH_TYPE_TURTLE)
+#else
+# define machine_is_turtle1916()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_3DS
+# endif
+# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
+#else
+# define machine_is_mx27_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BISHOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BISHOP
+# endif
+# define machine_is_bishop()	(machine_arch_type == MACH_TYPE_BISHOP)
+#else
+# define machine_is_bishop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXX
+# endif
+# define machine_is_pxx()	(machine_arch_type == MACH_TYPE_PXX)
+#else
+# define machine_is_pxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDWOOD
+# endif
+# define machine_is_redwood()	(machine_arch_type == MACH_TYPE_REDWOOD)
+#else
+# define machine_is_redwood()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430DLP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430DLP
+# endif
+# define machine_is_omap_2430dlp()	(machine_arch_type == MACH_TYPE_OMAP_2430DLP)
+#else
+# define machine_is_omap_2430dlp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430OSK
+# endif
+# define machine_is_omap_2430osk()	(machine_arch_type == MACH_TYPE_OMAP_2430OSK)
+#else
+# define machine_is_omap_2430osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SARDINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SARDINE
+# endif
+# define machine_is_sardine()	(machine_arch_type == MACH_TYPE_SARDINE)
+#else
+# define machine_is_sardine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALIBUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALIBUT
+# endif
+# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
+#else
+# define machine_is_halibut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROUT
+# endif
+# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
+#else
+# define machine_is_trout()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOLDFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOLDFISH
+# endif
+# define machine_is_goldfish()	(machine_arch_type == MACH_TYPE_GOLDFISH)
+#else
+# define machine_is_goldfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC2440
+# endif
+# define machine_is_gesbc2440()	(machine_arch_type == MACH_TYPE_GESBC2440)
+#else
+# define machine_is_gesbc2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMAD
+# endif
+# define machine_is_nomad()	(machine_arch_type == MACH_TYPE_NOMAD)
+#else
+# define machine_is_nomad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROSALIND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROSALIND
+# endif
+# define machine_is_rosalind()	(machine_arch_type == MACH_TYPE_ROSALIND)
+#else
+# define machine_is_rosalind()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9215
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9215
+# endif
+# define machine_is_cc9p9215()	(machine_arch_type == MACH_TYPE_CC9P9215)
+#else
+# define machine_is_cc9p9215()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9210
+# endif
+# define machine_is_cc9p9210()	(machine_arch_type == MACH_TYPE_CC9P9210)
+#else
+# define machine_is_cc9p9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9215JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9215JS
+# endif
+# define machine_is_cc9p9215js()	(machine_arch_type == MACH_TYPE_CC9P9215JS)
+#else
+# define machine_is_cc9p9215js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9210JS
+# endif
+# define machine_is_cc9p9210js()	(machine_arch_type == MACH_TYPE_CC9P9210JS)
+#else
+# define machine_is_cc9p9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NASFFE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NASFFE
+# endif
+# define machine_is_nasffe()	(machine_arch_type == MACH_TYPE_NASFFE)
+#else
+# define machine_is_nasffe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TN2X0BD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TN2X0BD
+# endif
+# define machine_is_tn2x0bd()	(machine_arch_type == MACH_TYPE_TN2X0BD)
+#else
+# define machine_is_tn2x0bd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GWMPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GWMPXA
+# endif
+# define machine_is_gwmpxa()	(machine_arch_type == MACH_TYPE_GWMPXA)
+#else
+# define machine_is_gwmpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXYPLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXYPLUS
+# endif
+# define machine_is_exyplus()	(machine_arch_type == MACH_TYPE_EXYPLUS)
+#else
+# define machine_is_exyplus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADOO21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADOO21
+# endif
+# define machine_is_jadoo21()	(machine_arch_type == MACH_TYPE_JADOO21)
+#else
+# define machine_is_jadoo21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOOXN560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOOXN560
+# endif
+# define machine_is_looxn560()	(machine_arch_type == MACH_TYPE_LOOXN560)
+#else
+# define machine_is_looxn560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONSAI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONSAI
+# endif
+# define machine_is_bonsai()	(machine_arch_type == MACH_TYPE_BONSAI)
+#else
+# define machine_is_bonsai()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSMILGATO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSMILGATO
+# endif
+# define machine_is_adsmilgato()	(machine_arch_type == MACH_TYPE_ADSMILGATO)
+#else
+# define machine_is_adsmilgato()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GBA
+# endif
+# define machine_is_gba()	(machine_arch_type == MACH_TYPE_GBA)
+#else
+# define machine_is_gba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6044
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6044
+# endif
+# define machine_is_h6044()	(machine_arch_type == MACH_TYPE_H6044)
+#else
+# define machine_is_h6044()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APP
+# endif
+# define machine_is_app()	(machine_arch_type == MACH_TYPE_APP)
+#else
+# define machine_is_app()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCT_HAMMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
+# endif
+# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
+#else
+# define machine_is_tct_hammer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERALD
+# endif
+# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
+#else
+# define machine_is_herald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARTEMIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARTEMIS
+# endif
+# define machine_is_artemis()	(machine_arch_type == MACH_TYPE_ARTEMIS)
+#else
+# define machine_is_artemis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCTITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCTITAN
+# endif
+# define machine_is_htctitan()	(machine_arch_type == MACH_TYPE_HTCTITAN)
+#else
+# define machine_is_htctitan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QRANIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QRANIUM
+# endif
+# define machine_is_qranium()	(machine_arch_type == MACH_TYPE_QRANIUM)
+#else
+# define machine_is_qranium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_WSC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_WSC2
+# endif
+# define machine_is_adx_wsc2()	(machine_arch_type == MACH_TYPE_ADX_WSC2)
+#else
+# define machine_is_adx_wsc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_MEDCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_MEDCOM
+# endif
+# define machine_is_adx_medcom()	(machine_arch_type == MACH_TYPE_ADX_MEDCOM)
+#else
+# define machine_is_adx_medcom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBOARD
+# endif
+# define machine_is_bboard()	(machine_arch_type == MACH_TYPE_BBOARD)
+#else
+# define machine_is_bboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAMBRIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMBRIA
+# endif
+# define machine_is_cambria()	(machine_arch_type == MACH_TYPE_CAMBRIA)
+#else
+# define machine_is_cambria()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT7XXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT7XXX
+# endif
+# define machine_is_mt7xxx()	(machine_arch_type == MACH_TYPE_MT7XXX)
+#else
+# define machine_is_mt7xxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX512
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX512
+# endif
+# define machine_is_matrix512()	(machine_arch_type == MACH_TYPE_MATRIX512)
+#else
+# define machine_is_matrix512()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX522
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX522
+# endif
+# define machine_is_matrix522()	(machine_arch_type == MACH_TYPE_MATRIX522)
+#else
+# define machine_is_matrix522()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPAC5010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPAC5010
+# endif
+# define machine_is_ipac5010()	(machine_arch_type == MACH_TYPE_IPAC5010)
+#else
+# define machine_is_ipac5010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAKURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAKURA
+# endif
+# define machine_is_sakura()	(machine_arch_type == MACH_TYPE_SAKURA)
+#else
+# define machine_is_sakura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GROCX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GROCX
+# endif
+# define machine_is_grocx()	(machine_arch_type == MACH_TYPE_GROCX)
+#else
+# define machine_is_grocx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM9263
+# endif
+# define machine_is_pm9263()	(machine_arch_type == MACH_TYPE_PM9263)
+#else
+# define machine_is_pm9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIM_ONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIM_ONE
+# endif
+# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
+#else
+# define machine_is_sim_one()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACQ132
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACQ132
+# endif
+# define machine_is_acq132()	(machine_arch_type == MACH_TYPE_ACQ132)
+#else
+# define machine_is_acq132()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATR
+# endif
+# define machine_is_datr()	(machine_arch_type == MACH_TYPE_DATR)
+#else
+# define machine_is_datr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTUX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTUX1
+# endif
+# define machine_is_actux1()	(machine_arch_type == MACH_TYPE_ACTUX1)
+#else
+# define machine_is_actux1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTUX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTUX2
+# endif
+# define machine_is_actux2()	(machine_arch_type == MACH_TYPE_ACTUX2)
+#else
+# define machine_is_actux2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTUX3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTUX3
+# endif
+# define machine_is_actux3()	(machine_arch_type == MACH_TYPE_ACTUX3)
+#else
+# define machine_is_actux3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEXIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXIT
+# endif
+# define machine_is_flexit()	(machine_arch_type == MACH_TYPE_FLEXIT)
+#else
+# define machine_is_flexit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BH2X0BD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BH2X0BD
+# endif
+# define machine_is_bh2x0bd()	(machine_arch_type == MACH_TYPE_BH2X0BD)
+#else
+# define machine_is_bh2x0bd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATB2002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATB2002
+# endif
+# define machine_is_atb2002()	(machine_arch_type == MACH_TYPE_ATB2002)
+#else
+# define machine_is_atb2002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XENON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XENON
+# endif
+# define machine_is_xenon()	(machine_arch_type == MACH_TYPE_XENON)
+#else
+# define machine_is_xenon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FM607
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FM607
+# endif
+# define machine_is_fm607()	(machine_arch_type == MACH_TYPE_FM607)
+#else
+# define machine_is_fm607()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX514
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX514
+# endif
+# define machine_is_matrix514()	(machine_arch_type == MACH_TYPE_MATRIX514)
+#else
+# define machine_is_matrix514()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX524
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX524
+# endif
+# define machine_is_matrix524()	(machine_arch_type == MACH_TYPE_MATRIX524)
+#else
+# define machine_is_matrix524()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INPOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INPOD
+# endif
+# define machine_is_inpod()	(machine_arch_type == MACH_TYPE_INPOD)
+#else
+# define machine_is_inpod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIVE
+# endif
+# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
+#else
+# define machine_is_jive()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLL_MX21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLL_MX21
+# endif
+# define machine_is_tll_mx21()	(machine_arch_type == MACH_TYPE_TLL_MX21)
+#else
+# define machine_is_tll_mx21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2800
+# endif
+# define machine_is_sbc2800()	(machine_arch_type == MACH_TYPE_SBC2800)
+#else
+# define machine_is_sbc2800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC7UCAMRY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC7UCAMRY
+# endif
+# define machine_is_cc7ucamry()	(machine_arch_type == MACH_TYPE_CC7UCAMRY)
+#else
+# define machine_is_cc7ucamry()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_SC15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_SC15
+# endif
+# define machine_is_ubisys_p9_sc15()	(machine_arch_type == MACH_TYPE_UBISYS_P9_SC15)
+#else
+# define machine_is_ubisys_p9_sc15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_SSC2D10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_SSC2D10
+# endif
+# define machine_is_ubisys_p9_ssc2d10()	(machine_arch_type == MACH_TYPE_UBISYS_P9_SSC2D10)
+#else
+# define machine_is_ubisys_p9_ssc2d10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_RCU3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_RCU3
+# endif
+# define machine_is_ubisys_p9_rcu3()	(machine_arch_type == MACH_TYPE_UBISYS_P9_RCU3)
+#else
+# define machine_is_ubisys_p9_rcu3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M8000
+# endif
+# define machine_is_aml_m8000()	(machine_arch_type == MACH_TYPE_AML_M8000)
+#else
+# define machine_is_aml_m8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_270
+# endif
+# define machine_is_snapper_270()	(machine_arch_type == MACH_TYPE_SNAPPER_270)
+#else
+# define machine_is_snapper_270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_BBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_BBX
+# endif
+# define machine_is_omap_bbx()	(machine_arch_type == MACH_TYPE_OMAP_BBX)
+#else
+# define machine_is_omap_bbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCN2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCN2410
+# endif
+# define machine_is_ucn2410()	(machine_arch_type == MACH_TYPE_UCN2410)
+#else
+# define machine_is_ucn2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9260
+# endif
+# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
+#else
+# define machine_is_sam9_l9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETI_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETI_C2
+# endif
+# define machine_is_eti_c2()	(machine_arch_type == MACH_TYPE_ETI_C2)
+#else
+# define machine_is_eti_c2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVALANCHE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVALANCHE
+# endif
+# define machine_is_avalanche()	(machine_arch_type == MACH_TYPE_AVALANCHE)
+#else
+# define machine_is_avalanche()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
+# endif
+# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
+#else
+# define machine_is_realview_pb1176()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP1500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP1500
+# endif
+# define machine_is_dp1500()	(machine_arch_type == MACH_TYPE_DP1500)
+#else
+# define machine_is_dp1500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APPLE_IPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APPLE_IPHONE
+# endif
+# define machine_is_apple_iphone()	(machine_arch_type == MACH_TYPE_APPLE_IPHONE)
+#else
+# define machine_is_apple_iphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL9200
+# endif
+# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
+#else
+# define machine_is_yl9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5182
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5182
+# endif
+# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
+#else
+# define machine_is_rd88f5182()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KUROBOX_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
+# endif
+# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
+#else
+# define machine_is_kurobox_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SE_POET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SE_POET
+# endif
+# define machine_is_se_poet()	(machine_arch_type == MACH_TYPE_SE_POET)
+#else
+# define machine_is_se_poet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_3DS
+# endif
+# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
+#else
+# define machine_is_mx31_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R270
+# endif
+# define machine_is_r270()	(machine_arch_type == MACH_TYPE_R270)
+#else
+# define machine_is_r270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMOUR21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMOUR21
+# endif
+# define machine_is_armour21()	(machine_arch_type == MACH_TYPE_ARMOUR21)
+#else
+# define machine_is_armour21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DT2
+# endif
+# define machine_is_dt2()	(machine_arch_type == MACH_TYPE_DT2)
+#else
+# define machine_is_dt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VT4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VT4
+# endif
+# define machine_is_vt4()	(machine_arch_type == MACH_TYPE_VT4)
+#else
+# define machine_is_vt4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TYCO320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TYCO320
+# endif
+# define machine_is_tyco320()	(machine_arch_type == MACH_TYPE_TYCO320)
+#else
+# define machine_is_tyco320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADMA
+# endif
+# define machine_is_adma()	(machine_arch_type == MACH_TYPE_ADMA)
+#else
+# define machine_is_adma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WP188
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WP188
+# endif
+# define machine_is_wp188()	(machine_arch_type == MACH_TYPE_WP188)
+#else
+# define machine_is_wp188()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORSICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORSICA
+# endif
+# define machine_is_corsica()	(machine_arch_type == MACH_TYPE_CORSICA)
+#else
+# define machine_is_corsica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGEYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGEYE
+# endif
+# define machine_is_bigeye()	(machine_arch_type == MACH_TYPE_BIGEYE)
+#else
+# define machine_is_bigeye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TLL5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TLL5000
+# endif
+# define machine_is_tll5000()	(machine_arch_type == MACH_TYPE_TLL5000)
+#else
+# define machine_is_tll5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEBOT
+# endif
+# define machine_is_bebot()	(machine_arch_type == MACH_TYPE_BEBOT)
+#else
+# define machine_is_bebot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QONG
+# endif
+# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
+#else
+# define machine_is_qong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCOMPACT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCOMPACT
+# endif
+# define machine_is_tcompact()	(machine_arch_type == MACH_TYPE_TCOMPACT)
+#else
+# define machine_is_tcompact()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUMA5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUMA5
+# endif
+# define machine_is_puma5()	(machine_arch_type == MACH_TYPE_PUMA5)
+#else
+# define machine_is_puma5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELARA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELARA
+# endif
+# define machine_is_elara()	(machine_arch_type == MACH_TYPE_ELARA)
+#else
+# define machine_is_elara()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELLINGTON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELLINGTON
+# endif
+# define machine_is_ellington()	(machine_arch_type == MACH_TYPE_ELLINGTON)
+#else
+# define machine_is_ellington()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XDA_ATOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDA_ATOM
+# endif
+# define machine_is_xda_atom()	(machine_arch_type == MACH_TYPE_XDA_ATOM)
+#else
+# define machine_is_xda_atom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENERGIZER2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENERGIZER2
+# endif
+# define machine_is_energizer2()	(machine_arch_type == MACH_TYPE_ENERGIZER2)
+#else
+# define machine_is_energizer2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ODIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ODIN
+# endif
+# define machine_is_odin()	(machine_arch_type == MACH_TYPE_ODIN)
+#else
+# define machine_is_odin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTUX4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTUX4
+# endif
+# define machine_is_actux4()	(machine_arch_type == MACH_TYPE_ACTUX4)
+#else
+# define machine_is_actux4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_OMAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_OMAP
+# endif
+# define machine_is_esl_omap()	(machine_arch_type == MACH_TYPE_ESL_OMAP)
+#else
+# define machine_is_esl_omap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP2EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP2EVM
+# endif
+# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
+#else
+# define machine_is_omap2evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3EVM
+# endif
+# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
+#else
+# define machine_is_omap3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_PCU57
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_PCU57
+# endif
+# define machine_is_adx_pcu57()	(machine_arch_type == MACH_TYPE_ADX_PCU57)
+#else
+# define machine_is_adx_pcu57()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONACO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONACO
+# endif
+# define machine_is_monaco()	(machine_arch_type == MACH_TYPE_MONACO)
+#else
+# define machine_is_monaco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEVANTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEVANTE
+# endif
+# define machine_is_levante()	(machine_arch_type == MACH_TYPE_LEVANTE)
+#else
+# define machine_is_levante()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TMXIPX425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TMXIPX425
+# endif
+# define machine_is_tmxipx425()	(machine_arch_type == MACH_TYPE_TMXIPX425)
+#else
+# define machine_is_tmxipx425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEEP
+# endif
+# define machine_is_leep()	(machine_arch_type == MACH_TYPE_LEEP)
+#else
+# define machine_is_leep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAAD
+# endif
+# define machine_is_raad()	(machine_arch_type == MACH_TYPE_RAAD)
+#else
+# define machine_is_raad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS323
+# endif
+# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
+#else
+# define machine_is_dns323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP1000
+# endif
+# define machine_is_ap1000()	(machine_arch_type == MACH_TYPE_AP1000)
+#else
+# define machine_is_ap1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9SAM6432
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9SAM6432
+# endif
+# define machine_is_a9sam6432()	(machine_arch_type == MACH_TYPE_A9SAM6432)
+#else
+# define machine_is_a9sam6432()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHINY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHINY
+# endif
+# define machine_is_shiny()	(machine_arch_type == MACH_TYPE_SHINY)
+#else
+# define machine_is_shiny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BEAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
+# endif
+# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
+#else
+# define machine_is_omap3_beagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSR_BDB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSR_BDB2
+# endif
+# define machine_is_csr_bdb2()	(machine_arch_type == MACH_TYPE_CSR_BDB2)
+#else
+# define machine_is_csr_bdb2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810
+# endif
+# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
+#else
+# define machine_is_nokia_n810()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C270
+# endif
+# define machine_is_c270()	(machine_arch_type == MACH_TYPE_C270)
+#else
+# define machine_is_c270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SENTRY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SENTRY
+# endif
+# define machine_is_sentry()	(machine_arch_type == MACH_TYPE_SENTRY)
+#else
+# define machine_is_sentry()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM038
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM038
+# endif
+# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
+#else
+# define machine_is_pcm038()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANC300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANC300
+# endif
+# define machine_is_anc300()	(machine_arch_type == MACH_TYPE_ANC300)
+#else
+# define machine_is_anc300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCKAISER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCKAISER
+# endif
+# define machine_is_htckaiser()	(machine_arch_type == MACH_TYPE_HTCKAISER)
+#else
+# define machine_is_htckaiser()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBAT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBAT100
+# endif
+# define machine_is_sbat100()	(machine_arch_type == MACH_TYPE_SBAT100)
+#else
+# define machine_is_sbat100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MODUNORM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MODUNORM
+# endif
+# define machine_is_modunorm()	(machine_arch_type == MACH_TYPE_MODUNORM)
+#else
+# define machine_is_modunorm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELOS_TWARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELOS_TWARM
+# endif
+# define machine_is_pelos_twarm()	(machine_arch_type == MACH_TYPE_PELOS_TWARM)
+#else
+# define machine_is_pelos_twarm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLANK
+# endif
+# define machine_is_flank()	(machine_arch_type == MACH_TYPE_FLANK)
+#else
+# define machine_is_flank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIRLOIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIRLOIN
+# endif
+# define machine_is_sirloin()	(machine_arch_type == MACH_TYPE_SIRLOIN)
+#else
+# define machine_is_sirloin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BRISKET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRISKET
+# endif
+# define machine_is_brisket()	(machine_arch_type == MACH_TYPE_BRISKET)
+#else
+# define machine_is_brisket()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUCK
+# endif
+# define machine_is_chuck()	(machine_arch_type == MACH_TYPE_CHUCK)
+#else
+# define machine_is_chuck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTTER
+# endif
+# define machine_is_otter()	(machine_arch_type == MACH_TYPE_OTTER)
+#else
+# define machine_is_otter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_LDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_LDK
+# endif
+# define machine_is_davinci_ldk()	(machine_arch_type == MACH_TYPE_DAVINCI_LDK)
+#else
+# define machine_is_davinci_ldk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHREEDOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHREEDOM
+# endif
+# define machine_is_phreedom()	(machine_arch_type == MACH_TYPE_PHREEDOM)
+#else
+# define machine_is_phreedom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG310
+# endif
+# define machine_is_sg310()	(machine_arch_type == MACH_TYPE_SG310)
+#else
+# define machine_is_sg310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS209
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS209
+# endif
+# define machine_is_ts_x09()	(machine_arch_type == MACH_TYPE_TS209)
+#else
+# define machine_is_ts_x09()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9ADK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
+# endif
+# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
+#else
+# define machine_is_at91cap9adk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TION9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TION9315
+# endif
+# define machine_is_tion9315()	(machine_arch_type == MACH_TYPE_TION9315)
+#else
+# define machine_is_tion9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAST
+# endif
+# define machine_is_mast()	(machine_arch_type == MACH_TYPE_MAST)
+#else
+# define machine_is_mast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PFW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFW
+# endif
+# define machine_is_pfw()	(machine_arch_type == MACH_TYPE_PFW)
+#else
+# define machine_is_pfw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL_P2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL_P2440
+# endif
+# define machine_is_yl_p2440()	(machine_arch_type == MACH_TYPE_YL_P2440)
+#else
+# define machine_is_yl_p2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZSBC32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZSBC32
+# endif
+# define machine_is_zsbc32()	(machine_arch_type == MACH_TYPE_ZSBC32)
+#else
+# define machine_is_zsbc32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PACE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PACE2
+# endif
+# define machine_is_omap_pace2()	(machine_arch_type == MACH_TYPE_OMAP_PACE2)
+#else
+# define machine_is_omap_pace2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX_PACE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX_PACE2
+# endif
+# define machine_is_imx_pace2()	(machine_arch_type == MACH_TYPE_IMX_PACE2)
+#else
+# define machine_is_imx_pace2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31MOBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
+# endif
+# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
+#else
+# define machine_is_mx31moboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX37_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX37_3DS
+# endif
+# define machine_is_mx37_3ds()	(machine_arch_type == MACH_TYPE_MX37_3DS)
+#else
+# define machine_is_mx37_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RCC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RCC
+# endif
+# define machine_is_rcc()	(machine_arch_type == MACH_TYPE_RCC)
+#else
+# define machine_is_rcc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM9
+# endif
+# define machine_is_dmp()	(machine_arch_type == MACH_TYPE_ARM9)
+#else
+# define machine_is_dmp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VISION_EP9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VISION_EP9307
+# endif
+# define machine_is_vision_ep9307()	(machine_arch_type == MACH_TYPE_VISION_EP9307)
+#else
+# define machine_is_vision_ep9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCLY1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCLY1000
+# endif
+# define machine_is_scly1000()	(machine_arch_type == MACH_TYPE_SCLY1000)
+#else
+# define machine_is_scly1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FONTEL_EP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FONTEL_EP
+# endif
+# define machine_is_fontel_ep()	(machine_arch_type == MACH_TYPE_FONTEL_EP)
+#else
+# define machine_is_fontel_ep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE3G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE3G
+# endif
+# define machine_is_voiceblue3g()	(machine_arch_type == MACH_TYPE_VOICEBLUE3G)
+#else
+# define machine_is_voiceblue3g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT9200
+# endif
+# define machine_is_tt9200()	(machine_arch_type == MACH_TYPE_TT9200)
+#else
+# define machine_is_tt9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIGI2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIGI2410
+# endif
+# define machine_is_digi2410()	(machine_arch_type == MACH_TYPE_DIGI2410)
+#else
+# define machine_is_digi2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_PRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
+# endif
+# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
+#else
+# define machine_is_terastation_pro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
+# endif
+# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
+#else
+# define machine_is_linkstation_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOROLA_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOROLA_A780
+# endif
+# define machine_is_motorola_a780()	(machine_arch_type == MACH_TYPE_MOTOROLA_A780)
+#else
+# define machine_is_motorola_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOROLA_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOROLA_E6
+# endif
+# define machine_is_motorola_e6()	(machine_arch_type == MACH_TYPE_MOTOROLA_E6)
+#else
+# define machine_is_motorola_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOROLA_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOROLA_E2
+# endif
+# define machine_is_motorola_e2()	(machine_arch_type == MACH_TYPE_MOTOROLA_E2)
+#else
+# define machine_is_motorola_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOROLA_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOROLA_E680
+# endif
+# define machine_is_motorola_e680()	(machine_arch_type == MACH_TYPE_MOTOROLA_E680)
+#else
+# define machine_is_motorola_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UR2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UR2410
+# endif
+# define machine_is_ur2410()	(machine_arch_type == MACH_TYPE_UR2410)
+#else
+# define machine_is_ur2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAS9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAS9261
+# endif
+# define machine_is_tas9261()	(machine_arch_type == MACH_TYPE_TAS9261)
+#else
+# define machine_is_tas9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERMES_HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERMES_HD
+# endif
+# define machine_is_davinci_hermes_hd()	(machine_arch_type == MACH_TYPE_HERMES_HD)
+#else
+# define machine_is_davinci_hermes_hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PERSEO_HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSEO_HD
+# endif
+# define machine_is_davinci_perseo_hd()	(machine_arch_type == MACH_TYPE_PERSEO_HD)
+#else
+# define machine_is_davinci_perseo_hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGAZER2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGAZER2
+# endif
+# define machine_is_stargazer2()	(machine_arch_type == MACH_TYPE_STARGAZER2)
+#else
+# define machine_is_stargazer2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E350
+# endif
+# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
+#else
+# define machine_is_e350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WPCM450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WPCM450
+# endif
+# define machine_is_wpcm450()	(machine_arch_type == MACH_TYPE_WPCM450)
+#else
+# define machine_is_wpcm450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARTESIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARTESIO
+# endif
+# define machine_is_cartesio()	(machine_arch_type == MACH_TYPE_CARTESIO)
+#else
+# define machine_is_cartesio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOYBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOYBOX
+# endif
+# define machine_is_toybox()	(machine_arch_type == MACH_TYPE_TOYBOX)
+#else
+# define machine_is_toybox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX27
+# endif
+# define machine_is_tx27()	(machine_arch_type == MACH_TYPE_TX27)
+#else
+# define machine_is_tx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS409
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS409
+# endif
+# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
+#else
+# define machine_is_ts409()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P300
+# endif
+# define machine_is_p300()	(machine_arch_type == MACH_TYPE_P300)
+#else
+# define machine_is_p300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XDACOMET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDACOMET
+# endif
+# define machine_is_xdacomet()	(machine_arch_type == MACH_TYPE_XDACOMET)
+#else
+# define machine_is_xdacomet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEXFLEX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEXFLEX2
+# endif
+# define machine_is_dexflex2()	(machine_arch_type == MACH_TYPE_DEXFLEX2)
+#else
+# define machine_is_dexflex2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OW
+# endif
+# define machine_is_ow()	(machine_arch_type == MACH_TYPE_OW)
+#else
+# define machine_is_ow()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMEBS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMEBS3
+# endif
+# define machine_is_armebs3()	(machine_arch_type == MACH_TYPE_ARMEBS3)
+#else
+# define machine_is_armebs3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U3
+# endif
+# define machine_is_u3()	(machine_arch_type == MACH_TYPE_U3)
+#else
+# define machine_is_u3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2450
+# endif
+# define machine_is_smdk2450()	(machine_arch_type == MACH_TYPE_SMDK2450)
+#else
+# define machine_is_smdk2450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSI_EWS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSI_EWS
+# endif
+# define machine_is_rsi_ews()	(machine_arch_type == MACH_TYPE_RSI_EWS)
+#else
+# define machine_is_rsi_ews()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNB
+# endif
+# define machine_is_tnb()	(machine_arch_type == MACH_TYPE_TNB)
+#else
+# define machine_is_tnb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOEPATH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOEPATH
+# endif
+# define machine_is_toepath()	(machine_arch_type == MACH_TYPE_TOEPATH)
+#else
+# define machine_is_toepath()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9263
+# endif
+# define machine_is_kb9263()	(machine_arch_type == MACH_TYPE_KB9263)
+#else
+# define machine_is_kb9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT7108
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT7108
+# endif
+# define machine_is_mt7108()	(machine_arch_type == MACH_TYPE_MT7108)
+#else
+# define machine_is_mt7108()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMTR2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMTR2440
+# endif
+# define machine_is_smtr2440()	(machine_arch_type == MACH_TYPE_SMTR2440)
+#else
+# define machine_is_smtr2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANAO
+# endif
+# define machine_is_manao()	(machine_arch_type == MACH_TYPE_MANAO)
+#else
+# define machine_is_manao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GULFSTREAM_KP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GULFSTREAM_KP
+# endif
+# define machine_is_gulfstream_kp()	(machine_arch_type == MACH_TYPE_GULFSTREAM_KP)
+#else
+# define machine_is_gulfstream_kp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN522
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN522
+# endif
+# define machine_is_lanreadyfn522()	(machine_arch_type == MACH_TYPE_LANREADYFN522)
+#else
+# define machine_is_lanreadyfn522()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMA37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMA37
+# endif
+# define machine_is_arma37()	(machine_arch_type == MACH_TYPE_ARMA37)
+#else
+# define machine_is_arma37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENDEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENDEL
+# endif
+# define machine_is_mendel()	(machine_arch_type == MACH_TYPE_MENDEL)
+#else
+# define machine_is_mendel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ILIAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ILIAD
+# endif
+# define machine_is_pelco_iliad()	(machine_arch_type == MACH_TYPE_PELCO_ILIAD)
+#else
+# define machine_is_pelco_iliad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIT2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIT2P
+# endif
+# define machine_is_unit2p()	(machine_arch_type == MACH_TYPE_UNIT2P)
+#else
+# define machine_is_unit2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INC20OTTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INC20OTTER
+# endif
+# define machine_is_inc20otter()	(machine_arch_type == MACH_TYPE_INC20OTTER)
+#else
+# define machine_is_inc20otter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STORCENTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORCENTER
+# endif
+# define machine_is_sc_ge2()	(machine_arch_type == MACH_TYPE_STORCENTER)
+#else
+# define machine_is_sc_ge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U500
+# endif
+# define machine_is_u500()	(machine_arch_type == MACH_TYPE_U500)
+#else
+# define machine_is_u500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS9260
+# endif
+# define machine_is_ds9260()	(machine_arch_type == MACH_TYPE_DS9260)
+#else
+# define machine_is_ds9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIVERROCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIVERROCK
+# endif
+# define machine_is_riverrock()	(machine_arch_type == MACH_TYPE_RIVERROCK)
+#else
+# define machine_is_riverrock()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCIBATH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCIBATH
+# endif
+# define machine_is_scibath()	(machine_arch_type == MACH_TYPE_SCIBATH)
+#else
+# define machine_is_scibath()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM7SE512EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM7SE512EK
+# endif
+# define machine_is_at91sam7se()	(machine_arch_type == MACH_TYPE_AT91SAM7SE512EK)
+#else
+# define machine_is_at91sam7se()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIMEDIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIMEDIA
+# endif
+# define machine_is_multimedia()	(machine_arch_type == MACH_TYPE_MULTIMEDIA)
+#else
+# define machine_is_multimedia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVIN
+# endif
+# define machine_is_marvin()	(machine_arch_type == MACH_TYPE_MARVIN)
+#else
+# define machine_is_marvin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X500
+# endif
+# define machine_is_x500()	(machine_arch_type == MACH_TYPE_X500)
+#else
+# define machine_is_x500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWLUG4LCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWLUG4LCU
+# endif
+# define machine_is_awlug4lcu()	(machine_arch_type == MACH_TYPE_AWLUG4LCU)
+#else
+# define machine_is_awlug4lcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALERMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALERMOC
+# endif
+# define machine_is_palermoc()	(machine_arch_type == MACH_TYPE_PALERMOC)
+#else
+# define machine_is_palermoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP500
+# endif
+# define machine_is_ip500()	(machine_arch_type == MACH_TYPE_IP500)
+#else
+# define machine_is_ip500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASE2
+# endif
+# define machine_is_ase2()	(machine_arch_type == MACH_TYPE_ASE2)
+#else
+# define machine_is_ase2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35EVB
+# endif
+# define machine_is_mx35evb()	(machine_arch_type == MACH_TYPE_MX35EVB)
+#else
+# define machine_is_mx35evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M8050
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M8050
+# endif
+# define machine_is_aml_m8050()	(machine_arch_type == MACH_TYPE_AML_M8050)
+#else
+# define machine_is_aml_m8050()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARS
+# endif
+# define machine_is_mars()	(machine_arch_type == MACH_TYPE_MARS)
+#else
+# define machine_is_mars()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEUROS_OSD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
+# endif
+# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
+#else
+# define machine_is_neuros_osd2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BADGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGER
+# endif
+# define machine_is_badger()	(machine_arch_type == MACH_TYPE_BADGER)
+#else
+# define machine_is_badger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS5
+# endif
+# define machine_is_trizeps5()	(machine_arch_type == MACH_TYPE_TRIZEPS5)
+#else
+# define machine_is_trizeps5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARLIN
+# endif
+# define machine_is_marlin()	(machine_arch_type == MACH_TYPE_MARLIN)
+#else
+# define machine_is_marlin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPIPAQ214
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPIPAQ214
+# endif
+# define machine_is_hpipaq214()	(machine_arch_type == MACH_TYPE_HPIPAQ214)
+#else
+# define machine_is_hpipaq214()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940DCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940DCM
+# endif
+# define machine_is_at572d940dcm()	(machine_arch_type == MACH_TYPE_AT572D940DCM)
+#else
+# define machine_is_at572d940dcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NE1BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NE1BOARD
+# endif
+# define machine_is_ne1board()	(machine_arch_type == MACH_TYPE_NE1BOARD)
+#else
+# define machine_is_ne1board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZANTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZANTE
+# endif
+# define machine_is_zante()	(machine_arch_type == MACH_TYPE_ZANTE)
+#else
+# define machine_is_zante()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TW2662
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TW2662
+# endif
+# define machine_is_tw2662()	(machine_arch_type == MACH_TYPE_TW2662)
+#else
+# define machine_is_tw2662()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VF10XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VF10XX
+# endif
+# define machine_is_vf10xx()	(machine_arch_type == MACH_TYPE_VF10XX)
+#else
+# define machine_is_vf10xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZORAN43XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZORAN43XX
+# endif
+# define machine_is_zoran43xx()	(machine_arch_type == MACH_TYPE_ZORAN43XX)
+#else
+# define machine_is_zoran43xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONIX926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONIX926
+# endif
+# define machine_is_sonix926()	(machine_arch_type == MACH_TYPE_SONIX926)
+#else
+# define machine_is_sonix926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CELESTIALSEMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CELESTIALSEMI
+# endif
+# define machine_is_celestialsemi()	(machine_arch_type == MACH_TYPE_CELESTIALSEMI)
+#else
+# define machine_is_celestialsemi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9M2443JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9M2443JS
+# endif
+# define machine_is_cc9m2443js()	(machine_arch_type == MACH_TYPE_CC9M2443JS)
+#else
+# define machine_is_cc9m2443js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TW5334
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TW5334
+# endif
+# define machine_is_tw5334()	(machine_arch_type == MACH_TYPE_TW5334)
+#else
+# define machine_is_tw5334()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCARTEMIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCARTEMIS
+# endif
+# define machine_is_omap_htcartemis()	(machine_arch_type == MACH_TYPE_HTCARTEMIS)
+#else
+# define machine_is_omap_htcartemis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAL_HLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAL_HLITE
+# endif
+# define machine_is_nal_hlite()	(machine_arch_type == MACH_TYPE_NAL_HLITE)
+#else
+# define machine_is_nal_hlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCVOGUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCVOGUE
+# endif
+# define machine_is_htcvogue()	(machine_arch_type == MACH_TYPE_HTCVOGUE)
+#else
+# define machine_is_htcvogue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTWEB
+# endif
+# define machine_is_smartweb()	(machine_arch_type == MACH_TYPE_SMARTWEB)
+#else
+# define machine_is_smartweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV86XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV86XX
+# endif
+# define machine_is_mv86xx()	(machine_arch_type == MACH_TYPE_MV86XX)
+#else
+# define machine_is_mv86xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV87XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV87XX
+# endif
+# define machine_is_mv87xx()	(machine_arch_type == MACH_TYPE_MV87XX)
+#else
+# define machine_is_mv87xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONGYOUNGHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONGYOUNGHO
+# endif
+# define machine_is_songyoungho()	(machine_arch_type == MACH_TYPE_SONGYOUNGHO)
+#else
+# define machine_is_songyoungho()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YOUNGHOTEMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOUNGHOTEMA
+# endif
+# define machine_is_younghotema()	(machine_arch_type == MACH_TYPE_YOUNGHOTEMA)
+#else
+# define machine_is_younghotema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMVP
+# endif
+# define machine_is_mmvp()	(machine_arch_type == MACH_TYPE_MMVP)
+#else
+# define machine_is_mmvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMAP
+# endif
+# define machine_is_mmap()	(machine_arch_type == MACH_TYPE_MMAP)
+#else
+# define machine_is_mmap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTID2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTID2410
+# endif
+# define machine_is_ptid2410()	(machine_arch_type == MACH_TYPE_PTID2410)
+#else
+# define machine_is_ptid2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAMES_926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAMES_926
+# endif
+# define machine_is_james_926()	(machine_arch_type == MACH_TYPE_JAMES_926)
+#else
+# define machine_is_james_926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FM6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FM6000
+# endif
+# define machine_is_fm6000()	(machine_arch_type == MACH_TYPE_FM6000)
+#else
+# define machine_is_fm6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_SPIDER_SI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_SPIDER_SI
+# endif
+# define machine_is_oce_spider_si()	(machine_arch_type == MACH_TYPE_OCE_SPIDER_SI)
+#else
+# define machine_is_oce_spider_si()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_SPIDER_SK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_SPIDER_SK
+# endif
+# define machine_is_oce_spider_sk()	(machine_arch_type == MACH_TYPE_OCE_SPIDER_SK)
+#else
+# define machine_is_oce_spider_sk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERN6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERN6
+# endif
+# define machine_is_rovern6()	(machine_arch_type == MACH_TYPE_ROVERN6)
+#else
+# define machine_is_rovern6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_EVOLUTION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_EVOLUTION
+# endif
+# define machine_is_pelco_evolution()	(machine_arch_type == MACH_TYPE_PELCO_EVOLUTION)
+#else
+# define machine_is_pelco_evolution()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELARACPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELARACPE
+# endif
+# define machine_is_elaracpe()	(machine_arch_type == MACH_TYPE_ELARACPE)
+#else
+# define machine_is_elaracpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MABV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MABV3
+# endif
+# define machine_is_mabv3()	(machine_arch_type == MACH_TYPE_MABV3)
+#else
+# define machine_is_mabv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB737
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB737
+# endif
+# define machine_is_csb737()	(machine_arch_type == MACH_TYPE_CSB737)
+#else
+# define machine_is_csb737()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G900
+# endif
+# define machine_is_g900()	(machine_arch_type == MACH_TYPE_G900)
+#else
+# define machine_is_g900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF27
+# endif
+# define machine_is_apf27()	(machine_arch_type == MACH_TYPE_APF27)
+#else
+# define machine_is_apf27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GGUS2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GGUS2000
+# endif
+# define machine_is_ggus2000()	(machine_arch_type == MACH_TYPE_GGUS2000)
+#else
+# define machine_is_ggus2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430_MIMIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430_MIMIC
+# endif
+# define machine_is_omap_2430_mimic()	(machine_arch_type == MACH_TYPE_OMAP_2430_MIMIC)
+#else
+# define machine_is_omap_2430_mimic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALMEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALMEX
+# endif
+# define machine_is_almex()	(machine_arch_type == MACH_TYPE_ALMEX)
+#else
+# define machine_is_almex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONTROL
+# endif
+# define machine_is_control()	(machine_arch_type == MACH_TYPE_CONTROL)
+#else
+# define machine_is_control()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBA2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBA2410
+# endif
+# define machine_is_mba2410()	(machine_arch_type == MACH_TYPE_MBA2410)
+#else
+# define machine_is_mba2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOLCANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOLCANO
+# endif
+# define machine_is_volcano()	(machine_arch_type == MACH_TYPE_VOLCANO)
+#else
+# define machine_is_volcano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZENITH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZENITH
+# endif
+# define machine_is_zenith()	(machine_arch_type == MACH_TYPE_ZENITH)
+#else
+# define machine_is_zenith()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUCHIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUCHIP
+# endif
+# define machine_is_muchip()	(machine_arch_type == MACH_TYPE_MUCHIP)
+#else
+# define machine_is_muchip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGELLAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGELLAN
+# endif
+# define machine_is_magellan()	(machine_arch_type == MACH_TYPE_MAGELLAN)
+#else
+# define machine_is_magellan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CME9210
+# endif
+# define machine_is_cme9210()	(machine_arch_type == MACH_TYPE_CME9210)
+#else
+# define machine_is_cme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HCZH4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HCZH4
+# endif
+# define machine_is_hczh4()	(machine_arch_type == MACH_TYPE_HCZH4)
+#else
+# define machine_is_hczh4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEARBASIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARBASIC
+# endif
+# define machine_is_spearbasic()	(machine_arch_type == MACH_TYPE_SPEARBASIC)
+#else
+# define machine_is_spearbasic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2440
+# endif
+# define machine_is_dep2440()	(machine_arch_type == MACH_TYPE_DEP2440)
+#else
+# define machine_is_dep2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GXR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GXR
+# endif
+# define machine_is_hdl_gxr()	(machine_arch_type == MACH_TYPE_HDL_GXR)
+#else
+# define machine_is_hdl_gxr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GT
+# endif
+# define machine_is_hdl_gt()	(machine_arch_type == MACH_TYPE_HDL_GT)
+#else
+# define machine_is_hdl_gt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_4G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_4G
+# endif
+# define machine_is_hdl_4g()	(machine_arch_type == MACH_TYPE_HDL_4G)
+#else
+# define machine_is_hdl_4g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6000
+# endif
+# define machine_is_s3c6000()	(machine_arch_type == MACH_TYPE_S3C6000)
+#else
+# define machine_is_s3c6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMSP2_MDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMSP2_MDK
+# endif
+# define machine_is_mmsp2_mdk()	(machine_arch_type == MACH_TYPE_MMSP2_MDK)
+#else
+# define machine_is_mmsp2_mdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPX220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPX220
+# endif
+# define machine_is_mpx220()	(machine_arch_type == MACH_TYPE_MPX220)
+#else
+# define machine_is_mpx220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_POLARIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_POLARIS
+# endif
+# define machine_is_htc_polaris()	(machine_arch_type == MACH_TYPE_HTC_POLARIS)
+#else
+# define machine_is_htc_polaris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_KAISER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_KAISER
+# endif
+# define machine_is_htc_kaiser()	(machine_arch_type == MACH_TYPE_HTC_KAISER)
+#else
+# define machine_is_htc_kaiser()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LG_KS20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LG_KS20
+# endif
+# define machine_is_lg_ks20()	(machine_arch_type == MACH_TYPE_LG_KS20)
+#else
+# define machine_is_lg_ks20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HHGPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHGPS
+# endif
+# define machine_is_hhgps()	(machine_arch_type == MACH_TYPE_HHGPS)
+#else
+# define machine_is_hhgps()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INSIGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INSIGHT
+# endif
+# define machine_is_insight()	(machine_arch_type == MACH_TYPE_INSIGHT)
+#else
+# define machine_is_insight()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637XO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637XO
+# endif
+# define machine_is_csb637xo()	(machine_arch_type == MACH_TYPE_CSB637XO)
+#else
+# define machine_is_csb637xo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVISIONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVISIONG
+# endif
+# define machine_is_evisiong()	(machine_arch_type == MACH_TYPE_EVISIONG)
+#else
+# define machine_is_evisiong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNT
+# endif
+# define machine_is_tnt()	(machine_arch_type == MACH_TYPE_TNT)
+#else
+# define machine_is_tnt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TBXT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBXT
+# endif
+# define machine_is_tbxt()	(machine_arch_type == MACH_TYPE_TBXT)
+#else
+# define machine_is_tbxt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLAYMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLAYMATE
+# endif
+# define machine_is_playmate()	(machine_arch_type == MACH_TYPE_PLAYMATE)
+#else
+# define machine_is_playmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNS10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNS10
+# endif
+# define machine_is_pns10()	(machine_arch_type == MACH_TYPE_PNS10)
+#else
+# define machine_is_pns10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZNAVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZNAVI
+# endif
+# define machine_is_eznavi()	(machine_arch_type == MACH_TYPE_EZNAVI)
+#else
+# define machine_is_eznavi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PS4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PS4000
+# endif
+# define machine_is_ps4000()	(machine_arch_type == MACH_TYPE_PS4000)
+#else
+# define machine_is_ps4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX31
+# endif
+# define machine_is_cwmx31()	(machine_arch_type == MACH_TYPE_CWMX31)
+#else
+# define machine_is_cwmx31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SL2312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SL2312
+# endif
+# define machine_is_sl2312()	(machine_arch_type == MACH_TYPE_SL2312)
+#else
+# define machine_is_sl2312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLENNY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLENNY
+# endif
+# define machine_is_blenny()	(machine_arch_type == MACH_TYPE_BLENNY)
+#else
+# define machine_is_blenny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS107
+# endif
+# define machine_is_ds107()	(machine_arch_type == MACH_TYPE_DS107)
+#else
+# define machine_is_ds107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSX07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSX07
+# endif
+# define machine_is_dsx07()	(machine_arch_type == MACH_TYPE_DSX07)
+#else
+# define machine_is_dsx07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM1
+# endif
+# define machine_is_picocom1()	(machine_arch_type == MACH_TYPE_PICOCOM1)
+#else
+# define machine_is_picocom1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LYNX_WOLVERINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LYNX_WOLVERINE
+# endif
+# define machine_is_lynx_wolverine()	(machine_arch_type == MACH_TYPE_LYNX_WOLVERINE)
+#else
+# define machine_is_lynx_wolverine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_SC19
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_SC19
+# endif
+# define machine_is_ubisys_p9_sc19()	(machine_arch_type == MACH_TYPE_UBISYS_P9_SC19)
+#else
+# define machine_is_ubisys_p9_sc19()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRATOS_LOW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRATOS_LOW
+# endif
+# define machine_is_kratos_low()	(machine_arch_type == MACH_TYPE_KRATOS_LOW)
+#else
+# define machine_is_kratos_low()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M700
+# endif
+# define machine_is_m700()	(machine_arch_type == MACH_TYPE_M700)
+#else
+# define machine_is_m700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSLFEMTOCELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSLFEMTOCELL
+# endif
+# define machine_is_hslfemtocell()	(machine_arch_type == MACH_TYPE_HSLFEMTOCELL)
+#else
+# define machine_is_hslfemtocell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAINTREE_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAINTREE_AT91
+# endif
+# define machine_is_daintree_at91()	(machine_arch_type == MACH_TYPE_DAINTREE_AT91)
+#else
+# define machine_is_daintree_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560USB
+# endif
+# define machine_is_sg560usb()	(machine_arch_type == MACH_TYPE_SG560USB)
+#else
+# define machine_is_sg560usb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USR8200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USR8200
+# endif
+# define machine_is_usr8200()	(machine_arch_type == MACH_TYPE_USR8200)
+#else
+# define machine_is_usr8200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S1S65K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S1S65K
+# endif
+# define machine_is_s1s65k()	(machine_arch_type == MACH_TYPE_S1S65K)
+#else
+# define machine_is_s1s65k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S2S65A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S2S65A
+# endif
+# define machine_is_s2s65a()	(machine_arch_type == MACH_TYPE_S2S65A)
+#else
+# define machine_is_s2s65a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICORE
+# endif
+# define machine_is_icore()	(machine_arch_type == MACH_TYPE_ICORE)
+#else
+# define machine_is_icore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BELMONT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BELMONT
+# endif
+# define machine_is_belmont()	(machine_arch_type == MACH_TYPE_BELMONT)
+#else
+# define machine_is_belmont()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP525
+# endif
+# define machine_is_asusp525()	(machine_arch_type == MACH_TYPE_ASUSP525)
+#else
+# define machine_is_asusp525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPXA
+# endif
+# define machine_is_hipxa()	(machine_arch_type == MACH_TYPE_HIPXA)
+#else
+# define machine_is_hipxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M800
+# endif
+# define machine_is_m800()	(machine_arch_type == MACH_TYPE_M800)
+#else
+# define machine_is_m800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA_EVB
+# endif
+# define machine_is_prima_evb()	(machine_arch_type == MACH_TYPE_PRIMA_EVB)
+#else
+# define machine_is_prima_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31BT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31BT1
+# endif
+# define machine_is_mx31bt1()	(machine_arch_type == MACH_TYPE_MX31BT1)
+#else
+# define machine_is_mx31bt1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS4_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS4_EVB
+# endif
+# define machine_is_atlas4_evb()	(machine_arch_type == MACH_TYPE_ATLAS4_EVB)
+#else
+# define machine_is_atlas4_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31CICADA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31CICADA
+# endif
+# define machine_is_mx31cicada()	(machine_arch_type == MACH_TYPE_MX31CICADA)
+#else
+# define machine_is_mx31cicada()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MI424WR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MI424WR
+# endif
+# define machine_is_mi424wr()	(machine_arch_type == MACH_TYPE_MI424WR)
+#else
+# define machine_is_mi424wr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXS_ULTRAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXS_ULTRAX
+# endif
+# define machine_is_axs_ultrax()	(machine_arch_type == MACH_TYPE_AXS_ULTRAX)
+#else
+# define machine_is_axs_ultrax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940DEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940DEB
+# endif
+# define machine_is_at572d940deb()	(machine_arch_type == MACH_TYPE_AT572D940DEB)
+#else
+# define machine_is_at572d940deb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
+# endif
+# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
+#else
+# define machine_is_davinci_da830_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP9302
+# endif
+# define machine_is_ep9302()	(machine_arch_type == MACH_TYPE_EP9302)
+#else
+# define machine_is_ep9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFEB
+# endif
+# define machine_is_at572d940hfek()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
+#else
+# define machine_is_at572d940hfek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBOOK3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBOOK3
+# endif
+# define machine_is_cybook3()	(machine_arch_type == MACH_TYPE_CYBOOK3)
+#else
+# define machine_is_cybook3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WDG002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WDG002
+# endif
+# define machine_is_wdg002()	(machine_arch_type == MACH_TYPE_WDG002)
+#else
+# define machine_is_wdg002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560ADSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560ADSL
+# endif
+# define machine_is_sg560adsl()	(machine_arch_type == MACH_TYPE_SG560ADSL)
+#else
+# define machine_is_sg560adsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXTIO_N2800_ICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTIO_N2800_ICA
+# endif
+# define machine_is_nextio_n2800_ica()	(machine_arch_type == MACH_TYPE_NEXTIO_N2800_ICA)
+#else
+# define machine_is_nextio_n2800_ica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB
+# endif
+# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
+#else
+# define machine_is_dove_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_NEWDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_NEWDB
+# endif
+# define machine_is_marvell_newdb()	(machine_arch_type == MACH_TYPE_MARVELL_NEWDB)
+#else
+# define machine_is_marvell_newdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANDIHUD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANDIHUD
+# endif
+# define machine_is_vandihud()	(machine_arch_type == MACH_TYPE_VANDIHUD)
+#else
+# define machine_is_vandihud()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_E8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_E8
+# endif
+# define machine_is_magx_e8()	(machine_arch_type == MACH_TYPE_MAGX_E8)
+#else
+# define machine_is_magx_e8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_Z6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_Z6
+# endif
+# define machine_is_magx_z6()	(machine_arch_type == MACH_TYPE_MAGX_Z6)
+#else
+# define machine_is_magx_z6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_V8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_V8
+# endif
+# define machine_is_magx_v8()	(machine_arch_type == MACH_TYPE_MAGX_V8)
+#else
+# define machine_is_magx_v8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_U9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_U9
+# endif
+# define machine_is_magx_u9()	(machine_arch_type == MACH_TYPE_MAGX_U9)
+#else
+# define machine_is_magx_u9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUGHCF08
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUGHCF08
+# endif
+# define machine_is_toughcf08()	(machine_arch_type == MACH_TYPE_TOUGHCF08)
+#else
+# define machine_is_toughcf08()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZW4400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZW4400
+# endif
+# define machine_is_zw4400()	(machine_arch_type == MACH_TYPE_ZW4400)
+#else
+# define machine_is_zw4400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARAT91
+# endif
+# define machine_is_marat91()	(machine_arch_type == MACH_TYPE_MARAT91)
+#else
+# define machine_is_marat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27
+# endif
+# define machine_is_imx27()	(machine_arch_type == MACH_TYPE_IMX27)
+#else
+# define machine_is_imx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOOSE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOOSE_DB
+# endif
+# define machine_is_moose_db()	(machine_arch_type == MACH_TYPE_MOOSE_DB)
+#else
+# define machine_is_moose_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FAB4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FAB4
+# endif
+# define machine_is_fab4()	(machine_arch_type == MACH_TYPE_FAB4)
+#else
+# define machine_is_fab4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCDIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCDIAMOND
+# endif
+# define machine_is_htcdiamond()	(machine_arch_type == MACH_TYPE_HTCDIAMOND)
+#else
+# define machine_is_htcdiamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIONA
+# endif
+# define machine_is_fiona()	(machine_arch_type == MACH_TYPE_FIONA)
+#else
+# define machine_is_fiona()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030_X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030_X
+# endif
+# define machine_is_mxc30030_x()	(machine_arch_type == MACH_TYPE_MXC30030_X)
+#else
+# define machine_is_mxc30030_x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BMP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMP1000
+# endif
+# define machine_is_bmp1000()	(machine_arch_type == MACH_TYPE_BMP1000)
+#else
+# define machine_is_bmp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGI9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGI9200
+# endif
+# define machine_is_logi9200()	(machine_arch_type == MACH_TYPE_LOGI9200)
+#else
+# define machine_is_logi9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA31
+# endif
+# define machine_is_tqma31()	(machine_arch_type == MACH_TYPE_TQMA31)
+#else
+# define machine_is_tqma31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9P9215JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9P9215JS
+# endif
+# define machine_is_ccw9p9215js()	(machine_arch_type == MACH_TYPE_CCW9P9215JS)
+#else
+# define machine_is_ccw9p9215js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIFMAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIFMAIN
+# endif
+# define machine_is_sifmain()	(machine_arch_type == MACH_TYPE_SIFMAIN)
+#else
+# define machine_is_sifmain()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9261
+# endif
+# define machine_is_sam9_l9261()	(machine_arch_type == MACH_TYPE_SAM9_L9261)
+#else
+# define machine_is_sam9_l9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9M2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9M2443
+# endif
+# define machine_is_cc9m2443()	(machine_arch_type == MACH_TYPE_CC9M2443)
+#else
+# define machine_is_cc9m2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARIA300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARIA300
+# endif
+# define machine_is_xaria300()	(machine_arch_type == MACH_TYPE_XARIA300)
+#else
+# define machine_is_xaria300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IT9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IT9200
+# endif
+# define machine_is_it9200()	(machine_arch_type == MACH_TYPE_IT9200)
+#else
+# define machine_is_it9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRISS_SENSOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRISS_SENSOR
+# endif
+# define machine_is_kriss_sensor()	(machine_arch_type == MACH_TYPE_KRISS_SENSOR)
+#else
+# define machine_is_kriss_sensor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI5
+# endif
+# define machine_is_pilz_pmi5()	(machine_arch_type == MACH_TYPE_PILZ_PMI5)
+#else
+# define machine_is_pilz_pmi5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADE
+# endif
+# define machine_is_jade()	(machine_arch_type == MACH_TYPE_JADE)
+#else
+# define machine_is_jade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KS8695_SOFTPLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695_SOFTPLC
+# endif
+# define machine_is_ks8695_softplc()	(machine_arch_type == MACH_TYPE_KS8695_SOFTPLC)
+#else
+# define machine_is_ks8695_softplc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPRISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPRISC3
+# endif
+# define machine_is_gprisc3()	(machine_arch_type == MACH_TYPE_GPRISC3)
+#else
+# define machine_is_gprisc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6430
+# endif
+# define machine_is_smdk6430()	(machine_arch_type == MACH_TYPE_SMDK6430)
+#else
+# define machine_is_smdk6430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTER_EYECAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTER_EYECAM
+# endif
+# define machine_is_deister_eyecam()	(machine_arch_type == MACH_TYPE_DEISTER_EYECAM)
+#else
+# define machine_is_deister_eyecam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRODUO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRODUO
+# endif
+# define machine_is_linkstation_produo()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRODUO)
+#else
+# define machine_is_linkstation_produo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIT_B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIT_B0
+# endif
+# define machine_is_hit_b0()	(machine_arch_type == MACH_TYPE_HIT_B0)
+#else
+# define machine_is_hit_b0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_RMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_RMU
+# endif
+# define machine_is_adx_rmu()	(machine_arch_type == MACH_TYPE_ADX_RMU)
+#else
+# define machine_is_adx_rmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XG_CPE_MAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XG_CPE_MAIN
+# endif
+# define machine_is_xg_cpe_main()	(machine_arch_type == MACH_TYPE_XG_CPE_MAIN)
+#else
+# define machine_is_xg_cpe_main()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9407A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9407A
+# endif
+# define machine_is_edb9407a()	(machine_arch_type == MACH_TYPE_EDB9407A)
+#else
+# define machine_is_edb9407a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DTB9608
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DTB9608
+# endif
+# define machine_is_dtb9608()	(machine_arch_type == MACH_TYPE_DTB9608)
+#else
+# define machine_is_dtb9608()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM104V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM104V1
+# endif
+# define machine_is_em104v1()	(machine_arch_type == MACH_TYPE_EM104V1)
+#else
+# define machine_is_em104v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEMO
+# endif
+# define machine_is_demo()	(machine_arch_type == MACH_TYPE_DEMO)
+#else
+# define machine_is_demo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGI9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGI9260
+# endif
+# define machine_is_logi9260()	(machine_arch_type == MACH_TYPE_LOGI9260)
+#else
+# define machine_is_logi9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_EXM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_EXM32
+# endif
+# define machine_is_mx31_exm32()	(machine_arch_type == MACH_TYPE_MX31_EXM32)
+#else
+# define machine_is_mx31_exm32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9G20
+# endif
+# define machine_is_usb_a9g20()	(machine_arch_type == MACH_TYPE_USB_A9G20)
+#else
+# define machine_is_usb_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICPROJE2008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICPROJE2008
+# endif
+# define machine_is_picproje2008()	(machine_arch_type == MACH_TYPE_PICPROJE2008)
+#else
+# define machine_is_picproje2008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_E9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_E9315
+# endif
+# define machine_is_cs_e9315()	(machine_arch_type == MACH_TYPE_CS_E9315)
+#else
+# define machine_is_cs_e9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9G20
+# endif
+# define machine_is_qil_a9g20()	(machine_arch_type == MACH_TYPE_QIL_A9G20)
+#else
+# define machine_is_qil_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON020
+# endif
+# define machine_is_sha_pon020()	(machine_arch_type == MACH_TYPE_SHA_PON020)
+#else
+# define machine_is_sha_pon020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAD
+# endif
+# define machine_is_nad()	(machine_arch_type == MACH_TYPE_NAD)
+#else
+# define machine_is_nad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC35_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC35_A9260
+# endif
+# define machine_is_sbc35_a9260()	(machine_arch_type == MACH_TYPE_SBC35_A9260)
+#else
+# define machine_is_sbc35_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC35_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC35_A9G20
+# endif
+# define machine_is_sbc35_a9g20()	(machine_arch_type == MACH_TYPE_SBC35_A9G20)
+#else
+# define machine_is_sbc35_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_BEGINNING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_BEGINNING
+# endif
+# define machine_is_davinci_beginning()	(machine_arch_type == MACH_TYPE_DAVINCI_BEGINNING)
+#else
+# define machine_is_davinci_beginning()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWC
+# endif
+# define machine_is_uwc()	(machine_arch_type == MACH_TYPE_UWC)
+#else
+# define machine_is_uwc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCNIKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCNIKE
+# endif
+# define machine_is_htcnike()	(machine_arch_type == MACH_TYPE_HTCNIKE)
+#else
+# define machine_is_htcnike()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTER_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTER_PXA270
+# endif
+# define machine_is_deister_pxa270()	(machine_arch_type == MACH_TYPE_DEISTER_PXA270)
+#else
+# define machine_is_deister_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CME9210JS
+# endif
+# define machine_is_cme9210js()	(machine_arch_type == MACH_TYPE_CME9210JS)
+#else
+# define machine_is_cme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360
+# endif
+# define machine_is_cc9p9360()	(machine_arch_type == MACH_TYPE_CC9P9360)
+#else
+# define machine_is_cc9p9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOCHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOCHA
+# endif
+# define machine_is_mocha()	(machine_arch_type == MACH_TYPE_MOCHA)
+#else
+# define machine_is_mocha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WAPD170AG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WAPD170AG
+# endif
+# define machine_is_wapd170ag()	(machine_arch_type == MACH_TYPE_WAPD170AG)
+#else
+# define machine_is_wapd170ag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90X900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90X900
+# endif
+# define machine_is_w90x900()	(machine_arch_type == MACH_TYPE_W90X900)
+#else
+# define machine_is_w90x900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90X700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90X700
+# endif
+# define machine_is_w90x700()	(machine_arch_type == MACH_TYPE_W90X700)
+#else
+# define machine_is_w90x700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT300IP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT300IP
+# endif
+# define machine_is_kt300ip()	(machine_arch_type == MACH_TYPE_KT300IP)
+#else
+# define machine_is_kt300ip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT300IP_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT300IP_G20
+# endif
+# define machine_is_kt300ip_g20()	(machine_arch_type == MACH_TYPE_KT300IP_G20)
+#else
+# define machine_is_kt300ip_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRCM
+# endif
+# define machine_is_srcm()	(machine_arch_type == MACH_TYPE_SRCM)
+#else
+# define machine_is_srcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLNX_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLNX_9260
+# endif
+# define machine_is_wlnx_9260()	(machine_arch_type == MACH_TYPE_WLNX_9260)
+#else
+# define machine_is_wlnx_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENMOKO_GTA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENMOKO_GTA03
+# endif
+# define machine_is_openmoko_gta03()	(machine_arch_type == MACH_TYPE_OPENMOKO_GTA03)
+#else
+# define machine_is_openmoko_gta03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSPREY2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSPREY2
+# endif
+# define machine_is_osprey2()	(machine_arch_type == MACH_TYPE_OSPREY2)
+#else
+# define machine_is_osprey2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBIO9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBIO9260
+# endif
+# define machine_is_kbio9260()	(machine_arch_type == MACH_TYPE_KBIO9260)
+#else
+# define machine_is_kbio9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GINZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GINZA
+# endif
+# define machine_is_ginza()	(machine_arch_type == MACH_TYPE_GINZA)
+#else
+# define machine_is_ginza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A636N
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A636N
+# endif
+# define machine_is_a636n()	(machine_arch_type == MACH_TYPE_A636N)
+#else
+# define machine_is_a636n()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEMOC
+# endif
+# define machine_is_nemoc()	(machine_arch_type == MACH_TYPE_NEMOC)
+#else
+# define machine_is_nemoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA
+# endif
+# define machine_is_geneva()	(machine_arch_type == MACH_TYPE_GENEVA)
+#else
+# define machine_is_geneva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPHAROS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPHAROS
+# endif
+# define machine_is_htcpharos()	(machine_arch_type == MACH_TYPE_HTCPHAROS)
+#else
+# define machine_is_htcpharos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEONC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEONC
+# endif
+# define machine_is_neonc()	(machine_arch_type == MACH_TYPE_NEONC)
+#else
+# define machine_is_neonc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS7100
+# endif
+# define machine_is_nas7100()	(machine_arch_type == MACH_TYPE_NAS7100)
+#else
+# define machine_is_nas7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEUPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEUPHONE
+# endif
+# define machine_is_teuphone()	(machine_arch_type == MACH_TYPE_TEUPHONE)
+#else
+# define machine_is_teuphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_ETH2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_ETH2
+# endif
+# define machine_is_annax_eth2()	(machine_arch_type == MACH_TYPE_ANNAX_ETH2)
+#else
+# define machine_is_annax_eth2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB733
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB733
+# endif
+# define machine_is_csb733()	(machine_arch_type == MACH_TYPE_CSB733)
+#else
+# define machine_is_csb733()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BK3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BK3
+# endif
+# define machine_is_bk3()	(machine_arch_type == MACH_TYPE_BK3)
+#else
+# define machine_is_bk3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_EM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_EM32
+# endif
+# define machine_is_omap_em32()	(machine_arch_type == MACH_TYPE_OMAP_EM32)
+#else
+# define machine_is_omap_em32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ET9261CP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ET9261CP
+# endif
+# define machine_is_et9261cp()	(machine_arch_type == MACH_TYPE_ET9261CP)
+#else
+# define machine_is_et9261cp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JASPERC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPERC
+# endif
+# define machine_is_jasperc()	(machine_arch_type == MACH_TYPE_JASPERC)
+#else
+# define machine_is_jasperc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISSI_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISSI_ARM9
+# endif
+# define machine_is_issi_arm9()	(machine_arch_type == MACH_TYPE_ISSI_ARM9)
+#else
+# define machine_is_issi_arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UED
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UED
+# endif
+# define machine_is_ued()	(machine_arch_type == MACH_TYPE_UED)
+#else
+# define machine_is_ued()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESIBLADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESIBLADE
+# endif
+# define machine_is_esiblade()	(machine_arch_type == MACH_TYPE_ESIBLADE)
+#else
+# define machine_is_esiblade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EYE02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EYE02
+# endif
+# define machine_is_eye02()	(machine_arch_type == MACH_TYPE_EYE02)
+#else
+# define machine_is_eye02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27KBD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27KBD
+# endif
+# define machine_is_imx27kbd()	(machine_arch_type == MACH_TYPE_IMX27KBD)
+#else
+# define machine_is_imx27kbd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SST61VC010_FPGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SST61VC010_FPGA
+# endif
+# define machine_is_sst61vc010_fpga()	(machine_arch_type == MACH_TYPE_SST61VC010_FPGA)
+#else
+# define machine_is_sst61vc010_fpga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXVP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXVP435
+# endif
+# define machine_is_kixvp435()	(machine_arch_type == MACH_TYPE_KIXVP435)
+#else
+# define machine_is_kixvp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXNP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXNP435
+# endif
+# define machine_is_kixnp435()	(machine_arch_type == MACH_TYPE_KIXNP435)
+#else
+# define machine_is_kixnp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFRICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFRICA
+# endif
+# define machine_is_africa()	(machine_arch_type == MACH_TYPE_AFRICA)
+#else
+# define machine_is_africa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NH233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NH233
+# endif
+# define machine_is_nh233()	(machine_arch_type == MACH_TYPE_NH233)
+#else
+# define machine_is_nh233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM4760
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM4760
+# endif
+# define machine_is_bcm4760()	(machine_arch_type == MACH_TYPE_BCM4760)
+#else
+# define machine_is_bcm4760()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDDY_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDDY_V2
+# endif
+# define machine_is_eddy_v2()	(machine_arch_type == MACH_TYPE_EDDY_V2)
+#else
+# define machine_is_eddy_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HID_A7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HID_A7
+# endif
+# define machine_is_hid_a7()	(machine_arch_type == MACH_TYPE_HID_A7)
+#else
+# define machine_is_hid_a7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERO
+# endif
+# define machine_is_hero()	(machine_arch_type == MACH_TYPE_HERO)
+#else
+# define machine_is_hero()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_POSEIDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_POSEIDON
+# endif
+# define machine_is_omap_poseidon()	(machine_arch_type == MACH_TYPE_OMAP_POSEIDON)
+#else
+# define machine_is_omap_poseidon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAKO
+# endif
+# define machine_is_mako()	(machine_arch_type == MACH_TYPE_MAKO)
+#else
+# define machine_is_mako()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XDAFLAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDAFLAME
+# endif
+# define machine_is_xdaflame()	(machine_arch_type == MACH_TYPE_XDAFLAME)
+#else
+# define machine_is_xdaflame()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC2
+# endif
+# define machine_is_phidget_sbc2()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC2)
+#else
+# define machine_is_phidget_sbc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIMESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIMESTONE
+# endif
+# define machine_is_limestone()	(machine_arch_type == MACH_TYPE_LIMESTONE)
+#else
+# define machine_is_limestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPROBE_C32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPROBE_C32
+# endif
+# define machine_is_iprobe_c32()	(machine_arch_type == MACH_TYPE_IPROBE_C32)
+#else
+# define machine_is_iprobe_c32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP535
+# endif
+# define machine_is_asusp535()	(machine_arch_type == MACH_TYPE_ASUSP535)
+#else
+# define machine_is_asusp535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL
+# endif
+# define machine_is_htcraphael()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL)
+#else
+# define machine_is_htcraphael()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG1
+# endif
+# define machine_is_sygdg1()	(machine_arch_type == MACH_TYPE_SYGDG1)
+#else
+# define machine_is_sygdg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG2
+# endif
+# define machine_is_sygdg2()	(machine_arch_type == MACH_TYPE_SYGDG2)
+#else
+# define machine_is_sygdg2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEOUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEOUL
+# endif
+# define machine_is_seoul()	(machine_arch_type == MACH_TYPE_SEOUL)
+#else
+# define machine_is_seoul()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALERNO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALERNO
+# endif
+# define machine_is_salerno()	(machine_arch_type == MACH_TYPE_SALERNO)
+#else
+# define machine_is_salerno()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCN_S3C64XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCN_S3C64XX
+# endif
+# define machine_is_ucn_s3c64xx()	(machine_arch_type == MACH_TYPE_UCN_S3C64XX)
+#else
+# define machine_is_ucn_s3c64xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7201A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7201A
+# endif
+# define machine_is_msm7201a()	(machine_arch_type == MACH_TYPE_MSM7201A)
+#else
+# define machine_is_msm7201a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPR1
+# endif
+# define machine_is_lpr1()	(machine_arch_type == MACH_TYPE_LPR1)
+#else
+# define machine_is_lpr1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO500FX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO500FX
+# endif
+# define machine_is_armadillo500fx()	(machine_arch_type == MACH_TYPE_ARMADILLO500FX)
+#else
+# define machine_is_armadillo500fx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_DM355
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_DM355
+# endif
+# define machine_is_z3_dm355()	(machine_arch_type == MACH_TYPE_Z3_DM355)
+#else
+# define machine_is_z3_dm355()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P920EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P920EVB
+# endif
+# define machine_is_w90p920evb()	(machine_arch_type == MACH_TYPE_W90P920EVB)
+#else
+# define machine_is_w90p920evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAMHD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMHD
+# endif
+# define machine_is_camhd()	(machine_arch_type == MACH_TYPE_CAMHD)
+#else
+# define machine_is_camhd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MVC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVC100
+# endif
+# define machine_is_mvc100()	(machine_arch_type == MACH_TYPE_MVC100)
+#else
+# define machine_is_mvc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELECTRUM_200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELECTRUM_200
+# endif
+# define machine_is_electrum_200()	(machine_arch_type == MACH_TYPE_ELECTRUM_200)
+#else
+# define machine_is_electrum_200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCJADE
+# endif
+# define machine_is_htcjade()	(machine_arch_type == MACH_TYPE_HTCJADE)
+#else
+# define machine_is_htcjade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEMPHIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEMPHIS
+# endif
+# define machine_is_memphis()	(machine_arch_type == MACH_TYPE_MEMPHIS)
+#else
+# define machine_is_memphis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27SBC
+# endif
+# define machine_is_imx27sbc()	(machine_arch_type == MACH_TYPE_IMX27SBC)
+#else
+# define machine_is_imx27sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXTAR
+# endif
+# define machine_is_lextar()	(machine_arch_type == MACH_TYPE_LEXTAR)
+#else
+# define machine_is_lextar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z32AN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z32AN
+# endif
+# define machine_is_z32an_series()	(machine_arch_type == MACH_TYPE_Z32AN)
+#else
+# define machine_is_z32an_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TMQ_CAPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TMQ_CAPD
+# endif
+# define machine_is_tmq_capd()	(machine_arch_type == MACH_TYPE_TMQ_CAPD)
+#else
+# define machine_is_tmq_capd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WL
+# endif
+# define machine_is_omap3_wl()	(machine_arch_type == MACH_TYPE_OMAP3_WL)
+#else
+# define machine_is_omap3_wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUMBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUMBY
+# endif
+# define machine_is_chumby()	(machine_arch_type == MACH_TYPE_CHUMBY)
+#else
+# define machine_is_chumby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATSARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATSARM9
+# endif
+# define machine_is_atsarm9()	(machine_arch_type == MACH_TYPE_ATSARM9)
+#else
+# define machine_is_atsarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BAHAMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAHAMAS
+# endif
+# define machine_is_bahamas()	(machine_arch_type == MACH_TYPE_BAHAMAS)
+#else
+# define machine_is_bahamas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAS
+# endif
+# define machine_is_das()	(machine_arch_type == MACH_TYPE_DAS)
+#else
+# define machine_is_das()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIDAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIDAS
+# endif
+# define machine_is_minidas()	(machine_arch_type == MACH_TYPE_MINIDAS)
+#else
+# define machine_is_minidas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VK1000
+# endif
+# define machine_is_vk1000()	(machine_arch_type == MACH_TYPE_VK1000)
+#else
+# define machine_is_vk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY
+# endif
+# define machine_is_ctera_2bay()	(machine_arch_type == MACH_TYPE_CTERA_2BAY)
+#else
+# define machine_is_ctera_2bay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGECONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGECONNECT
+# endif
+# define machine_is_edgeconnect()	(machine_arch_type == MACH_TYPE_EDGECONNECT)
+#else
+# define machine_is_edgeconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ND27000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ND27000
+# endif
+# define machine_is_nd27000()	(machine_arch_type == MACH_TYPE_ND27000)
+#else
+# define machine_is_nd27000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMALTO_COBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMALTO_COBRA
+# endif
+# define machine_is_cobra()	(machine_arch_type == MACH_TYPE_GEMALTO_COBRA)
+#else
+# define machine_is_cobra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INGELABS_COMET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INGELABS_COMET
+# endif
+# define machine_is_ingelabs_comet()	(machine_arch_type == MACH_TYPE_INGELABS_COMET)
+#else
+# define machine_is_ingelabs_comet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLLUX_WIZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLLUX_WIZ
+# endif
+# define machine_is_pollux_wiz()	(machine_arch_type == MACH_TYPE_POLLUX_WIZ)
+#else
+# define machine_is_pollux_wiz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKSTONE
+# endif
+# define machine_is_blackstone()	(machine_arch_type == MACH_TYPE_BLACKSTONE)
+#else
+# define machine_is_blackstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPAZ
+# endif
+# define machine_is_topaz()	(machine_arch_type == MACH_TYPE_TOPAZ)
+#else
+# define machine_is_topaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIXLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIXLE
+# endif
+# define machine_is_aixle()	(machine_arch_type == MACH_TYPE_AIXLE)
+#else
+# define machine_is_aixle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MW998
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MW998
+# endif
+# define machine_is_mw998()	(machine_arch_type == MACH_TYPE_MW998)
+#else
+# define machine_is_mw998()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSC5605EV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSC5605EV
+# endif
+# define machine_is_vsc5605ev()	(machine_arch_type == MACH_TYPE_VSC5605EV)
+#else
+# define machine_is_vsc5605ev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NT98700DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NT98700DK
+# endif
+# define machine_is_nt98700dk()	(machine_arch_type == MACH_TYPE_NT98700DK)
+#else
+# define machine_is_nt98700dk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTACT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTACT
+# endif
+# define machine_is_icontact()	(machine_arch_type == MACH_TYPE_ICONTACT)
+#else
+# define machine_is_icontact()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_FRCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_FRCPU
+# endif
+# define machine_is_swarco_frcpu()	(machine_arch_type == MACH_TYPE_SWARCO_FRCPU)
+#else
+# define machine_is_swarco_frcpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_SCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_SCPU
+# endif
+# define machine_is_swarco_scpu()	(machine_arch_type == MACH_TYPE_SWARCO_SCPU)
+#else
+# define machine_is_swarco_scpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBOX_P16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBOX_P16
+# endif
+# define machine_is_bbox_p16()	(machine_arch_type == MACH_TYPE_BBOX_P16)
+#else
+# define machine_is_bbox_p16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSTD
+# endif
+# define machine_is_bstd()	(machine_arch_type == MACH_TYPE_BSTD)
+#else
+# define machine_is_bstd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2440II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2440II
+# endif
+# define machine_is_sbc2440ii()	(machine_arch_type == MACH_TYPE_SBC2440II)
+#else
+# define machine_is_sbc2440ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM034
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM034
+# endif
+# define machine_is_pcm034()	(machine_arch_type == MACH_TYPE_PCM034)
+#else
+# define machine_is_pcm034()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NESO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESO
+# endif
+# define machine_is_neso()	(machine_arch_type == MACH_TYPE_NESO)
+#else
+# define machine_is_neso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLNX_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLNX_9G20
+# endif
+# define machine_is_wlnx_9g20()	(machine_arch_type == MACH_TYPE_WLNX_9G20)
+#else
+# define machine_is_wlnx_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOTEMNOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTEMNOVA
+# endif
+# define machine_is_totemnova()	(machine_arch_type == MACH_TYPE_TOTEMNOVA)
+#else
+# define machine_is_totemnova()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C5000
+# endif
+# define machine_is_c5000()	(machine_arch_type == MACH_TYPE_C5000)
+#else
+# define machine_is_c5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIPO_AT91SAM9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIPO_AT91SAM9263
+# endif
+# define machine_is_unipo_at91sam9263()	(machine_arch_type == MACH_TYPE_UNIPO_AT91SAM9263)
+#else
+# define machine_is_unipo_at91sam9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERNUT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERNUT5
+# endif
+# define machine_is_ethernut5()	(machine_arch_type == MACH_TYPE_ETHERNUT5)
+#else
+# define machine_is_ethernut5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM11
+# endif
+# define machine_is_arm11()	(machine_arch_type == MACH_TYPE_ARM11)
+#else
+# define machine_is_arm11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUPXA255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUPXA255
+# endif
+# define machine_is_cpupxa255()	(machine_arch_type == MACH_TYPE_CPUPXA255)
+#else
+# define machine_is_cpupxa255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUIMX27
+# endif
+# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_CPUIMX27)
+#else
+# define machine_is_eukrea_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEFLUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEFLUX
+# endif
+# define machine_is_cheflux()	(machine_arch_type == MACH_TYPE_CHEFLUX)
+#else
+# define machine_is_cheflux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB_CPUX9K2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB_CPUX9K2
+# endif
+# define machine_is_eb_cpux9k2()	(machine_arch_type == MACH_TYPE_EB_CPUX9K2)
+#else
+# define machine_is_eb_cpux9k2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPCOTEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPCOTEC
+# endif
+# define machine_is_opcotec()	(machine_arch_type == MACH_TYPE_OPCOTEC)
+#else
+# define machine_is_opcotec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YT
+# endif
+# define machine_is_yt()	(machine_arch_type == MACH_TYPE_YT)
+#else
+# define machine_is_yt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOQ
+# endif
+# define machine_is_motoq()	(machine_arch_type == MACH_TYPE_MOTOQ)
+#else
+# define machine_is_motoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSB1
+# endif
+# define machine_is_bsb1()	(machine_arch_type == MACH_TYPE_BSB1)
+#else
+# define machine_is_bsb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILAN
+# endif
+# define machine_is_milan()	(machine_arch_type == MACH_TYPE_MILAN)
+#else
+# define machine_is_milan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUARTZV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUARTZV2
+# endif
+# define machine_is_quartzv2()	(machine_arch_type == MACH_TYPE_QUARTZV2)
+#else
+# define machine_is_quartzv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSVP
+# endif
+# define machine_is_rsvp()	(machine_arch_type == MACH_TYPE_RSVP)
+#else
+# define machine_is_rsvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMP200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMP200
+# endif
+# define machine_is_rmp200()	(machine_arch_type == MACH_TYPE_RMP200)
+#else
+# define machine_is_rmp200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCM
+# endif
+# define machine_is_adsgcm()	(machine_arch_type == MACH_TYPE_ADSGCM)
+#else
+# define machine_is_adsgcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASE2_400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASE2_400
+# endif
+# define machine_is_ase2_400()	(machine_arch_type == MACH_TYPE_ASE2_400)
+#else
+# define machine_is_ase2_400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIZZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIZZA
+# endif
+# define machine_is_pizza()	(machine_arch_type == MACH_TYPE_PIZZA)
+#else
+# define machine_is_pizza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPOT_NGPL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT_NGPL
+# endif
+# define machine_is_spot_ngpl()	(machine_arch_type == MACH_TYPE_SPOT_NGPL)
+#else
+# define machine_is_spot_ngpl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMATA
+# endif
+# define machine_is_armata()	(machine_arch_type == MACH_TYPE_ARMATA)
+#else
+# define machine_is_armata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31SF005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31SF005
+# endif
+# define machine_is_mx31sf005()	(machine_arch_type == MACH_TYPE_MX31SF005)
+#else
+# define machine_is_mx31sf005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_F5D8231_4_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_F5D8231_4_V2
+# endif
+# define machine_is_f5d8231_4_v2()	(machine_arch_type == MACH_TYPE_F5D8231_4_V2)
+#else
+# define machine_is_f5d8231_4_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Q2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Q2440
+# endif
+# define machine_is_q2440()	(machine_arch_type == MACH_TYPE_Q2440)
+#else
+# define machine_is_q2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QQ2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QQ2440
+# endif
+# define machine_is_qq2440()	(machine_arch_type == MACH_TYPE_QQ2440)
+#else
+# define machine_is_qq2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADES
+# endif
+# define machine_is_jades()	(machine_arch_type == MACH_TYPE_JADES)
+#else
+# define machine_is_jades()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARK
+# endif
+# define machine_is_spark()	(machine_arch_type == MACH_TYPE_SPARK)
+#else
+# define machine_is_spark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZINA
+# endif
+# define machine_is_benzina()	(machine_arch_type == MACH_TYPE_BENZINA)
+#else
+# define machine_is_benzina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLAZE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLAZE
+# endif
+# define machine_is_blaze()	(machine_arch_type == MACH_TYPE_BLAZE)
+#else
+# define machine_is_blaze()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCVENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCVENUS
+# endif
+# define machine_is_htckovsky()	(machine_arch_type == MACH_TYPE_HTCVENUS)
+#else
+# define machine_is_htckovsky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONY_PRS505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONY_PRS505
+# endif
+# define machine_is_sony_prs505()	(machine_arch_type == MACH_TYPE_SONY_PRS505)
+#else
+# define machine_is_sony_prs505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HANLIN_V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HANLIN_V3
+# endif
+# define machine_is_hanlin_v3()	(machine_arch_type == MACH_TYPE_HANLIN_V3)
+#else
+# define machine_is_hanlin_v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRA
+# endif
+# define machine_is_sapphira()	(machine_arch_type == MACH_TYPE_SAPPHIRA)
+#else
+# define machine_is_sapphira()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DACK_SDA_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DACK_SDA_01
+# endif
+# define machine_is_dack_sda_01()	(machine_arch_type == MACH_TYPE_DACK_SDA_01)
+#else
+# define machine_is_dack_sda_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMBOX
+# endif
+# define machine_is_armbox()	(machine_arch_type == MACH_TYPE_ARMBOX)
+#else
+# define machine_is_armbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARRIS_RVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARRIS_RVP
+# endif
+# define machine_is_harris_rvp()	(machine_arch_type == MACH_TYPE_HARRIS_RVP)
+#else
+# define machine_is_harris_rvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIBALDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIBALDO
+# endif
+# define machine_is_ribaldo()	(machine_arch_type == MACH_TYPE_RIBALDO)
+#else
+# define machine_is_ribaldo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AGORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AGORA
+# endif
+# define machine_is_agora()	(machine_arch_type == MACH_TYPE_AGORA)
+#else
+# define machine_is_agora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_MINI
+# endif
+# define machine_is_omap3_mini()	(machine_arch_type == MACH_TYPE_OMAP3_MINI)
+#else
+# define machine_is_omap3_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9SAM6432_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9SAM6432_B
+# endif
+# define machine_is_a9sam6432_b()	(machine_arch_type == MACH_TYPE_A9SAM6432_B)
+#else
+# define machine_is_a9sam6432_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USG2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USG2410
+# endif
+# define machine_is_usg2410()	(machine_arch_type == MACH_TYPE_USG2410)
+#else
+# define machine_is_usg2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC72052_I10_REVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC72052_I10_REVB
+# endif
+# define machine_is_pc72052_i10_revb()	(machine_arch_type == MACH_TYPE_PC72052_I10_REVB)
+#else
+# define machine_is_pc72052_i10_revb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_EXM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_EXM32
+# endif
+# define machine_is_mx35_exm32()	(machine_arch_type == MACH_TYPE_MX35_EXM32)
+#else
+# define machine_is_mx35_exm32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPAS910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPAS910
+# endif
+# define machine_is_topas910()	(machine_arch_type == MACH_TYPE_TOPAS910)
+#else
+# define machine_is_topas910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYENA
+# endif
+# define machine_is_hyena()	(machine_arch_type == MACH_TYPE_HYENA)
+#else
+# define machine_is_hyena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POSPAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSPAX
+# endif
+# define machine_is_pospax()	(machine_arch_type == MACH_TYPE_POSPAX)
+#else
+# define machine_is_pospax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GX
+# endif
+# define machine_is_hdl_gx()	(machine_arch_type == MACH_TYPE_HDL_GX)
+#else
+# define machine_is_hdl_gx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_4BAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_4BAY
+# endif
+# define machine_is_ctera_4bay()	(machine_arch_type == MACH_TYPE_CTERA_4BAY)
+#else
+# define machine_is_ctera_4bay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C
+# endif
+# define machine_is_ctera_plug_c()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C)
+#else
+# define machine_is_ctera_plug_c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRWEA_PLUG_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRWEA_PLUG_I
+# endif
+# define machine_is_crwea_plug_i()	(machine_arch_type == MACH_TYPE_CRWEA_PLUG_I)
+#else
+# define machine_is_crwea_plug_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EGAUGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EGAUGE2
+# endif
+# define machine_is_egauge2()	(machine_arch_type == MACH_TYPE_EGAUGE2)
+#else
+# define machine_is_egauge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIDJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIDJ
+# endif
+# define machine_is_didj()	(machine_arch_type == MACH_TYPE_DIDJ)
+#else
+# define machine_is_didj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEISTER
+# endif
+# define machine_is_m_s3c2443()	(machine_arch_type == MACH_TYPE_MEISTER)
+#else
+# define machine_is_m_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBLACKSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBLACKSTONE
+# endif
+# define machine_is_htcblackstone()	(machine_arch_type == MACH_TYPE_HTCBLACKSTONE)
+#else
+# define machine_is_htcblackstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_35XX_MVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_35XX_MVP
+# endif
+# define machine_is_omap_35xx_mvp()	(machine_arch_type == MACH_TYPE_OMAP_35XX_MVP)
+#else
+# define machine_is_omap_35xx_mvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_I
+# endif
+# define machine_is_ctera_plug_i()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_I)
+#else
+# define machine_is_ctera_plug_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVG610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVG610
+# endif
+# define machine_is_pvg610_100()	(machine_arch_type == MACH_TYPE_PVG610)
+#else
+# define machine_is_pvg610_100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPRW6815
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPRW6815
+# endif
+# define machine_is_hprw6815()	(machine_arch_type == MACH_TYPE_HPRW6815)
+#else
+# define machine_is_hprw6815()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_OSWALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_OSWALD
+# endif
+# define machine_is_omap3_oswald()	(machine_arch_type == MACH_TYPE_OMAP3_OSWALD)
+#else
+# define machine_is_omap3_oswald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_CDMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_CDMA
+# endif
+# define machine_is_htcraphael_cdma()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_CDMA)
+#else
+# define machine_is_htcraphael_cdma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCDIAMOND_CDMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCDIAMOND_CDMA
+# endif
+# define machine_is_htcdiamond_cdma()	(machine_arch_type == MACH_TYPE_HTCDIAMOND_CDMA)
+#else
+# define machine_is_htcdiamond_cdma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCALER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCALER
+# endif
+# define machine_is_scaler()	(machine_arch_type == MACH_TYPE_SCALER)
+#else
+# define machine_is_scaler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON
+# endif
+# define machine_is_teton()	(machine_arch_type == MACH_TYPE_TETON)
+#else
+# define machine_is_teton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BISHOP2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BISHOP2
+# endif
+# define machine_is_bishop2()	(machine_arch_type == MACH_TYPE_BISHOP2)
+#else
+# define machine_is_bishop2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPPV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPPV5
+# endif
+# define machine_is_ippv5()	(machine_arch_type == MACH_TYPE_IPPV5)
+#else
+# define machine_is_ippv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARM926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARM926
+# endif
+# define machine_is_farm926()	(machine_arch_type == MACH_TYPE_FARM926)
+#else
+# define machine_is_farm926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMCCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMCCPU
+# endif
+# define machine_is_mmccpu()	(machine_arch_type == MACH_TYPE_MMCCPU)
+#else
+# define machine_is_mmccpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGMSFL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGMSFL
+# endif
+# define machine_is_sgmsfl()	(machine_arch_type == MACH_TYPE_SGMSFL)
+#else
+# define machine_is_sgmsfl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT8000
+# endif
+# define machine_is_tt8000()	(machine_arch_type == MACH_TYPE_TT8000)
+#else
+# define machine_is_tt8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZRN4300LP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZRN4300LP
+# endif
+# define machine_is_zrn4300lp()	(machine_arch_type == MACH_TYPE_ZRN4300LP)
+#else
+# define machine_is_zrn4300lp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPTC
+# endif
+# define machine_is_mptc()	(machine_arch_type == MACH_TYPE_MPTC)
+#else
+# define machine_is_mptc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6051
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6051
+# endif
+# define machine_is_h6051()	(machine_arch_type == MACH_TYPE_H6051)
+#else
+# define machine_is_h6051()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVG610_101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVG610_101
+# endif
+# define machine_is_pvg610_101()	(machine_arch_type == MACH_TYPE_PVG610_101)
+#else
+# define machine_is_pvg610_101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9261_PC_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9261_PC_EVB
+# endif
+# define machine_is_stamp9261_pc_evb()	(machine_arch_type == MACH_TYPE_STAMP9261_PC_EVB)
+#else
+# define machine_is_stamp9261_pc_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ODYSSEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ODYSSEUS
+# endif
+# define machine_is_pelco_odysseus()	(machine_arch_type == MACH_TYPE_PELCO_ODYSSEUS)
+#else
+# define machine_is_pelco_odysseus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9260
+# endif
+# define machine_is_tny_a9260()	(machine_arch_type == MACH_TYPE_TNY_A9260)
+#else
+# define machine_is_tny_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9G20
+# endif
+# define machine_is_tny_a9g20()	(machine_arch_type == MACH_TYPE_TNY_A9G20)
+#else
+# define machine_is_tny_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AESOP_MP2530F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AESOP_MP2530F
+# endif
+# define machine_is_aesop_mp2530f()	(machine_arch_type == MACH_TYPE_AESOP_MP2530F)
+#else
+# define machine_is_aesop_mp2530f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DX900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DX900
+# endif
+# define machine_is_dx900()	(machine_arch_type == MACH_TYPE_DX900)
+#else
+# define machine_is_dx900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPODC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPODC2
+# endif
+# define machine_is_cpodc2()	(machine_arch_type == MACH_TYPE_CPODC2)
+#else
+# define machine_is_cpodc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TILT_8925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TILT_8925
+# endif
+# define machine_is_tilt_8925()	(machine_arch_type == MACH_TYPE_TILT_8925)
+#else
+# define machine_is_tilt_8925()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM357_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM357_EVM
+# endif
+# define machine_is_davinci_dm357_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM357_EVM)
+#else
+# define machine_is_davinci_dm357_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWORDFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWORDFISH
+# endif
+# define machine_is_swordfish()	(machine_arch_type == MACH_TYPE_SWORDFISH)
+#else
+# define machine_is_swordfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORVUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORVUS
+# endif
+# define machine_is_corvus()	(machine_arch_type == MACH_TYPE_CORVUS)
+#else
+# define machine_is_corvus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAURUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAURUS
+# endif
+# define machine_is_taurus()	(machine_arch_type == MACH_TYPE_TAURUS)
+#else
+# define machine_is_taurus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXM
+# endif
+# define machine_is_axm()	(machine_arch_type == MACH_TYPE_AXM)
+#else
+# define machine_is_axm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXC
+# endif
+# define machine_is_axc()	(machine_arch_type == MACH_TYPE_AXC)
+#else
+# define machine_is_axc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BABY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BABY
+# endif
+# define machine_is_baby()	(machine_arch_type == MACH_TYPE_BABY)
+#else
+# define machine_is_baby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP200
+# endif
+# define machine_is_mp200()	(machine_arch_type == MACH_TYPE_MP200)
+#else
+# define machine_is_mp200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HANLIN_V3C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HANLIN_V3C
+# endif
+# define machine_is_hanlin_v3c()	(machine_arch_type == MACH_TYPE_HANLIN_V3C)
+#else
+# define machine_is_hanlin_v3c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBK9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBK9G20
+# endif
+# define machine_is_kbk9g20()	(machine_arch_type == MACH_TYPE_KBK9G20)
+#else
+# define machine_is_kbk9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSTURBOG5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSTURBOG5
+# endif
+# define machine_is_adsturbog5()	(machine_arch_type == MACH_TYPE_ADSTURBOG5)
+#else
+# define machine_is_adsturbog5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGER_LITE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGER_LITE1
+# endif
+# define machine_is_avenger_lite1()	(machine_arch_type == MACH_TYPE_AVENGER_LITE1)
+#else
+# define machine_is_avenger_lite1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUC
+# endif
+# define machine_is_suc82x()	(machine_arch_type == MACH_TYPE_SUC)
+#else
+# define machine_is_suc82x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM7S256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM7S256
+# endif
+# define machine_is_at91sam7s256()	(machine_arch_type == MACH_TYPE_AT91SAM7S256)
+#else
+# define machine_is_at91sam7s256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENDOZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENDOZA
+# endif
+# define machine_is_mendoza()	(machine_arch_type == MACH_TYPE_MENDOZA)
+#else
+# define machine_is_mendoza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIRA
+# endif
+# define machine_is_kira()	(machine_arch_type == MACH_TYPE_KIRA)
+#else
+# define machine_is_kira()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1HBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1HBM
+# endif
+# define machine_is_mx1hbm()	(machine_arch_type == MACH_TYPE_MX1HBM)
+#else
+# define machine_is_mx1hbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO43XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO43XX
+# endif
+# define machine_is_quatro43xx()	(machine_arch_type == MACH_TYPE_QUATRO43XX)
+#else
+# define machine_is_quatro43xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO4230
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO4230
+# endif
+# define machine_is_quatro4230()	(machine_arch_type == MACH_TYPE_QUATRO4230)
+#else
+# define machine_is_quatro4230()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB400
+# endif
+# define machine_is_nsb400()	(machine_arch_type == MACH_TYPE_NSB400)
+#else
+# define machine_is_nsb400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRP255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRP255
+# endif
+# define machine_is_drp255()	(machine_arch_type == MACH_TYPE_DRP255)
+#else
+# define machine_is_drp255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THOTH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THOTH
+# endif
+# define machine_is_thoth()	(machine_arch_type == MACH_TYPE_THOTH)
+#else
+# define machine_is_thoth()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIRESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIRESTONE
+# endif
+# define machine_is_firestone()	(machine_arch_type == MACH_TYPE_FIRESTONE)
+#else
+# define machine_is_firestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP750
+# endif
+# define machine_is_asusp750()	(machine_arch_type == MACH_TYPE_ASUSP750)
+#else
+# define machine_is_asusp750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_DL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_DL
+# endif
+# define machine_is_ctera_dl()	(machine_arch_type == MACH_TYPE_CTERA_DL)
+#else
+# define machine_is_ctera_dl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCR
+# endif
+# define machine_is_socr()	(machine_arch_type == MACH_TYPE_SOCR)
+#else
+# define machine_is_socr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCOXYGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCOXYGEN
+# endif
+# define machine_is_htcoxygen()	(machine_arch_type == MACH_TYPE_HTCOXYGEN)
+#else
+# define machine_is_htcoxygen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEROC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEROC
+# endif
+# define machine_is_heroc()	(machine_arch_type == MACH_TYPE_HEROC)
+#else
+# define machine_is_heroc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZENO6800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZENO6800
+# endif
+# define machine_is_zeno6800()	(machine_arch_type == MACH_TYPE_ZENO6800)
+#else
+# define machine_is_zeno6800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2MCS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2MCS
+# endif
+# define machine_is_sc2mcs()	(machine_arch_type == MACH_TYPE_SC2MCS)
+#else
+# define machine_is_sc2mcs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENE100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENE100
+# endif
+# define machine_is_gene100()	(machine_arch_type == MACH_TYPE_GENE100)
+#else
+# define machine_is_gene100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS353X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS353X
+# endif
+# define machine_is_as353x()	(machine_arch_type == MACH_TYPE_AS353X)
+#else
+# define machine_is_as353x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20
+# endif
+# define machine_is_at91sam9g20()	(machine_arch_type == MACH_TYPE_AT91SAM9G20)
+#else
+# define machine_is_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6192GTW_FE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6192GTW_FE
+# endif
+# define machine_is_mv88f6192gtw_fe()	(machine_arch_type == MACH_TYPE_MV88F6192GTW_FE)
+#else
+# define machine_is_mv88f6192gtw_fe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9200
+# endif
+# define machine_is_cc9200()	(machine_arch_type == MACH_TYPE_CC9200)
+#else
+# define machine_is_cc9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM9200
+# endif
+# define machine_is_sm9200()	(machine_arch_type == MACH_TYPE_SM9200)
+#else
+# define machine_is_sm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TP9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TP9200
+# endif
+# define machine_is_tp9200()	(machine_arch_type == MACH_TYPE_TP9200)
+#else
+# define machine_is_tp9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPERDV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPERDV
+# endif
+# define machine_is_snapperdv()	(machine_arch_type == MACH_TYPE_SNAPPERDV)
+#else
+# define machine_is_snapperdv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE1
+# endif
+# define machine_is_avengers_lite1()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE1)
+#else
+# define machine_is_avengers_lite1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3AXON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3AXON
+# endif
+# define machine_is_omap3axon()	(machine_arch_type == MACH_TYPE_OMAP3AXON)
+#else
+# define machine_is_omap3axon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MA8XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MA8XX
+# endif
+# define machine_is_ma8xx()	(machine_arch_type == MACH_TYPE_MA8XX)
+#else
+# define machine_is_ma8xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP201EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP201EK
+# endif
+# define machine_is_mp201ek()	(machine_arch_type == MACH_TYPE_MP201EK)
+#else
+# define machine_is_mp201ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_TUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_TUX
+# endif
+# define machine_is_davinci_tux()	(machine_arch_type == MACH_TYPE_DAVINCI_TUX)
+#else
+# define machine_is_davinci_tux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPA1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPA1600
+# endif
+# define machine_is_mpa1600()	(machine_arch_type == MACH_TYPE_MPA1600)
+#else
+# define machine_is_mpa1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_TROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_TROY
+# endif
+# define machine_is_pelco_troy()	(machine_arch_type == MACH_TYPE_PELCO_TROY)
+#else
+# define machine_is_pelco_troy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB667
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB667
+# endif
+# define machine_is_nsb667()	(machine_arch_type == MACH_TYPE_NSB667)
+#else
+# define machine_is_nsb667()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERS5_4MPIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERS5_4MPIX
+# endif
+# define machine_is_rovers5_4mpix()	(machine_arch_type == MACH_TYPE_ROVERS5_4MPIX)
+#else
+# define machine_is_rovers5_4mpix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWOCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWOCOM
+# endif
+# define machine_is_twocom()	(machine_arch_type == MACH_TYPE_TWOCOM)
+#else
+# define machine_is_twocom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_RCU3R2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_RCU3R2
+# endif
+# define machine_is_ubisys_p9_rcu3r2()	(machine_arch_type == MACH_TYPE_UBISYS_P9_RCU3R2)
+#else
+# define machine_is_ubisys_p9_rcu3r2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERO_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERO_ESPRESSO
+# endif
+# define machine_is_hero_espresso()	(machine_arch_type == MACH_TYPE_HERO_ESPRESSO)
+#else
+# define machine_is_hero_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEUSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEUSB
+# endif
+# define machine_is_afeusb()	(machine_arch_type == MACH_TYPE_AFEUSB)
+#else
+# define machine_is_afeusb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T830
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T830
+# endif
+# define machine_is_t830()	(machine_arch_type == MACH_TYPE_T830)
+#else
+# define machine_is_t830()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPD8020_CC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPD8020_CC
+# endif
+# define machine_is_spd8020_cc()	(machine_arch_type == MACH_TYPE_SPD8020_CC)
+#else
+# define machine_is_spd8020_cc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OM_3D7K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OM_3D7K
+# endif
+# define machine_is_om_3d7k()	(machine_arch_type == MACH_TYPE_OM_3D7K)
+#else
+# define machine_is_om_3d7k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM2
+# endif
+# define machine_is_picocom2()	(machine_arch_type == MACH_TYPE_PICOCOM2)
+#else
+# define machine_is_picocom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWG4MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWG4MX27
+# endif
+# define machine_is_uwg4mx27()	(machine_arch_type == MACH_TYPE_UWG4MX27)
+#else
+# define machine_is_uwg4mx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWG4MX31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWG4MX31
+# endif
+# define machine_is_uwg4mx31()	(machine_arch_type == MACH_TYPE_UWG4MX31)
+#else
+# define machine_is_uwg4mx31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHERRY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHERRY
+# endif
+# define machine_is_cherry()	(machine_arch_type == MACH_TYPE_CHERRY)
+#else
+# define machine_is_cherry()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2440TURKIYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440TURKIYE
+# endif
+# define machine_is_s3c2440turkiye()	(machine_arch_type == MACH_TYPE_S3C2440TURKIYE)
+#else
+# define machine_is_s3c2440turkiye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX37
+# endif
+# define machine_is_tx37()	(machine_arch_type == MACH_TYPE_TX37)
+#else
+# define machine_is_tx37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2800_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2800_9G20
+# endif
+# define machine_is_sbc2800_9g20()	(machine_arch_type == MACH_TYPE_SBC2800_9G20)
+#else
+# define machine_is_sbc2800_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZGLB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZGLB
+# endif
+# define machine_is_benzglb()	(machine_arch_type == MACH_TYPE_BENZGLB)
+#else
+# define machine_is_benzglb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZTD
+# endif
+# define machine_is_benztd()	(machine_arch_type == MACH_TYPE_BENZTD)
+#else
+# define machine_is_benztd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARTESIO_PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARTESIO_PLUS
+# endif
+# define machine_is_cartesio_plus()	(machine_arch_type == MACH_TYPE_CARTESIO_PLUS)
+#else
+# define machine_is_cartesio_plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLRAD_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLRAD_G20
+# endif
+# define machine_is_solrad_g20()	(machine_arch_type == MACH_TYPE_SOLRAD_G20)
+#else
+# define machine_is_solrad_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27WALLACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27WALLACE
+# endif
+# define machine_is_mx27wallace()	(machine_arch_type == MACH_TYPE_MX27WALLACE)
+#else
+# define machine_is_mx27wallace()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMZWEBMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMZWEBMODUL
+# endif
+# define machine_is_fmzwebmodul()	(machine_arch_type == MACH_TYPE_FMZWEBMODUL)
+#else
+# define machine_is_fmzwebmodul()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMALLOGGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMALLOGGER
+# endif
+# define machine_is_smallogger()	(machine_arch_type == MACH_TYPE_SMALLOGGER)
+#else
+# define machine_is_smallogger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9P9215
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9P9215
+# endif
+# define machine_is_ccw9p9215()	(machine_arch_type == MACH_TYPE_CCW9P9215)
+#else
+# define machine_is_ccw9p9215()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9263
+# endif
+# define machine_is_tny_a9263()	(machine_arch_type == MACH_TYPE_TNY_A9263)
+#else
+# define machine_is_tny_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APOLLO
+# endif
+# define machine_is_apollo()	(machine_arch_type == MACH_TYPE_APOLLO)
+#else
+# define machine_is_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9STK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9STK
+# endif
+# define machine_is_at91cap9stk()	(machine_arch_type == MACH_TYPE_AT91CAP9STK)
+#else
+# define machine_is_at91cap9stk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPC300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPC300
+# endif
+# define machine_is_spc300()	(machine_arch_type == MACH_TYPE_SPC300)
+#else
+# define machine_is_spc300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EKO
+# endif
+# define machine_is_eko()	(machine_arch_type == MACH_TYPE_EKO)
+#else
+# define machine_is_eko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9M2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9M2443
+# endif
+# define machine_is_ccw9m2443()	(machine_arch_type == MACH_TYPE_CCW9M2443)
+#else
+# define machine_is_ccw9m2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9M2443JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9M2443JS
+# endif
+# define machine_is_ccw9m2443js()	(machine_arch_type == MACH_TYPE_CCW9M2443JS)
+#else
+# define machine_is_ccw9m2443js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M2M_ROUTER_DEVICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M2M_ROUTER_DEVICE
+# endif
+# define machine_is_m2m_router_device()	(machine_arch_type == MACH_TYPE_M2M_ROUTER_DEVICE)
+#else
+# define machine_is_m2m_router_device()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAR9104NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAR9104NAS
+# endif
+# define machine_is_str9104nas()	(machine_arch_type == MACH_TYPE_STAR9104NAS)
+#else
+# define machine_is_str9104nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_DM365_MOD_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_DM365_MOD_01
+# endif
+# define machine_is_z3_dm365_mod_01()	(machine_arch_type == MACH_TYPE_Z3_DM365_MOD_01)
+#else
+# define machine_is_z3_dm365_mod_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPOX
+# endif
+# define machine_is_hipox()	(machine_arch_type == MACH_TYPE_HIPOX)
+#else
+# define machine_is_hipox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PITEDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PITEDS
+# endif
+# define machine_is_omap3_piteds()	(machine_arch_type == MACH_TYPE_OMAP3_PITEDS)
+#else
+# define machine_is_omap3_piteds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BM150R
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BM150R
+# endif
+# define machine_is_bm150r()	(machine_arch_type == MACH_TYPE_BM150R)
+#else
+# define machine_is_bm150r()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TBONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBONE
+# endif
+# define machine_is_tbone()	(machine_arch_type == MACH_TYPE_TBONE)
+#else
+# define machine_is_tbone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERLIN
+# endif
+# define machine_is_merlin()	(machine_arch_type == MACH_TYPE_MERLIN)
+#else
+# define machine_is_merlin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FALCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FALCON
+# endif
+# define machine_is_falcon()	(machine_arch_type == MACH_TYPE_FALCON)
+#else
+# define machine_is_falcon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5P6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5P6440
+# endif
+# define machine_is_s5p6440()	(machine_arch_type == MACH_TYPE_S5P6440)
+#else
+# define machine_is_s5p6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC313X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC313X
+# endif
+# define machine_is_lpc313x()	(machine_arch_type == MACH_TYPE_LPC313X)
+#else
+# define machine_is_lpc313x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_EM30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_EM30
+# endif
+# define machine_is_magx_em30()	(machine_arch_type == MACH_TYPE_MAGX_EM30)
+#else
+# define machine_is_magx_em30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_VE66
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_VE66
+# endif
+# define machine_is_magx_ve66()	(machine_arch_type == MACH_TYPE_MAGX_VE66)
+#else
+# define machine_is_magx_ve66()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEESC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEESC
+# endif
+# define machine_is_meesc()	(machine_arch_type == MACH_TYPE_MEESC)
+#else
+# define machine_is_meesc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTC570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTC570
+# endif
+# define machine_is_otc570()	(machine_arch_type == MACH_TYPE_OTC570)
+#else
+# define machine_is_otc570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCU2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCU2412
+# endif
+# define machine_is_bcu2412()	(machine_arch_type == MACH_TYPE_BCU2412)
+#else
+# define machine_is_bcu2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEACON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEACON
+# endif
+# define machine_is_beacon()	(machine_arch_type == MACH_TYPE_BEACON)
+#else
+# define machine_is_beacon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTIA_TGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIA_TGW
+# endif
+# define machine_is_actia_tgw()	(machine_arch_type == MACH_TYPE_ACTIA_TGW)
+#else
+# define machine_is_actia_tgw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E4430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E4430
+# endif
+# define machine_is_e4430()	(machine_arch_type == MACH_TYPE_E4430)
+#else
+# define machine_is_e4430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL300
+# endif
+# define machine_is_ql300()	(machine_arch_type == MACH_TYPE_QL300)
+#else
+# define machine_is_ql300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ201
+# endif
+# define machine_is_sq201()	(machine_arch_type == MACH_TYPE_SQ201)
+#else
+# define machine_is_sq201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO45XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO45XX
+# endif
+# define machine_is_quatro45xx()	(machine_arch_type == MACH_TYPE_QUATRO45XX)
+#else
+# define machine_is_quatro45xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENPAD
+# endif
+# define machine_is_openpad()	(machine_arch_type == MACH_TYPE_OPENPAD)
+#else
+# define machine_is_openpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX25
+# endif
+# define machine_is_tx25()	(machine_arch_type == MACH_TYPE_TX25)
+#else
+# define machine_is_tx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_K
+# endif
+# define machine_is_htcraphael_k()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_K)
+#else
+# define machine_is_htcraphael_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAL43
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAL43
+# endif
+# define machine_is_lal43()	(machine_arch_type == MACH_TYPE_LAL43)
+#else
+# define machine_is_lal43()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_CDMA500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_CDMA500
+# endif
+# define machine_is_htcraphael_cdma500()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_CDMA500)
+#else
+# define machine_is_htcraphael_cdma500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPROPHET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPROPHET
+# endif
+# define machine_is_htcprophet()	(machine_arch_type == MACH_TYPE_HTCPROPHET)
+#else
+# define machine_is_htcprophet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CFA_10022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CFA_10022
+# endif
+# define machine_is_cfa_10022()	(machine_arch_type == MACH_TYPE_CFA_10022)
+#else
+# define machine_is_cfa_10022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PX2IMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PX2IMX27
+# endif
+# define machine_is_px2imx27()	(machine_arch_type == MACH_TYPE_PX2IMX27)
+#else
+# define machine_is_px2imx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM3210E_EVAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM3210E_EVAL
+# endif
+# define machine_is_stm3210e_eval()	(machine_arch_type == MACH_TYPE_STM3210E_EVAL)
+#else
+# define machine_is_stm3210e_eval()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DVS10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DVS10
+# endif
+# define machine_is_dvs10()	(machine_arch_type == MACH_TYPE_DVS10)
+#else
+# define machine_is_dvs10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM_SPV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM_SPV
+# endif
+# define machine_is_arm_spv()	(machine_arch_type == MACH_TYPE_ARM_SPV)
+#else
+# define machine_is_arm_spv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CABESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CABESPRESSO
+# endif
+# define machine_is_cabespresso()	(machine_arch_type == MACH_TYPE_CABESPRESSO)
+#else
+# define machine_is_cabespresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMC800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMC800
+# endif
+# define machine_is_hmc800()	(machine_arch_type == MACH_TYPE_HMC800)
+#else
+# define machine_is_hmc800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOLES
+# endif
+# define machine_is_sholes()	(machine_arch_type == MACH_TYPE_SHOLES)
+#else
+# define machine_is_sholes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMXC31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMXC31
+# endif
+# define machine_is_btmxc31()	(machine_arch_type == MACH_TYPE_BTMXC31)
+#else
+# define machine_is_btmxc31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DT501
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DT501
+# endif
+# define machine_is_dt501()	(machine_arch_type == MACH_TYPE_DT501)
+#else
+# define machine_is_dt501()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KTX
+# endif
+# define machine_is_ktx()	(machine_arch_type == MACH_TYPE_KTX)
+#else
+# define machine_is_ktx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET4BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET4BIG_V2
+# endif
+# define machine_is_net4big_v2()	(machine_arch_type == MACH_TYPE_NET4BIG_V2)
+#else
+# define machine_is_net4big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDB2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDB2443
+# endif
+# define machine_is_endb2443()	(machine_arch_type == MACH_TYPE_ENDB2443)
+#else
+# define machine_is_endb2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROS
+# endif
+# define machine_is_tros()	(machine_arch_type == MACH_TYPE_TROS)
+#else
+# define machine_is_tros()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_HOMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_HOMER
+# endif
+# define machine_is_pelco_homer()	(machine_arch_type == MACH_TYPE_PELCO_HOMER)
+#else
+# define machine_is_pelco_homer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OFSP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OFSP8
+# endif
+# define machine_is_ofsp8()	(machine_arch_type == MACH_TYPE_OFSP8)
+#else
+# define machine_is_ofsp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUF_CUPID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUF_CUPID
+# endif
+# define machine_is_guf_cupid()	(machine_arch_type == MACH_TYPE_GUF_CUPID)
+#else
+# define machine_is_guf_cupid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAB1R
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAB1R
+# endif
+# define machine_is_eab1r()	(machine_arch_type == MACH_TYPE_EAB1R)
+#else
+# define machine_is_eab1r()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESIREC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESIREC
+# endif
+# define machine_is_desirec()	(machine_arch_type == MACH_TYPE_DESIREC)
+#else
+# define machine_is_desirec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORDOBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORDOBA
+# endif
+# define machine_is_cordoba()	(machine_arch_type == MACH_TYPE_CORDOBA)
+#else
+# define machine_is_cordoba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IRVINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IRVINE
+# endif
+# define machine_is_irvine()	(machine_arch_type == MACH_TYPE_IRVINE)
+#else
+# define machine_is_irvine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFF772
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFF772
+# endif
+# define machine_is_sff772()	(machine_arch_type == MACH_TYPE_SFF772)
+#else
+# define machine_is_sff772()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MILANO
+# endif
+# define machine_is_pelco_milano()	(machine_arch_type == MACH_TYPE_PELCO_MILANO)
+#else
+# define machine_is_pelco_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIP6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIP6000
+# endif
+# define machine_is_bip6000()	(machine_arch_type == MACH_TYPE_BIP6000)
+#else
+# define machine_is_bip6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SILVERMOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SILVERMOON
+# endif
+# define machine_is_silvermoon()	(machine_arch_type == MACH_TYPE_SILVERMOON)
+#else
+# define machine_is_silvermoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0830
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0830
+# endif
+# define machine_is_vc0830()	(machine_arch_type == MACH_TYPE_VC0830)
+#else
+# define machine_is_vc0830()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DT430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DT430
+# endif
+# define machine_is_dt430()	(machine_arch_type == MACH_TYPE_DT430)
+#else
+# define machine_is_dt430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JI42PF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JI42PF
+# endif
+# define machine_is_ji42pf()	(machine_arch_type == MACH_TYPE_JI42PF)
+#else
+# define machine_is_ji42pf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_KSM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_KSM
+# endif
+# define machine_is_gnet_ksm()	(machine_arch_type == MACH_TYPE_GNET_KSM)
+#else
+# define machine_is_gnet_ksm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGM
+# endif
+# define machine_is_gnet_sgm()	(machine_arch_type == MACH_TYPE_GNET_SGM)
+#else
+# define machine_is_gnet_sgm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGR
+# endif
+# define machine_is_gnet_sgr()	(machine_arch_type == MACH_TYPE_GNET_SGR)
+#else
+# define machine_is_gnet_sgr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_ICETEKEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_ICETEKEVM
+# endif
+# define machine_is_omap3_icetekevm()	(machine_arch_type == MACH_TYPE_OMAP3_ICETEKEVM)
+#else
+# define machine_is_omap3_icetekevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP
+# endif
+# define machine_is_pnp()	(machine_arch_type == MACH_TYPE_PNP)
+#else
+# define machine_is_pnp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_K
+# endif
+# define machine_is_ctera_2bay_k()	(machine_arch_type == MACH_TYPE_CTERA_2BAY_K)
+#else
+# define machine_is_ctera_2bay_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_U
+# endif
+# define machine_is_ctera_2bay_u()	(machine_arch_type == MACH_TYPE_CTERA_2BAY_U)
+#else
+# define machine_is_ctera_2bay_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAS_C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAS_C
+# endif
+# define machine_is_sas_c()	(machine_arch_type == MACH_TYPE_SAS_C)
+#else
+# define machine_is_sas_c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMA2315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMA2315
+# endif
+# define machine_is_vma2315()	(machine_arch_type == MACH_TYPE_VMA2315)
+#else
+# define machine_is_vma2315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCS
+# endif
+# define machine_is_vcs()	(machine_arch_type == MACH_TYPE_VCS)
+#else
+# define machine_is_vcs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1300
+# endif
+# define machine_is_spear1300()	(machine_arch_type == MACH_TYPE_SPEAR1300)
+#else
+# define machine_is_spear1300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARVOO_AX301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARVOO_AX301
+# endif
+# define machine_is_arvoo_ax301()	(machine_arch_type == MACH_TYPE_ARVOO_AX301)
+#else
+# define machine_is_arvoo_ax301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAPPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAPPHONE
+# endif
+# define machine_is_mapphone()	(machine_arch_type == MACH_TYPE_MAPPHONE)
+#else
+# define machine_is_mapphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGEND
+# endif
+# define machine_is_legend()	(machine_arch_type == MACH_TYPE_LEGEND)
+#else
+# define machine_is_legend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALSA
+# endif
+# define machine_is_salsa()	(machine_arch_type == MACH_TYPE_SALSA)
+#else
+# define machine_is_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOUNGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOUNGE
+# endif
+# define machine_is_lounge()	(machine_arch_type == MACH_TYPE_LOUNGE)
+#else
+# define machine_is_lounge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VISION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VISION
+# endif
+# define machine_is_vision()	(machine_arch_type == MACH_TYPE_VISION)
+#else
+# define machine_is_vision()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMB20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMB20
+# endif
+# define machine_is_vmb20()	(machine_arch_type == MACH_TYPE_VMB20)
+#else
+# define machine_is_vmb20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY2410
+# endif
+# define machine_is_hy2410()	(machine_arch_type == MACH_TYPE_HY2410)
+#else
+# define machine_is_hy2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY9315
+# endif
+# define machine_is_hy9315()	(machine_arch_type == MACH_TYPE_HY9315)
+#else
+# define machine_is_hy9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BULLWINKLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BULLWINKLE
+# endif
+# define machine_is_bullwinkle()	(machine_arch_type == MACH_TYPE_BULLWINKLE)
+#else
+# define machine_is_bullwinkle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM_ULTIMATOR2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM_ULTIMATOR2
+# endif
+# define machine_is_arm_ultimator2()	(machine_arch_type == MACH_TYPE_ARM_ULTIMATOR2)
+#else
+# define machine_is_arm_ultimator2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VS_V210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VS_V210
+# endif
+# define machine_is_vs_v210()	(machine_arch_type == MACH_TYPE_VS_V210)
+#else
+# define machine_is_vs_v210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VS_V212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VS_V212
+# endif
+# define machine_is_vs_v212()	(machine_arch_type == MACH_TYPE_VS_V212)
+#else
+# define machine_is_vs_v212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUEN3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUEN3
+# endif
+# define machine_is_suen3()	(machine_arch_type == MACH_TYPE_SUEN3)
+#else
+# define machine_is_suen3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VESPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VESPER
+# endif
+# define machine_is_vesper()	(machine_arch_type == MACH_TYPE_VESPER)
+#else
+# define machine_is_vesper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR9
+# endif
+# define machine_is_str9()	(machine_arch_type == MACH_TYPE_STR9)
+#else
+# define machine_is_str9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WL_FF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WL_FF
+# endif
+# define machine_is_omap3_wl_ff()	(machine_arch_type == MACH_TYPE_OMAP3_WL_FF)
+#else
+# define machine_is_omap3_wl_ff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMCOM
+# endif
+# define machine_is_simcom()	(machine_arch_type == MACH_TYPE_SIMCOM)
+#else
+# define machine_is_simcom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCWEBIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCWEBIO
+# endif
+# define machine_is_mcwebio()	(machine_arch_type == MACH_TYPE_MCWEBIO)
+#else
+# define machine_is_mcwebio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PHRAZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PHRAZER
+# endif
+# define machine_is_omap3_phrazer()	(machine_arch_type == MACH_TYPE_OMAP3_PHRAZER)
+#else
+# define machine_is_omap3_phrazer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DARWIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DARWIN
+# endif
+# define machine_is_darwin()	(machine_arch_type == MACH_TYPE_DARWIN)
+#else
+# define machine_is_darwin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISCOMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISCOMU
+# endif
+# define machine_is_oratiscomu()	(machine_arch_type == MACH_TYPE_ORATISCOMU)
+#else
+# define machine_is_oratiscomu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTSBC20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTSBC20
+# endif
+# define machine_is_rtsbc20()	(machine_arch_type == MACH_TYPE_RTSBC20)
+#else
+# define machine_is_rtsbc20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I780
+# endif
+# define machine_is_sgh_i780()	(machine_arch_type == MACH_TYPE_I780)
+#else
+# define machine_is_sgh_i780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMINI324
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI324
+# endif
+# define machine_is_gemini324()	(machine_arch_type == MACH_TYPE_GEMINI324)
+#else
+# define machine_is_gemini324()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISLAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISLAN
+# endif
+# define machine_is_oratislan()	(machine_arch_type == MACH_TYPE_ORATISLAN)
+#else
+# define machine_is_oratislan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISALOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISALOG
+# endif
+# define machine_is_oratisalog()	(machine_arch_type == MACH_TYPE_ORATISALOG)
+#else
+# define machine_is_oratisalog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISMADI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISMADI
+# endif
+# define machine_is_oratismadi()	(machine_arch_type == MACH_TYPE_ORATISMADI)
+#else
+# define machine_is_oratismadi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISOT16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISOT16
+# endif
+# define machine_is_oratisot16()	(machine_arch_type == MACH_TYPE_ORATISOT16)
+#else
+# define machine_is_oratisot16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISDESK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISDESK
+# endif
+# define machine_is_oratisdesk()	(machine_arch_type == MACH_TYPE_ORATISDESK)
+#else
+# define machine_is_oratisdesk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEXPRESS
+# endif
+# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
+#else
+# define machine_is_vexpress()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEXO
+# endif
+# define machine_is_sintexo()	(machine_arch_type == MACH_TYPE_SINTEXO)
+#else
+# define machine_is_sintexo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM3389
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM3389
+# endif
+# define machine_is_cm3389()	(machine_arch_type == MACH_TYPE_CM3389)
+#else
+# define machine_is_cm3389()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_CIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_CIO
+# endif
+# define machine_is_omap3_cio()	(machine_arch_type == MACH_TYPE_OMAP3_CIO)
+#else
+# define machine_is_omap3_cio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I900
+# endif
+# define machine_is_sgh_i900()	(machine_arch_type == MACH_TYPE_SGH_I900)
+#else
+# define machine_is_sgh_i900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BST100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BST100
+# endif
+# define machine_is_bst100()	(machine_arch_type == MACH_TYPE_BST100)
+#else
+# define machine_is_bst100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSION
+# endif
+# define machine_is_passion()	(machine_arch_type == MACH_TYPE_PASSION)
+#else
+# define machine_is_passion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INDESIGN_AT91SAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INDESIGN_AT91SAM
+# endif
+# define machine_is_indesign_at91sam()	(machine_arch_type == MACH_TYPE_INDESIGN_AT91SAM)
+#else
+# define machine_is_indesign_at91sam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C4_BADGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C4_BADGER
+# endif
+# define machine_is_c4_badger()	(machine_arch_type == MACH_TYPE_C4_BADGER)
+#else
+# define machine_is_c4_badger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C4_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C4_VIPER
+# endif
+# define machine_is_c4_viper()	(machine_arch_type == MACH_TYPE_C4_VIPER)
+#else
+# define machine_is_c4_viper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTALVISION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTALVISION
+# endif
+# define machine_is_notalvision()	(machine_arch_type == MACH_TYPE_NOTALVISION)
+#else
+# define machine_is_notalvision()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_KBOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_KBOC
+# endif
+# define machine_is_omap3_kboc()	(machine_arch_type == MACH_TYPE_OMAP3_KBOC)
+#else
+# define machine_is_omap3_kboc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYCLONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYCLONE
+# endif
+# define machine_is_cyclone()	(machine_arch_type == MACH_TYPE_CYCLONE)
+#else
+# define machine_is_cyclone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NINJA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NINJA
+# endif
+# define machine_is_ninja()	(machine_arch_type == MACH_TYPE_NINJA)
+#else
+# define machine_is_ninja()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RESOL_DL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RESOL_DL2
+# endif
+# define machine_is_resol_dl2()	(machine_arch_type == MACH_TYPE_RESOL_DL2)
+#else
+# define machine_is_resol_dl2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IFOSW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IFOSW
+# endif
+# define machine_is_ifosw()	(machine_arch_type == MACH_TYPE_IFOSW)
+#else
+# define machine_is_ifosw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRHODIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRHODIUM
+# endif
+# define machine_is_htcrhodium()	(machine_arch_type == MACH_TYPE_HTCRHODIUM)
+#else
+# define machine_is_htcrhodium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCTOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCTOPAZ
+# endif
+# define machine_is_htctopaz()	(machine_arch_type == MACH_TYPE_HTCTOPAZ)
+#else
+# define machine_is_htctopaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX504
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX504
+# endif
+# define machine_is_matrix504()	(machine_arch_type == MACH_TYPE_MATRIX504)
+#else
+# define machine_is_matrix504()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRFSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRFSA
+# endif
+# define machine_is_mrfsa()	(machine_arch_type == MACH_TYPE_MRFSA)
+#else
+# define machine_is_mrfsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC_P270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC_P270
+# endif
+# define machine_is_sc_p270()	(machine_arch_type == MACH_TYPE_SC_P270)
+#else
+# define machine_is_sc_p270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS5_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS5_EVB
+# endif
+# define machine_is_atlas5_evb()	(machine_arch_type == MACH_TYPE_ATLAS5_EVB)
+#else
+# define machine_is_atlas5_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_LOBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_LOBOX
+# endif
+# define machine_is_pelco_lobox()	(machine_arch_type == MACH_TYPE_PELCO_LOBOX)
+#else
+# define machine_is_pelco_lobox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DILAX_PCU200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DILAX_PCU200
+# endif
+# define machine_is_dilax_pcu200()	(machine_arch_type == MACH_TYPE_DILAX_PCU200)
+#else
+# define machine_is_dilax_pcu200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEONARDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEONARDO
+# endif
+# define machine_is_leonardo()	(machine_arch_type == MACH_TYPE_LEONARDO)
+#else
+# define machine_is_leonardo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZORAN_APPROACH7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZORAN_APPROACH7
+# endif
+# define machine_is_zoran_approach7()	(machine_arch_type == MACH_TYPE_ZORAN_APPROACH7)
+#else
+# define machine_is_zoran_approach7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM2153_VESPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM2153_VESPER
+# endif
+# define machine_is_bcm2153_vesper()	(machine_arch_type == MACH_TYPE_BCM2153_VESPER)
+#else
+# define machine_is_bcm2153_vesper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLICKC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLICKC
+# endif
+# define machine_is_clickc()	(machine_arch_type == MACH_TYPE_CLICKC)
+#else
+# define machine_is_clickc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZB_GATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZB_GATEWAY
+# endif
+# define machine_is_zb_gateway()	(machine_arch_type == MACH_TYPE_ZB_GATEWAY)
+#else
+# define machine_is_zb_gateway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZCARD
+# endif
+# define machine_is_tazcard()	(machine_arch_type == MACH_TYPE_TAZCARD)
+#else
+# define machine_is_tazcard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZDEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZDEV
+# endif
+# define machine_is_tazdev()	(machine_arch_type == MACH_TYPE_TAZDEV)
+#else
+# define machine_is_tazdev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_CB_ARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_CB_ARM
+# endif
+# define machine_is_annax_cb_arm()	(machine_arch_type == MACH_TYPE_ANNAX_CB_ARM)
+#else
+# define machine_is_annax_cb_arm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_DM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_DM3
+# endif
+# define machine_is_annax_dm3()	(machine_arch_type == MACH_TYPE_ANNAX_DM3)
+#else
+# define machine_is_annax_dm3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEREBRIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEREBRIC
+# endif
+# define machine_is_cerebric()	(machine_arch_type == MACH_TYPE_CEREBRIC)
+#else
+# define machine_is_cerebric()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORCA
+# endif
+# define machine_is_orca()	(machine_arch_type == MACH_TYPE_ORCA)
+#else
+# define machine_is_orca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC9260
+# endif
+# define machine_is_pc9260()	(machine_arch_type == MACH_TYPE_PC9260)
+#else
+# define machine_is_pc9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS285A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS285A
+# endif
+# define machine_is_ems285a()	(machine_arch_type == MACH_TYPE_EMS285A)
+#else
+# define machine_is_ems285a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEC2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEC2410
+# endif
+# define machine_is_gec2410()	(machine_arch_type == MACH_TYPE_GEC2410)
+#else
+# define machine_is_gec2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEC2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEC2440
+# endif
+# define machine_is_gec2440()	(machine_arch_type == MACH_TYPE_GEC2440)
+#else
+# define machine_is_gec2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCH_MW903
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_MW903
+# endif
+# define machine_is_mw903()	(machine_arch_type == MACH_TYPE_ARCH_MW903)
+#else
+# define machine_is_mw903()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MW2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MW2440
+# endif
+# define machine_is_mw2440()	(machine_arch_type == MACH_TYPE_MW2440)
+#else
+# define machine_is_mw2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECAC2378
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECAC2378
+# endif
+# define machine_is_ecac2378()	(machine_arch_type == MACH_TYPE_ECAC2378)
+#else
+# define machine_is_ecac2378()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZKIOSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZKIOSK
+# endif
+# define machine_is_tazkiosk()	(machine_arch_type == MACH_TYPE_TAZKIOSK)
+#else
+# define machine_is_tazkiosk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHITERABBIT_MCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITERABBIT_MCH
+# endif
+# define machine_is_whiterabbit_mch()	(machine_arch_type == MACH_TYPE_WHITERABBIT_MCH)
+#else
+# define machine_is_whiterabbit_mch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBOX9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBOX9263
+# endif
+# define machine_is_sbox9263()	(machine_arch_type == MACH_TYPE_SBOX9263)
+#else
+# define machine_is_sbox9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OREO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OREO
+# endif
+# define machine_is_oreo()	(machine_arch_type == MACH_TYPE_OREO)
+#else
+# define machine_is_oreo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6442
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6442
+# endif
+# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
+#else
+# define machine_is_smdk6442()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
+# endif
+# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
+#else
+# define machine_is_openrd_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCREDIBLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCREDIBLE
+# endif
+# define machine_is_incredible()	(machine_arch_type == MACH_TYPE_INCREDIBLE)
+#else
+# define machine_is_incredible()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCREDIBLEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCREDIBLEC
+# endif
+# define machine_is_incrediblec()	(machine_arch_type == MACH_TYPE_INCREDIBLEC)
+#else
+# define machine_is_incrediblec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEROCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEROCT
+# endif
+# define machine_is_heroct()	(machine_arch_type == MACH_TYPE_HEROCT)
+#else
+# define machine_is_heroct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMNET1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMNET1000
+# endif
+# define machine_is_mmnet1000()	(machine_arch_type == MACH_TYPE_MMNET1000)
+#else
+# define machine_is_mmnet1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT8000
+# endif
+# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
+#else
+# define machine_is_devkit8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT9000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT9000
+# endif
+# define machine_is_devkit9000()	(machine_arch_type == MACH_TYPE_DEVKIT9000)
+#else
+# define machine_is_devkit9000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31TXTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31TXTR
+# endif
+# define machine_is_mx31txtr()	(machine_arch_type == MACH_TYPE_MX31TXTR)
+#else
+# define machine_is_mx31txtr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U380
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U380
+# endif
+# define machine_is_u380()	(machine_arch_type == MACH_TYPE_U380)
+#else
+# define machine_is_u380()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUALU_BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUALU_BOARD
+# endif
+# define machine_is_oamp3_hualu()	(machine_arch_type == MACH_TYPE_HUALU_BOARD)
+#else
+# define machine_is_oamp3_hualu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NPCMX50
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NPCMX50
+# endif
+# define machine_is_npcmx50()	(machine_arch_type == MACH_TYPE_NPCMX50)
+#else
+# define machine_is_npcmx50()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_LANGE51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_LANGE51
+# endif
+# define machine_is_mx51_lange51()	(machine_arch_type == MACH_TYPE_MX51_LANGE51)
+#else
+# define machine_is_mx51_lange51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_LANGE52
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_LANGE52
+# endif
+# define machine_is_mx51_lange52()	(machine_arch_type == MACH_TYPE_MX51_LANGE52)
+#else
+# define machine_is_mx51_lange52()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOM
+# endif
+# define machine_is_riom()	(machine_arch_type == MACH_TYPE_RIOM)
+#else
+# define machine_is_riom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMCAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMCAS
+# endif
+# define machine_is_comcas()	(machine_arch_type == MACH_TYPE_COMCAS)
+#else
+# define machine_is_comcas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WSI_MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WSI_MX27
+# endif
+# define machine_is_wsi_mx27()	(machine_arch_type == MACH_TYPE_WSI_MX27)
+#else
+# define machine_is_wsi_mx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T35
+# endif
+# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
+#else
+# define machine_is_cm_t35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG
+# endif
+# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
+#else
+# define machine_is_net2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOROLA_A1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOROLA_A1600
+# endif
+# define machine_is_motorola_a1600()	(machine_arch_type == MACH_TYPE_MOTOROLA_A1600)
+#else
+# define machine_is_motorola_a1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0020
+# endif
+# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
+#else
+# define machine_is_igep0020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0010
+# endif
+# define machine_is_igep0010()	(machine_arch_type == MACH_TYPE_IGEP0010)
+#else
+# define machine_is_igep0010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV6281GTWGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV6281GTWGE2
+# endif
+# define machine_is_mv6281gtwge2()	(machine_arch_type == MACH_TYPE_MV6281GTWGE2)
+#else
+# define machine_is_mv6281gtwge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCAT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCAT100
+# endif
+# define machine_is_scat100()	(machine_arch_type == MACH_TYPE_SCAT100)
+#else
+# define machine_is_scat100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANMINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANMINA
+# endif
+# define machine_is_sanmina()	(machine_arch_type == MACH_TYPE_SANMINA)
+#else
+# define machine_is_sanmina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOMENTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOMENTO
+# endif
+# define machine_is_momento()	(machine_arch_type == MACH_TYPE_MOMENTO)
+#else
+# define machine_is_momento()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC9XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC9XX
+# endif
+# define machine_is_nuc9xx()	(machine_arch_type == MACH_TYPE_NUC9XX)
+#else
+# define machine_is_nuc9xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC910EVB
+# endif
+# define machine_is_nuc910evb()	(machine_arch_type == MACH_TYPE_NUC910EVB)
+#else
+# define machine_is_nuc910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC920EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC920EVB
+# endif
+# define machine_is_nuc920evb()	(machine_arch_type == MACH_TYPE_NUC920EVB)
+#else
+# define machine_is_nuc920evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC950EVB
+# endif
+# define machine_is_nuc950evb()	(machine_arch_type == MACH_TYPE_NUC950EVB)
+#else
+# define machine_is_nuc950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC945EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC945EVB
+# endif
+# define machine_is_nuc945evb()	(machine_arch_type == MACH_TYPE_NUC945EVB)
+#else
+# define machine_is_nuc945evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC960EVB
+# endif
+# define machine_is_nuc960evb()	(machine_arch_type == MACH_TYPE_NUC960EVB)
+#else
+# define machine_is_nuc960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC932EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC932EVB
+# endif
+# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
+#else
+# define machine_is_nuc932evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC900
+# endif
+# define machine_is_nuc900()	(machine_arch_type == MACH_TYPE_NUC900)
+#else
+# define machine_is_nuc900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SD1SOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SD1SOC
+# endif
+# define machine_is_sd1soc()	(machine_arch_type == MACH_TYPE_SD1SOC)
+#else
+# define machine_is_sd1soc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LN2440BC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LN2440BC
+# endif
+# define machine_is_ln2440bc()	(machine_arch_type == MACH_TYPE_LN2440BC)
+#else
+# define machine_is_ln2440bc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSBC
+# endif
+# define machine_is_rsbc()	(machine_arch_type == MACH_TYPE_RSBC)
+#else
+# define machine_is_rsbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_CLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
+# endif
+# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
+#else
+# define machine_is_openrd_client()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPIPAQ11X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPIPAQ11X
+# endif
+# define machine_is_hpipaq11x()	(machine_arch_type == MACH_TYPE_HPIPAQ11X)
+#else
+# define machine_is_hpipaq11x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WAYLAND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WAYLAND
+# endif
+# define machine_is_wayland()	(machine_arch_type == MACH_TYPE_WAYLAND)
+#else
+# define machine_is_wayland()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACNBSX102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACNBSX102
+# endif
+# define machine_is_acnbsx102()	(machine_arch_type == MACH_TYPE_ACNBSX102)
+#else
+# define machine_is_acnbsx102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HWAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HWAT91
+# endif
+# define machine_is_hwat91()	(machine_arch_type == MACH_TYPE_HWAT91)
+#else
+# define machine_is_hwat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263CS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263CS
+# endif
+# define machine_is_at91sam9263cs()	(machine_arch_type == MACH_TYPE_AT91SAM9263CS)
+#else
+# define machine_is_at91sam9263cs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB732
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB732
+# endif
+# define machine_is_csb732()	(machine_arch_type == MACH_TYPE_CSB732)
+#else
+# define machine_is_csb732()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U8500
+# endif
+# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
+#else
+# define machine_is_u8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUQIU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUQIU
+# endif
+# define machine_is_huqiu()	(machine_arch_type == MACH_TYPE_HUQIU)
+#else
+# define machine_is_huqiu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_KUNLUN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_KUNLUN
+# endif
+# define machine_is_mx51_kunlun()	(machine_arch_type == MACH_TYPE_MX51_KUNLUN)
+#else
+# define machine_is_mx51_kunlun()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PMT1G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PMT1G
+# endif
+# define machine_is_pmt1g()	(machine_arch_type == MACH_TYPE_PMT1G)
+#else
+# define machine_is_pmt1g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCELF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCELF
+# endif
+# define machine_is_htcelf()	(machine_arch_type == MACH_TYPE_HTCELF)
+#else
+# define machine_is_htcelf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO420
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO420
+# endif
+# define machine_is_armadillo420()	(machine_arch_type == MACH_TYPE_ARMADILLO420)
+#else
+# define machine_is_armadillo420()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO440
+# endif
+# define machine_is_armadillo440()	(machine_arch_type == MACH_TYPE_ARMADILLO440)
+#else
+# define machine_is_armadillo440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U_CHIP_DUAL_ARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U_CHIP_DUAL_ARM
+# endif
+# define machine_is_u_chip_dual_arm()	(machine_arch_type == MACH_TYPE_U_CHIP_DUAL_ARM)
+#else
+# define machine_is_u_chip_dual_arm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSR_BDB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSR_BDB3
+# endif
+# define machine_is_csr_bdb3()	(machine_arch_type == MACH_TYPE_CSR_BDB3)
+#else
+# define machine_is_csr_bdb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOLBY_CAT1018
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOLBY_CAT1018
+# endif
+# define machine_is_dolby_cat1018()	(machine_arch_type == MACH_TYPE_DOLBY_CAT1018)
+#else
+# define machine_is_dolby_cat1018()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY9307
+# endif
+# define machine_is_hy9307()	(machine_arch_type == MACH_TYPE_HY9307)
+#else
+# define machine_is_hy9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A_ES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A_ES
+# endif
+# define machine_is_aspire_easystore()	(machine_arch_type == MACH_TYPE_A_ES)
+#else
+# define machine_is_aspire_easystore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_IRIF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_IRIF
+# endif
+# define machine_is_davinci_irif()	(machine_arch_type == MACH_TYPE_DAVINCI_IRIF)
+#else
+# define machine_is_davinci_irif()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AGAMA9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AGAMA9263
+# endif
+# define machine_is_agama9263()	(machine_arch_type == MACH_TYPE_AGAMA9263)
+#else
+# define machine_is_agama9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
+# endif
+# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
+#else
+# define machine_is_marvell_jasper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLINT
+# endif
+# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
+#else
+# define machine_is_flint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB3
+# endif
+# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
+#else
+# define machine_is_tavorevb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCH_M490
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCH_M490
+# endif
+# define machine_is_sch_m490()	(machine_arch_type == MACH_TYPE_SCH_M490)
+#else
+# define machine_is_sch_m490()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RBL01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RBL01
+# endif
+# define machine_is_rbl01()	(machine_arch_type == MACH_TYPE_RBL01)
+#else
+# define machine_is_rbl01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMNIFI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMNIFI
+# endif
+# define machine_is_omnifi()	(machine_arch_type == MACH_TYPE_OMNIFI)
+#else
+# define machine_is_omnifi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTAVALO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTAVALO
+# endif
+# define machine_is_otavalo()	(machine_arch_type == MACH_TYPE_OTAVALO)
+#else
+# define machine_is_otavalo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIENNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIENNA
+# endif
+# define machine_is_sienna()	(machine_arch_type == MACH_TYPE_SIENNA)
+#else
+# define machine_is_sienna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_EXCALIBUR_S620
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_EXCALIBUR_S620
+# endif
+# define machine_is_htc_excalibur_s620()	(machine_arch_type == MACH_TYPE_HTC_EXCALIBUR_S620)
+#else
+# define machine_is_htc_excalibur_s620()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_OPAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_OPAL
+# endif
+# define machine_is_htc_opal()	(machine_arch_type == MACH_TYPE_HTC_OPAL)
+#else
+# define machine_is_htc_opal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
+# endif
+# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
+#else
+# define machine_is_touchbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LATTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LATTE
+# endif
+# define machine_is_latte()	(machine_arch_type == MACH_TYPE_LATTE)
+#else
+# define machine_is_latte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XA200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XA200
+# endif
+# define machine_is_xa200()	(machine_arch_type == MACH_TYPE_XA200)
+#else
+# define machine_is_xa200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIMROD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIMROD
+# endif
+# define machine_is_nimrod()	(machine_arch_type == MACH_TYPE_NIMROD)
+#else
+# define machine_is_nimrod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9215_3G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9215_3G
+# endif
+# define machine_is_cc9p9215_3g()	(machine_arch_type == MACH_TYPE_CC9P9215_3G)
+#else
+# define machine_is_cc9p9215_3g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9215_3GJS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9215_3GJS
+# endif
+# define machine_is_cc9p9215_3gjs()	(machine_arch_type == MACH_TYPE_CC9P9215_3GJS)
+#else
+# define machine_is_cc9p9215_3gjs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TK71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TK71
+# endif
+# define machine_is_tk71()	(machine_arch_type == MACH_TYPE_TK71)
+#else
+# define machine_is_tk71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COMHAM3525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COMHAM3525
+# endif
+# define machine_is_comham3525()	(machine_arch_type == MACH_TYPE_COMHAM3525)
+#else
+# define machine_is_comham3525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31EREBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31EREBUS
+# endif
+# define machine_is_mx31erebus()	(machine_arch_type == MACH_TYPE_MX31EREBUS)
+#else
+# define machine_is_mx31erebus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCARDMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCARDMX27
+# endif
+# define machine_is_mcardmx27()	(machine_arch_type == MACH_TYPE_MCARDMX27)
+#else
+# define machine_is_mcardmx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PARADISE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PARADISE
+# endif
+# define machine_is_paradise()	(machine_arch_type == MACH_TYPE_PARADISE)
+#else
+# define machine_is_paradise()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIDE
+# endif
+# define machine_is_tide()	(machine_arch_type == MACH_TYPE_TIDE)
+#else
+# define machine_is_tide()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WZL2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WZL2440
+# endif
+# define machine_is_wzl2440()	(machine_arch_type == MACH_TYPE_WZL2440)
+#else
+# define machine_is_wzl2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDRDEMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDRDEMO
+# endif
+# define machine_is_sdrdemo()	(machine_arch_type == MACH_TYPE_SDRDEMO)
+#else
+# define machine_is_sdrdemo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERCAN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERCAN2
+# endif
+# define machine_is_ethercan2()	(machine_arch_type == MACH_TYPE_ETHERCAN2)
+#else
+# define machine_is_ethercan2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECMIMG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECMIMG20
+# endif
+# define machine_is_ecmimg20()	(machine_arch_type == MACH_TYPE_ECMIMG20)
+#else
+# define machine_is_ecmimg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_DRAGON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_DRAGON
+# endif
+# define machine_is_omap_dragon()	(machine_arch_type == MACH_TYPE_OMAP_DRAGON)
+#else
+# define machine_is_omap_dragon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALO
+# endif
+# define machine_is_halo()	(machine_arch_type == MACH_TYPE_HALO)
+#else
+# define machine_is_halo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUANGSHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUANGSHAN
+# endif
+# define machine_is_huangshan()	(machine_arch_type == MACH_TYPE_HUANGSHAN)
+#else
+# define machine_is_huangshan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VL_MA2SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VL_MA2SC
+# endif
+# define machine_is_vl_ma2sc()	(machine_arch_type == MACH_TYPE_VL_MA2SC)
+#else
+# define machine_is_vl_ma2sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_RC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
+# endif
+# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
+#else
+# define machine_is_raumfeld_rc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
+# endif
+# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
+#else
+# define machine_is_raumfeld_connector()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
+# endif
+# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
+#else
+# define machine_is_raumfeld_speaker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIBUS_MASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIBUS_MASTER
+# endif
+# define machine_is_multibus_master()	(machine_arch_type == MACH_TYPE_MULTIBUS_MASTER)
+#else
+# define machine_is_multibus_master()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIBUS_PBK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIBUS_PBK
+# endif
+# define machine_is_multibus_pbk()	(machine_arch_type == MACH_TYPE_MULTIBUS_PBK)
+#else
+# define machine_is_multibus_pbk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNETV107X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNETV107X
+# endif
+# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
+#else
+# define machine_is_tnetv107x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAKE
+# endif
+# define machine_is_snake()	(machine_arch_type == MACH_TYPE_SNAKE)
+#else
+# define machine_is_snake()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX27
+# endif
+# define machine_is_cwmx27()	(machine_arch_type == MACH_TYPE_CWMX27)
+#else
+# define machine_is_cwmx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCH_M480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCH_M480
+# endif
+# define machine_is_sch_m480()	(machine_arch_type == MACH_TYPE_SCH_M480)
+#else
+# define machine_is_sch_m480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLATYPUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLATYPUS
+# endif
+# define machine_is_platypus()	(machine_arch_type == MACH_TYPE_PLATYPUS)
+#else
+# define machine_is_platypus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PSS2
+# endif
+# define machine_is_pss2()	(machine_arch_type == MACH_TYPE_PSS2)
+#else
+# define machine_is_pss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_APM150
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_APM150
+# endif
+# define machine_is_davinci_apm150()	(machine_arch_type == MACH_TYPE_DAVINCI_APM150)
+#else
+# define machine_is_davinci_apm150()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR9100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR9100
+# endif
+# define machine_is_str9100()	(machine_arch_type == MACH_TYPE_STR9100)
+#else
+# define machine_is_str9100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG
+# endif
+# define machine_is_net5big()	(machine_arch_type == MACH_TYPE_NET5BIG)
+#else
+# define machine_is_net5big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABED9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABED9263
+# endif
+# define machine_is_seabed9263()	(machine_arch_type == MACH_TYPE_SEABED9263)
+#else
+# define machine_is_seabed9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_M2ID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_M2ID
+# endif
+# define machine_is_mx51_m2id()	(machine_arch_type == MACH_TYPE_MX51_M2ID)
+#else
+# define machine_is_mx51_m2id()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCTVOCPLUS_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCTVOCPLUS_EB
+# endif
+# define machine_is_octvocplus_eb()	(machine_arch_type == MACH_TYPE_OCTVOCPLUS_EB)
+#else
+# define machine_is_octvocplus_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_FIREFOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_FIREFOX
+# endif
+# define machine_is_klk_firefox()	(machine_arch_type == MACH_TYPE_KLK_FIREFOX)
+#else
+# define machine_is_klk_firefox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_WIRMA_MODULE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_WIRMA_MODULE
+# endif
+# define machine_is_klk_wirma_module()	(machine_arch_type == MACH_TYPE_KLK_WIRMA_MODULE)
+#else
+# define machine_is_klk_wirma_module()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KLK_WIRMA_MMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KLK_WIRMA_MMI
+# endif
+# define machine_is_klk_wirma_mmi()	(machine_arch_type == MACH_TYPE_KLK_WIRMA_MMI)
+#else
+# define machine_is_klk_wirma_mmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUPERSONIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUPERSONIC
+# endif
+# define machine_is_supersonic()	(machine_arch_type == MACH_TYPE_SUPERSONIC)
+#else
+# define machine_is_supersonic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBERTY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBERTY
+# endif
+# define machine_is_liberty()	(machine_arch_type == MACH_TYPE_LIBERTY)
+#else
+# define machine_is_liberty()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MH355
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MH355
+# endif
+# define machine_is_mh355()	(machine_arch_type == MACH_TYPE_MH355)
+#else
+# define machine_is_mh355()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7802
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7802
+# endif
+# define machine_is_pc7802()	(machine_arch_type == MACH_TYPE_PC7802)
+#else
+# define machine_is_pc7802()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGC
+# endif
+# define machine_is_gnet_sgc()	(machine_arch_type == MACH_TYPE_GNET_SGC)
+#else
+# define machine_is_gnet_sgc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EINSTEIN15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EINSTEIN15
+# endif
+# define machine_is_einstein15()	(machine_arch_type == MACH_TYPE_EINSTEIN15)
+#else
+# define machine_is_einstein15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMPD
+# endif
+# define machine_is_cmpd()	(machine_arch_type == MACH_TYPE_CMPD)
+#else
+# define machine_is_cmpd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_HASE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_HASE1
+# endif
+# define machine_is_davinci_hase1()	(machine_arch_type == MACH_TYPE_DAVINCI_HASE1)
+#else
+# define machine_is_davinci_hase1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LGEINCITEPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LGEINCITEPHONE
+# endif
+# define machine_is_lgeincitephone()	(machine_arch_type == MACH_TYPE_LGEINCITEPHONE)
+#else
+# define machine_is_lgeincitephone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA313X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA313X
+# endif
+# define machine_is_ea313x()	(machine_arch_type == MACH_TYPE_EA313X)
+#else
+# define machine_is_ea313x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_39064
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_39064
+# endif
+# define machine_is_fwbd_39064()	(machine_arch_type == MACH_TYPE_FWBD_39064)
+#else
+# define machine_is_fwbd_39064()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_390128
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_390128
+# endif
+# define machine_is_fwbd_390128()	(machine_arch_type == MACH_TYPE_FWBD_390128)
+#else
+# define machine_is_fwbd_390128()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MOE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MOE
+# endif
+# define machine_is_pelco_moe()	(machine_arch_type == MACH_TYPE_PELCO_MOE)
+#else
+# define machine_is_pelco_moe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIMIX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIMIX27
+# endif
+# define machine_is_minimix27()	(machine_arch_type == MACH_TYPE_MINIMIX27)
+#else
+# define machine_is_minimix27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_THUNDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_THUNDER
+# endif
+# define machine_is_omap3_thunder()	(machine_arch_type == MACH_TYPE_OMAP3_THUNDER)
+#else
+# define machine_is_omap3_thunder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSIONC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSIONC
+# endif
+# define machine_is_passionc()	(machine_arch_type == MACH_TYPE_PASSIONC)
+#else
+# define machine_is_passionc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27AMATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27AMATA
+# endif
+# define machine_is_mx27amata()	(machine_arch_type == MACH_TYPE_MX27AMATA)
+#else
+# define machine_is_mx27amata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BGAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BGAT1
+# endif
+# define machine_is_bgat1()	(machine_arch_type == MACH_TYPE_BGAT1)
+#else
+# define machine_is_bgat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUZZ
+# endif
+# define machine_is_buzz()	(machine_arch_type == MACH_TYPE_BUZZ)
+#else
+# define machine_is_buzz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB9G20
+# endif
+# define machine_is_mb9g20()	(machine_arch_type == MACH_TYPE_MB9G20)
+#else
+# define machine_is_mb9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YUSHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YUSHAN
+# endif
+# define machine_is_yushan()	(machine_arch_type == MACH_TYPE_YUSHAN)
+#else
+# define machine_is_yushan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIZARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIZARD
+# endif
+# define machine_is_lizard()	(machine_arch_type == MACH_TYPE_LIZARD)
+#else
+# define machine_is_lizard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3POLYCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3POLYCOM
+# endif
+# define machine_is_omap3polycom()	(machine_arch_type == MACH_TYPE_OMAP3POLYCOM)
+#else
+# define machine_is_omap3polycom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BRAVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRAVO
+# endif
+# define machine_is_bravo()	(machine_arch_type == MACH_TYPE_BRAVO)
+#else
+# define machine_is_bravo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO1
+# endif
+# define machine_is_siogentoo1()	(machine_arch_type == MACH_TYPE_SIOGENTOO1)
+#else
+# define machine_is_siogentoo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO2
+# endif
+# define machine_is_siogentoo2()	(machine_arch_type == MACH_TYPE_SIOGENTOO2)
+#else
+# define machine_is_siogentoo2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM3K
+# endif
+# define machine_is_sm3k()	(machine_arch_type == MACH_TYPE_SM3K)
+#else
+# define machine_is_sm3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_F900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_F900
+# endif
+# define machine_is_acer_tempo_f900()	(machine_arch_type == MACH_TYPE_ACER_TEMPO_F900)
+#else
+# define machine_is_acer_tempo_f900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SST61VC010_DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SST61VC010_DEV
+# endif
+# define machine_is_sst61vc010_dev()	(machine_arch_type == MACH_TYPE_SST61VC010_DEV)
+#else
+# define machine_is_sst61vc010_dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLITTERTIND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLITTERTIND
+# endif
+# define machine_is_glittertind()	(machine_arch_type == MACH_TYPE_GLITTERTIND)
+#else
+# define machine_is_glittertind()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBOOK2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBOOK2440
+# endif
+# define machine_is_cybook2440()	(machine_arch_type == MACH_TYPE_CYBOOK2440)
+#else
+# define machine_is_cybook2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORINO_S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORINO_S
+# endif
+# define machine_is_torino_s()	(machine_arch_type == MACH_TYPE_TORINO_S)
+#else
+# define machine_is_torino_s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAVANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAVANA
+# endif
+# define machine_is_havana()	(machine_arch_type == MACH_TYPE_HAVANA)
+#else
+# define machine_is_havana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEAUMONT_11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEAUMONT_11
+# endif
+# define machine_is_beaumont_11()	(machine_arch_type == MACH_TYPE_BEAUMONT_11)
+#else
+# define machine_is_beaumont_11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGUARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGUARD
+# endif
+# define machine_is_vanguard()	(machine_arch_type == MACH_TYPE_VANGUARD)
+#else
+# define machine_is_vanguard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5PC110_DRACO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5PC110_DRACO
+# endif
+# define machine_is_s5pc110_draco()	(machine_arch_type == MACH_TYPE_S5PC110_DRACO)
+#else
+# define machine_is_s5pc110_draco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARTESIO_TWO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARTESIO_TWO
+# endif
+# define machine_is_cartesio_two()	(machine_arch_type == MACH_TYPE_CARTESIO_TWO)
+#else
+# define machine_is_cartesio_two()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASTER
+# endif
+# define machine_is_aster()	(machine_arch_type == MACH_TYPE_ASTER)
+#else
+# define machine_is_aster()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOGUESV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOGUESV210
+# endif
+# define machine_is_voguesv210()	(machine_arch_type == MACH_TYPE_VOGUESV210)
+#else
+# define machine_is_voguesv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACM500X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACM500X
+# endif
+# define machine_is_acm500x()	(machine_arch_type == MACH_TYPE_ACM500X)
+#else
+# define machine_is_acm500x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KM9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KM9260
+# endif
+# define machine_is_km9260()	(machine_arch_type == MACH_TYPE_KM9260)
+#else
+# define machine_is_km9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NIDEFLEXG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NIDEFLEXG1
+# endif
+# define machine_is_nideflexg1()	(machine_arch_type == MACH_TYPE_NIDEFLEXG1)
+#else
+# define machine_is_nideflexg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_IO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_IO
+# endif
+# define machine_is_ctera_plug_io()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_IO)
+#else
+# define machine_is_ctera_plug_io()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK2
+# endif
+# define machine_is_at91sam9g10ek2()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK2)
+#else
+# define machine_is_at91sam9g10ek2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP527
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP527
+# endif
+# define machine_is_asusp527()	(machine_arch_type == MACH_TYPE_ASUSP527)
+#else
+# define machine_is_asusp527()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20MPM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20MPM2
+# endif
+# define machine_is_at91sam9g20mpm2()	(machine_arch_type == MACH_TYPE_AT91SAM9G20MPM2)
+#else
+# define machine_is_at91sam9g20mpm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPASA900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPASA900
+# endif
+# define machine_is_topasa900()	(machine_arch_type == MACH_TYPE_TOPASA900)
+#else
+# define machine_is_topasa900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELECTRUM_100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELECTRUM_100
+# endif
+# define machine_is_electrum_100()	(machine_arch_type == MACH_TYPE_ELECTRUM_100)
+#else
+# define machine_is_electrum_100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51GRB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51GRB
+# endif
+# define machine_is_mx51grb()	(machine_arch_type == MACH_TYPE_MX51GRB)
+#else
+# define machine_is_mx51grb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XEA300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XEA300
+# endif
+# define machine_is_xea300()	(machine_arch_type == MACH_TYPE_XEA300)
+#else
+# define machine_is_xea300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCSTARTREK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCSTARTREK
+# endif
+# define machine_is_htcstartrek()	(machine_arch_type == MACH_TYPE_HTCSTARTREK)
+#else
+# define machine_is_htcstartrek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIMA
+# endif
+# define machine_is_lima()	(machine_arch_type == MACH_TYPE_LIMA)
+#else
+# define machine_is_lima()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB740
+# endif
+# define machine_is_csb740()	(machine_arch_type == MACH_TYPE_CSB740)
+#else
+# define machine_is_csb740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_S8815
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_S8815
+# endif
+# define machine_is_usb_s8815()	(machine_arch_type == MACH_TYPE_USB_S8815)
+#else
+# define machine_is_usb_s8815()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILKYWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILKYWAY
+# endif
+# define machine_is_milkyway()	(machine_arch_type == MACH_TYPE_MILKYWAY)
+#else
+# define machine_is_milkyway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOMOD6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOMOD6
+# endif
+# define machine_is_picomod6()	(machine_arch_type == MACH_TYPE_PICOMOD6)
+#else
+# define machine_is_picomod6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP6000
+# endif
+# define machine_is_ip6000()	(machine_arch_type == MACH_TYPE_IP6000)
+#else
+# define machine_is_ip6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP6010
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP6010
+# endif
+# define machine_is_ip6010()	(machine_arch_type == MACH_TYPE_IP6010)
+#else
+# define machine_is_ip6010()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UTM400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UTM400
+# endif
+# define machine_is_utm400()	(machine_arch_type == MACH_TYPE_UTM400)
+#else
+# define machine_is_utm400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_ZYBEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_ZYBEX
+# endif
+# define machine_is_omap3_zybex()	(machine_arch_type == MACH_TYPE_OMAP3_ZYBEX)
+#else
+# define machine_is_omap3_zybex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WIRELESS_SPACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WIRELESS_SPACE
+# endif
+# define machine_is_wireless_space()	(machine_arch_type == MACH_TYPE_WIRELESS_SPACE)
+#else
+# define machine_is_wireless_space()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX560
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX560
+# endif
+# define machine_is_sx560()	(machine_arch_type == MACH_TYPE_SX560)
+#else
+# define machine_is_sx560()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELPHEL10373
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELPHEL10373
+# endif
+# define machine_is_elphel10373()	(machine_arch_type == MACH_TYPE_ELPHEL10373)
+#else
+# define machine_is_elphel10373()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHOBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHOBOT
+# endif
+# define machine_is_rhobot()	(machine_arch_type == MACH_TYPE_RHOBOT)
+#else
+# define machine_is_rhobot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_REFRESH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_REFRESH
+# endif
+# define machine_is_mx51_refresh()	(machine_arch_type == MACH_TYPE_MX51_REFRESH)
+#else
+# define machine_is_mx51_refresh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LS9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LS9260
+# endif
+# define machine_is_ls9260()	(machine_arch_type == MACH_TYPE_LS9260)
+#else
+# define machine_is_ls9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANK
+# endif
+# define machine_is_shank()	(machine_arch_type == MACH_TYPE_SHANK)
+#else
+# define machine_is_shank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_ST1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_ST1
+# endif
+# define machine_is_qsd8x50_st1()	(machine_arch_type == MACH_TYPE_QSD8X50_ST1)
+#else
+# define machine_is_qsd8x50_st1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10EKES
+# endif
+# define machine_is_at91sam9m10ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9M10EKES)
+#else
+# define machine_is_at91sam9m10ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIRAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIRAM
+# endif
+# define machine_is_hiram()	(machine_arch_type == MACH_TYPE_HIRAM)
+#else
+# define machine_is_hiram()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA3250
+# endif
+# define machine_is_ea3250()	(machine_arch_type == MACH_TYPE_EA3250)
+#else
+# define machine_is_ea3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FDI3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FDI3250
+# endif
+# define machine_is_fdi3250()	(machine_arch_type == MACH_TYPE_FDI3250)
+#else
+# define machine_is_fdi3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHITESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITESTONE
+# endif
+# define machine_is_whitestone()	(machine_arch_type == MACH_TYPE_WHITESTONE)
+#else
+# define machine_is_whitestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263NIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263NIT
+# endif
+# define machine_is_at91sam9263nit()	(machine_arch_type == MACH_TYPE_AT91SAM9263NIT)
+#else
+# define machine_is_at91sam9263nit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX51
+# endif
+# define machine_is_ccmx51()	(machine_arch_type == MACH_TYPE_CCMX51)
+#else
+# define machine_is_ccmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX51JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX51JS
+# endif
+# define machine_is_ccmx51js()	(machine_arch_type == MACH_TYPE_CCMX51JS)
+#else
+# define machine_is_ccmx51js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51
+# endif
+# define machine_is_ccwmx51()	(machine_arch_type == MACH_TYPE_CCWMX51)
+#else
+# define machine_is_ccwmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51JS
+# endif
+# define machine_is_ccwmx51js()	(machine_arch_type == MACH_TYPE_CCWMX51JS)
+#else
+# define machine_is_ccwmx51js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINY6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINY6410
+# endif
+# define machine_is_tiny6410()	(machine_arch_type == MACH_TYPE_TINY6410)
+#else
+# define machine_is_tiny6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANO6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANO6410
+# endif
+# define machine_is_nano6410()	(machine_arch_type == MACH_TYPE_NANO6410)
+#else
+# define machine_is_nano6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFNLDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFNLDB
+# endif
+# define machine_is_at572d940hfnldb()	(machine_arch_type == MACH_TYPE_AT572D940HFNLDB)
+#else
+# define machine_is_at572d940hfnldb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCLEO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCLEO
+# endif
+# define machine_is_htcleo()	(machine_arch_type == MACH_TYPE_HTCLEO)
+#else
+# define machine_is_htcleo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVP13
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVP13
+# endif
+# define machine_is_avp13()	(machine_arch_type == MACH_TYPE_AVP13)
+#else
+# define machine_is_avp13()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XXSVIDEOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XXSVIDEOD
+# endif
+# define machine_is_xxsvideod()	(machine_arch_type == MACH_TYPE_XXSVIDEOD)
+#else
+# define machine_is_xxsvideod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPNEXT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPNEXT
+# endif
+# define machine_is_vpnext()	(machine_arch_type == MACH_TYPE_VPNEXT)
+#else
+# define machine_is_vpnext()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_ITC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_ITC3
+# endif
+# define machine_is_swarco_itc3()	(machine_arch_type == MACH_TYPE_SWARCO_ITC3)
+#else
+# define machine_is_swarco_itc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX51
+# endif
+# define machine_is_tx51()	(machine_arch_type == MACH_TYPE_TX51)
+#else
+# define machine_is_tx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOLBY_CAT1021
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOLBY_CAT1021
+# endif
+# define machine_is_dolby_cat1021()	(machine_arch_type == MACH_TYPE_DOLBY_CAT1021)
+#else
+# define machine_is_dolby_cat1021()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHOENIX260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHOENIX260
+# endif
+# define machine_is_phoenix260()	(machine_arch_type == MACH_TYPE_PHOENIX260)
+#else
+# define machine_is_phoenix260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UVACA_STORK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UVACA_STORK
+# endif
+# define machine_is_uvaca_stork()	(machine_arch_type == MACH_TYPE_UVACA_STORK)
+#else
+# define machine_is_uvaca_stork()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALL3078
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALL3078
+# endif
+# define machine_is_all3078()	(machine_arch_type == MACH_TYPE_ALL3078)
+#else
+# define machine_is_all3078()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_DS
+# endif
+# define machine_is_ctera_2bay_ds()	(machine_arch_type == MACH_TYPE_CTERA_2BAY_DS)
+#else
+# define machine_is_ctera_2bay_ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIOGENTOO3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIOGENTOO3
+# endif
+# define machine_is_siogentoo3()	(machine_arch_type == MACH_TYPE_SIOGENTOO3)
+#else
+# define machine_is_siogentoo3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPB5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPB5000
+# endif
+# define machine_is_epb5000()	(machine_arch_type == MACH_TYPE_EPB5000)
+#else
+# define machine_is_epb5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY9263
+# endif
+# define machine_is_hy9263()	(machine_arch_type == MACH_TYPE_HY9263)
+#else
+# define machine_is_hy9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_M900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_M900
+# endif
+# define machine_is_acer_tempo_m900()	(machine_arch_type == MACH_TYPE_ACER_TEMPO_M900)
+#else
+# define machine_is_acer_tempo_m900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_DX900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_DX900
+# endif
+# define machine_is_acer_tempo_dx650()	(machine_arch_type == MACH_TYPE_ACER_TEMPO_DX900)
+#else
+# define machine_is_acer_tempo_dx650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_TEMPO_X960
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_TEMPO_X960
+# endif
+# define machine_is_acer_tempo_x960()	(machine_arch_type == MACH_TYPE_ACER_TEMPO_X960)
+#else
+# define machine_is_acer_tempo_x960()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_ETEN_V900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_ETEN_V900
+# endif
+# define machine_is_acer_eten_v900()	(machine_arch_type == MACH_TYPE_ACER_ETEN_V900)
+#else
+# define machine_is_acer_eten_v900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_ETEN_X900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_ETEN_X900
+# endif
+# define machine_is_acer_eten_x900()	(machine_arch_type == MACH_TYPE_ACER_ETEN_X900)
+#else
+# define machine_is_acer_eten_x900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONNELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONNELL
+# endif
+# define machine_is_bonnell()	(machine_arch_type == MACH_TYPE_BONNELL)
+#else
+# define machine_is_bonnell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OHT_MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OHT_MX27
+# endif
+# define machine_is_oht_mx27()	(machine_arch_type == MACH_TYPE_OHT_MX27)
+#else
+# define machine_is_oht_mx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCQUARTZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCQUARTZ
+# endif
+# define machine_is_htcquartz()	(machine_arch_type == MACH_TYPE_HTCQUARTZ)
+#else
+# define machine_is_htcquartz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C3AX03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C3AX03
+# endif
+# define machine_is_c3ax03()	(machine_arch_type == MACH_TYPE_C3AX03)
+#else
+# define machine_is_c3ax03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESYX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESYX
+# endif
+# define machine_is_esyx()	(machine_arch_type == MACH_TYPE_ESYX)
+#else
+# define machine_is_esyx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB2
+# endif
+# define machine_is_dove_db2()	(machine_arch_type == MACH_TYPE_DOVE_DB2)
+#else
+# define machine_is_dove_db2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BULLDOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BULLDOG
+# endif
+# define machine_is_bulldog()	(machine_arch_type == MACH_TYPE_BULLDOG)
+#else
+# define machine_is_bulldog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DERELL_ME2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DERELL_ME2000
+# endif
+# define machine_is_derell_me2000()	(machine_arch_type == MACH_TYPE_DERELL_ME2000)
+#else
+# define machine_is_derell_me2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_BASE
+# endif
+# define machine_is_bcmring_base()	(machine_arch_type == MACH_TYPE_BCMRING_BASE)
+#else
+# define machine_is_bcmring_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_EVM
+# endif
+# define machine_is_bcmring_evm()	(machine_arch_type == MACH_TYPE_BCMRING_EVM)
+#else
+# define machine_is_bcmring_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_EVM_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_EVM_JAZZ
+# endif
+# define machine_is_bcmring_evm_jazz()	(machine_arch_type == MACH_TYPE_BCMRING_EVM_JAZZ)
+#else
+# define machine_is_bcmring_evm_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_SP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_SP
+# endif
+# define machine_is_bcmring_sp()	(machine_arch_type == MACH_TYPE_BCMRING_SP)
+#else
+# define machine_is_bcmring_sp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_SV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_SV
+# endif
+# define machine_is_bcmring_sv()	(machine_arch_type == MACH_TYPE_BCMRING_SV)
+#else
+# define machine_is_bcmring_sv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_SV_JAZZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_SV_JAZZ
+# endif
+# define machine_is_bcmring_sv_jazz()	(machine_arch_type == MACH_TYPE_BCMRING_SV_JAZZ)
+#else
+# define machine_is_bcmring_sv_jazz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_TABLET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_TABLET
+# endif
+# define machine_is_bcmring_tablet()	(machine_arch_type == MACH_TYPE_BCMRING_TABLET)
+#else
+# define machine_is_bcmring_tablet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_VP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_VP
+# endif
+# define machine_is_bcmring_vp()	(machine_arch_type == MACH_TYPE_BCMRING_VP)
+#else
+# define machine_is_bcmring_vp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_EVM_SEIKOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_EVM_SEIKOR
+# endif
+# define machine_is_bcmring_evm_seikor()	(machine_arch_type == MACH_TYPE_BCMRING_EVM_SEIKOR)
+#else
+# define machine_is_bcmring_evm_seikor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_SP_WQVGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_SP_WQVGA
+# endif
+# define machine_is_bcmring_sp_wqvga()	(machine_arch_type == MACH_TYPE_BCMRING_SP_WQVGA)
+#else
+# define machine_is_bcmring_sp_wqvga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING_CUSTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING_CUSTOM
+# endif
+# define machine_is_bcmring_custom()	(machine_arch_type == MACH_TYPE_BCMRING_CUSTOM)
+#else
+# define machine_is_bcmring_custom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_S200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_S200
+# endif
+# define machine_is_acer_s200()	(machine_arch_type == MACH_TYPE_ACER_S200)
+#else
+# define machine_is_acer_s200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BT270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BT270
+# endif
+# define machine_is_bt270()	(machine_arch_type == MACH_TYPE_BT270)
+#else
+# define machine_is_bt270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISEO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISEO
+# endif
+# define machine_is_iseo()	(machine_arch_type == MACH_TYPE_ISEO)
+#else
+# define machine_is_iseo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEZANNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEZANNE
+# endif
+# define machine_is_cezanne()	(machine_arch_type == MACH_TYPE_CEZANNE)
+#else
+# define machine_is_cezanne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LUCCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUCCA
+# endif
+# define machine_is_lucca()	(machine_arch_type == MACH_TYPE_LUCCA)
+#else
+# define machine_is_lucca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUPERSMART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUPERSMART
+# endif
+# define machine_is_supersmart()	(machine_arch_type == MACH_TYPE_SUPERSMART)
+#else
+# define machine_is_supersmart()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_MISANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_MISANO
+# endif
+# define machine_is_arm11_board()	(machine_arch_type == MACH_TYPE_CS_MISANO)
+#else
+# define machine_is_arm11_board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGNOLIA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGNOLIA2
+# endif
+# define machine_is_magnolia2()	(machine_arch_type == MACH_TYPE_MAGNOLIA2)
+#else
+# define machine_is_magnolia2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMXX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMXX
+# endif
+# define machine_is_emxx()	(machine_arch_type == MACH_TYPE_EMXX)
+#else
+# define machine_is_emxx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OUTLAW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OUTLAW
+# endif
+# define machine_is_outlaw()	(machine_arch_type == MACH_TYPE_OUTLAW)
+#else
+# define machine_is_outlaw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_BEI2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_BEI2
+# endif
+# define machine_is_riot_bei2()	(machine_arch_type == MACH_TYPE_RIOT_BEI2)
+#else
+# define machine_is_riot_bei2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_VOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_VOX
+# endif
+# define machine_is_riot_vox()	(machine_arch_type == MACH_TYPE_RIOT_VOX)
+#else
+# define machine_is_riot_vox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_X37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_X37
+# endif
+# define machine_is_riot_x37()	(machine_arch_type == MACH_TYPE_RIOT_X37)
+#else
+# define machine_is_riot_x37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEGA25MX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEGA25MX
+# endif
+# define machine_is_mega25mx()	(machine_arch_type == MACH_TYPE_MEGA25MX)
+#else
+# define machine_is_mega25mx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZINA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZINA2
+# endif
+# define machine_is_benzina2()	(machine_arch_type == MACH_TYPE_BENZINA2)
+#else
+# define machine_is_benzina2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGNITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGNITE
+# endif
+# define machine_is_ignite()	(machine_arch_type == MACH_TYPE_IGNITE)
+#else
+# define machine_is_ignite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FOGGIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FOGGIA
+# endif
+# define machine_is_foggia()	(machine_arch_type == MACH_TYPE_FOGGIA)
+#else
+# define machine_is_foggia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AREZZO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AREZZO
+# endif
+# define machine_is_arezzo()	(machine_arch_type == MACH_TYPE_AREZZO)
+#else
+# define machine_is_arezzo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEICA_SKYWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEICA_SKYWALKER
+# endif
+# define machine_is_leica_skywalker()	(machine_arch_type == MACH_TYPE_LEICA_SKYWALKER)
+#else
+# define machine_is_leica_skywalker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JACINTO2_JAMR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JACINTO2_JAMR
+# endif
+# define machine_is_jacinto2_jamr()	(machine_arch_type == MACH_TYPE_JACINTO2_JAMR)
+#else
+# define machine_is_jacinto2_jamr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTS_NOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTS_NOVA
+# endif
+# define machine_is_gts_nova()	(machine_arch_type == MACH_TYPE_GTS_NOVA)
+#else
+# define machine_is_gts_nova()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P3600
+# endif
+# define machine_is_p3600()	(machine_arch_type == MACH_TYPE_P3600)
+#else
+# define machine_is_p3600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DLT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DLT2
+# endif
+# define machine_is_dlt2()	(machine_arch_type == MACH_TYPE_DLT2)
+#else
+# define machine_is_dlt2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DF3120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DF3120
+# endif
+# define machine_is_df3120()	(machine_arch_type == MACH_TYPE_DF3120)
+#else
+# define machine_is_df3120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECUCORE_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECUCORE_9G20
+# endif
+# define machine_is_ecucore_9g20()	(machine_arch_type == MACH_TYPE_ECUCORE_9G20)
+#else
+# define machine_is_ecucore_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAUTEL_LPC3240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAUTEL_LPC3240
+# endif
+# define machine_is_nautel_lpc3240()	(machine_arch_type == MACH_TYPE_NAUTEL_LPC3240)
+#else
+# define machine_is_nautel_lpc3240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLACIER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLACIER
+# endif
+# define machine_is_glacier()	(machine_arch_type == MACH_TYPE_GLACIER)
+#else
+# define machine_is_glacier()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHRAZER_BULLDOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHRAZER_BULLDOG
+# endif
+# define machine_is_phrazer_bulldog()	(machine_arch_type == MACH_TYPE_PHRAZER_BULLDOG)
+#else
+# define machine_is_phrazer_bulldog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BULLDOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BULLDOG
+# endif
+# define machine_is_omap3_bulldog()	(machine_arch_type == MACH_TYPE_OMAP3_BULLDOG)
+#else
+# define machine_is_omap3_bulldog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA101
+# endif
+# define machine_is_pca101()	(machine_arch_type == MACH_TYPE_PCA101)
+#else
+# define machine_is_pca101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUZZC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUZZC
+# endif
+# define machine_is_buzzc()	(machine_arch_type == MACH_TYPE_BUZZC)
+#else
+# define machine_is_buzzc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SASIE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SASIE2
+# endif
+# define machine_is_sasie2()	(machine_arch_type == MACH_TYPE_SASIE2)
+#else
+# define machine_is_sasie2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_CIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_CIO
+# endif
+# define machine_is_davinci_cio()	(machine_arch_type == MACH_TYPE_DAVINCI_CIO)
+#else
+# define machine_is_davinci_cio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTMETER_DL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTMETER_DL
+# endif
+# define machine_is_smartmeter_dl()	(machine_arch_type == MACH_TYPE_SMARTMETER_DL)
+#else
+# define machine_is_smartmeter_dl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WZL6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WZL6410
+# endif
+# define machine_is_wzl6410()	(machine_arch_type == MACH_TYPE_WZL6410)
+#else
+# define machine_is_wzl6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WZL6410M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WZL6410M
+# endif
+# define machine_is_wzl6410m()	(machine_arch_type == MACH_TYPE_WZL6410M)
+#else
+# define machine_is_wzl6410m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WZL6410F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WZL6410F
+# endif
+# define machine_is_wzl6410f()	(machine_arch_type == MACH_TYPE_WZL6410F)
+#else
+# define machine_is_wzl6410f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WZL6410I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WZL6410I
+# endif
+# define machine_is_wzl6410i()	(machine_arch_type == MACH_TYPE_WZL6410I)
+#else
+# define machine_is_wzl6410i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPACECOM1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPACECOM1
+# endif
+# define machine_is_spacecom1()	(machine_arch_type == MACH_TYPE_SPACECOM1)
+#else
+# define machine_is_spacecom1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PINGU920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PINGU920
+# endif
+# define machine_is_pingu920()	(machine_arch_type == MACH_TYPE_PINGU920)
+#else
+# define machine_is_pingu920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BRAVOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRAVOC
+# endif
+# define machine_is_bravoc()	(machine_arch_type == MACH_TYPE_BRAVOC)
+#else
+# define machine_is_bravoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBO2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBO2440
+# endif
+# define machine_is_cybo2440()	(machine_arch_type == MACH_TYPE_CYBO2440)
+#else
+# define machine_is_cybo2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VDSSW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VDSSW
+# endif
+# define machine_is_vdssw()	(machine_arch_type == MACH_TYPE_VDSSW)
+#else
+# define machine_is_vdssw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROMULUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROMULUS
+# endif
+# define machine_is_romulus()	(machine_arch_type == MACH_TYPE_ROMULUS)
+#else
+# define machine_is_romulus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_MAGIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_MAGIC
+# endif
+# define machine_is_omap_magic()	(machine_arch_type == MACH_TYPE_OMAP_MAGIC)
+#else
+# define machine_is_omap_magic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELTD100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELTD100
+# endif
+# define machine_is_eltd100()	(machine_arch_type == MACH_TYPE_ELTD100)
+#else
+# define machine_is_eltd100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAPC7117
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAPC7117
+# endif
+# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
+#else
+# define machine_is_capc7117()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWAN
+# endif
+# define machine_is_swan()	(machine_arch_type == MACH_TYPE_SWAN)
+#else
+# define machine_is_swan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEU
+# endif
+# define machine_is_veu()	(machine_arch_type == MACH_TYPE_VEU)
+#else
+# define machine_is_veu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RM2
+# endif
+# define machine_is_rm2()	(machine_arch_type == MACH_TYPE_RM2)
+#else
+# define machine_is_rm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT2100
+# endif
+# define machine_is_tt2100()	(machine_arch_type == MACH_TYPE_TT2100)
+#else
+# define machine_is_tt2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENICE
+# endif
+# define machine_is_venice()	(machine_arch_type == MACH_TYPE_VENICE)
+#else
+# define machine_is_venice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7323
+# endif
+# define machine_is_pc7323()	(machine_arch_type == MACH_TYPE_PC7323)
+#else
+# define machine_is_pc7323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MASP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MASP
+# endif
+# define machine_is_masp()	(machine_arch_type == MACH_TYPE_MASP)
+#else
+# define machine_is_masp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_TVSTBSOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_TVSTBSOC
+# endif
+# define machine_is_fujitsu_tvstbsoc0()	(machine_arch_type == MACH_TYPE_FUJITSU_TVSTBSOC)
+#else
+# define machine_is_fujitsu_tvstbsoc0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJITSU_TVSTBSOC1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJITSU_TVSTBSOC1
+# endif
+# define machine_is_fujitsu_tvstbsoc1()	(machine_arch_type == MACH_TYPE_FUJITSU_TVSTBSOC1)
+#else
+# define machine_is_fujitsu_tvstbsoc1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXIKON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXIKON
+# endif
+# define machine_is_lexikon()	(machine_arch_type == MACH_TYPE_LEXIKON)
+#else
+# define machine_is_lexikon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440V2
+# endif
+# define machine_is_mini2440v2()	(machine_arch_type == MACH_TYPE_MINI2440V2)
+#else
+# define machine_is_mini2440v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTROL
+# endif
+# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
+#else
+# define machine_is_icontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAD
+# endif
+# define machine_is_sheevad()	(machine_arch_type == MACH_TYPE_SHEEVAD)
+#else
+# define machine_is_sheevad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_1
+# endif
+# define machine_is_qsd8x50a_st1_1()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_1)
+#else
+# define machine_is_qsd8x50a_st1_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
+# endif
+# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
+#else
+# define machine_is_qsd8x50a_st1_5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEE
+# endif
+# define machine_is_bee()	(machine_arch_type == MACH_TYPE_BEE)
+#else
+# define machine_is_bee()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX23EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX23EVK
+# endif
+# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
+#else
+# define machine_is_mx23evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP4EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP4EVB
+# endif
+# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
+#else
+# define machine_is_ap4evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STOCKHOLM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STOCKHOLM
+# endif
+# define machine_is_stockholm()	(machine_arch_type == MACH_TYPE_STOCKHOLM)
+#else
+# define machine_is_stockholm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC_H3131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC_H3131
+# endif
+# define machine_is_lpc_h3131()	(machine_arch_type == MACH_TYPE_LPC_H3131)
+#else
+# define machine_is_lpc_h3131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STINGRAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STINGRAY
+# endif
+# define machine_is_stingray()	(machine_arch_type == MACH_TYPE_STINGRAY)
+#else
+# define machine_is_stingray()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRAKEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRAKEN
+# endif
+# define machine_is_kraken()	(machine_arch_type == MACH_TYPE_KRAKEN)
+#else
+# define machine_is_kraken()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GW2388
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GW2388
+# endif
+# define machine_is_gw2388()	(machine_arch_type == MACH_TYPE_GW2388)
+#else
+# define machine_is_gw2388()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADECPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADECPU
+# endif
+# define machine_is_jadecpu()	(machine_arch_type == MACH_TYPE_JADECPU)
+#else
+# define machine_is_jadecpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARLISLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARLISLE
+# endif
+# define machine_is_carlisle()	(machine_arch_type == MACH_TYPE_CARLISLE)
+#else
+# define machine_is_carlisle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LUX_SFT9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUX_SFT9
+# endif
+# define machine_is_lux_sf9()	(machine_arch_type == MACH_TYPE_LUX_SFT9)
+#else
+# define machine_is_lux_sf9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEMID_TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEMID_TB
+# endif
+# define machine_is_nemid_tb()	(machine_arch_type == MACH_TYPE_NEMID_TB)
+#else
+# define machine_is_nemid_tb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERRIER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERRIER
+# endif
+# define machine_is_terrier()	(machine_arch_type == MACH_TYPE_TERRIER)
+#else
+# define machine_is_terrier()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TURBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TURBOT
+# endif
+# define machine_is_turbot()	(machine_arch_type == MACH_TYPE_TURBOT)
+#else
+# define machine_is_turbot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANDDAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANDDAB
+# endif
+# define machine_is_sanddab()	(machine_arch_type == MACH_TYPE_SANDDAB)
+#else
+# define machine_is_sanddab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_CICADA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_CICADA
+# endif
+# define machine_is_mx35_cicada()	(machine_arch_type == MACH_TYPE_MX35_CICADA)
+#else
+# define machine_is_mx35_cicada()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GHI2703D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GHI2703D
+# endif
+# define machine_is_ghi2703d()	(machine_arch_type == MACH_TYPE_GHI2703D)
+#else
+# define machine_is_ghi2703d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LUX_SFX9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUX_SFX9
+# endif
+# define machine_is_lux_sfx9()	(machine_arch_type == MACH_TYPE_LUX_SFX9)
+#else
+# define machine_is_lux_sfx9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LUX_SF9G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUX_SF9G
+# endif
+# define machine_is_lux_sf9g()	(machine_arch_type == MACH_TYPE_LUX_SF9G)
+#else
+# define machine_is_lux_sf9g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LUX_EDK9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUX_EDK9
+# endif
+# define machine_is_lux_edk9()	(machine_arch_type == MACH_TYPE_LUX_EDK9)
+#else
+# define machine_is_lux_edk9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HW90240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HW90240
+# endif
+# define machine_is_hw90240()	(machine_arch_type == MACH_TYPE_HW90240)
+#else
+# define machine_is_hw90240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM365_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM365_LEOPARD
+# endif
+# define machine_is_dm365_leopard()	(machine_arch_type == MACH_TYPE_DM365_LEOPARD)
+#else
+# define machine_is_dm365_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MITYOMAPL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
+# endif
+# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
+#else
+# define machine_is_mityomapl138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCAT110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCAT110
+# endif
+# define machine_is_scat110()	(machine_arch_type == MACH_TYPE_SCAT110)
+#else
+# define machine_is_scat110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A1
+# endif
+# define machine_is_acer_a1()	(machine_arch_type == MACH_TYPE_ACER_A1)
+#else
+# define machine_is_acer_a1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CMCONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CMCONTROL
+# endif
+# define machine_is_cmcontrol()	(machine_arch_type == MACH_TYPE_CMCONTROL)
+#else
+# define machine_is_cmcontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_LAMAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_LAMAR
+# endif
+# define machine_is_pelco_lamar()	(machine_arch_type == MACH_TYPE_PELCO_LAMAR)
+#else
+# define machine_is_pelco_lamar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFP43
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFP43
+# endif
+# define machine_is_rfp43()	(machine_arch_type == MACH_TYPE_RFP43)
+#else
+# define machine_is_rfp43()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SK86R0301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SK86R0301
+# endif
+# define machine_is_sk86r0301()	(machine_arch_type == MACH_TYPE_SK86R0301)
+#else
+# define machine_is_sk86r0301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTPXA
+# endif
+# define machine_is_ctpxa()	(machine_arch_type == MACH_TYPE_CTPXA)
+#else
+# define machine_is_ctpxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPB_ARM9_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPB_ARM9_A
+# endif
+# define machine_is_epb_arm9_a()	(machine_arch_type == MACH_TYPE_EPB_ARM9_A)
+#else
+# define machine_is_epb_arm9_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURUPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURUPLUG
+# endif
+# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
+#else
+# define machine_is_guruplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR310
+# endif
+# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
+#else
+# define machine_is_spear310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320
+# endif
+# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
+#else
+# define machine_is_spear320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROBOTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROBOTX
+# endif
+# define machine_is_robotx()	(machine_arch_type == MACH_TYPE_ROBOTX)
+#else
+# define machine_is_robotx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LSXHL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LSXHL
+# endif
+# define machine_is_lsxhl()	(machine_arch_type == MACH_TYPE_LSXHL)
+#else
+# define machine_is_lsxhl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTLITE
+# endif
+# define machine_is_smartlite()	(machine_arch_type == MACH_TYPE_SMARTLITE)
+#else
+# define machine_is_smartlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWS2
+# endif
+# define machine_is_cws2()	(machine_arch_type == MACH_TYPE_CWS2)
+#else
+# define machine_is_cws2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M619
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M619
+# endif
+# define machine_is_m619()	(machine_arch_type == MACH_TYPE_M619)
+#else
+# define machine_is_m619()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTVIEW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTVIEW
+# endif
+# define machine_is_smartview()	(machine_arch_type == MACH_TYPE_SMARTVIEW)
+#else
+# define machine_is_smartview()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LSA_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LSA_SALSA
+# endif
+# define machine_is_lsa_salsa()	(machine_arch_type == MACH_TYPE_LSA_SALSA)
+#else
+# define machine_is_lsa_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIZBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIZBOX
+# endif
+# define machine_is_kizbox()	(machine_arch_type == MACH_TYPE_KIZBOX)
+#else
+# define machine_is_kizbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCCHARMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCCHARMER
+# endif
+# define machine_is_htccharmer()	(machine_arch_type == MACH_TYPE_HTCCHARMER)
+#else
+# define machine_is_htccharmer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUF_NESO_LT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUF_NESO_LT
+# endif
+# define machine_is_guf_neso_lt()	(machine_arch_type == MACH_TYPE_GUF_NESO_LT)
+#else
+# define machine_is_guf_neso_lt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PM9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PM9G45
+# endif
+# define machine_is_pm9g45()	(machine_arch_type == MACH_TYPE_PM9G45)
+#else
+# define machine_is_pm9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPANTHER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPANTHER
+# endif
+# define machine_is_htcpanther()	(machine_arch_type == MACH_TYPE_HTCPANTHER)
+#else
+# define machine_is_htcpanther()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPANTHER_CDMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPANTHER_CDMA
+# endif
+# define machine_is_htcpanther_cdma()	(machine_arch_type == MACH_TYPE_HTCPANTHER_CDMA)
+#else
+# define machine_is_htcpanther_cdma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REB01
+# endif
+# define machine_is_reb01()	(machine_arch_type == MACH_TYPE_REB01)
+#else
+# define machine_is_reb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUILA
+# endif
+# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
+#else
+# define machine_is_aquila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARK_SLS_HW2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARK_SLS_HW2
+# endif
+# define machine_is_spark_sls_hw2()	(machine_arch_type == MACH_TYPE_SPARK_SLS_HW2)
+#else
+# define machine_is_spark_sls_hw2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
+# endif
+# define machine_is_sheeva_esata()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
+#else
+# define machine_is_sheeva_esata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SURF7X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SURF7X30
+# endif
+# define machine_is_surf7x30()	(machine_arch_type == MACH_TYPE_SURF7X30)
+#else
+# define machine_is_surf7x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO2440
+# endif
+# define machine_is_micro2440()	(machine_arch_type == MACH_TYPE_MICRO2440)
+#else
+# define machine_is_micro2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AM2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AM2440
+# endif
+# define machine_is_am2440()	(machine_arch_type == MACH_TYPE_AM2440)
+#else
+# define machine_is_am2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQ2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQ2440
+# endif
+# define machine_is_tq2440()	(machine_arch_type == MACH_TYPE_TQ2440)
+#else
+# define machine_is_tq2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC2478OEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC2478OEM
+# endif
+# define machine_is_lpc2478oem()	(machine_arch_type == MACH_TYPE_LPC2478OEM)
+#else
+# define machine_is_lpc2478oem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK880X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK880X
+# endif
+# define machine_is_ak880x()	(machine_arch_type == MACH_TYPE_AK880X)
+#else
+# define machine_is_ak880x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBRA3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBRA3530
+# endif
+# define machine_is_cobra3530()	(machine_arch_type == MACH_TYPE_COBRA3530)
+#else
+# define machine_is_cobra3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PMPPB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PMPPB
+# endif
+# define machine_is_pmppb()	(machine_arch_type == MACH_TYPE_PMPPB)
+#else
+# define machine_is_pmppb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U6715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U6715
+# endif
+# define machine_is_u6715()	(machine_arch_type == MACH_TYPE_U6715)
+#else
+# define machine_is_u6715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXAR1500_SENDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXAR1500_SENDER
+# endif
+# define machine_is_axar1500_sender()	(machine_arch_type == MACH_TYPE_AXAR1500_SENDER)
+#else
+# define machine_is_axar1500_sender()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G30_DVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G30_DVB
+# endif
+# define machine_is_g30_dvb()	(machine_arch_type == MACH_TYPE_G30_DVB)
+#else
+# define machine_is_g30_dvb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC088X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC088X
+# endif
+# define machine_is_vc088x()	(machine_arch_type == MACH_TYPE_VC088X)
+#else
+# define machine_is_vc088x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA702
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA702
+# endif
+# define machine_is_mioa702()	(machine_arch_type == MACH_TYPE_MIOA702)
+#else
+# define machine_is_mioa702()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPMIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPMIN
+# endif
+# define machine_is_hpmin()	(machine_arch_type == MACH_TYPE_HPMIN)
+#else
+# define machine_is_hpmin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AK880XAK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AK880XAK
+# endif
+# define machine_is_ak880xak()	(machine_arch_type == MACH_TYPE_AK880XAK)
+#else
+# define machine_is_ak880xak()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VAL3153
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VAL3153
+# endif
+# define machine_is_val3153()	(machine_arch_type == MACH_TYPE_VAL3153)
+#else
+# define machine_is_val3153()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VAL3154
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VAL3154
+# endif
+# define machine_is_val3154()	(machine_arch_type == MACH_TYPE_VAL3154)
+#else
+# define machine_is_val3154()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA3152
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA3152
+# endif
+# define machine_is_ea3152()	(machine_arch_type == MACH_TYPE_EA3152)
+#else
+# define machine_is_ea3152()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -Nur ../linux-2.6.33-lpc313x/include/generated/utsrelease.h ../linux-2.6.33-lpc313x_original/include/generated/utsrelease.h
--- ../linux-2.6.33-lpc313x/include/generated/utsrelease.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/generated/utsrelease.h	2012-10-07 01:51:11.000000000 +0200
@@ -0,0 +1 @@
+#define UTS_RELEASE "2.6.33-gcf33f41-dirty"
diff -Nur ../linux-2.6.33-lpc313x/include/linux/atomic.h ../linux-2.6.33-lpc313x_original/include/linux/atomic.h
--- ../linux-2.6.33-lpc313x/include/linux/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/linux/atomic.h	2012-10-06 18:29:30.000000000 +0200
@@ -0,0 +1,104 @@
+/* Atomic operations usable in machine independent code */
+#ifndef _LINUX_ATOMIC_H
+#define _LINUX_ATOMIC_H
+#include <asm/atomic.h>
+
+/**
+ * atomic_add_unless - add unless the number is already a given value
+ * @v: pointer of type atomic_t
+ * @a: the amount to add to v...
+ * @u: ...unless v is equal to u.
+ *
+ * Atomically adds @a to @v, so long as @v was not already @u.
+ * Returns non-zero if @v was not @u, and zero otherwise.
+ */
+static inline int atomic_add_unless(atomic_t *v, int a, int u)
+{
+	return __atomic_add_unless(v, a, u) != u;
+}
+
+/**
+ * atomic_inc_not_zero - increment unless the number is zero
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1, so long as @v is non-zero.
+ * Returns non-zero if @v was non-zero, and zero otherwise.
+ */
+#define atomic_inc_not_zero(v)		atomic_add_unless((v), 1, 0)
+
+/**
+ * atomic_inc_not_zero_hint - increment if not null
+ * @v: pointer of type atomic_t
+ * @hint: probable value of the atomic before the increment
+ *
+ * This version of atomic_inc_not_zero() gives a hint of probable
+ * value of the atomic. This helps processor to not read the memory
+ * before doing the atomic read/modify/write cycle, lowering
+ * number of bus transactions on some arches.
+ *
+ * Returns: 0 if increment was not done, 1 otherwise.
+ */
+#ifndef atomic_inc_not_zero_hint
+static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
+{
+	int val, c = hint;
+
+	/* sanity test, should be removed by compiler if hint is a constant */
+	if (!hint)
+		return atomic_inc_not_zero(v);
+
+	do {
+		val = atomic_cmpxchg(v, c, c + 1);
+		if (val == c)
+			return 1;
+		c = val;
+	} while (c);
+
+	return 0;
+}
+#endif
+
+#ifndef atomic_inc_unless_negative
+static inline int atomic_inc_unless_negative(atomic_t *p)
+{
+	int v, v1;
+	for (v = 0; v >= 0; v = v1) {
+		v1 = atomic_cmpxchg(p, v, v + 1);
+		if (likely(v1 == v))
+			return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifndef atomic_dec_unless_positive
+static inline int atomic_dec_unless_positive(atomic_t *p)
+{
+	int v, v1;
+	for (v = 0; v <= 0; v = v1) {
+		v1 = atomic_cmpxchg(p, v, v - 1);
+		if (likely(v1 == v))
+			return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_ARCH_HAS_ATOMIC_OR
+static inline void atomic_or(int i, atomic_t *v)
+{
+	int old;
+	int new;
+
+	do {
+		old = atomic_read(v);
+		new = old | i;
+	} while (atomic_cmpxchg(v, old, new) != old);
+}
+#endif /* #ifndef CONFIG_ARCH_HAS_ATOMIC_OR */
+
+#include <asm-generic/atomic-long.h>
+#ifdef CONFIG_GENERIC_ATOMIC64
+#include <asm-generic/atomic64.h>
+#endif
+#endif /* _LINUX_ATOMIC_H */
diff -Nur ../linux-2.6.33-lpc313x/include/linux/version.h ../linux-2.6.33-lpc313x_original/include/linux/version.h
--- ../linux-2.6.33-lpc313x/include/linux/version.h	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/include/linux/version.h	2012-10-06 18:29:30.000000000 +0200
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132641
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -Nur ../linux-2.6.33-lpc313x/kernel/mutex.c ../linux-2.6.33-lpc313x_original/kernel/mutex.c
--- ../linux-2.6.33-lpc313x/kernel/mutex.c	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/kernel/mutex.c	2012-10-06 18:29:30.000000000 +0200
@@ -485,7 +485,7 @@
 int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)
 {
 	/* dec if we can't possibly hit 0 */
-	if (atomic_add_unless(cnt, -1, 1))
+	if (__atomic_add_unless(cnt, -1, 1))
 		return 0;
 	/* we might hit 0, so take the lock */
 	mutex_lock(lock);
diff -Nur ../linux-2.6.33-lpc313x/lib/dec_and_lock.c ../linux-2.6.33-lpc313x_original/lib/dec_and_lock.c
--- ../linux-2.6.33-lpc313x/lib/dec_and_lock.c	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/lib/dec_and_lock.c	2012-10-06 18:29:30.000000000 +0200
@@ -20,7 +20,7 @@
 int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock)
 {
 	/* Subtract 1 from counter unless that drops it to 0 (ie. it was 1) */
-	if (atomic_add_unless(atomic, -1, 1))
+	if (__atomic_add_unless(atomic, -1, 1))
 		return 0;
 
 	/* Otherwise do it the slow way */
diff -Nur ../linux-2.6.33-lpc313x/lib/hexdump.c ../linux-2.6.33-lpc313x_original/lib/hexdump.c
--- ../linux-2.6.33-lpc313x/lib/hexdump.c	2012-10-07 02:07:25.000000000 +0200
+++ ../linux-2.6.33-lpc313x_original/lib/hexdump.c	2012-10-06 18:29:30.000000000 +0200
@@ -15,6 +15,52 @@
 const char hex_asc[] = "0123456789abcdef";
 EXPORT_SYMBOL(hex_asc);
 
+
+
+
+
+/**
+ * hex_to_bin - convert a hex digit to its real value
+ * @ch: ascii character represents hex digit
+ *
+ * hex_to_bin() converts one hex digit to its actual value or -1 in case of bad
+ * input.
+ */
+int hex_to_bin(char ch)
+{
+        if ((ch >= '0') && (ch <= '9'))
+                return ch - '0';
+        ch = tolower(ch);
+        if ((ch >= 'a') && (ch <= 'f'))
+                return ch - 'a' + 10;
+        return -1;
+}
+EXPORT_SYMBOL(hex_to_bin);
+
+/**
+ * hex2bin - convert an ascii hexadecimal string to its binary representation
+ * @dst: binary result
+ * @src: ascii hexadecimal string
+ * @count: result length
+ *
+ * Return 0 on success, -1 in case of bad input.
+ */
+int hex2bin(u8 *dst, const char *src, size_t count)
+{
+        while (count--) {
+                int hi = hex_to_bin(*src++);
+                int lo = hex_to_bin(*src++);
+
+                if ((hi < 0) || (lo < 0))
+                        return -1;
+
+                *dst++ = (hi << 4) | lo;
+        }
+        return 0;
+}
+EXPORT_SYMBOL(hex2bin);
+
+
 /**
  * hex_dump_to_buffer - convert a blob of data to "hex ASCII" in memory
  * @buf: data blob to dump
diff -Nur ../linux-2.6.33-lpc313x/Module.symvers ../linux-2.6.33-lpc313x_original/Module.symvers
--- ../linux-2.6.33-lpc313x/Module.symvers	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/Module.symvers	2012-10-06 18:29:27.000000000 +0200
@@ -0,0 +1,3741 @@
+0x00000000	cfg80211_send_rx_assoc	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_wake_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_videomate_tv_pvr_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_kaiomy_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_put_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
+0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	unblock_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_tbs_nec_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_stopped	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwscan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_register	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_end_command	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_execute	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_seq_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_add_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_map_sector_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_update_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_initialize_rcv_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	net_enable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	sockfd_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__unregister_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	directly_mappable_cdev_bdi	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_get_command	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_next_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	input_handler_for_each_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	iget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestampns	vmlinux	EXPORT_SYMBOL
+0x00000000	class_interface_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_get_device_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_interface_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_md5_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	reset_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_budget_ci_old_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bus_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_last	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_string	vmlinux	EXPORT_SYMBOL
+0x00000000	memmove	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	laptop_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	end_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	return_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_genius_tvgo_a11mce_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_get_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_request_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwfreq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfreq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
+0x00000000	register_console	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_socketpair	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_fill_dv_preset_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arpt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_copy_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	__krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	task_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	kset_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mm_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_chip_data	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_fini	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_avermedia_a16d_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	load_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_unmap_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_year_days	vmlinux	EXPORT_SYMBOL
+0x00000000	input_unregister_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ehci_cf_port_reset_rwsem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_mon_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
+0x00000000	single_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	I_BDEV	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_get	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_tty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_sg_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_buffer_unmap_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_reset_provider	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_request_specific_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_twsk_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_try_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_extd_sense_format	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_to_ieee80211_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_is_keyboard_id	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_new_subdev_board	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_driver_release_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_blockdev	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__ashrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__lshrdi3	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_rfree	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_asus_pc39_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__root_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_arm926_set_pte_ext	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_release	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_long	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pgprot_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfree_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	walk_stackframe	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_nocheck	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_defrag	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	idr_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_read	vmlinux	EXPORT_SYMBOL
+0x00000000	free_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_setup_caps	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_get	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateIncomp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_pre_get	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sigprocmask	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	do_mmap_pgoff	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_nebula_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_master_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_flush_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	genlmsg_multicast_allns	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_rescan_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_add	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_empty_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_kernel_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	mktime	vmlinux	EXPORT_SYMBOL
+0x00000000	system_state	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_int_ioctl_0	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_next	vmlinux	EXPORT_SYMBOL
+0x00000000	csum_partial_copy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_em_terratec_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	con_set_default_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	cgu_set_subdomain_freq	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_addr_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	ioctl_by_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_power_restore_host	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_remove_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_delete_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_wait_for_req	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_lasr	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_llsr	vmlinux	EXPORT_SYMBOL
+0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_next	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
+0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_terratec_cinergy_xs_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
+0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_reinject	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_add_host	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_chars_in_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unregister_region	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_sub_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcds_loaded	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__csum_ipv6_magic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull_rcsum	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	malloc_sizes	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_on	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_unwind_cpp_pr0	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_unwind_cpp_pr2	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_inode_is_dead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	module_refcount	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ctl_sock_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_vs_conn_in_get	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_put_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_driver_flush_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	strsep	vmlinux	EXPORT_SYMBOL
+0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_4	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_min_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_disable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serial8250_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_skip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	put_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_bdi_congested	vmlinux	EXPORT_SYMBOL
+0x00000000	____pagevec_lru_add	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_me_harder	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_addr_unsync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_block_bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_skip_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_data_from_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	bin2bcd	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_read_only	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pages_list	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wfree	vmlinux	EXPORT_SYMBOL
+0x00000000	test_set_page_writeback	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_exclusive_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	qdisc_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_remap	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_timer_bug_msg	vmlinux	EXPORT_SYMBOL
+0x00000000	input_flush_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	num_physpages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_list_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_disk_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
+0x00000000	register_ip_vs_app_inc	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	video_device_release	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_prepare_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	_change_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_hdrlen_from_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_cancel_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_underlying_metadata	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	krealloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_data	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__invalidate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_low_latency	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_max_low_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_sync_file	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_table	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_flip_buffer_push	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_divisor	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_init_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_add_safe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	msleep	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unpoison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
+0x00000000	get_random_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_off	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_peek_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_free_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_prep_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_ip_vs_scheduler	vmlinux	EXPORT_SYMBOL
+0x00000000	vlan_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_input_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_shorten	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	thread_notify_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_scan_target	vmlinux	EXPORT_SYMBOL
+0x00000000	list_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
+0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xc5000_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_blk_pc_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_uevent_env	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_timer_key	vmlinux	EXPORT_SYMBOL
+0x00000000	put_cmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_free_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	filp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_std_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_inode_pages_range	vmlinux	EXPORT_SYMBOL
+0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_get_name	vmlinux	EXPORT_SYMBOL
+0x00000000	d_path	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	igrab	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__softnet_data	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_check_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	warn_slowpath_null	vmlinux	EXPORT_SYMBOL
+0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_init_io	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_subdev_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_i2c_subdev_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_write_wakeup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_append	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_from_user_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wireless_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sget	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_chip	vmlinux	EXPORT_SYMBOL
+0x00000000	memset	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_dst_blackhole	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_hw_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_mounts_for_expiry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_drain	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_int_device_try_attach_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_in	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_get_port	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	loop_unregister_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget_failed	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_sub_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_set_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_claim_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu____irq_regs	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_session	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_video_std_frame_period	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_size_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfifo_free	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_prev	vmlinux	EXPORT_SYMBOL
+0x00000000	down_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_parse_md5sig_option	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__const_udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_queue_work	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_power_off	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_register_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	con_copy_unimap	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_ldisc_ref_wait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_u64	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_commit_write	vmlinux	EXPORT_SYMBOL
+0x00000000	__netdev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	bcd2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	dput	vmlinux	EXPORT_SYMBOL
+0x00000000	is_container_init	vmlinux	EXPORT_SYMBOL
+0x00000000	cgu_hpll_config	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_remember_stamp	vmlinux	EXPORT_SYMBOL
+0x00000000	fill_inquiry_response	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_match_one_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	screen_glyph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_uidivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_hdrlen	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_norm_to_name	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_flush_dcache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_vddrange_to_ocrmask	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_pixelview_new_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unlock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	do_posix_clock_nosettime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_congestion_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_vs_conn_put	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_push	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_f0_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
+0x00000000	free_task	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_release_host	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in_n	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_out_peek	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_unlink_urb_from_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagevec_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	current_kernel_time	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_cong_avoid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_set_nonroot	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_start_copy_compat	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_remove_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_find_next_zero_area	vmlinux	EXPORT_SYMBOL
+0x00000000	__suspend_report_result	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	unload_nls	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gso_segment	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_left	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_skb_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_init	vmlinux	EXPORT_SYMBOL
+0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
+0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memset_io	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_start_tx_ba_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_process_call	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iput	vmlinux	EXPORT_SYMBOL
+0x00000000	sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_mib_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_upload	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_low	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
+0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_set_mnt	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_event_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_get	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_unlink_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netdev_alloc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_inode_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwgenie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_insert_cloned_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_update_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_timer_deferrable_key	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_from_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_release	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_optmem_max	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in4_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	in6_pton	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_mode_select	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_xor	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__clear_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	suspend_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_has_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_channel_to_frequency	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dcache_dir_lseek	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	test_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	__udivsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_pv951_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_bh_lrus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_check_match	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_compat_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_expand_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_splice_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek_unlocked	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mem_map	vmlinux	EXPORT_SYMBOL
+0x00000000	console_suspend_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_fix_features	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_release_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_wait_for_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_find_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cad_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	cacheid	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_probing_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tuner_count	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_setcleanup	vmlinux	EXPORT_SYMBOL
+0x00000000	recalc_sigpending	vmlinux	EXPORT_SYMBOL
+0x00000000	system_serial_high	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_dev_find	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_restart_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_read_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_init	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_set_default	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_pause_and_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	fiemap_fill_next_extent	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_init	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6msg_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_set_sk_err	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_real_audio_220_32_keys_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_add_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	downgrade_write	vmlinux	EXPORT_SYMBOL
+0x00000000	complete	vmlinux	EXPORT_SYMBOL
+0x00000000	get_mem_type	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_single_seg_count	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_test_unit_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_index	vmlinux	EXPORT_SYMBOL
+0x00000000	high_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_check_arch	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_get_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	mc44s803_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_link	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_target	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_result	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_cache_async_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	kblockd_schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_event_send	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_close	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_store_int	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_cache_page_async	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_uninterruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	allow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_put_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_alt_setting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_frags_exit_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_printk_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_put	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_copystring	vmlinux	EXPORT_SYMBOL
+0x00000000	__send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_scuttle_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	div64_u64	vmlinux	EXPORT_SYMBOL
+0x00000000	ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_reset_configuration	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	down_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_cleanup_ops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_equal	vmlinux	EXPORT_SYMBOL
+0x00000000	__init_rwsem	vmlinux	EXPORT_SYMBOL
+0x00000000	page_zero_new_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	fasync_helper	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_hauppauge_new_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_mandatory_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_deschedule	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_table_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_pskb	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_shift_right	vmlinux	EXPORT_SYMBOL
+0x00000000	__request_module	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_unregister_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
+0x00000000	dlci_ioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_tx_ipv6_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwretry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	refrigerator	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	do_blank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	single_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_page_dirty_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_conn_request	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_udp_wmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_syn_recv_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_shrink	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_stop_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	__readwrite_bug	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_add_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	csum_partial_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_hashinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5761_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_aead_setauthsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fd_install	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_internal_device_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync_range	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_device_klist	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	path_put	vmlinux	EXPORT_SYMBOL
+0x00000000	apply_to_page_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	out_of_line_wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	dst_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	video_register_device	vmlinux	EXPORT_SYMBOL
+0x00000000	__iowrite64_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_partition	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_release_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_miter_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_proto_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vmalloc_32_user	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_copy_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_brk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_rc5_timer_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_stdinpipe	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_current_state	vmlinux	EXPORT_SYMBOL
+0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_start	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_release	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_before	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
+0x00000000	down_read	vmlinux	EXPORT_SYMBOL
+0x00000000	km_report	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_compat_translate_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_setup_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_softirq_done	vmlinux	EXPORT_SYMBOL
+0x00000000	d_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_mc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_flush_done_q	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_morph	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_arm926_dcache_clean_area	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_set_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_dcache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_next_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_is_host_device	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioremap_nocache	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_ssthresh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iter_div_u64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_alloc_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
+0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_tevii_nec_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_kworld_plus_tv_analog_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_effect_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_segment_boundary	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stop_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_insert_request	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_virt_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_create_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	task_active_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clock_t_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	__ipv6_isatap_ifid	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_fusionhdtv_mce_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_winfast_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	up_write	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_all_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_state_check	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	fget	vmlinux	EXPORT_SYMBOL
+0x00000000	match_token	vmlinux	EXPORT_SYMBOL
+0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_frequency_to_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_block_super	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_lookup_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwencodeext	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_create_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_queue_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_interrupt	vmlinux	EXPORT_SYMBOL
+0x00000000	color_table	vmlinux	EXPORT_SYMBOL
+0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	argv_split	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_hw_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_aes_set_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alg_test	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_conditional_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_discard	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_symlink	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_detach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	microtune_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xattr_getsecurity	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	smp_call_function_single	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_free_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_erase	vmlinux	EXPORT_SYMBOL
+0x00000000	strcasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	save_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	ifla_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	video_usercopy	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unthrottle	vmlinux	EXPORT_SYMBOL
+0x00000000	set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	block_page_mkwrite	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_core_debug	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwtxpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwtxpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
+0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_nested_thread	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_manli_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_gro_receive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flock_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_match	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_warn_lro_forwarding	vmlinux	EXPORT_SYMBOL
+0x00000000	memcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_digest	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	locks_init_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_add_pc_page	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_stacked_transfer_operstate	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_reconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	d_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_finish	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_ioport_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	cont_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate	vmlinux	EXPORT_SYMBOL
+0x00000000	vscnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_recount_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_out	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_request_sg_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_gadget_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
+0x00000000	arm926_flush_user_cache_range	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_dm1105_nec_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_sysdev_class	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache_update	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	strncpy	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	get_max_files	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_set_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_release_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_init_eff_set	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_mount_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_requeue_request	vmlinux	EXPORT_SYMBOL
+0x00000000	insert_inode_locked4	vmlinux	EXPORT_SYMBOL
+0x00000000	strndup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_behold_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwfrag	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
+0x00000000	class_compat_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	allocate_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	block_prepare_write	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_netdev_mq	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_write_then_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	splice_from_pipe_feed	vmlinux	EXPORT_SYMBOL
+0x00000000	__round_jiffies	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rmdir	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_shutdown_super	vmlinux	EXPORT_SYMBOL
+0x00000000	get_jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_track_queue_full	vmlinux	EXPORT_SYMBOL
+0x00000000	init_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_avertv_303_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	schedule_timeout_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_buffer_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_export	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_remove	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_release_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	con_is_bound	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_page	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	restore_time_delta	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_auth_canceled	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ioremap_page	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
+0x00000000	__kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	async_schedule	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_put	vmlinux	EXPORT_SYMBOL
+0x00000000	strnstr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_unplug_device	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_elf_read_implies_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_show_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	async_schedule_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bug	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_memcpy_fromio	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_2	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_get	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_put	vmlinux	EXPORT_SYMBOL
+0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5761_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_setkeys	vmlinux	EXPORT_SYMBOL
+0x00000000	__check_region	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rate_control_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_get_part	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_kernel_release	vmlinux	EXPORT_SYMBOL
+0x00000000	down_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_off	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_request_done	vmlinux	EXPORT_SYMBOL
+0x00000000	sdev_evt_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lease_get_mtime	vmlinux	EXPORT_SYMBOL
+0x00000000	sb_set_blocksize	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_start_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_sk_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_writew	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_clear_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_ctstoself_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	tda829x_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_fpu	vmlinux	EXPORT_SYMBOL
+0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_apac_viewcomp_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_extract_bits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_zero_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_suspend	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	class_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	thaw_process	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
+0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
+0x00000000	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_set_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	arm_pm_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_md5_hash_key	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_rc5_tv_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_former_request	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_wait_data	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_replace_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_hashinfo_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_int_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_transfer_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	end_buffer_read_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pinned	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_for_each	vmlinux	EXPORT_SYMBOL
+0x00000000	rtc_month_days	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_calc_bus_time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_miter_next	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_shash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_init_ahash_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_get_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pull	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_find_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_app_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_unmount_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_tx_ba_cb	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_build_and_send_pkt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_gifconf	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_rng_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_rcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_out_n	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_classify8021d	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap	vmlinux	EXPORT_SYMBOL
+0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_release_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	put_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	put_page	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_deref	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
+0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_claim_by_disk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nobh_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_generic_frame_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_set_tx_hw_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	up	vmlinux	EXPORT_SYMBOL
+0x00000000	icmp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	path_get	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_udp_rmem_min	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
+0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	execute_in_process_context	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_table_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	video_register_device_no_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5767_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kset_register	vmlinux	EXPORT_SYMBOL
+0x00000000	fput	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_ep0_reinit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_lock_file_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_remove_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	strnicmp	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_to_page	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_update_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_release	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_giveback_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	add_wait_queue_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
+0x00000000	register_posix_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_init	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	lpc313x_entering_suspend_mem	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_readsl	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_adjust_queue_depth	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_check_req	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_register	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_close	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pgrp	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_build_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
+0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_free_datagram_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sock_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_idiv	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_start_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_alloc_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_cache_maint_page	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_sta_block_awake	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_unregister_child_port	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_input_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_merge_bvec	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_want_write_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_md5_hash_header	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_free_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	should_remove_suid	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_avermedia_dvbt_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_register	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_set	vmlinux	EXPORT_SYMBOL
+0x00000000	param_array_get	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_beacon_get_tim	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__div0	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_buffer_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
+0x00000000	init_user_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_map_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_pinnacle_pctv_hd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__sk_mem_reclaim	vmlinux	EXPORT_SYMBOL
+0x00000000	d_prune_aliases	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_fromiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
+0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_tt_1500_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_autopm_put_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_unlock	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_register_family_with_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	net_assign_generic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__kstat	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
+0x00000000	kbd_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_fill_super	vmlinux	EXPORT_SYMBOL
+0x00000000	have_submounts	vmlinux	EXPORT_SYMBOL
+0x00000000	printk_timed_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_vlan_hwaccel_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_load	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_add_page	vmlinux	EXPORT_SYMBOL
+0x00000000	init_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__memzero	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_thread	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflateEnd	vmlinux	EXPORT_SYMBOL
+0x00000000	open_by_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	contig_page_data	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__softirq_work_list	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_target	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_g_keycode_from_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	console_blanked	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_start_tx_ba_session	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_roundup_tablesize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitrev32	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_read	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_mmap_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_connect_result	vmlinux	EXPORT_SYMBOL
+0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_sysfs_set_active_low	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_create	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kill_litter_super	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_vs_conn_new	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_proto_csum_replace4	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_free_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_prepare_flip_string_flags	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_check_limits	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__lock_page_killable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_rules_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_copy_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_all	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_make_synack	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_page	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_forward	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bit_waitqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inodes	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_file_write_access	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_mc_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
+0x00000000	get_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_roamed	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kick_iocb	vmlinux	EXPORT_SYMBOL
+0x00000000	snprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	get_io_context	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_kzalloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_attr_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bread	vmlinux	EXPORT_SYMBOL
+0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
+0x00000000	posix_unblock_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	__mnt_is_readonly	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_close	vmlinux	EXPORT_SYMBOL
+0x00000000	__scm_send	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_dma_map	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_free_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_cred	vmlinux	EXPORT_SYMBOL
+0x00000000	add_input_randomness	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iov_iter_advance	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_unblock_requests	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_free_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_claim	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_posix_clock_nonanosleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_master_send	vmlinux	EXPORT_SYMBOL
+0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_free	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_drop_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_readpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_srcu_expedited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__umodsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cong_avoid_ai	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpuidle_resume_and_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_altnum_to_altsetting	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	redraw_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_change	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_complement	vmlinux	EXPORT_SYMBOL
+0x00000000	memdup_user	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_get_required_mask	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	del_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_log_unbind_pf	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_current_frame_number	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pm_qos_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_close	vmlinux	EXPORT_SYMBOL
+0x00000000	__mark_inode_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	noop_qdisc	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_alloc_send_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_field_names	vmlinux	EXPORT_SYMBOL
+0x00000000	tda9887_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__destroy_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_is_cwnd_limited	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_nec_terratec_cinergy_xs_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_mon_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_plug_device	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_mod_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_device_unregister_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_execve	vmlinux	EXPORT_SYMBOL
+0x00000000	__printk_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twdr_hangman	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_encore_enltv_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	__blk_end_request_err	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf8_to_utf32	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_prep_return	vmlinux	EXPORT_SYMBOL
+0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
+0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_radiotap_iterator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writesb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timecompare_transform	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_query_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_append	vmlinux	EXPORT_SYMBOL
+0x00000000	random32	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_find_sta	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_tx_status_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_cinergy_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_gotview7135_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
+0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_md5_hash_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_max	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
+0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
+0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_resume_root_hub	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_ibss_joined	vmlinux	EXPORT_SYMBOL
+0x00000000	tea5767_autodetection	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_by_index_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
+0x00000000	ksize	vmlinux	EXPORT_SYMBOL
+0x00000000	sha_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_uidiv	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_kill_links	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_set_name	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_full	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elf_platform	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_msi_tvanywhere_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_device_ro	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	panic_blink	vmlinux	EXPORT_SYMBOL
+0x00000000	kmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
+0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_use_client	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_stop_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
+0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	__cap_full_set	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp4_gro_receive	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
+0x00000000	__pneigh_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_tuner_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	devm_iounmap	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_find_sta_by_hw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_remove_watch_locked	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bioset_create	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_put_cacheinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
+0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	xrlim_allow	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_put	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	single_open	vmlinux	EXPORT_SYMBOL
+0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	hex2bin	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_listen_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf32_to_utf8	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_free	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_reboot_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	cleanup_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sk_clone	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_perform_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	interruptible_sleep_on	vmlinux	EXPORT_SYMBOL
+0x00000000	__ip_route_output_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_rc5_decode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_buffer_map_sg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_invalidate_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	remove_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	io_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_set	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_stop_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_listen	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_txq_stats_fold	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_purge	vmlinux	EXPORT_SYMBOL
+0x00000000	register_vt_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_unmapped_area	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_lru	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_rq_map_user	vmlinux	EXPORT_SYMBOL
+0x00000000	d_find_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	yield	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_claim_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	memcpy_toiovecend	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_command_normalize_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_init_always	vmlinux	EXPORT_SYMBOL
+0x00000000	d_invalidate	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_32	vmlinux	EXPORT_SYMBOL
+0x00000000	pid_task	vmlinux	EXPORT_SYMBOL
+0x00000000	copy_page	vmlinux	EXPORT_SYMBOL
+0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	monotonic_to_bootbased	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
+0x00000000	fib_rules_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
+0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rts_duration	vmlinux	EXPORT_SYMBOL
+0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
+0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
+0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_newsize_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	strncmp	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kfree_s	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_access_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_le	vmlinux	EXPORT_SYMBOL
+0x00000000	scatterwalk_map_and_copy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__task_pid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	v4wb_copy_user_highpage	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_link	vmlinux	EXPORT_SYMBOL
+0x00000000	input_event_to_user	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	read_cache_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_generic_getfrag	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_enqueue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_add_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	thaw_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_run_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	d_move	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_idivmod	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_del_multiple	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_unregister_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	strstr	vmlinux	EXPORT_SYMBOL
+0x00000000	strchr	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_buffered_bc	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_new_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	_memcpy_toio	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_alloc_writecombine	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_hwcap	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_release_client	vmlinux	EXPORT_SYMBOL
+0x00000000	take_over_console	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_readsw	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	napi_reuse_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_mark_declared_memory_occupied	vmlinux	EXPORT_SYMBOL
+0x00000000	lock_may_write	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_submit_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_out_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_ioremap_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_header_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_change_mtu	vmlinux	EXPORT_SYMBOL
+0x00000000	bdev_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_wake_async	vmlinux	EXPORT_SYMBOL
+0x00000000	getrawmonotonic	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_free_clusters	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__set_page_dirty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_platform_shutdown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	per_cpu__vm_event_states	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_ordered	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	copy_strings_kernel	vmlinux	EXPORT_SYMBOL
+0x00000000	__wait_on_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_register_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_pixelview_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_get_remaining	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_enter_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_add_rx_frag	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unregister_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	probe_kernel_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_create	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_alloc_xmit_buf	vmlinux	EXPORT_SYMBOL
+0x00000000	no_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_timed_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_declare_coherent_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_receive_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_show_options	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	register_sysctl_paths	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_avermedia_m135a_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	capable	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	input_set_capability	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_cmd_aborted	vmlinux	EXPORT_SYMBOL
+0x00000000	autoremove_wake_function	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	give_up_console	vmlinux	EXPORT_SYMBOL
+0x00000000	getname	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_unexport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_response_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getpeername	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_chmod_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_event	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_to_bin	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_pin_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	vmalloc_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	__muldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	get_current_tty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bitmap_scnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_create_data	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_getsockname	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_givcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_log_packet	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_remove_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	rq_flush_dcache_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkcipher_walk_virt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	posix_lock_file	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	set_page_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	video_device_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	totalram_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_match_host	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_get_kset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__register_chrdev	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpio_get_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	free_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_lib_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
+0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
+0x00000000	printk	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	try_to_release_page	vmlinux	EXPORT_SYMBOL
+0x00000000	synchronize_srcu	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_add	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_list_start_head	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_ulcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_detach	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_device_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	device_rename	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kernel_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	fg_console	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_find	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_read	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_read	vmlinux	EXPORT_SYMBOL
+0x00000000	__devm_release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_hash_nolisten	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	memcpy_fromiovec	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_npgtech_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_prep_rq	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_peek_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_write_counter	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__div64_32	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	mntput_no_expire	vmlinux	EXPORT_SYMBOL
+0x00000000	__get_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	disallow_signal	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_ip_nonlocal_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcp_get_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	utf8s_to_utf16s	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_net_fops_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_resize_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
+0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_dummy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lookup_instantiate_filp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_ip_vs_app	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_tuner_addrs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kunmap_high	vmlinux	EXPORT_SYMBOL
+0x00000000	match_strdup	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__crypto_dequeue_request	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rt_mutex_unlock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_seq_next	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_ro_fops	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
+0x00000000	inetdev_by_index	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_base_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	console_blank_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_request_find_target	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_scsi_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	file_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_unmap_aliases	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_finish_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_device_flags_keyed	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_fetch_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	block_all_signals	vmlinux	EXPORT_SYMBOL
+0x00000000	_test_and_clear_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writeb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_decode_biphase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	cgu_get_clk_freq	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fib_default_rule_add	vmlinux	EXPORT_SYMBOL
+0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	check_disk_change	vmlinux	EXPORT_SYMBOL
+0x00000000	default_file_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	writeback_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_encore_enltv_fm53_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
+0x00000000	get_option	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_iopoll_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	up_read	vmlinux	EXPORT_SYMBOL
+0x00000000	_cond_resched	vmlinux	EXPORT_SYMBOL
+0x00000000	empty_zero_page	vmlinux	EXPORT_SYMBOL
+0x00000000	__pskb_pull_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_wait_until_sent	vmlinux	EXPORT_SYMBOL
+0x00000000	bioset_free	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fstat	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_lstat	vmlinux	EXPORT_SYMBOL
+0x00000000	orderly_poweroff	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_storage_usb_ids	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__netif_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_export_link	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fh_to_parent	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_unregister_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
+0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	abort	vmlinux	EXPORT_SYMBOL
+0x00000000	save_time_delta	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	try_acquire_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_get_mesh	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_find_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_task_ioprio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	setup_arg_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	make_bad_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmdrop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_memory_allocated	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_release_private	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_console_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_removexattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__mutex_init	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_unwind_cpp_pr1	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readsb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_host_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_irq_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_register_port	vmlinux	EXPORT_SYMBOL
+0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_detect_change	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ahash_setkey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	search_binary_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_trylock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rtnl_link_get_net	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readw	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_readl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_remove_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ahash_attr_alg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__put_user_8	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_disconnect	vmlinux	EXPORT_SYMBOL
+0x00000000	put_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_pair_release	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_softlockup_watchdog	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_expedited_torture_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_alloc_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_filesystem	vmlinux	EXPORT_SYMBOL
+0x00000000	loops_per_jiffy	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_validate_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_copy_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_debug_root	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_make_request	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_delayed_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip_send_check	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_dntv_live_dvb_t_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mangle_path	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_scan_completed	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tda829x_probe	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
+0x00000000	kunmap	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_free_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_pin	vmlinux	EXPORT_SYMBOL
+0x00000000	set_create_files_as	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strict_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_rejoin_group	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	avenrun	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_release_sg_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	__arm_ioremap	vmlinux	EXPORT_SYMBOL
+0x00000000	elf_set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_type_names	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_input_nokey	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	block_sync_page	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_batches_completed_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__do_div64	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
+0x00000000	register_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_update_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	open_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_vs_skb_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	div_s64_rem	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
+0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_transparent_scsi_command	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_bios_ptable	vmlinux	EXPORT_SYMBOL
+0x00000000	arm926_flush_kern_cache_all	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_connected_output	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_ushort	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_flush_pending_frames	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_kernel_create	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_stats	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_parse_user	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	nlmsg_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_dump_samples	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmput	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	init_task	vmlinux	EXPORT_SYMBOL
+0x00000000	video_devdata	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	build_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
+0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_verify_client	vmlinux	EXPORT_SYMBOL
+0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
+0x00000000	__insert_inode_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	getboottime	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	revert_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_flydvb_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ioport_map	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_checksum_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
+0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	dpm_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_search_long	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_path	vmlinux	EXPORT_SYMBOL
+0x00000000	msleep_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_valid_name	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_addr_add	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_notify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hweight8	vmlinux	EXPORT_SYMBOL
+0x00000000	sg_init_table	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
+0x00000000	default_unplug_io_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
+0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_register_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_queue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_lookup_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_test_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_exit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_host_lazy_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_clock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_execute_req	vmlinux	EXPORT_SYMBOL
+0x00000000	queue_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	oops_in_progress	vmlinux	EXPORT_SYMBOL
+0x00000000	release_console_sem	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_tx_hash	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_register_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_throttle	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_check_change	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_backing_dev_info	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__gpio_get_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__gpio_set_value	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	close_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_dump_start	vmlinux	EXPORT_SYMBOL
+0x00000000	call_netevent_notifiers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_base	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aio_put_req	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesb	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesw	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_writesl	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_ext_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_wait_for_app_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	serial8250_unregister_port	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
+0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	_test_and_change_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	pskb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_rc5_timer_keyup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_schedule_eh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strict_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	strict_strtoll	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_alloc_new_dir	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__raw_readsb	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_command	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_handle_response	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	int_sqrt	vmlinux	EXPORT_SYMBOL
+0x00000000	local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	system_rev	vmlinux	EXPORT_SYMBOL
+0x00000000	round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__ucmpdi2	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_iter_init_node	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	v4l2_ctrl_check	vmlinux	EXPORT_SYMBOL
+0x00000000	video_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_update_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_request	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	use_module	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_try_to_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_mmap_writecombine	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	__dev_get_by_name	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_ati_tv_wonder_hd_600_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_handle	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_replace	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_sched	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_suspend	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdev	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_limits_io_opt	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twsk_purge	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_andnot	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_drop_spawn	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_short	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	strim	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_write	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_avermedia_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfree	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_page_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_host_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_rq_merge_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_pool_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_do_rcv	vmlinux	EXPORT_SYMBOL
+0x00000000	get_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_dump_rq_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_tso	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_allocate_polled_device	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	root_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_ms_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_kill	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_getattr	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_tx_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	attribute_container_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_for_each_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdget_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_rcv_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_tx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_to_sgvec	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sscanf	vmlinux	EXPORT_SYMBOL
+0x00000000	__breadahead	vmlinux	EXPORT_SYMBOL
+0x00000000	icmpv6_statistics	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_add_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_md5_do_del	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hweight32	vmlinux	EXPORT_SYMBOL
+0x00000000	hweight16	vmlinux	EXPORT_SYMBOL
+0x00000000	hweight64	vmlinux	EXPORT_SYMBOL
+0x00000000	___ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	__create_workqueue_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_kmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
+0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
+0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_timewait_state_process	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__aeabi_lmul	vmlinux	EXPORT_SYMBOL
+0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
+0x00000000	global_cursor_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
+0x00000000	srcu_init_notifier_head	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	jiffies_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_reno_min_cwnd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_schedule_flip	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_get_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_follow_link	vmlinux	EXPORT_SYMBOL
+0x00000000	touch_all_softlockup_watchdogs	vmlinux	EXPORT_SYMBOL
+0x00000000	tuners	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_devnum	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_rm_wd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_parse	vmlinux	EXPORT_SYMBOL
+0x00000000	kstat_irqs_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_iodata_bctv7e_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_free_device	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__divsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__modsi3	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_evga_indtube_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_free_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	__napi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_wait_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_set_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_or	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strlen	vmlinux	EXPORT_SYMBOL
+0x00000000	strspn	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_allocate_command	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_strcmp	vmlinux	EXPORT_SYMBOL
+0x00000000	strict_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_ahash_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__kfifo_from_user_n	vmlinux	EXPORT_SYMBOL
+0x00000000	leds_event	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
+0x00000000	per_cpu__xt_info_locks	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	match_int	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_tag_set	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bridge_tunnel_header	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_behold_columbus_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_get_adapter	vmlinux	EXPORT_SYMBOL
+0x00000000	get_options	vmlinux	EXPORT_SYMBOL
+0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_rc5_hauppauge_new_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	call_usermodehelper_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
+0x00000000	register_ip_vs_scheduler	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_enable_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_printf	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_free_host	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtol	vmlinux	EXPORT_SYMBOL
+0x00000000	ilookup5_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_kill_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_alignment_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_super	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_get_sense_info_fld	vmlinux	EXPORT_SYMBOL
+0x00000000	__bio_clone	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_cookie_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysdev_driver_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cap_netlink_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	nr_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pfn_valid	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_kunmap_atomic_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_block_when_processing_errors	vmlinux	EXPORT_SYMBOL
+0x00000000	open_bdev_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	submit_bh	vmlinux	EXPORT_SYMBOL
+0x00000000	mnt_clone_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_mkclean	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_seconds	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_anchor_empty	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
+0x00000000	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_cinergy_1400_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_assoc_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clear_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwessid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwessid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_awake	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_input_keydown	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_hcd_link_urb_to_ep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	device_release_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_lookup_devt	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_grab_skcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_srb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
+0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	update_region	vmlinux	EXPORT_SYMBOL
+0x00000000	sprint_symbol	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_fp_dup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_card_can_sleep	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_vhangup	vmlinux	EXPORT_SYMBOL
+0x00000000	kref_set	vmlinux	EXPORT_SYMBOL
+0x00000000	kcrypto_wq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	shrink_dcache_parent	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_twdr_twkill_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_net	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_for_each_drv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	__udelay	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_find_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	in_egroup_p	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_i2c_new_subdev_cfg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_termios_baud_rate	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_gang_lookup_slot	vmlinux	EXPORT_SYMBOL
+0x00000000	ktime_add_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_append_datato_frags	vmlinux	EXPORT_SYMBOL
+0x00000000	release_firmware	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_msecs	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_to_usecs	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_last	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_rm_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
+0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_query_menu	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_attr_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_listxattr	vmlinux	EXPORT_SYMBOL
+0x00000000	net_ratelimit	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_host_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	shash_ahash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_autopm_get_interface_async	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_shash_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_vma	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_dentry_parent_queue_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_stream_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	splice_from_pipe_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	boot_tvec_bases	vmlinux	EXPORT_SYMBOL
+0x00000000	_find_first_bit_le	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_class_remove_file	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_physical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_wake_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_close_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_next	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_rcv_established	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_unregister_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_alloc_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_prep_fn	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_pseudo	vmlinux	EXPORT_SYMBOL
+0x00000000	__rtnl_link_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_dma_alignment	vmlinux	EXPORT_SYMBOL
+0x00000000	remap_vmalloc_range	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_free_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	enable_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	enable_hlt	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	memchr	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_bus_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	anon_transport_class_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	submit_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_page_buffers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	synchronize_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_remove_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_mtup_init	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_setattr	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_set_irq_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp4_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_input	vmlinux	EXPORT_SYMBOL
+0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_md5_hash_skb_data	vmlinux	EXPORT_SYMBOL
+0x00000000	aio_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
+0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
+0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_del_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_remove_plug	vmlinux	EXPORT_SYMBOL
+0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_beacon_loss	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_clients_command	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ethtool_op_get_ufo	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_set_data_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l_bound_align_image	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_cons	vmlinux	EXPORT_SYMBOL
+0x00000000	strncat	vmlinux	EXPORT_SYMBOL
+0x00000000	strlcat	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_discard_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_should_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_mapping_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	__tcp_put_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_add_device	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_scan	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_change_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	datagram_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_print_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_end_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	arm926_flush_user_cache_all	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_Bulk_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_old_exec	vmlinux	EXPORT_SYMBOL
+0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss_frame	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
+0x00000000	stop_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_create	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	get_sb_nodev	vmlinux	EXPORT_SYMBOL
+0x00000000	kthread_create	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_writel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_memcpy_toio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
+0x00000000	strcspn	vmlinux	EXPORT_SYMBOL
+0x00000000	do_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blkdev_aio_write	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rx_irqsafe	vmlinux	EXPORT_SYMBOL
+0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_find	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_getbyhwaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	alloc_etherdev_mq	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
+0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	default_red	vmlinux	EXPORT_SYMBOL
+0x00000000	generate_random_uuid	vmlinux	EXPORT_SYMBOL
+0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_power_save_host	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_iterate_active_interfaces_atomic	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_new_probed_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
+0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
+0x00000000	may_umount	vmlinux	EXPORT_SYMBOL
+0x00000000	block_read_full_page	vmlinux	EXPORT_SYMBOL
+0x00000000	console_drivers	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__scsi_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_sort_breadthfirst	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_v4_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_sync_mss	vmlinux	EXPORT_SYMBOL
+0x00000000	emergency_restart	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_disable	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	serio_rescan	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwencode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwencode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
+0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_create	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
+0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_get_by_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_alloc_root	vmlinux	EXPORT_SYMBOL
+0x00000000	page_address	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_over_panic	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
+0x00000000	__ieee80211_get_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_set_block_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__usb_get_extra_descriptor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_pctv_sedna_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fsnotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_netdevice	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_disconnect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_init	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_finish_command	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_to_irq	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	elv_queue_empty	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_get	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_put	vmlinux	EXPORT_SYMBOL
+0x00000000	kill_pid_info_as_uid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_get_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__alloc_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	__gpio_cansleep	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mutex_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64	vmlinux	EXPORT_SYMBOL
+0x00000000	half_md4_transform	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_prev_hole	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_readdir	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
+0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	__machine_arch_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_alloc_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	lro_vlan_hwaccel_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_alloc_md5sig_pool	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_common_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_direction_input	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_disconnected	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_send_rx_auth	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_sg	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
+0x00000000	disable_irq_nosync	vmlinux	EXPORT_SYMBOL
+0x00000000	call_usermodehelper_freeinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	add_uevent_var	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
+0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_schedule_callback	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	raw_hash_sk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_control_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	pgprot_user	vmlinux	EXPORT_SYMBOL
+0x00000000	udplite_table	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_max_segment_size	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_add_tail	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	do_unblank_screen	vmlinux	EXPORT_SYMBOL
+0x00000000	__symbol_put	vmlinux	EXPORT_SYMBOL
+0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
+0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_channel_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_unplug	vmlinux	EXPORT_SYMBOL
+0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dev_addr_type	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_register_table	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_release_from_disk	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_resume_port	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_add_to_lists	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_handle_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	ahash_free_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_register_dev	vmlinux	EXPORT_SYMBOL
+0x00000000	pagecache_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_f0_readb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_register_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_vs_conn_out_get	vmlinux	EXPORT_SYMBOL
+0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	transport_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xc2028_attach	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_read_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL
+0x00000000	ps2_begin_command	vmlinux	EXPORT_SYMBOL
+0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_open	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_rq_map_user_iov	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_putc	vmlinux	EXPORT_SYMBOL
+0x00000000	seq_puts	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_qos_remove_requirement	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	uart_update_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	part_round_stats	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_add_mount	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	d_genocide	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_put_and_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_cache_maint	vmlinux	EXPORT_SYMBOL
+0x00000000	elv_dispatch_add_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_write_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	d_rehash	vmlinux	EXPORT_SYMBOL
+0x00000000	__ashldi3	vmlinux	EXPORT_SYMBOL
+0x00000000	__mmc_claim_host	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_poison_urb	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bdevname	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_write	vmlinux	EXPORT_SYMBOL
+0x00000000	netif_rx	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_request_specific_sg_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_sync_sg_for_device	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_ip_vs_app	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_binfmt	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_vm_area	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_bonding_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_reset_txq	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_accept	vmlinux	EXPORT_SYMBOL
+0x00000000	set_groups	vmlinux	EXPORT_SYMBOL
+0x00000000	klist_del	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mmc_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	elevator_exit	vmlinux	EXPORT_SYMBOL
+0x00000000	__lock_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_scan_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_prepare_sg_list	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_pinnacle_color_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unmap_mapping_range	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	overflowgid	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_select_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	wireless_send_event	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_close	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_in_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	__copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_get_cookie	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bitmap_subset	vmlinux	EXPORT_SYMBOL
+0x00000000	set_normalized_timespec	vmlinux	EXPORT_SYMBOL
+0x00000000	eth_type_trans	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_blob	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_insert_mixed	vmlinux	EXPORT_SYMBOL
+0x00000000	send_sig	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_videomate_s350_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_v4_md5_do_add	vmlinux	EXPORT_SYMBOL
+0x00000000	net_disable_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_ctrl_transfer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_partsize	vmlinux	EXPORT_SYMBOL
+0x00000000	groups_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_unregister_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_release_fs	vmlinux	EXPORT_SYMBOL
+0x00000000	down	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_end_request	vmlinux	EXPORT_SYMBOL
+0x00000000	__aeabi_llsl	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_unsync	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_put	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_host_put	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	add_wait_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_add_pack	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hub_clear_tt_buffer	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strnchr	vmlinux	EXPORT_SYMBOL
+0x00000000	balance_dirty_pages_ratelimited_nr	vmlinux	EXPORT_SYMBOL
+0x00000000	strrchr	vmlinux	EXPORT_SYMBOL
+0x00000000	vsnprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	rb_replace_node	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_get_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_put_default_rng	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_mod_put	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cancel_work_sync	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_reordering	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_dntv_live_dvbt_pro_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	input_set_keycode	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bdi_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_tstamp_tx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_adstech_dvb_t_pci_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_set_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_copy_le	vmlinux	EXPORT_SYMBOL
+0x00000000	memscan	vmlinux	EXPORT_SYMBOL
+0x00000000	mark_buffer_dirty	vmlinux	EXPORT_SYMBOL
+0x00000000	get_super	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_to_user	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_scheduled_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_prog_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	v4wb_clear_user_highpage	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy_and_csum_bits	vmlinux	EXPORT_SYMBOL
+0x00000000	block_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	ll_rw_block	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_eztv_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ps2_sendbyte	vmlinux	EXPORT_SYMBOL
+0x00000000	resume_device_irqs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_get_attr_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_get_sense	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kref_init	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_aead	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_spawn_tfm2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	round_jiffies_up	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_set_mac_address	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_receive_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	kd_mksound	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_segment_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_cookie_generator	vmlinux	EXPORT_SYMBOL
+0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
+0x00000000	serio_close	vmlinux	EXPORT_SYMBOL
+0x00000000	loop_register_transfer	vmlinux	EXPORT_SYMBOL
+0x00000000	__cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
+0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
+0x00000000	rfc1042_header	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_under_panic	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_dointvec	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ehash_secret	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_established	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	udp_lib_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_hook_slow	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_chip_ident_i2c_client	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflate_workspacesize	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_recvmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	console_start	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_simple_retransmit	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_register_match	vmlinux	EXPORT_SYMBOL
+0x00000000	anon_inode_getfile	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
+0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
+0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
+0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
+0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
+0x00000000	arm926_flush_kern_dcache_area	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_cmd_print_sense_hdr	vmlinux	EXPORT_SYMBOL
+0x00000000	zero_fill_bio	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_resume_host	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_log_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_alloc_host	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_eh_ready_devs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_file_buffered_write	vmlinux	EXPORT_SYMBOL
+0x00000000	set_irq_wake	vmlinux	EXPORT_SYMBOL
+0x00000000	input_open_device	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_giwrange	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	i2c_new_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_free_hw	vmlinux	EXPORT_SYMBOL
+0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
+0x00000000	bd_set_size	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sk_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_copy	vmlinux	EXPORT_SYMBOL
+0x00000000	input_inject_event	vmlinux	EXPORT_SYMBOL
+0x00000000	memparse	vmlinux	EXPORT_SYMBOL
+0x00000000	block_truncate_page	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_write_checks	vmlinux	EXPORT_SYMBOL
+0x00000000	do_gettimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
+0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
+0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_tty_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_align_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
+0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
+0x00000000	default_blu	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
+0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rts_get	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_unicast_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	video_ioctl2	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_proteus_2309_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_ctrl_query_menu_valid_items	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	inode_needs_sync	vmlinux	EXPORT_SYMBOL
+0x00000000	grab_cache_page_nowait	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up_sync_key	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_purpletv_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_internal_device_block	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fs_overflowuid	vmlinux	EXPORT_SYMBOL
+0x00000000	wake_up_process	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_dequeue_tail	vmlinux	EXPORT_SYMBOL
+0x00000000	input_ff_erase	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_target_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	__module_address	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_stream_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_reset	vmlinux	EXPORT_SYMBOL
+0x00000000	register_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_complete_request	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_tested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_unmap_user	vmlinux	EXPORT_SYMBOL
+0x00000000	put_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ns_to_timeval	vmlinux	EXPORT_SYMBOL
+0x00000000	skip_spaces	vmlinux	EXPORT_SYMBOL
+0x00000000	get_sb_single	vmlinux	EXPORT_SYMBOL
+0x00000000	add_taint	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_power_off	vmlinux	EXPORT_SYMBOL
+0x00000000	__neigh_for_each_release	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_busnum_to_master	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dpm_suspend_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_initialize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_init_tags	vmlinux	EXPORT_SYMBOL
+0x00000000	bdget	vmlinux	EXPORT_SYMBOL
+0x00000000	bdput	vmlinux	EXPORT_SYMBOL
+0x00000000	fsstack_copy_inode_size	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_usual_ignore_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_broken_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	fs_kobj	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__bad_xchg	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_ablkcipher	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_init	vmlinux	EXPORT_SYMBOL
+0x00000000	all_vm_events	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arm926_coherent_kern_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdio_enable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
+0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_make_writable	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	pipe_to_file	vmlinux	EXPORT_SYMBOL
+0x00000000	release_resource	vmlinux	EXPORT_SYMBOL
+0x00000000	brioctl_set	vmlinux	EXPORT_SYMBOL
+0x00000000	device_schedule_callback_owner	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
+0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
+0x00000000	freq_reg_info	vmlinux	EXPORT_SYMBOL
+0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
+0x00000000	gen_replace_estimator	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_target_unblock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	param_get_bool	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_many	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_abort_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_logical_block_size	vmlinux	EXPORT_SYMBOL
+0x00000000	init_srcu_struct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
+0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	__backtrace	vmlinux	EXPORT_SYMBOL
+0x00000000	processor_id	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
+0x00000000	net_vs_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xt_unregister_match	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_set	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_transaction_get	vmlinux	EXPORT_SYMBOL
+0x00000000	find_pid_ns	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	klist_node_attached	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_disable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	k_handler	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_deregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_alloc_instance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	mpage_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	set_security_override	vmlinux	EXPORT_SYMBOL
+0x00000000	dump_stack	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_start	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kobject_del	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_unregister_ahash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_reset_endpoint	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_keyboard_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_last_bit	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_initwait	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_console	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	rate_control_send_low	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_radiotap_iterator_next	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
+0x00000000	sort	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_sg_cancel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kern_path	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_queue_handler	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_alloc_from_coherent	vmlinux	EXPORT_SYMBOL
+0x00000000	__sg_alloc_table	vmlinux	EXPORT_SYMBOL
+0x00000000	shrink_dcache_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	blkdev_issue_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_init_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	default_backing_dev_info	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_drop_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_inode_number	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_to_user_n	vmlinux	EXPORT_SYMBOL
+0x00000000	sys_tz	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_init_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	unlock_page	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_memcpy_fromio	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
+0x00000000	hrtimer_init_sleeper	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eth_rebuild_header	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_compat_output	vmlinux	EXPORT_SYMBOL
+0x00000000	user_path_at	vmlinux	EXPORT_SYMBOL
+0x00000000	module_put	vmlinux	EXPORT_SYMBOL
+0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
+0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_print_status	vmlinux	EXPORT_SYMBOL
+0x00000000	eventfd_ctx_fileget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	max_mapnr	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_new	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_int_ioctl_1	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inotify_find_update_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	iunique	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
+0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_alloc_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
+0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_bss_get_ie	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	hwmon_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	simple_attr_open	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_root_hub_lost_power	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	rcu_batches_completed_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
+0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
+0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	new_inode	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_build_sense_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close	vmlinux	EXPORT_SYMBOL
+0x00000000	idr_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	ida_get_new	vmlinux	EXPORT_SYMBOL
+0x00000000	argv_free	vmlinux	EXPORT_SYMBOL
+0x00000000	genl_unregister_family	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_netdevice_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_suspend_host	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_norwood_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	sdio_release_host	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_remove_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_detach_inode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	mempool_alloc_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	__tasklet_hi_schedule	vmlinux	EXPORT_SYMBOL
+0x00000000	cgu_get_base_freq	vmlinux	EXPORT_SYMBOL
+0x00000000	cgu_set_base_freq	vmlinux	EXPORT_SYMBOL
+0x00000000	arp_send	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_matches	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateReset	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_onto	vmlinux	EXPORT_SYMBOL
+0x00000000	cdev_del	vmlinux	EXPORT_SYMBOL
+0x00000000	pneigh_enqueue	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_alloc_name	vmlinux	EXPORT_SYMBOL
+0x00000000	iov_iter_copy_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kfifo_from_user	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_fh_to_dentry	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_bulk_transfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_init_termios	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alloc_instance2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	read_dev_sector	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_avermedia_cardbus_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strcat	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_gadget_unregister_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_vs_proto_name	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_tx_status	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
+0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_video_std_construct	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
+0x00000000	get_inotify_watch	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bmap	vmlinux	EXPORT_SYMBOL
+0x00000000	kmemdup	vmlinux	EXPORT_SYMBOL
+0x00000000	__blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__strnlen_user	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_register_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_gro_complete	vmlinux	EXPORT_SYMBOL
+0x00000000	sync_filesystem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_connect	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_table_clear	vmlinux	EXPORT_SYMBOL
+0x00000000	led_trigger_event	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_sync_sg_for_cpu	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
+0x00000000	mmc_align_data_size	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_pinnacle_grey_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dma_read_counter	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
+0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
+0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
+0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
+0x00000000	spi_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_bus	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
+0x00000000	default_grn	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_rate_control_unregister	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
+0x00000000	alloc_disk_node	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work	vmlinux	EXPORT_SYMBOL
+0x00000000	dequeue_signal	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_gro_reset_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	sysdev_driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ablkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_bundle_ok	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_flyvideo_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	spi_add_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
+0x00000000	napi_frags_skb	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_change_net_namespace	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ir_codes_powercolor_real_angel_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_rq_timeout	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_twsk_destructor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scm_detach_fds	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_msi_tvanywhere_plus_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_stor_pre_reset	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_irq_type	vmlinux	EXPORT_SYMBOL
+0x00000000	put_pid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	driver_find_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_insert_flip_string	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
+0x00000000	dma_prog_sg_channel	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_inform_bss	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_get_tkip_key	vmlinux	EXPORT_SYMBOL
+0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
+0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
+0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
+0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	ieee80211_data_to_8023	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_device_register_subdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_encore_enltv2_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gpiochip_is_requested	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_set_default_limits	vmlinux	EXPORT_SYMBOL
+0x00000000	rtnl_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lookup_bdev	vmlinux	EXPORT_SYMBOL
+0x00000000	irq_stat	vmlinux	EXPORT_SYMBOL
+0x00000000	raw_seq_stop	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	gnet_stats_copy_basic	vmlinux	EXPORT_SYMBOL
+0x00000000	create_mnt_ns	vmlinux	EXPORT_SYMBOL
+0x00000000	vm_map_ram	vmlinux	EXPORT_SYMBOL
+0x00000000	filemap_fdatawrite_range	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_sendmsg	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_cmsg_recv	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_alg_sem	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bio_sector_offset	vmlinux	EXPORT_SYMBOL
+0x00000000	inverse_translate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	unregister_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_exec_domain	vmlinux	EXPORT_SYMBOL
+0x00000000	nobh_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	__kfifo_to_user_generic	vmlinux	EXPORT_SYMBOL
+0x00000000	interruptible_sleep_on_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	netlink_ack	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_no_bind	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_get_timestamp	vmlinux	EXPORT_SYMBOL
+0x00000000	zlib_inflateInit2	vmlinux	EXPORT_SYMBOL
+0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_plug_device_unlocked	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_open	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_input_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
+0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	lro_flush_pkt	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
+0x00000000	vprintk	vmlinux	EXPORT_SYMBOL
+0x00000000	sysctl_tcp_syncookies	vmlinux	EXPORT_SYMBOL
+0x00000000	tcp_poll	vmlinux	EXPORT_SYMBOL
+0x00000000	vsprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	generic_splice_sendpage	vmlinux	EXPORT_SYMBOL
+0x00000000	attribute_container_find_class_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	grab_cache_page_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	rt_mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__get_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	__put_user_1	vmlinux	EXPORT_SYMBOL
+0x00000000	class_create_file	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	utf16s_to_utf8s	vmlinux	EXPORT_SYMBOL
+0x00000000	__cond_resched_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_pernet_subsys	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_queue_max_sectors	vmlinux	EXPORT_SYMBOL
+0x00000000	wait_on_sync_kiocb	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
+0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_ctstoself_get	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
+0x00000000	dev_set_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__sk_dst_check	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_queue_reset_device	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	debugfs_initialized	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__timecompare_update	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usb_interrupt_msg	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register_data	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	bus_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	byte_rev_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__elv_add_request	vmlinux	EXPORT_SYMBOL
+0x00000000	skcipher_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	set_bh_page	vmlinux	EXPORT_SYMBOL
+0x00000000	strcpy	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_destroy_tfm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	filemap_fault	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_sense_invalidCDB	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_pair_get_tty	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_pair_get_pty	vmlinux	EXPORT_SYMBOL
+0x00000000	inotify_destroy	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blocking_notifier_chain_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	skb_unlink	vmlinux	EXPORT_SYMBOL
+0x00000000	get_cpu_sysdev	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_register_template	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	node_states	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwmlme	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwname	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwmode	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_siwrate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwrate	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_send_auth_timeout	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
+0x00000000	regulatory_hint	vmlinux	EXPORT_SYMBOL
+0x00000000	wiphy_rfkill_start_polling	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
+0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	clocksource_register	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_target	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_unregister_hooks	vmlinux	EXPORT_SYMBOL
+0x00000000	device_create_vargs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_port_hangup	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_inc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	crypto_xor	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	wiphy_apply_custom_regulatory	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_getattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fat_setattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_read_dir	vmlinux	EXPORT_SYMBOL
+0x00000000	dentry_unhash	vmlinux	EXPORT_SYMBOL
+0x00000000	kallsyms_lookup_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	writeback_inodes_sb_if_idle	vmlinux	EXPORT_SYMBOL
+0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
+0x00000000	v4l2_prio_check	vmlinux	EXPORT_SYMBOL
+0x00000000	vc_resize	vmlinux	EXPORT_SYMBOL
+0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
+0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	param_set_ulong	vmlinux	EXPORT_SYMBOL
+0x00000000	_local_bh_enable	vmlinux	EXPORT_SYMBOL
+0x00000000	try_wait_for_completion	vmlinux	EXPORT_SYMBOL
+0x00000000	cpu_active_mask	vmlinux	EXPORT_SYMBOL
+0x00000000	ethtool_op_get_rx_csum	vmlinux	EXPORT_SYMBOL
+0x00000000	bus_find_device_by_name	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
+0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_codes_gadmei_rm008z_table	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
+0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
+0x00000000	__inet_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_realloc_headroom	vmlinux	EXPORT_SYMBOL
+0x00000000	platform_device_unregister	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cgu_get_pll_freq	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_port_close_end	vmlinux	EXPORT_SYMBOL
+0x00000000	__set_personality	vmlinux	EXPORT_SYMBOL
+0x00000000	register_con_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwauth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwauth	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
+0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
+0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
+0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
+0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_setxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	vfs_getxattr	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	sock_init_data	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
+0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	km_query	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
+0x00000000	rwsem_is_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
+0x00000000	neigh_create	vmlinux	EXPORT_SYMBOL
+0x00000000	usb_stor_CB_transport	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	fb_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__round_jiffies_relative	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	inet_twsk_alloc	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__serio_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	kfree	vmlinux	EXPORT_SYMBOL
+0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
+0x00000000	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_route_output_key	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
+0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
+0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
+0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_device_resume	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
+0x00000000	totalhigh_pages	vmlinux	EXPORT_SYMBOL
+0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
+0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
+0x00000000	ir_decode_pulsedistance	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
+0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_michael_mic_failure	vmlinux	EXPORT_SYMBOL
+0x00000000	ipt_do_table	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
+0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_find_target	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_recv_ts_and_drops	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	dget_locked	vmlinux	EXPORT_SYMBOL
+0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
+0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
+0x00000000	pm_set_vt_switch	vmlinux	EXPORT_SYMBOL
+0x00000000	tty_free_termios	vmlinux	EXPORT_SYMBOL
+0x00000000	nla_validate	vmlinux	EXPORT_SYMBOL
+0x00000000	bdi_register	vmlinux	EXPORT_SYMBOL
+0x00000000	inet_csk_clear_xmit_timers	vmlinux	EXPORT_SYMBOL
+0x00000000	hex_asc	vmlinux	EXPORT_SYMBOL
+0x00000000	fat_time_unix2fat	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
+0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
+0x00000000	cfg80211_wext_siwpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	cfg80211_wext_giwpower	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
+0x00000000	ip_fragment	vmlinux	EXPORT_SYMBOL
+0x00000000	cpuidle_register_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_eh_prep_cmnd	vmlinux	EXPORT_SYMBOL
+0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
+0x00000000	xt_register_targets	vmlinux	EXPORT_SYMBOL
+0x00000000	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL
+0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
+0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
+0x00000000	poll_freewait	vmlinux	EXPORT_SYMBOL
+0x00000000	si_meminfo	vmlinux	EXPORT_SYMBOL
+0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
+0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
+0x00000000	ieee80211_iterate_active_interfaces	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
+0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
+0x00000000	aead_geniv_init	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
+0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
+0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
+0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
+0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
+0x00000000	arpt_unregister_table	vmlinux	EXPORT_SYMBOL
+0x00000000	sk_filter	vmlinux	EXPORT_SYMBOL
+0x00000000	gpio_direction_output	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	generic_removexattr	vmlinux	EXPORT_SYMBOL
+0x00000000	deactivate_super	vmlinux	EXPORT_SYMBOL
+0x00000000	vmap	vmlinux	EXPORT_SYMBOL
diff -Nur ../linux-2.6.33-lpc313x/.version ../linux-2.6.33-lpc313x_original/.version
--- ../linux-2.6.33-lpc313x/.version	1970-01-01 01:00:00.000000000 +0100
+++ ../linux-2.6.33-lpc313x_original/.version	2012-10-07 01:54:33.000000000 +0200
@@ -0,0 +1 @@
+2
